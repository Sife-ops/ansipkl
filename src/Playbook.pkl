module Playbook

abstract class Base {
    name: String?
    connection: String?
    port: Int?
    remote_user: String?
    vars: Dynamic?
    module_defaults: Dynamic?
    environment: Dynamic?
    no_log: Boolean?
    run_once: Boolean?
    ignore_errors: Boolean?
    ignore_unreachable: Boolean?
    check_mode: Boolean?
    diff: Boolean?
    any_errors_fatal: Boolean?
    throttle: Int?
    timeout: Int?
    debugger: String?
    become: Boolean?
    become_method: String?
    become_user: String?
    become_flags: String?
    become_exe: String?
}

abstract class Plays extends Base {}

function NewPlaybook(x: Listing<Plays>): Listing<Plays> = x

class Play extends Plays {
    hosts: String?
    tasks: Listing<Tasks>?
    post_tasks: Listing<Tasks>?
    pre_tasks: Listing<Tasks>?
    gather_subset: Listing<String>?
    vars_files: Listing<String>?
    vars_prompt: Listing<Dynamic>?
    roles: Listing<Role>?
    handlers: Listing<Tasks>?
    serial: (String|Int|Listing<String|Int>)?

    function ModuleDefaults(x: Listing<Tasks>): Play = this
        |> new Mixin {
            module_defaults = x
                .toList()
                .toMap((y) -> y.GetModuleName(), (y) -> y.GetModuleOptions())
                .toDynamic()
        }

    
    gather_facts: Boolean?
    gather_timeout: Int?
    fact_path: String?
    force_handlers: Boolean?
    max_fail_percentage: String?
    strategy: String?
    order: String?

    // base classes
    tags: (String|Listing<String>)?
    collections: (String|Listing<String>)?
}

class PlaybookInclude extends Plays {
    `ansible.builtin.import_playbook`: String?
    vars: Dynamic?

    
    `when`: String?
    tags: (String|Listing<String>)?
}

class ImportPlaybook extends Base {
    import_playbook: String?
    vars_val: Dynamic?

    function Include(): PlaybookInclude = this
        .toMap()
        .put("ansible.builtin.import_playbook", this.import_playbook)
        .put("vars", this.vars_val)
        .toTyped(PlaybookInclude)

    
    `when`: String?
    tags: (String|Listing<String>)?
}

abstract class Tasks extends Base {}

function NewRole(x: Listing<Tasks>): Listing<Tasks> = x

abstract class Task extends Tasks {
    changed_when: Any?
    failed_when: Any?
    loop: (String|Listing<String>)?
    until: (String|Listing<String>)?

    
    args: Dynamic?
    action: String?
    async_val: Int?
    delay: Int?
    loop_control: String?
    poll: Int?
    register: String?
    retries: Int?
    loop_with: String?

    
    `when`: String?
    tags: (String|Listing<String>)?
    collections: (String|Listing<String>)?
    notify: (String|Listing<String>)?
    delegate_to: String?
    delegate_facts: Boolean?
}

abstract class TaskBuilder extends Base {
    options_mixin: Mixin?

    changed_when: Any?
    failed_when: Any?
    loop: (String|Listing<String>)?
    until: (String|Listing<String>)?

    
    args: Dynamic?
    action: String?
    async_val: Int?
    delay: Int?
    loop_control: String?
    poll: Int?
    register: String?
    retries: Int?
    loop_with: String?

    
    `when`: String?
    tags: (String|Listing<String>)?
    collections: (String|Listing<String>)?
    notify: (String|Listing<String>)?
    delegate_to: String?
    delegate_facts: Boolean?
}

class Block extends Tasks {
    block: Listing<Tasks>?
    rescue: Listing<Tasks>?
    always: Listing<Tasks>?

    
    `when`: String?
    collections: (String|Listing<String>)?
    tags: (String|Listing<String>)?
    notify: (String|Listing<String>)?
    delegate_to: String?
    delegate_facts: Boolean?
}

class Handler extends Task {
    listen: Dynamic?
}

class Role extends Base {
    role: String

    
    `when`: String?
    collections: (String|Listing<String>)?
    tags: (String|Listing<String>)?
}

