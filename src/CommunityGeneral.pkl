module CommunityGeneral

import "./Playbook.pkl"

/// Check or wait for migrations between nodes
/// This can be used to check for migrations in a cluster. This makes it easy to do a rolling upgrade/update on Aerospike nodes.
/// If waiting for migrations is not desired, simply just poll until port 3000 if available or asinfo -v status returns ok
class AerospikeMigrationsOptions {
    /// How long to try to connect before giving up (milliseconds)
    connect_timeout: Int?
    /// How many times should the cluster report "no migrations" consecutively before returning OK back to ansible?
    consecutive_good_checks: Int?
    /// Fail if the cluster key changes if something else is changing the cluster, we may want to fail
    fail_on_cluster_change: Boolean?
    /// Which host do we use as seed for info connection
    host: String?
    /// Do you wish to only check for migrations on the local node before returning, or do you want all nodes in the cluster to finish before returning?
    local_only: Boolean
    /// The metric key used to determine if we have rx migrations remaining. Changeable due to backwards compatibility.
    migrate_rx_key: String?
    /// The metric key used to determine if we have tx migrations remaining. Changeable due to backwards compatibility.
    migrate_tx_key: String?
    /// Check will return bad until cluster size is met or until tries is exhausted
    min_cluster_size: Int?
    /// Which port to connect to Aerospike on (service port)
    port: Int?
    /// How long to sleep between each check (seconds).
    sleep_between_checks: Int?
    /// When all aerospike builds in the cluster are greater than version 4.3, then the C(cluster-stable) info command will be used. Inside this command, you can optionally specify what the target cluster size is - but it is not necessary. You can still rely on min_cluster_size if you don't want to use this option.
    /// If this option is specified on a cluster that has at least 1 host <4.3 then it will be ignored until the min version reaches 4.3.
    target_cluster_size: Int?
    /// How many times do we poll before giving up and failing?
    tries_limit: Int?
}

/// Task class for aerospike_migrations
class AerospikeMigrationsTask extends Playbook.Task {
    /// todo doc
    `community.general.aerospike_migrations`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.aerospike_migrations"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.aerospike_migrations`
}

/// TaskBuilder class for aerospike_migrations
class AerospikeMigrations extends Playbook.TaskBuilder {
    /// Options for community.general.aerospike_migrations
    options: AerospikeMigrationsOptions?
    /// todo doc
    function Task(): AerospikeMigrationsTask = this
        .toMap()
        .put("community.general.aerospike_migrations", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(AerospikeMigrationsTask)
}

/// Notify airbrake about app deployments
/// Notify airbrake about app deployments (see U(https://airbrake.io/docs/api/#deploys-v4)).
class AirbrakeDeploymentOptions {
    /// The airbrake environment name, typically 'production', 'staging', etc.
    environment: String
    /// Airbrake PROJECT_ID
    project_id: String
    /// Airbrake PROJECT_KEY.
    project_key: String
    /// URL of the project repository
    repo: String?
    /// A hash, number, tag, or other identifier showing what revision from version control was deployed
    revision: String?
    /// Optional URL to submit the notification to. Use to send notifications to Airbrake-compliant tools like Errbit.
    url: String?
    /// The username of the person doing the deployment
    user: String?
    /// If V(false), SSL certificates for the target url will not be validated. This should only be used on personally controlled sites using self-signed certificates.
    validate_certs: Boolean?
    /// A string identifying what version was deployed
    version: String?
}

/// Task class for airbrake_deployment
class AirbrakeDeploymentTask extends Playbook.Task {
    /// todo doc
    `community.general.airbrake_deployment`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.airbrake_deployment"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.airbrake_deployment`
}

/// TaskBuilder class for airbrake_deployment
class AirbrakeDeployment extends Playbook.TaskBuilder {
    /// Options for community.general.airbrake_deployment
    options: AirbrakeDeploymentOptions?
    /// todo doc
    function Task(): AirbrakeDeploymentTask = this
        .toMap()
        .put("community.general.airbrake_deployment", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(AirbrakeDeploymentTask)
}

/// Manages AIX devices
/// This module discovers, defines, removes and modifies attributes of AIX devices.
class AixDevicesOptions {
    /// A list of device attributes.
    attributes: Any?
    /// The name of the device.
    /// V(all) is valid to rescan C(available) all devices (AIX cfgmgr command).
    device: String?
    /// Forces action.
    force: Boolean?
    /// Removes or defines a device and children devices.
    recursive: Boolean?
    /// Controls the device state.
    /// V(available) (alias V(present)) rescan a specific device or all devices (when O(device) is not specified).
    /// V(removed) (alias V(absent) removes a device.
    /// V(defined) changes device to Defined state.
    state: ("available"|"defined"|"removed")?
}

/// Task class for aix_devices
class AixDevicesTask extends Playbook.Task {
    /// todo doc
    `community.general.aix_devices`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.aix_devices"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.aix_devices`
}

/// TaskBuilder class for aix_devices
class AixDevices extends Playbook.TaskBuilder {
    /// Options for community.general.aix_devices
    options: AixDevicesOptions?
    /// todo doc
    function Task(): AixDevicesTask = this
        .toMap()
        .put("community.general.aix_devices", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(AixDevicesTask)
}

/// Configure LVM and NFS file systems for AIX
/// This module creates, removes, mount and unmount LVM and NFS file system for AIX using C(/etc/filesystems).
/// For LVM file systems is possible to resize a file system.
class AixFilesystemOptions {
    /// Specifies whether the file system is to be processed by the accounting subsystem.
    account_subsystem: Boolean?
    /// Specifies attributes for files system separated by comma.
    attributes: Listing<String>?
    /// File system is automatically mounted at system restart.
    auto_mount: Boolean?
    /// Logical volume (LV) device name or remote export device to create a NFS file system.
    /// It is used to create a file system on an already existing logical volume or the exported NFS file system.
    /// If not mentioned a new logical volume name will be created following AIX standards (LVM).
    device: String?
    /// Specifies the mount point, which is the directory where the file system will be mounted.
    filesystem: String
    /// Specifies the virtual file system type.
    fs_type: String?
    /// Specifies the mount group.
    mount_group: String?
    /// Specifies a Network File System (NFS) server.
    nfs_server: String?
    /// Set file system permissions. V(rw) (read-write) or V(ro) (read-only).
    permissions: ("ro"|"rw")?
    /// Removes the mount point directory when used with state V(absent).
    rm_mount_point: Boolean?
    /// Specifies the file system size.
    /// For already V(present) it will be resized.
    /// 512-byte blocks, Megabytes or Gigabytes. If the value has M specified it will be in Megabytes. If the value has G specified it will be in Gigabytes.
    /// If no M or G the value will be 512-byte blocks.
    /// If "+" is specified in begin of value, the value will be added.
    /// If "-" is specified in begin of value, the value will be removed.
    /// If "+" or "-" is not specified, the total value will be the specified.
    /// Size will respects the LVM AIX standards.
    size: String?
    /// Controls the file system state.
    /// V(present) check if file system exists, creates or resize.
    /// V(absent) removes existing file system if already V(unmounted).
    /// V(mounted) checks if the file system is mounted or mount the file system.
    /// V(unmounted) check if the file system is unmounted or unmount the file system.
    state: ("absent"|"mounted"|"present"|"unmounted")?
    /// Specifies an existing volume group (VG).
    vg: String?
}

/// Task class for aix_filesystem
class AixFilesystemTask extends Playbook.Task {
    /// todo doc
    `community.general.aix_filesystem`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.aix_filesystem"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.aix_filesystem`
}

/// TaskBuilder class for aix_filesystem
class AixFilesystem extends Playbook.TaskBuilder {
    /// Options for community.general.aix_filesystem
    options: AixFilesystemOptions?
    /// todo doc
    function Task(): AixFilesystemTask = this
        .toMap()
        .put("community.general.aix_filesystem", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(AixFilesystemTask)
}

/// Manages the inittab on AIX
/// Manages the inittab on AIX.
class AixInittabOptions {
    /// Action what the init has to do with this entry.
    action: ("boot"|"bootwait"|"hold"|"initdefault"|"off"|"once"|"ondemand"|"powerfail"|"powerwait"|"respawn"|"sysinit"|"wait")?
    /// What command has to run.
    command: String
    /// After which inittabline should the new entry inserted.
    insertafter: String?
    /// Name of the inittab entry.
    name: String
    /// Runlevel of the entry.
    runlevel: String
    /// Whether the entry should be present or absent in the inittab file.
    state: ("absent"|"present")?
}

/// Task class for aix_inittab
class AixInittabTask extends Playbook.Task {
    /// todo doc
    `community.general.aix_inittab`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.aix_inittab"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.aix_inittab`
}

/// TaskBuilder class for aix_inittab
class AixInittab extends Playbook.TaskBuilder {
    /// Options for community.general.aix_inittab
    options: AixInittabOptions?
    /// todo doc
    function Task(): AixInittabTask = this
        .toMap()
        .put("community.general.aix_inittab", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(AixInittabTask)
}

/// Manage LVM volume groups on AIX
/// This module creates, removes or resize volume groups on AIX LVM.
class AixLvgOptions {
    /// Force volume group creation.
    force: Boolean?
    /// The size of the physical partition in megabytes.
    pp_size: Int?
    /// List of comma-separated devices to use as physical devices in this volume group.
    /// Required when creating or extending (V(present) state) the volume group.
    /// If not informed reducing (V(absent) state) the volume group will be removed.
    pvs: Listing<String>?
    /// Control if the volume group exists and volume group AIX state varyonvg V(varyon) or varyoffvg V(varyoff).
    state: ("absent"|"present"|"varyoff"|"varyon")?
    /// The name of the volume group.
    vg: String
    /// The type of the volume group.
    vg_type: ("big"|"normal"|"scalable")?
}

/// Task class for aix_lvg
class AixLvgTask extends Playbook.Task {
    /// todo doc
    `community.general.aix_lvg`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.aix_lvg"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.aix_lvg`
}

/// TaskBuilder class for aix_lvg
class AixLvg extends Playbook.TaskBuilder {
    /// Options for community.general.aix_lvg
    options: AixLvgOptions?
    /// todo doc
    function Task(): AixLvgTask = this
        .toMap()
        .put("community.general.aix_lvg", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(AixLvgTask)
}

/// Configure AIX LVM logical volumes
/// This module creates, removes or resizes AIX logical volumes. Inspired by lvol module.
class AixLvolOptions {
    /// The number of copies of the logical volume.
    /// Maximum copies are 3.
    copies: Int?
    /// The name of the logical volume.
    lv: String
    /// The type of the logical volume.
    lv_type: String?
    /// Free-form options to be passed to the mklv command.
    opts: String?
    /// Sets the interphysical volume allocation policy.
    /// V(maximum) allocates logical partitions across the maximum number of physical volumes.
    /// V(minimum) allocates logical partitions across the minimum number of physical volumes.
    policy: ("maximum"|"minimum")?
    /// A list of physical volumes, for example V(hdisk1,hdisk2).
    pvs: Listing<String>?
    /// The size of the logical volume with one of the [MGT] units.
    size: String?
    /// Control if the logical volume exists. If V(present) and the volume does not already exist then the O(size) option is required.
    state: ("absent"|"present")?
    /// The volume group this logical volume is part of.
    vg: String
}

/// Task class for aix_lvol
class AixLvolTask extends Playbook.Task {
    /// todo doc
    `community.general.aix_lvol`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.aix_lvol"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.aix_lvol`
}

/// TaskBuilder class for aix_lvol
class AixLvol extends Playbook.TaskBuilder {
    /// Options for community.general.aix_lvol
    options: AixLvolOptions?
    /// todo doc
    function Task(): AixLvolTask = this
        .toMap()
        .put("community.general.aix_lvol", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(AixLvolTask)
}

/// Manage customers in Alerta
/// Create or delete customers in Alerta with the REST API.
class AlertaCustomerOptions {
    /// The Alerta API endpoint.
    alerta_url: String
    /// The access token for the API.
    api_key: String?
    /// The password for the API using basic auth.
    api_password: String?
    /// The username for the API using basic auth.
    api_username: String?
    /// Name of the customer.
    customer: String
    /// The matching logged in user for the customer.
    match: String
    /// Whether the customer should exist or not.
    /// Both O(customer) and O(match) identify a customer that should be added or removed.
    state: ("absent"|"present")?
}

/// Task class for alerta_customer
class AlertaCustomerTask extends Playbook.Task {
    /// todo doc
    `community.general.alerta_customer`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.alerta_customer"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.alerta_customer`
}

/// TaskBuilder class for alerta_customer
class AlertaCustomer extends Playbook.TaskBuilder {
    /// Options for community.general.alerta_customer
    options: AlertaCustomerOptions?
    /// todo doc
    function Task(): AlertaCustomerTask = this
        .toMap()
        .put("community.general.alerta_customer", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(AlertaCustomerTask)
}

/// Create, Start, Stop, Restart or Terminate an Instance in ECS; Add or Remove Instance to/from a Security Group
/// Create, start, stop, restart, modify or terminate ecs instances.
/// Add or remove ecs instances to/from security group.
class AliInstanceOptions {
    /// Whether allocate a public ip for the new instance.
    allocate_public_ip: Boolean?
    /// Whether automate renew the charge of the instance.
    auto_renew: Boolean?
    /// The duration of the automatic renew the charge of the instance. Required when O(auto_renew=true).
    auto_renew_period: Int?
    /// Aliyun availability zone ID in which to launch the instance. If it is not specified, it will be allocated by system automatically.
    availability_zone: String?
    /// The number of the new instance. An integer value which indicates how many instances that match O(count_tag) should be running. Instances are either created or terminated based on this value.
    count: Int?
    /// O(count) determines how many instances based on a specific tag criteria should be present. This can be expressed in multiple ways and is shown in the EXAMPLES section. The specified count_tag must already exist or be passed in as the O(tags) option. If it is not specified, it will be replaced by O(instance_name).
    count_tag: String?
    /// The description of ECS instance, which is a string of 2 to 256 characters. It cannot begin with http:// or https://.
    description: String?
    /// Specifies whether to send a dry-run request.
    /// If O(dry_run=true), Only a dry-run request is sent and no instance is created. The system checks whether the required parameters are set, and validates the request format, service permissions, and available ECS instances. If the validation fails, the corresponding error code is returned. If the validation succeeds, the DryRunOperation error code is returned.
    /// If O(dry_run=false), A request is sent. If the validation succeeds, the instance is created.
    dry_run: Boolean?
    /// Whether the current operation needs to be execute forcibly.
    force: Boolean?
    /// Instance host name. Ordered hostname is not supported.
    host_name: String?
    /// Image ID used to launch instances. Required when O(state=present) and creating new ECS instances.
    image_id: String?
    /// Whether to change instance disks charge type when changing instance charge type.
    include_data_disks: Boolean?
    /// The charge type of the instance.
    instance_charge_type: ("PrePaid"|"PostPaid")?
    /// A list of instance ids. It is required when need to operate existing instances. If it is specified, O(count) will lose efficacy.
    instance_ids: Listing<String>?
    /// The name of ECS instance, which is a string of 2 to 128 Chinese or English characters. It must begin with an uppercase/lowercase letter or a Chinese character and can contain numerals, ".", "_" or "-". It cannot begin with http:// or https://.
    instance_name: String?
    /// Instance type used to launch instances. Required when O(state=present) and creating new ECS instances.
    instance_type: String?
    /// Internet charge type of ECS instance.
    internet_charge_type: ("PayByBandwidth"|"PayByTraffic")?
    /// The name of key pair which is used to access ECS instance in SSH.
    key_name: String?
    /// Maximum incoming bandwidth from the public network, measured in Mbps (Megabits per second).
    max_bandwidth_in: Int?
    /// Maximum outgoing bandwidth to the public network, measured in Mbps (Megabits per second). Required when O(allocate_public_ip=true). Ignored when O(allocate_public_ip=false).
    max_bandwidth_out: Int?
    /// The password to login instance. After rebooting instances, modified password will take effect.
    password: String?
    /// The charge duration of the instance, in months. Required when O(instance_charge_type=PrePaid).
    /// The valid value are [1-9, 12, 24, 36].
    period: Int?
    /// The duration unit that you will buy the resource. It is valid when O(instance_charge_type=PrePaid).
    period_unit: ("Month"|"Week")?
    /// Delete any tags not specified in the task that are on the instance. If True, it means you have to specify all the desired tags on each task affecting an instance.
    purge_tags: Boolean?
    /// The name of the instance RAM role.
    ram_role_name: String?
    /// A list of security group IDs.
    security_groups: Listing<String>?
    /// The maximum hourly price for the preemptible instance. This parameter supports a maximum of three decimal places and takes effect when the SpotStrategy parameter is set to SpotWithPriceLimit.
    spot_price_limit: Any?
    /// The bidding mode of the pay-as-you-go instance. This parameter is valid when InstanceChargeType is set to PostPaid.
    spot_strategy: ("NoSpot"|"SpotWithPriceLimit"|"SpotAsPriceGo")?
    /// The state of the instance after operating.
    state: ("present"|"running"|"stopped"|"restarted"|"absent")?
    /// Category of the system disk.
    system_disk_category: ("cloud_efficiency"|"cloud_ssd")?
    /// Description of the system disk.
    system_disk_description: String?
    /// Name of the system disk.
    system_disk_name: String?
    /// Size of the system disk, in GB. The valid values are 40~500.
    system_disk_size: Int?
    /// A hash/dictionaries of instance tags, to add to the new instance or for starting/stopping instance by tag. V({"key":"value"})
    tags: Any?
    /// Specifies whether to add sequential suffixes to the host_name. The sequential suffix ranges from 001 to 999.
    unique_suffix: Boolean?
    /// User-defined data to customize the startup behaviors of an ECS instance and to pass data into an ECS instance. It only will take effect when launching the new ECS instances.
    user_data: String?
    /// The subnet ID in which to launch the instances (VPC).
    vswitch_id: String?
}

/// Task class for ali_instance
class AliInstanceTask extends Playbook.Task {
    /// todo doc
    `community.general.ali_instance`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ali_instance"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ali_instance`
}

/// TaskBuilder class for ali_instance
class AliInstance extends Playbook.TaskBuilder {
    /// Options for community.general.ali_instance
    options: AliInstanceOptions?
    /// todo doc
    function Task(): AliInstanceTask = this
        .toMap()
        .put("community.general.ali_instance", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(AliInstanceTask)
}

/// Gather information on instances of Alibaba Cloud ECS
/// This module fetches data from the Open API in Alicloud. The module must be called from within the ECS instance itself.
class AliInstanceInfoOptions {
    /// A dict of filters to apply. Each dict item consists of a filter key and a filter value. The filter keys can be all of request parameters. See U(https://www.alibabacloud.com/help/doc-detail/25506.htm) for parameter details. Filter keys can be same as request parameter name or be lower case and use underscore (V("_")) or dash (V("-")) to connect different words in one parameter. C(InstanceIds) should be a list. C(Tag.n.Key) and C(Tag.n.Value) should be a dict and using O(tags) instead.
    filters: Any?
    /// Use a instance name prefix to filter ecs instances.
    name_prefix: String?
    /// A hash/dictionaries of instance tags. C({"key":"value"})
    tags: Any?
}

/// Task class for ali_instance_info
class AliInstanceInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.ali_instance_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ali_instance_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ali_instance_info`
}

/// TaskBuilder class for ali_instance_info
class AliInstanceInfo extends Playbook.TaskBuilder {
    /// Options for community.general.ali_instance_info
    options: AliInstanceInfoOptions?
    /// todo doc
    function Task(): AliInstanceInfoTask = this
        .toMap()
        .put("community.general.ali_instance_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(AliInstanceInfoTask)
}

/// Manages alternative programs for common commands
/// Manages symbolic links using the 'update-alternatives' tool.
/// Useful when multiple programs are installed but provide similar functionality (e.g. different editors).
class AlternativesOptions {
    /// The path to the symbolic link that should point to the real executable.
    /// This option is always required on RHEL-based distributions. On Debian-based distributions this option is required when the alternative O(name) is unknown to the system.
    link: String?
    /// The generic name of the link.
    name: String
    /// The path to the real executable that the link should point to.
    path: String
    /// The priority of the alternative. If no priority is given for creation V(50) is used as a fallback.
    priority: Int?
    /// V(present) - install the alternative (if not already installed), but do not set it as the currently selected alternative for the group.
    /// V(selected) - install the alternative (if not already installed), and set it as the currently selected alternative for the group.
    /// V(auto) - install the alternative (if not already installed), and set the group to auto mode. Added in community.general 5.1.0.
    /// V(absent) - removes the alternative. Added in community.general 5.1.0.
    state: ("present"|"selected"|"auto"|"absent")?
    /// A list of subcommands.
    /// Each subcommand needs a name, a link and a path parameter.
    /// Subcommands are also named 'slaves' or 'followers', depending on the version of alternatives.
    subcommands: Listing<Any>?
}

/// Task class for alternatives
class AlternativesTask extends Playbook.Task {
    /// todo doc
    `community.general.alternatives`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.alternatives"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.alternatives`
}

/// TaskBuilder class for alternatives
class Alternatives extends Playbook.TaskBuilder {
    /// Options for community.general.alternatives
    options: AlternativesOptions?
    /// todo doc
    function Task(): AlternativesTask = this
        .toMap()
        .put("community.general.alternatives", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(AlternativesTask)
}

/// Install Ansible roles or collections using ansible-galaxy
/// This module allows the installation of Ansible collections or roles using C(ansible-galaxy).
class AnsibleGalaxyInstallOptions {
    /// This option has no longer any effect and will be removed in community.general 9.0.0.
    ack_ansible29: Boolean?
    /// This option has no longer any effect and will be removed in community.general 9.0.0.
    ack_min_ansiblecore211: Boolean?
    /// The path to the directory containing your collections or roles, according to the value of O(type).
    /// Please notice that C(ansible-galaxy) will not install collections with O(type=both), when O(requirements_file) contains both roles and collections and O(dest) is specified.
    dest: String?
    /// Force overwriting an existing role or collection.
    /// Using O(force=true) is mandatory when downgrading.
    force: Boolean?
    /// Name of the collection or role being installed.
    /// Versions can be specified with C(ansible-galaxy) usual formats. For example, the collection V(community.docker:1.6.1) or the role V(ansistrano.deploy,3.8.0).
    /// O(name) and O(requirements_file) are mutually exclusive.
    name: String?
    /// Refrain from installing dependencies.
    no_deps: Boolean?
    /// Path to a file containing a list of requirements to be installed.
    /// It works for O(type) equals to V(collection) and V(role).
    /// O(name) and O(requirements_file) are mutually exclusive.
    requirements_file: String?
    /// The type of installation performed by C(ansible-galaxy).
    /// If O(type=both), then O(requirements_file) must be passed and it may contain both roles and collections.
    /// Note however that the opposite is not true: if using a O(requirements_file), then O(type) can be any of the three choices.
    type: ("collection"|"role"|"both")
}

/// Task class for ansible_galaxy_install
class AnsibleGalaxyInstallTask extends Playbook.Task {
    /// todo doc
    `community.general.ansible_galaxy_install`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ansible_galaxy_install"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ansible_galaxy_install`
}

/// TaskBuilder class for ansible_galaxy_install
class AnsibleGalaxyInstall extends Playbook.TaskBuilder {
    /// Options for community.general.ansible_galaxy_install
    options: AnsibleGalaxyInstallOptions?
    /// todo doc
    function Task(): AnsibleGalaxyInstallTask = this
        .toMap()
        .put("community.general.ansible_galaxy_install", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(AnsibleGalaxyInstallTask)
}

/// Set and/or get members' attributes of an Apache httpd 2.4 mod_proxy balancer pool
/// Set and/or get members' attributes of an Apache httpd 2.4 mod_proxy balancer pool, using HTTP POST and GET requests. The httpd mod_proxy balancer-member status page has to be enabled and accessible, as this module relies on parsing this page. This module supports ansible check_mode, and requires BeautifulSoup python module.
class Apache2ModProxyOptions {
    /// Suffix of the balancer pool url required to access the balancer pool status page (e.g. balancer_vhost[:port]/balancer_url_suffix).
    balancer_url_suffix: String?
    /// (ipv4|ipv6|fqdn):port of the Apache httpd 2.4 mod_proxy balancer pool.
    balancer_vhost: String
    /// (ipv4|ipv6|fqdn) of the balancer member to get or to set attributes to. Port number is autodetected and should not be specified here. If undefined, apache2_mod_proxy module will return a members list of dictionaries of all the current balancer pool members' attributes.
    member_host: String?
    /// Desired state of the member host. (absent|disabled),drained,hot_standby,ignore_errors can be simultaneously invoked by separating them with a comma (e.g. state=drained,ignore_errors).
    /// Accepted state values: ["present", "absent", "enabled", "disabled", "drained", "hot_standby", "ignore_errors"]
    state: String?
    /// Use https to access balancer management page.
    tls: Boolean?
    /// Validate ssl/tls certificates.
    validate_certs: Boolean?
}

/// Task class for apache2_mod_proxy
class Apache2ModProxyTask extends Playbook.Task {
    /// todo doc
    `community.general.apache2_mod_proxy`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.apache2_mod_proxy"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.apache2_mod_proxy`
}

/// TaskBuilder class for apache2_mod_proxy
class Apache2ModProxy extends Playbook.TaskBuilder {
    /// Options for community.general.apache2_mod_proxy
    options: Apache2ModProxyOptions?
    /// todo doc
    function Task(): Apache2ModProxyTask = this
        .toMap()
        .put("community.general.apache2_mod_proxy", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(Apache2ModProxyTask)
}

/// Enables/disables a module of the Apache2 webserver
/// Enables or disables a specified module of the Apache2 webserver.
class Apache2ModuleOptions {
    /// Force disabling of default modules and override Debian warnings.
    force: Boolean?
    /// Identifier of the module as listed by C(apache2ctl -M). This is optional and usually determined automatically by the common convention of appending V(_module) to O(name) as well as custom exception for popular modules.
    identifier: String?
    /// Ignore configuration checks about inconsistent module configuration. Especially for mpm_* modules.
    ignore_configcheck: Boolean?
    /// Name of the module to enable/disable as given to C(a2enmod/a2dismod).
    name: String
    /// Desired state of the module.
    state: ("present"|"absent")?
    /// Control the behavior of the warning process for MPM modules.
    warn_mpm_absent: Boolean?
}

/// Task class for apache2_module
class Apache2ModuleTask extends Playbook.Task {
    /// todo doc
    `community.general.apache2_module`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.apache2_module"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.apache2_module`
}

/// TaskBuilder class for apache2_module
class Apache2Module extends Playbook.TaskBuilder {
    /// Options for community.general.apache2_module
    options: Apache2ModuleOptions?
    /// todo doc
    function Task(): Apache2ModuleTask = this
        .toMap()
        .put("community.general.apache2_module", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(Apache2ModuleTask)
}

/// Manages apk packages
/// Manages C(apk) packages for Alpine Linux.
class ApkOptions {
    /// During upgrade, reset versioned world dependencies and change logic to prefer replacing or downgrading packages (instead of holding them) if the currently installed package is no longer available from any repository.
    available: Boolean?
    /// A package name, like V(foo), or multiple packages, like V(foo,bar).
    /// Do not include additional whitespace when specifying multiple packages as a string. Prefer YAML lists over comma-separating multiple package names.
    name: Listing<String>?
    /// Do not use any local cache path.
    no_cache: Boolean?
    /// A package repository or multiple repositories. Unlike with the underlying apk command, this list will override the system repositories rather than supplement them.
    repository: Listing<String>?
    /// Indicates the desired package(s) state.
    /// V(present) ensures the package(s) is/are present. V(installed) can be used as an alias.
    /// V(absent) ensures the package(s) is/are absent. V(removed) can be used as an alias.
    /// V(latest) ensures the package(s) is/are present and the latest version(s).
    state: ("present"|"absent"|"latest"|"installed"|"removed")?
    /// Update repository indexes. Can be run with other steps or on its own.
    update_cache: Boolean?
    /// Upgrade all installed packages to their latest version.
    upgrade: Boolean?
    /// Use a custom world file when checking for explicitly installed packages.
    world: String?
}

/// Task class for apk
class ApkTask extends Playbook.Task {
    /// todo doc
    `community.general.apk`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.apk"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.apk`
}

/// TaskBuilder class for apk
class Apk extends Playbook.TaskBuilder {
    /// Options for community.general.apk
    options: ApkOptions?
    /// todo doc
    function Task(): ApkTask = this
        .toMap()
        .put("community.general.apk", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ApkTask)
}

/// Manage APT repositories via apt-repo
/// Manages APT repositories using apt-repo tool.
/// See U(https://www.altlinux.org/Apt-repo) for details about apt-repo
class AptRepoOptions {
    /// Remove other then added repositories
    /// Used if O(state=present)
    remove_others: Boolean?
    /// Name of the repository to add or remove.
    repo: String
    /// Indicates the desired repository state.
    state: ("absent"|"present")?
    /// Update the package database after changing repositories.
    update: Boolean?
}

/// Task class for apt_repo
class AptRepoTask extends Playbook.Task {
    /// todo doc
    `community.general.apt_repo`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.apt_repo"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.apt_repo`
}

/// TaskBuilder class for apt_repo
class AptRepo extends Playbook.TaskBuilder {
    /// Options for community.general.apt_repo
    options: AptRepoOptions?
    /// todo doc
    function Task(): AptRepoTask = this
        .toMap()
        .put("community.general.apt_repo", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(AptRepoTask)
}

/// APT-RPM package manager
/// Manages packages with C(apt-rpm). Both low-level (C(rpm)) and high-level (C(apt-get)) package manager binaries required.
class AptRpmOptions {
    /// Run the equivalent of C(apt-get clean) to clear out the local repository of retrieved package files. It removes everything but the lock file from C(/var/cache/apt/archives/) and C(/var/cache/apt/archives/partial/).
    /// Can be run as part of the package installation (clean runs before install) or as a separate step.
    clean: Boolean?
    /// If true performs an C(apt-get dist-upgrade) to upgrade system.
    dist_upgrade: Boolean?
    /// List of packages to install, upgrade, or remove.
    /// Since community.general 8.0.0, may include paths to local C(.rpm) files if O(state=installed) or O(state=present), requires C(rpm) python module.
    package: Listing<String>?
    /// Indicates the desired package state.
    /// Please note that V(present) and V(installed) are equivalent to V(latest) right now. This will change in the future. To simply ensure that a package is installed, without upgrading it, use the V(present_not_latest) state.
    /// The states V(latest) and V(present_not_latest) have been added in community.general 8.6.0.
    state: ("absent"|"present"|"present_not_latest"|"installed"|"removed"|"latest")?
    /// Run the equivalent of C(apt-get update) before the operation. Can be run as part of the package installation or as a separate step.
    /// Default is not to update the cache.
    update_cache: Boolean?
    /// If true performs an C(update-kernel) to upgrade kernel packages.
    update_kernel: Boolean?
}

/// Task class for apt_rpm
class AptRpmTask extends Playbook.Task {
    /// todo doc
    `community.general.apt_rpm`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.apt_rpm"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.apt_rpm`
}

/// TaskBuilder class for apt_rpm
class AptRpm extends Playbook.TaskBuilder {
    /// Options for community.general.apt_rpm
    options: AptRpmOptions?
    /// todo doc
    function Task(): AptRpmTask = this
        .toMap()
        .put("community.general.apt_rpm", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(AptRpmTask)
}

/// Creates a compressed archive of one or more files or trees
/// Creates or extends an archive.
/// The source and archive are on the remote host, and the archive I(is not) copied to the local host.
/// Source files can be deleted after archival by specifying O(remove=True).
class ArchiveOptions {
    /// The file name of the destination archive. The parent directory must exists on the remote host.
    /// This is required when O(path) refers to multiple files by either specifying a glob, a directory or multiple paths in a list.
    /// If the destination archive already exists, it will be truncated and overwritten.
    dest: String?
    /// Remote absolute path, glob, or list of paths or globs for the file or files to exclude from O(path) list and glob expansion.
    /// Use O(exclusion_patterns) to instead exclude files or subdirectories below any of the paths from the O(path) list.
    exclude_path: Listing<String>?
    /// Glob style patterns to exclude files or directories from the resulting archive.
    /// This differs from O(exclude_path) which applies only to the source paths from O(path).
    exclusion_patterns: Listing<String>?
    /// Allows you to force the module to treat this as an archive even if only a single file is specified.
    /// By default when a single file is specified it is compressed only (not archived).
    /// Enable this if you want to use M(ansible.builtin.unarchive) on an archive of a single file created with this module.
    force_archive: Boolean?
    /// The type of compression to use.
    format: ("bz2"|"gz"|"tar"|"xz"|"zip")?
    /// Remote absolute path, glob, or list of paths or globs for the file or files to compress or archive.
    path: Listing<String>
    /// Remove any added source files and trees after adding to archive.
    remove: Boolean?
}

/// Task class for archive
class ArchiveTask extends Playbook.Task {
    /// todo doc
    `community.general.archive`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.archive"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.archive`
}

/// TaskBuilder class for archive
class Archive extends Playbook.TaskBuilder {
    /// Options for community.general.archive
    options: ArchiveOptions?
    /// todo doc
    function Task(): ArchiveTask = this
        .toMap()
        .put("community.general.archive", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ArchiveTask)
}

/// Manage the containers on the atomic host platform
/// Manage the containers on the atomic host platform.
/// Allows to manage the lifecycle of a container on the atomic host platform.
class AtomicContainerOptions {
    /// Define the backend to use for the container.
    backend: ("docker"|"ostree")
    /// The image to use to install the container.
    image: String
    /// Define if it is an user or a system container.
    mode: ("user"|"system")?
    /// Name of the container.
    name: String
    /// Define the rootfs of the image.
    rootfs: String?
    /// State of the container.
    state: ("absent"|"latest"|"present"|"rollback")?
    /// Values for the installation of the container.
    /// This option is permitted only with mode 'user' or 'system'.
    /// The values specified here will be used at installation time as --set arguments for atomic install.
    values: Listing<String>?
}

/// Task class for atomic_container
class AtomicContainerTask extends Playbook.Task {
    /// todo doc
    `community.general.atomic_container`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.atomic_container"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.atomic_container`
}

/// TaskBuilder class for atomic_container
class AtomicContainer extends Playbook.TaskBuilder {
    /// Options for community.general.atomic_container
    options: AtomicContainerOptions?
    /// todo doc
    function Task(): AtomicContainerTask = this
        .toMap()
        .put("community.general.atomic_container", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(AtomicContainerTask)
}

/// Manage the atomic host platform
/// Manage the atomic host platform.
/// Rebooting of Atomic host platform should be done outside this module.
class AtomicHostOptions {
    /// The version number of the atomic host to be deployed.
    /// Providing V(latest) will upgrade to the latest available version.
    revision: String?
}

/// Task class for atomic_host
class AtomicHostTask extends Playbook.Task {
    /// todo doc
    `community.general.atomic_host`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.atomic_host"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.atomic_host`
}

/// TaskBuilder class for atomic_host
class AtomicHost extends Playbook.TaskBuilder {
    /// Options for community.general.atomic_host
    options: AtomicHostOptions?
    /// todo doc
    function Task(): AtomicHostTask = this
        .toMap()
        .put("community.general.atomic_host", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(AtomicHostTask)
}

/// Manage the container images on the atomic host platform
/// Manage the container images on the atomic host platform.
/// Allows to execute the commands specified by the RUN label in the container image when present.
class AtomicImageOptions {
    /// Define the backend where the image is pulled.
    backend: ("docker"|"ostree")?
    /// Name of the container image.
    name: String
    /// Start or Stop the container.
    started: Boolean?
    /// The state of the container image.
    /// The state V(latest) will ensure container image is upgraded to the latest version and forcefully restart container, if running.
    state: ("absent"|"latest"|"present")?
}

/// Task class for atomic_image
class AtomicImageTask extends Playbook.Task {
    /// todo doc
    `community.general.atomic_image`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.atomic_image"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.atomic_image`
}

/// TaskBuilder class for atomic_image
class AtomicImage extends Playbook.TaskBuilder {
    /// Options for community.general.atomic_image
    options: AtomicImageOptions?
    /// todo doc
    function Task(): AtomicImageTask = this
        .toMap()
        .put("community.general.atomic_image", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(AtomicImageTask)
}

/// Manage awall policies
/// This modules allows for enable/disable/activate of C(awall) policies.
/// Alpine Wall (C(awall)) generates a firewall configuration from the enabled policy files and activates the configuration on the system.
class AwallOptions {
    /// Activate the new firewall rules.
    /// Can be run with other steps or on its own.
    /// Idempotency is affected if O(activate=true), as the module will always report a changed state.
    activate: Boolean?
    /// One or more policy names.
    name: Listing<String>?
    /// Whether the policies should be enabled or disabled.
    state: ("disabled"|"enabled")?
}

/// Task class for awall
class AwallTask extends Playbook.Task {
    /// todo doc
    `community.general.awall`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.awall"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.awall`
}

/// TaskBuilder class for awall
class Awall extends Playbook.TaskBuilder {
    /// Options for community.general.awall
    options: AwallOptions?
    /// todo doc
    function Task(): AwallTask = this
        .toMap()
        .put("community.general.awall", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(AwallTask)
}

/// Manage ZFS boot environments on FreeBSD/Solaris/illumos systems
/// Create, delete or activate ZFS boot environments.
/// Mount and unmount ZFS boot environments.
class BeadmOptions {
    /// Associate a description with a new boot environment. This option is available only on Solarish platforms.
    description: String?
    /// Specifies if the unmount should be forced.
    force: Boolean?
    /// Path where to mount the ZFS boot environment.
    mountpoint: String?
    /// ZFS boot environment name.
    name: String
    /// Create the datasets for new BE with specific ZFS properties.
    /// Multiple options can be specified.
    /// This option is available only on Solarish platforms.
    options: String?
    /// If specified, the new boot environment will be cloned from the given snapshot or inactive boot environment.
    snapshot: String?
    /// Create or delete ZFS boot environment.
    state: ("absent"|"activated"|"mounted"|"present"|"unmounted")?
}

/// Task class for beadm
class BeadmTask extends Playbook.Task {
    /// todo doc
    `community.general.beadm`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.beadm"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.beadm`
}

/// TaskBuilder class for beadm
class Beadm extends Playbook.TaskBuilder {
    /// Options for community.general.beadm
    options: BeadmOptions?
    /// todo doc
    function Task(): BeadmTask = this
        .toMap()
        .put("community.general.beadm", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(BeadmTask)
}

/// Send BearyChat notifications
/// The M(community.general.bearychat) module sends notifications to U(https://bearychat.com) via the Incoming Robot integration.
class BearychatOptions {
    /// Define a list of attachments. For more information, see https://github.com/bearyinnovative/bearychat-tutorial/blob/master/robots/incoming.md#attachments
    attachments: Listing<Any>?
    /// Channel to send the message to. If absent, the message goes to the default channel selected by the O(url).
    channel: String?
    /// If V(true), text will be parsed as markdown.
    markdown: Boolean?
    /// Message to send.
    text: String?
    /// BearyChat WebHook URL. This authenticates you to the bearychat service. It looks like V(https://hook.bearychat.com/=ae2CF/incoming/e61bd5c57b164e04b11ac02e66f47f60).
    url: String
}

/// Task class for bearychat
class BearychatTask extends Playbook.Task {
    /// todo doc
    `community.general.bearychat`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.bearychat"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.bearychat`
}

/// TaskBuilder class for bearychat
class Bearychat extends Playbook.TaskBuilder {
    /// Options for community.general.bearychat
    options: BearychatOptions?
    /// todo doc
    function Task(): BearychatTask = this
        .toMap()
        .put("community.general.bearychat", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(BearychatTask)
}

/// Notify BigPanda about deployments
/// Notify BigPanda when deployments start and end (successfully or not). Returns a deployment object containing all the parameters for future module calls.
class BigpandaOptions {
    /// The name of the component being deployed. Ex: billing
    component: String
    /// Message about the deployment.
    deployment_message: String?
    /// Free text description of the deployment.
    description: String?
    /// The environment name, typically 'production', 'staging', etc.
    env: String?
    /// Name of affected host name. Can be a list.
    /// If not specified, it defaults to the remote system's hostname.
    hosts: String?
    /// The person responsible for the deployment.
    owner: String?
    /// Source system used in the requests to the API
    source_system: String?
    /// State of the deployment.
    state: ("started"|"finished"|"failed")
    /// API token.
    token: String
    /// Base URL of the API server.
    url: String?
    /// If V(false), SSL certificates for the target url will not be validated. This should only be used on personally controlled sites using self-signed certificates.
    validate_certs: Boolean?
    /// The deployment version.
    version: String
}

/// Task class for bigpanda
class BigpandaTask extends Playbook.Task {
    /// todo doc
    `community.general.bigpanda`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.bigpanda"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.bigpanda`
}

/// TaskBuilder class for bigpanda
class Bigpanda extends Playbook.TaskBuilder {
    /// Options for community.general.bigpanda
    options: BigpandaOptions?
    /// todo doc
    function Task(): BigpandaTask = this
        .toMap()
        .put("community.general.bigpanda", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(BigpandaTask)
}

/// Manages Bitbucket repository access keys
/// Manages Bitbucket repository access keys (also called deploy keys).
class BitbucketAccessKeyOptions {
    /// The SSH public key.
    key: String?
    /// The key label.
    label: String
    /// The repository name.
    repository: String
    /// Indicates desired state of the access key.
    state: ("absent"|"present")
    /// The repository owner.
    /// B(Note:) O(ignore:username) used to be an alias of this option. Since community.general 6.0.0 it is an alias of O(user).
    workspace: String
}

/// Task class for bitbucket_access_key
class BitbucketAccessKeyTask extends Playbook.Task {
    /// todo doc
    `community.general.bitbucket_access_key`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.bitbucket_access_key"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.bitbucket_access_key`
}

/// TaskBuilder class for bitbucket_access_key
class BitbucketAccessKey extends Playbook.TaskBuilder {
    /// Options for community.general.bitbucket_access_key
    options: BitbucketAccessKeyOptions?
    /// todo doc
    function Task(): BitbucketAccessKeyTask = this
        .toMap()
        .put("community.general.bitbucket_access_key", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(BitbucketAccessKeyTask)
}

/// Manages Bitbucket pipeline SSH key pair
/// Manages Bitbucket pipeline SSH key pair.
class BitbucketPipelineKeyPairOptions {
    /// The private key.
    private_key: String?
    /// The public key.
    public_key: String?
    /// The repository name.
    repository: String
    /// Indicates desired state of the key pair.
    state: ("absent"|"present")
    /// The repository owner.
    /// B(Note:) O(ignore:username) used to be an alias of this option. Since community.general 6.0.0 it is an alias of O(user).
    workspace: String
}

/// Task class for bitbucket_pipeline_key_pair
class BitbucketPipelineKeyPairTask extends Playbook.Task {
    /// todo doc
    `community.general.bitbucket_pipeline_key_pair`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.bitbucket_pipeline_key_pair"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.bitbucket_pipeline_key_pair`
}

/// TaskBuilder class for bitbucket_pipeline_key_pair
class BitbucketPipelineKeyPair extends Playbook.TaskBuilder {
    /// Options for community.general.bitbucket_pipeline_key_pair
    options: BitbucketPipelineKeyPairOptions?
    /// todo doc
    function Task(): BitbucketPipelineKeyPairTask = this
        .toMap()
        .put("community.general.bitbucket_pipeline_key_pair", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(BitbucketPipelineKeyPairTask)
}

/// Manages Bitbucket pipeline known hosts
/// Manages Bitbucket pipeline known hosts under the "SSH Keys" menu.
/// The host fingerprint will be retrieved automatically, but in case of an error, one can use O(key) field to specify it manually.
class BitbucketPipelineKnownHostOptions {
    /// The public key.
    key: String?
    /// The FQDN of the known host.
    name: String
    /// The repository name.
    repository: String
    /// Indicates desired state of the record.
    state: ("absent"|"present")
    /// The repository owner.
    /// B(Note:) O(ignore:username) used to be an alias of this option. Since community.general 6.0.0 it is an alias of O(user).
    workspace: String
}

/// Task class for bitbucket_pipeline_known_host
class BitbucketPipelineKnownHostTask extends Playbook.Task {
    /// todo doc
    `community.general.bitbucket_pipeline_known_host`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.bitbucket_pipeline_known_host"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.bitbucket_pipeline_known_host`
}

/// TaskBuilder class for bitbucket_pipeline_known_host
class BitbucketPipelineKnownHost extends Playbook.TaskBuilder {
    /// Options for community.general.bitbucket_pipeline_known_host
    options: BitbucketPipelineKnownHostOptions?
    /// todo doc
    function Task(): BitbucketPipelineKnownHostTask = this
        .toMap()
        .put("community.general.bitbucket_pipeline_known_host", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(BitbucketPipelineKnownHostTask)
}

/// Manages Bitbucket pipeline variables
/// Manages Bitbucket pipeline variables.
class BitbucketPipelineVariableOptions {
    /// The pipeline variable name.
    name: String
    /// The repository name.
    repository: String
    /// Whether to encrypt the variable value.
    secured: Boolean?
    /// Indicates desired state of the variable.
    state: ("absent"|"present")
    /// The pipeline variable value.
    value: String?
    /// The repository owner.
    /// B(Note:) O(ignore:username) used to be an alias of this option. Since community.general 6.0.0 it is an alias of O(user).
    workspace: String
}

/// Task class for bitbucket_pipeline_variable
class BitbucketPipelineVariableTask extends Playbook.Task {
    /// todo doc
    `community.general.bitbucket_pipeline_variable`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.bitbucket_pipeline_variable"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.bitbucket_pipeline_variable`
}

/// TaskBuilder class for bitbucket_pipeline_variable
class BitbucketPipelineVariable extends Playbook.TaskBuilder {
    /// Options for community.general.bitbucket_pipeline_variable
    options: BitbucketPipelineVariableOptions?
    /// todo doc
    function Task(): BitbucketPipelineVariableTask = this
        .toMap()
        .put("community.general.bitbucket_pipeline_variable", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(BitbucketPipelineVariableTask)
}

/// Manage bower packages with bower
/// Manage bower packages with bower
class BowerOptions {
    /// The name of a bower package to install
    name: String?
    /// Install packages from local cache, if the packages were installed before
    offline: Boolean?
    /// The base path where to install the bower packages
    path: String
    /// Install with --production flag
    production: Boolean?
    /// Relative path to bower executable from install path
    relative_execpath: String?
    /// The state of the bower package
    state: ("present"|"absent"|"latest")?
    /// The version to be installed
    version: String?
}

/// Task class for bower
class BowerTask extends Playbook.Task {
    /// todo doc
    `community.general.bower`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.bower"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.bower`
}

/// TaskBuilder class for bower
class Bower extends Playbook.TaskBuilder {
    /// Options for community.general.bower
    options: BowerOptions?
    /// todo doc
    function Task(): BowerTask = this
        .toMap()
        .put("community.general.bower", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(BowerTask)
}

/// Query btrfs filesystem info
/// Query status of available btrfs filesystems, including uuid, label, subvolumes and mountpoints.
class BtrfsInfoOptions {
}

/// Task class for btrfs_info
class BtrfsInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.btrfs_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.btrfs_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.btrfs_info`
}

/// TaskBuilder class for btrfs_info
class BtrfsInfo extends Playbook.TaskBuilder {
    /// Options for community.general.btrfs_info
    options: BtrfsInfoOptions?
    /// todo doc
    function Task(): BtrfsInfoTask = this
        .toMap()
        .put("community.general.btrfs_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(BtrfsInfoTask)
}

/// Manage btrfs subvolumes
/// Creates, updates and deletes btrfs subvolumes and snapshots.
class BtrfsSubvolumeOptions {
    /// Allow the module to temporarily mount the targeted btrfs filesystem in order to validate the current state and make any required changes.
    automount: Boolean?
    /// Make the subvolume specified by O(name) the filesystem's default subvolume.
    default: Boolean?
    /// A block device contained within the btrfs filesystem to be targeted.
    /// Useful when multiple btrfs filesystems are present to specify which filesystem should be targeted.
    filesystem_device: String?
    /// A descriptive label assigned to the btrfs filesystem to be targeted.
    /// Useful when multiple btrfs filesystems are present to specify which filesystem should be targeted.
    filesystem_label: String?
    /// A unique identifier assigned to the btrfs filesystem to be targeted.
    /// Useful when multiple btrfs filesystems are present to specify which filesystem should be targeted.
    filesystem_uuid: String?
    /// Name of the subvolume/snapshot to be targeted.
    name: String
    /// When true, indicates that parent/child subvolumes should be created/removedas necessary to complete the operation (for O(state=present) and O(state=absent) respectively).
    recursive: Boolean?
    /// Policy defining behavior when a subvolume already exists at the path of the requested snapshot.
    /// V(skip) - Create a snapshot only if a subvolume does not yet exist at the target location, otherwise indicate that no change is required. Warning, this option does not yet verify that the target subvolume was generated from a snapshot of the requested source.
    /// V(clobber) - If a subvolume already exists at the requested location, delete it first. This option is not idempotent and will result in a new snapshot being generated on every execution.
    /// V(error) - If a subvolume already exists at the requested location, return an error. This option is not idempotent and will result in an error on replay of the module.
    snapshot_conflict: ("skip"|"clobber"|"error")?
    /// Identifies the source subvolume for the created snapshot.
    /// Infers that the created subvolume is a snapshot.
    snapshot_source: String?
    /// Indicates the current state of the targeted subvolume.
    state: ("absent"|"present")?
}

/// Task class for btrfs_subvolume
class BtrfsSubvolumeTask extends Playbook.Task {
    /// todo doc
    `community.general.btrfs_subvolume`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.btrfs_subvolume"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.btrfs_subvolume`
}

/// TaskBuilder class for btrfs_subvolume
class BtrfsSubvolume extends Playbook.TaskBuilder {
    /// Options for community.general.btrfs_subvolume
    options: BtrfsSubvolumeOptions?
    /// todo doc
    function Task(): BtrfsSubvolumeTask = this
        .toMap()
        .put("community.general.btrfs_subvolume", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(BtrfsSubvolumeTask)
}

/// Manage Ruby Gem dependencies with Bundler
/// Manage installation and Gem version dependencies for Ruby using the Bundler gem
class BundlerOptions {
    /// Only applies if O(state=present). Specifies the directory to install any gem bins files to. When executed the bin files will run within the context of the Gemfile and fail if any required gem dependencies are not installed. If O(chdir) is set then this path is relative to O(chdir)
    binstub_directory: String?
    /// The directory to execute the bundler commands from. This directory needs to contain a valid Gemfile or .bundle/ directory
    /// If not specified, it will default to the temporary working directory
    chdir: String?
    /// Only applies if O(state=present). If set removes any gems on the target host that are not in the gemfile
    clean: Boolean?
    /// Only applies if O(state=present). If set it will install gems in ./vendor/bundle instead of the default location. Requires a Gemfile.lock file to have been created prior
    deployment_mode: Boolean?
    /// A list of Gemfile groups to exclude during operations. This only applies when O(state=present). Bundler considers this a 'remembered' property for the Gemfile and will automatically exclude groups in future operations even if O(exclude_groups) is not set
    exclude_groups: Listing<String>?
    /// The path to the bundler executable
    executable: String?
    /// A space separated string of additional commands that can be applied to the Bundler command. Refer to the Bundler documentation for more information
    extra_args: String?
    /// Only applies if O(state=present). Specifies the directory to install the gems into. If O(chdir) is set then this path is relative to O(chdir)
    /// If not specified the default RubyGems gem paths will be used.
    gem_path: String?
    /// Only applies if O(state=present). The path to the gemfile to use to install gems.
    /// If not specified it will default to the Gemfile in current directory
    gemfile: String?
    /// If set only installs gems from the cache on the target host
    `local`: Boolean?
    /// The desired state of the Gem bundle. V(latest) updates gems to the most recent, acceptable version
    state: ("present"|"latest")?
    /// Only applies if O(state=present). Installs gems in the local user's cache or for all users
    user_install: Boolean?
}

/// Task class for bundler
class BundlerTask extends Playbook.Task {
    /// todo doc
    `community.general.bundler`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.bundler"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.bundler`
}

/// TaskBuilder class for bundler
class Bundler extends Playbook.TaskBuilder {
    /// Options for community.general.bundler
    options: BundlerOptions?
    /// todo doc
    function Task(): BundlerTask = this
        .toMap()
        .put("community.general.bundler", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(BundlerTask)
}

/// Deploy software (or files) from bzr branches
/// Manage C(bzr) branches to deploy files or software.
class BzrOptions {
    /// Absolute path of where the branch should be cloned to.
    dest: String
    /// Path to bzr executable to use. If not supplied, the normal mechanism for resolving binary paths will be used.
    executable: String?
    /// If V(true), any modified files in the working tree will be discarded.
    force: Boolean?
    /// SSH or HTTP protocol address of the parent branch.
    name: String
    /// What version of the branch to clone.  This can be the bzr revno or revid.
    version: String?
}

/// Task class for bzr
class BzrTask extends Playbook.Task {
    /// todo doc
    `community.general.bzr`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.bzr"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.bzr`
}

/// TaskBuilder class for bzr
class Bzr extends Playbook.TaskBuilder {
    /// Options for community.general.bzr
    options: BzrOptions?
    /// todo doc
    function Task(): BzrTask = this
        .toMap()
        .put("community.general.bzr", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(BzrTask)
}

/// Send a message to Campfire
/// Send a message to Campfire.
/// Messages with newlines will result in a "Paste" message being sent.
class CampfireOptions {
    /// The message body.
    msg: String
    /// Send a notification sound before the message.
    notify: ("56k"|"bell"|"bezos"|"bueller"|"clowntown"|"cottoneyejoe"|"crickets"|"dadgummit"|"dangerzone"|"danielsan"|"deeper"|"drama"|"greatjob"|"greyjoy"|"guarantee"|"heygirl"|"horn"|"horror"|"inconceivable"|"live"|"loggins"|"makeitso"|"noooo"|"nyan"|"ohmy"|"ohyeah"|"pushit"|"rimshot"|"rollout"|"rumble"|"sax"|"secret"|"sexyback"|"story"|"tada"|"tmyk"|"trololo"|"trombone"|"unix"|"vuvuzela"|"what"|"whoomp"|"yeah"|"yodel")?
    /// Room number to which the message should be sent.
    room: String
    /// The subscription name to use.
    subscription: String
    /// API token.
    token: String
}

/// Task class for campfire
class CampfireTask extends Playbook.Task {
    /// todo doc
    `community.general.campfire`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.campfire"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.campfire`
}

/// TaskBuilder class for campfire
class Campfire extends Playbook.TaskBuilder {
    /// Options for community.general.campfire
    options: CampfireOptions?
    /// todo doc
    function Task(): CampfireTask = this
        .toMap()
        .put("community.general.campfire", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(CampfireTask)
}

/// Manage Linux capabilities
/// This module manipulates files privileges using the Linux capabilities(7) system.
class CapabilitiesOptions {
    /// Desired capability to set (with operator and flags, if O(state=present)) or remove (if O(state=absent))
    capability: String
    /// Specifies the path to the file to be managed.
    path: String
    /// Whether the entry should be present or absent in the file's capabilities.
    state: ("absent"|"present")?
}

/// Task class for capabilities
class CapabilitiesTask extends Playbook.Task {
    /// todo doc
    `community.general.capabilities`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.capabilities"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.capabilities`
}

/// TaskBuilder class for capabilities
class Capabilities extends Playbook.TaskBuilder {
    /// Options for community.general.capabilities
    options: CapabilitiesOptions?
    /// todo doc
    function Task(): CapabilitiesTask = this
        .toMap()
        .put("community.general.capabilities", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(CapabilitiesTask)
}

/// Manage Rust packages with cargo
/// Manage Rust packages with cargo.
class CargoOptions {
    /// Path to the C(cargo) installed in the system.
    /// If not specified, the module will look C(cargo) in E(PATH).
    executable: String?
    /// Install with locked dependencies.
    /// This is only used when installing packages.
    locked: Boolean?
    /// The name of a Rust package to install.
    name: Listing<String>
    /// -> The base path where to install the Rust packages. Cargo automatically appends V(/bin). In other words, V(/usr/local) will become V(/usr/local/bin).
    path: String?
    /// The state of the Rust package.
    state: ("present"|"absent"|"latest")?
    /// -> The version to install. If O(name) contains multiple values, the module will try to install all of them in this version.
    version: String?
}

/// Task class for cargo
class CargoTask extends Playbook.Task {
    /// todo doc
    `community.general.cargo`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.cargo"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.cargo`
}

/// TaskBuilder class for cargo
class Cargo extends Playbook.TaskBuilder {
    /// Options for community.general.cargo
    options: CargoOptions?
    /// todo doc
    function Task(): CargoTask = this
        .toMap()
        .put("community.general.cargo", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(CargoTask)
}

/// Send a sms / mms using the catapult bandwidth api
/// Allows notifications to be sent using sms / mms via the catapult bandwidth api.
class CatapultOptions {
    /// Api Secret from Api account page.
    api_secret: String
    /// Api Token from Api account page.
    api_token: String
    /// The phone number or numbers the message should be sent to (must be in E.164 format, like V(+19195551212)).
    dest: Listing<String>
    /// For MMS messages, a media url to the location of the media to be sent with the message.
    media: String?
    /// The contents of the text message (must be 2048 characters or less).
    msg: String
    /// One of your catapult telephone numbers the message should come from (must be in E.164 format, like V(+19195551212)).
    src: String
    /// User Id from Api account page.
    user_id: String
}

/// Task class for catapult
class CatapultTask extends Playbook.Task {
    /// todo doc
    `community.general.catapult`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.catapult"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.catapult`
}

/// TaskBuilder class for catapult
class Catapult extends Playbook.TaskBuilder {
    /// Options for community.general.catapult
    options: CatapultOptions?
    /// todo doc
    function Task(): CatapultTask = this
        .toMap()
        .put("community.general.catapult", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(CatapultTask)
}

/// Create an annotation in circonus
/// Create an annotation event with a given category, title and description. Optionally start, end or durations can be provided
class CirconusAnnotationOptions {
    /// Circonus API key
    api_key: String
    /// Annotation Category
    category: String
    /// Description of annotation
    description: String
    /// Duration in seconds of annotation
    duration: Int?
    /// Unix timestamp of event start
    /// If not specified, it defaults to "now".
    start: Int?
    /// Unix timestamp of event end
    /// If not specified, it defaults to "now" + O(duration).
    stop: Int?
    /// Title of annotation
    title: String
}

/// Task class for circonus_annotation
class CirconusAnnotationTask extends Playbook.Task {
    /// todo doc
    `community.general.circonus_annotation`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.circonus_annotation"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.circonus_annotation`
}

/// TaskBuilder class for circonus_annotation
class CirconusAnnotation extends Playbook.TaskBuilder {
    /// Options for community.general.circonus_annotation
    options: CirconusAnnotationOptions?
    /// todo doc
    function Task(): CirconusAnnotationTask = this
        .toMap()
        .put("community.general.circonus_annotation", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(CirconusAnnotationTask)
}

/// Send a message to a Cisco Webex Teams Room or Individual
/// Send a message to a Cisco Webex Teams Room or Individual with options to control the formatting.
class CiscoWebexOptions {
    /// The message you would like to send.
    msg: String
    /// Specifies how you would like the message formatted.
    msg_type: ("text"|"markdown")?
    /// Your personal access token required to validate the Webex Teams API.
    personal_token: String
    /// The unique identifier associated with the supplied O(recipient_type).
    recipient_id: String
    /// The request parameter you would like to send the message to.
    /// Messages can be sent to either a room or individual (by ID or E-Mail).
    recipient_type: ("roomId"|"toPersonEmail"|"toPersonId")
}

/// Task class for cisco_webex
class CiscoWebexTask extends Playbook.Task {
    /// todo doc
    `community.general.cisco_webex`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.cisco_webex"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.cisco_webex`
}

/// TaskBuilder class for cisco_webex
class CiscoWebex extends Playbook.TaskBuilder {
    /// Options for community.general.cisco_webex
    options: CiscoWebexOptions?
    /// todo doc
    function Task(): CiscoWebexTask = this
        .toMap()
        .put("community.general.cisco_webex", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(CiscoWebexTask)
}

/// Create or Delete Anti Affinity Policies at CenturyLink Cloud
/// An Ansible module to Create or Delete Anti Affinity Policies at CenturyLink Cloud.
class ClcAaPolicyOptions {
    /// Datacenter in which the policy lives/should live.
    location: String
    /// The name of the Anti Affinity Policy.
    name: String
    /// Whether to create or delete the policy.
    state: ("present"|"absent")?
}

/// Task class for clc_aa_policy
class ClcAaPolicyTask extends Playbook.Task {
    /// todo doc
    `community.general.clc_aa_policy`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.clc_aa_policy"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.clc_aa_policy`
}

/// TaskBuilder class for clc_aa_policy
class ClcAaPolicy extends Playbook.TaskBuilder {
    /// Options for community.general.clc_aa_policy
    options: ClcAaPolicyOptions?
    /// todo doc
    function Task(): ClcAaPolicyTask = this
        .toMap()
        .put("community.general.clc_aa_policy", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ClcAaPolicyTask)
}

/// Create or Delete Alert Policies at CenturyLink Cloud
/// An Ansible module to Create or Delete Alert Policies at CenturyLink Cloud.
class ClcAlertPolicyOptions {
    /// A list of recipient email ids to notify the alert. This is required for state 'present'
    alert_recipients: Listing<String>?
    /// The alias of your CLC Account
    alias: String
    /// The length of time in minutes that the condition must exceed the threshold. This is required for state 'present'
    duration: String?
    /// The alert policy id. This is mutually exclusive with name
    id: String?
    /// The metric on which to measure the condition that will trigger the alert. This is required for state 'present'
    metric: ("cpu"|"memory"|"disk")?
    /// The name of the alert policy. This is mutually exclusive with id
    name: String?
    /// Whether to create or delete the policy.
    state: ("present"|"absent")?
    /// The threshold that will trigger the alert when the metric equals or exceeds it. This is required for state 'present' This number represents a percentage and must be a value between 5.0 - 95.0 that is a multiple of 5.0
    threshold: Int?
}

/// Task class for clc_alert_policy
class ClcAlertPolicyTask extends Playbook.Task {
    /// todo doc
    `community.general.clc_alert_policy`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.clc_alert_policy"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.clc_alert_policy`
}

/// TaskBuilder class for clc_alert_policy
class ClcAlertPolicy extends Playbook.TaskBuilder {
    /// Options for community.general.clc_alert_policy
    options: ClcAlertPolicyOptions?
    /// todo doc
    function Task(): ClcAlertPolicyTask = this
        .toMap()
        .put("community.general.clc_alert_policy", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ClcAlertPolicyTask)
}

/// Deploys a blue print package on a set of servers in CenturyLink Cloud
/// An Ansible module to deploy blue print package on a set of servers in CenturyLink Cloud.
class ClcBlueprintPackageOptions {
    /// The package id of the blue print.
    package_id: String
    /// The dictionary of arguments required to deploy the blue print.
    package_params: Any?
    /// A list of server Ids to deploy the blue print package.
    server_ids: Listing<String>
    /// Whether to install or uninstall the package. Currently it supports only "present" for install action.
    state: ("present")?
    /// Whether to wait for the tasks to finish before returning.
    wait: String?
}

/// Task class for clc_blueprint_package
class ClcBlueprintPackageTask extends Playbook.Task {
    /// todo doc
    `community.general.clc_blueprint_package`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.clc_blueprint_package"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.clc_blueprint_package`
}

/// TaskBuilder class for clc_blueprint_package
class ClcBlueprintPackage extends Playbook.TaskBuilder {
    /// Options for community.general.clc_blueprint_package
    options: ClcBlueprintPackageOptions?
    /// todo doc
    function Task(): ClcBlueprintPackageTask = this
        .toMap()
        .put("community.general.clc_blueprint_package", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ClcBlueprintPackageTask)
}

/// Create/delete/update firewall policies
/// Create or delete or update firewall policies on Centurylink Cloud
class ClcFirewallPolicyOptions {
    /// The list of destination addresses for traffic on the terminating firewall. This is required when state is 'present'
    destination: Listing<String>?
    /// CLC alias for the destination account
    destination_account_alias: String?
    /// Whether the firewall policy is enabled or disabled
    enabled: ("True"|"False")?
    /// Id of the firewall policy. This is required to update or delete an existing firewall policy
    firewall_policy_id: String?
    /// Target datacenter for the firewall policy
    location: String
    /// The list of ports associated with the policy. TCP and UDP can take in single ports or port ranges.
    /// Example: V(['any', 'icmp', 'TCP/123', 'UDP/123', 'TCP/123-456', 'UDP/123-456']).
    ports: Listing<String>?
    /// The list  of source addresses for traffic on the originating firewall. This is required when state is 'present'
    source: Listing<String>?
    /// CLC alias for the source account
    source_account_alias: String
    /// Whether to create or delete the firewall policy
    state: ("present"|"absent")?
    /// Whether to wait for the provisioning tasks to finish before returning.
    wait: String?
}

/// Task class for clc_firewall_policy
class ClcFirewallPolicyTask extends Playbook.Task {
    /// todo doc
    `community.general.clc_firewall_policy`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.clc_firewall_policy"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.clc_firewall_policy`
}

/// TaskBuilder class for clc_firewall_policy
class ClcFirewallPolicy extends Playbook.TaskBuilder {
    /// Options for community.general.clc_firewall_policy
    options: ClcFirewallPolicyOptions?
    /// todo doc
    function Task(): ClcFirewallPolicyTask = this
        .toMap()
        .put("community.general.clc_firewall_policy", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ClcFirewallPolicyTask)
}

/// Create/delete Server Groups at Centurylink Cloud
/// Create or delete Server Groups at Centurylink Centurylink Cloud
class ClcGroupOptions {
    /// A description of the Server Group
    description: String?
    /// Datacenter to create the group in. If location is not provided, the group gets created in the default datacenter associated with the account
    location: String?
    /// The name of the Server Group
    name: String
    /// The parent group of the server group. If parent is not provided, it creates the group at top level.
    parent: String?
    /// Whether to create or delete the group
    state: ("present"|"absent")?
    /// Whether to wait for the tasks to finish before returning.
    wait: Boolean?
}

/// Task class for clc_group
class ClcGroupTask extends Playbook.Task {
    /// todo doc
    `community.general.clc_group`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.clc_group"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.clc_group`
}

/// TaskBuilder class for clc_group
class ClcGroup extends Playbook.TaskBuilder {
    /// Options for community.general.clc_group
    options: ClcGroupOptions?
    /// todo doc
    function Task(): ClcGroupTask = this
        .toMap()
        .put("community.general.clc_group", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ClcGroupTask)
}

/// Create, Delete shared loadbalancers in CenturyLink Cloud
/// An Ansible module to Create, Delete shared loadbalancers in CenturyLink Cloud.
class ClcLoadbalancerOptions {
    /// The alias of your CLC Account
    alias: String
    /// A description for the loadbalancer
    description: String?
    /// The location of the datacenter where the load balancer resides in
    location: String
    /// -The balancing method for the load balancer pool
    method: ("leastConnection"|"roundRobin")?
    /// The name of the loadbalancer
    name: String
    /// A list of nodes that needs to be added to the load balancer pool
    nodes: Listing<Any>?
    /// The persistence method for the load balancer
    persistence: ("standard"|"sticky")?
    /// Port to configure on the public-facing side of the load balancer pool
    port: ("80"|"443")?
    /// Whether to create or delete the load balancer pool
    state: ("present"|"absent"|"port_absent"|"nodes_present"|"nodes_absent")?
    /// The status of the loadbalancer
    status: ("enabled"|"disabled")?
}

/// Task class for clc_loadbalancer
class ClcLoadbalancerTask extends Playbook.Task {
    /// todo doc
    `community.general.clc_loadbalancer`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.clc_loadbalancer"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.clc_loadbalancer`
}

/// TaskBuilder class for clc_loadbalancer
class ClcLoadbalancer extends Playbook.TaskBuilder {
    /// Options for community.general.clc_loadbalancer
    options: ClcLoadbalancerOptions?
    /// todo doc
    function Task(): ClcLoadbalancerTask = this
        .toMap()
        .put("community.general.clc_loadbalancer", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ClcLoadbalancerTask)
}

/// Modify servers in CenturyLink Cloud
/// An Ansible module to modify servers in CenturyLink Cloud.
class ClcModifyServerOptions {
    /// The alert policy id to be associated to the server. This is mutually exclusive with 'alert_policy_name'
    alert_policy_id: String?
    /// The alert policy name to be associated to the server. This is mutually exclusive with 'alert_policy_id'
    alert_policy_name: String?
    /// The anti affinity policy id to be set for a hyper scale server. This is mutually exclusive with 'anti_affinity_policy_name'
    anti_affinity_policy_id: String?
    /// The anti affinity policy name to be set for a hyper scale server. This is mutually exclusive with 'anti_affinity_policy_id'
    anti_affinity_policy_name: String?
    /// How many CPUs to update on the server
    cpu: String?
    /// Memory (in GB) to set to the server.
    memory: String?
    /// A list of server Ids to modify.
    server_ids: Listing<String>
    /// The state to insure that the provided resources are in.
    state: ("present"|"absent")?
    /// Whether to wait for the provisioning tasks to finish before returning.
    wait: Boolean?
}

/// Task class for clc_modify_server
class ClcModifyServerTask extends Playbook.Task {
    /// todo doc
    `community.general.clc_modify_server`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.clc_modify_server"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.clc_modify_server`
}

/// TaskBuilder class for clc_modify_server
class ClcModifyServer extends Playbook.TaskBuilder {
    /// Options for community.general.clc_modify_server
    options: ClcModifyServerOptions?
    /// todo doc
    function Task(): ClcModifyServerTask = this
        .toMap()
        .put("community.general.clc_modify_server", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ClcModifyServerTask)
}

/// Add and Delete public ips on servers in CenturyLink Cloud
/// An Ansible module to add or delete public ip addresses on an existing server or servers in CenturyLink Cloud.
class ClcPublicipOptions {
    /// A list of ports to expose. This is required when state is 'present'
    ports: Listing<Int>?
    /// The protocol that the public IP will listen for.
    protocol: ("TCP"|"UDP"|"ICMP")?
    /// A list of servers to create public ips on.
    server_ids: Listing<String>
    /// Determine whether to create or delete public IPs. If present module will not create a second public ip if one already exists.
    state: ("present"|"absent")?
    /// Whether to wait for the tasks to finish before returning.
    wait: Boolean?
}

/// Task class for clc_publicip
class ClcPublicipTask extends Playbook.Task {
    /// todo doc
    `community.general.clc_publicip`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.clc_publicip"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.clc_publicip`
}

/// TaskBuilder class for clc_publicip
class ClcPublicip extends Playbook.TaskBuilder {
    /// Options for community.general.clc_publicip
    options: ClcPublicipOptions?
    /// todo doc
    function Task(): ClcPublicipTask = this
        .toMap()
        .put("community.general.clc_publicip", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ClcPublicipTask)
}

/// Create, Delete, Start and Stop servers in CenturyLink Cloud
/// An Ansible module to Create, Delete, Start and Stop servers in CenturyLink Cloud.
class ClcServerOptions {
    /// Whether to add a public ip to the server
    add_public_ip: Boolean?
    /// The list of additional disks for the server
    additional_disks: Listing<Any>?
    /// The alert policy to assign to the server. This is mutually exclusive with 'alert_policy_name'.
    alert_policy_id: String?
    /// The alert policy to assign to the server. This is mutually exclusive with 'alert_policy_id'.
    alert_policy_name: String?
    /// The account alias to provision the servers under.
    alias: String?
    /// The anti-affinity policy to assign to the server. This is mutually exclusive with 'anti_affinity_policy_name'.
    anti_affinity_policy_id: String?
    /// The anti-affinity policy to assign to the server. This is mutually exclusive with 'anti_affinity_policy_id'.
    anti_affinity_policy_name: String?
    /// Only required for bare metal servers. Specifies the identifier for the specific configuration type of bare metal server to deploy.
    configuration_id: String?
    /// The number of servers to build (mutually exclusive with exact_count)
    count: Int?
    /// Required when exact_count is specified.  The Server Group use to determine how many servers to deploy.
    count_group: String?
    /// How many CPUs to provision on the server
    cpu: Int?
    /// The autoscale policy to assign to the server.
    cpu_autoscale_policy_id: String?
    /// The list of custom fields to set on the server.
    custom_fields: Listing<Any>?
    /// The description to set for the server.
    description: String?
    /// Run in idempotent mode.  Will insure that this exact number of servers are running in the provided group, creating and deleting them to reach that count.  Requires count_group to be set.
    exact_count: Int?
    /// The Server Group to create servers under.
    group: String?
    /// The IP Address for the server. One is assigned if not provided.
    ip_address: String?
    /// The Datacenter to create servers in.
    location: String?
    /// Whether to create the server as 'Managed' or not.
    managed_os: Boolean?
    /// Memory in GB.
    memory: Int?
    /// A 1 to 6 character identifier to use for the server. This is required when state is 'present'
    name: String?
    /// The network UUID on which to create servers.
    network_id: String?
    /// Only required for bare metal servers. Specifies the OS to provision with the bare metal server.
    os_type: ("redHat6_64Bit"|"centOS6_64Bit"|"windows2012R2Standard_64Bit"|"ubuntu14_64Bit")?
    /// The list of blue print packages to run on the server after its created.
    packages: Listing<Any>?
    /// Password for the administrator / root user
    password: String?
    /// Primary DNS used by the server.
    primary_dns: String?
    /// A list of ports to allow on the firewall to the servers public ip, if add_public_ip is set to True.
    public_ip_ports: Listing<Any>?
    /// The protocol to use for the public ip if add_public_ip is set to True.
    public_ip_protocol: ("TCP"|"UDP"|"ICMP")?
    /// Secondary DNS used by the server.
    secondary_dns: String?
    /// Required for started, stopped, and absent states. A list of server Ids to insure are started, stopped, or absent.
    server_ids: Listing<String>?
    /// The password for the source server if a clone is specified.
    source_server_password: String?
    /// The state to insure that the provided resources are in.
    state: ("present"|"absent"|"started"|"stopped")?
    /// The type of storage to attach to the server.
    storage_type: ("standard"|"hyperscale")?
    /// The template to use for server creation.  Will search for a template if a partial string is provided. This is required when state is 'present'
    template: String?
    /// The time to live for the server in seconds.  The server will be deleted when this time expires.
    ttl: String?
    /// The type of server to create.
    type: ("standard"|"hyperscale"|"bareMetal")?
    /// Whether to wait for the provisioning tasks to finish before returning.
    wait: Boolean?
}

/// Task class for clc_server
class ClcServerTask extends Playbook.Task {
    /// todo doc
    `community.general.clc_server`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.clc_server"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.clc_server`
}

/// TaskBuilder class for clc_server
class ClcServer extends Playbook.TaskBuilder {
    /// Options for community.general.clc_server
    options: ClcServerOptions?
    /// todo doc
    function Task(): ClcServerTask = this
        .toMap()
        .put("community.general.clc_server", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ClcServerTask)
}

/// Create, Delete and Restore server snapshots in CenturyLink Cloud
/// An Ansible module to Create, Delete and Restore server snapshots in CenturyLink Cloud.
class ClcServerSnapshotOptions {
    /// The number of days to keep the server snapshot before it expires.
    expiration_days: Int?
    /// The list of CLC server Ids.
    server_ids: Listing<String>
    /// The state to insure that the provided resources are in.
    state: ("present"|"absent"|"restore")?
    /// Whether to wait for the provisioning tasks to finish before returning.
    wait: String?
}

/// Task class for clc_server_snapshot
class ClcServerSnapshotTask extends Playbook.Task {
    /// todo doc
    `community.general.clc_server_snapshot`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.clc_server_snapshot"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.clc_server_snapshot`
}

/// TaskBuilder class for clc_server_snapshot
class ClcServerSnapshot extends Playbook.TaskBuilder {
    /// Options for community.general.clc_server_snapshot
    options: ClcServerSnapshotOptions?
    /// todo doc
    function Task(): ClcServerSnapshotTask = this
        .toMap()
        .put("community.general.clc_server_snapshot", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ClcServerSnapshotTask)
}

/// Retrieve facts of cloud-init
/// Gathers facts by reading the status.json and result.json of cloud-init.
class CloudInitDataFactsOptions {
    /// Filter facts
    filter: ("status"|"result")?
}

/// Task class for cloud_init_data_facts
class CloudInitDataFactsTask extends Playbook.Task {
    /// todo doc
    `community.general.cloud_init_data_facts`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.cloud_init_data_facts"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.cloud_init_data_facts`
}

/// TaskBuilder class for cloud_init_data_facts
class CloudInitDataFacts extends Playbook.TaskBuilder {
    /// Options for community.general.cloud_init_data_facts
    options: CloudInitDataFactsOptions?
    /// todo doc
    function Task(): CloudInitDataFactsTask = this
        .toMap()
        .put("community.general.cloud_init_data_facts", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(CloudInitDataFactsTask)
}

/// Manage Cloudflare DNS records
/// Manages dns records via the Cloudflare API, see the docs: U(https://api.cloudflare.com/).
class CloudflareDnsOptions {
    /// Account API key.
    /// Required for api keys authentication.
    /// You can obtain your API key from the bottom of the Cloudflare 'My Account' page, found here: U(https://dash.cloudflare.com/).
    account_api_key: String?
    /// Account email. Required for API keys authentication.
    account_email: String?
    /// Algorithm number.
    /// Required for O(type=DS) and O(type=SSHFP) when O(state=present).
    algorithm: Int?
    /// API token.
    /// Required for api token authentication.
    /// You can obtain your API token from the bottom of the Cloudflare 'My Account' page, found here: U(https://dash.cloudflare.com/).
    /// Can be specified in E(CLOUDFLARE_TOKEN) environment variable since community.general 2.0.0.
    api_token: String?
    /// Certificate usage number.
    /// Required for O(type=TLSA) when O(state=present).
    cert_usage: Int?
    /// Issuer Critical Flag.
    /// Required for O(type=CAA) when O(state=present).
    flag: Int?
    /// Hash type number.
    /// Required for O(type=DS), O(type=SSHFP) and O(type=TLSA) when O(state=present).
    hash_type: Int?
    /// DNSSEC key tag.
    /// Needed for O(type=DS) when O(state=present).
    key_tag: Int?
    /// Service port.
    /// Required for O(type=SRV) and O(type=TLSA).
    port: Int?
    /// Record priority.
    /// Required for O(type=MX) and O(type=SRV)
    priority: Int?
    /// Service protocol. Required for O(type=SRV) and O(type=TLSA).
    /// Common values are TCP and UDP.
    proto: String?
    /// Proxy through Cloudflare network or just use DNS.
    proxied: Boolean?
    /// Record to add.
    /// Required if O(state=present).
    /// Default is V(@) (that is, the zone name).
    `record`: String?
    /// Selector number.
    /// Required for O(type=TLSA) when O(state=present).
    selector: Int?
    /// Record service.
    /// Required for O(type=SRV).
    service: String?
    /// Whether the record should be the only one for that record type and record name.
    /// Only use with O(state=present).
    /// This will delete all other records with the same record name and type.
    solo: Boolean?
    /// Whether the record(s) should exist or not.
    state: ("absent"|"present")?
    /// CAA issue restriction.
    /// Required for O(type=CAA) when O(state=present).
    tag: ("issue"|"issuewild"|"iodef")?
    /// Timeout for Cloudflare API calls.
    timeout: Int?
    /// The TTL to give the new record.
    /// Must be between 120 and 2,147,483,647 seconds, or 1 for automatic.
    ttl: Int?
    /// The type of DNS record to create. Required if O(state=present).
    /// Note that V(SPF) is no longer supported by CloudFlare. Support for it will be removed from community.general 9.0.0.
    type: ("A"|"AAAA"|"CNAME"|"DS"|"MX"|"NS"|"SPF"|"SRV"|"SSHFP"|"TLSA"|"CAA"|"TXT")?
    /// The record value.
    /// Required for O(state=present).
    value: String?
    /// Service weight.
    /// Required for O(type=SRV).
    weight: Int?
    /// The name of the Zone to work with (e.g. "example.com").
    /// The Zone must already exist.
    zone: String
}

/// Task class for cloudflare_dns
class CloudflareDnsTask extends Playbook.Task {
    /// todo doc
    `community.general.cloudflare_dns`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.cloudflare_dns"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.cloudflare_dns`
}

/// TaskBuilder class for cloudflare_dns
class CloudflareDns extends Playbook.TaskBuilder {
    /// Options for community.general.cloudflare_dns
    options: CloudflareDnsOptions?
    /// todo doc
    function Task(): CloudflareDnsTask = this
        .toMap()
        .put("community.general.cloudflare_dns", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(CloudflareDnsTask)
}

/// Sync Cobbler
/// Sync Cobbler to commit changes.
class CobblerSyncOptions {
    /// The name or IP address of the Cobbler system.
    host: String?
    /// The password to log in to Cobbler.
    password: String?
    /// Port number to be used for REST connection.
    /// The default value depends on parameter O(use_ssl).
    port: Int?
    /// If V(false), an HTTP connection will be used instead of the default HTTPS connection.
    use_ssl: Boolean?
    /// The username to log in to Cobbler.
    username: String?
    /// If V(false), SSL certificates will not be validated.
    /// This should only set to V(false) when used on personally controlled sites using self-signed certificates.
    validate_certs: Boolean?
}

/// Task class for cobbler_sync
class CobblerSyncTask extends Playbook.Task {
    /// todo doc
    `community.general.cobbler_sync`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.cobbler_sync"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.cobbler_sync`
}

/// TaskBuilder class for cobbler_sync
class CobblerSync extends Playbook.TaskBuilder {
    /// Options for community.general.cobbler_sync
    options: CobblerSyncOptions?
    /// todo doc
    function Task(): CobblerSyncTask = this
        .toMap()
        .put("community.general.cobbler_sync", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(CobblerSyncTask)
}

/// Manage system objects in Cobbler
/// Add, modify or remove systems in Cobbler
class CobblerSystemOptions {
    /// The name or IP address of the Cobbler system.
    host: String?
    /// A list of dictionaries containing interface options.
    interfaces: Any?
    /// The system name to manage.
    name: String?
    /// The password to log in to Cobbler.
    password: String?
    /// Port number to be used for REST connection.
    /// The default value depends on parameter O(use_ssl).
    port: Int?
    /// A dictionary with system properties.
    properties: Any?
    /// Whether the system should be present, absent or a query is made.
    state: ("absent"|"present"|"query")?
    /// Sync on changes.
    /// Concurrently syncing Cobbler is bound to fail.
    sync: Boolean?
    /// If V(false), an HTTP connection will be used instead of the default HTTPS connection.
    use_ssl: Boolean?
    /// The username to log in to Cobbler.
    username: String?
    /// If V(false), SSL certificates will not be validated.
    /// This should only set to V(false) when used on personally controlled sites using self-signed certificates.
    validate_certs: Boolean?
}

/// Task class for cobbler_system
class CobblerSystemTask extends Playbook.Task {
    /// todo doc
    `community.general.cobbler_system`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.cobbler_system"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.cobbler_system`
}

/// TaskBuilder class for cobbler_system
class CobblerSystem extends Playbook.TaskBuilder {
    /// Options for community.general.cobbler_system
    options: CobblerSystemOptions?
    /// todo doc
    function Task(): CobblerSystemTask = this
        .toMap()
        .put("community.general.cobbler_system", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(CobblerSystemTask)
}

/// Dependency Manager for PHP
/// Composer is a tool for dependency management in PHP. It allows you to declare the dependent libraries your project needs and it will install them in your project for you.
class ComposerOptions {
    /// Uses APCu to cache found/not-found classes
    apcu_autoloader: Boolean?
    /// Composer arguments like required package, version and so on.
    arguments: String?
    /// Autoload classes from classmap only.
    /// Implicitly enable optimize_autoloader.
    /// Recommended especially for production, but can take a bit of time to run.
    classmap_authoritative: Boolean?
    /// Composer command like "install", "update" and so on.
    command: String?
    /// Path to composer executable on the remote host, if composer is not in E(PATH) or a custom composer is needed.
    composer_executable: String?
    /// Path to PHP Executable on the remote host, if PHP is not in PATH.
    executable: String?
    /// Runs the specified command globally.
    global_command: Boolean?
    /// Ignore php, hhvm, lib-* and ext-* requirements and force the installation even if the local machine does not fulfill these.
    ignore_platform_reqs: Boolean?
    /// Disables installation of require-dev packages (see --no-dev).
    no_dev: Boolean?
    /// Disables all plugins (see --no-plugins).
    no_plugins: Boolean?
    /// Skips the execution of all scripts defined in composer.json (see --no-scripts).
    no_scripts: Boolean?
    /// Optimize autoloader during autoloader dump (see --optimize-autoloader).
    /// Convert PSR-0/4 autoloading to classmap to get a faster autoloader.
    /// Recommended especially for production, but can take a bit of time to run.
    optimize_autoloader: Boolean?
    /// Forces installation from package dist even for dev versions (see --prefer-dist).
    prefer_dist: Boolean?
    /// Forces installation from package sources when possible (see --prefer-source).
    prefer_source: Boolean?
    /// Directory of your project (see --working-dir). This is required when the command is not run globally.
    /// Will be ignored if O(global_command=true).
    working_dir: String?
}

/// Task class for composer
class ComposerTask extends Playbook.Task {
    /// todo doc
    `community.general.composer`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.composer"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.composer`
}

/// TaskBuilder class for composer
class Composer extends Playbook.TaskBuilder {
    /// Options for community.general.composer
    options: ComposerOptions?
    /// todo doc
    function Task(): ComposerTask = this
        .toMap()
        .put("community.general.composer", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ComposerTask)
}

/// Add, modify & delete services within a consul cluster
/// Registers services and checks for an agent with a consul cluster. A service is some process running on the agent node that should be advertised by consul's discovery mechanism. It may optionally supply a check definition, a periodic service test to notify the consul cluster of service's health.
/// Checks may also be registered per node e.g. disk usage, or cpu usage and notify the health of the entire node to the cluster. Service level checks do not require a check name or id as these are derived by Consul from the Service name and id respectively by appending 'service:' Node level checks require a O(check_name) and optionally a O(check_id).
/// Currently, there is no complete way to retrieve the script, interval or TTL metadata for a registered check. Without this metadata it is not possible to tell if the data supplied with ansible represents a change to a check. As a result this does not attempt to determine changes and will always report a changed occurred. An API method is planned to supply this metadata so at that stage change management will be added.
/// See U(http://consul.io) for more details.
class ConsulOptions {
    /// This parameter has no more effect and is deprecated. It will be removed in community.general 10.0.0.
    ack_params_state_absent: Boolean?
    /// Host name.
    check_host: String?
    /// An ID for the service check. If O(state=absent), defaults to O(check_name). Ignored if part of a service definition.
    check_id: String?
    /// Name for the service check. Required if standalone, ignored if part of service definition.
    check_name: String?
    /// Node name.
    check_node: String?
    /// Host of the consul agent defaults to localhost.
    host: String?
    /// Checks can be registered with an HTTP endpoint. This means that consul will check that the http endpoint returns a successful HTTP status.
    /// Requires O(interval) to be provided.
    /// Mutually exclusive with O(script), O(ttl) and O(tcp).
    http: String?
    /// The interval at which the service check will be run. This is a number with a V(s) or V(m) suffix to signify the units of seconds or minutes, for example V(15s) or V(1m). If no suffix is supplied V(s) will be used by default, for example V(10) will be V(10s).
    /// Required if one of the parameters O(script), O(http), or O(tcp) is specified.
    interval: String?
    /// Notes to attach to check when registering it.
    notes: String?
    /// The port on which the consul agent is running.
    port: Int?
    /// The protocol scheme on which the consul agent is running.
    scheme: String?
    /// The script/command that will be run periodically to check the health of the service.
    /// Requires O(interval) to be provided.
    /// Mutually exclusive with O(ttl), O(tcp) and O(http).
    script: String?
    /// The address to advertise that the service will be listening on. This value will be passed as the C(address) parameter to Consul's C(/v1/agent/service/register) API method, so refer to the Consul API documentation for further details.
    service_address: String?
    /// The ID for the service, must be unique per node. If O(state=absent), defaults to the service name if supplied.
    service_id: String?
    /// Unique name for the service on a node, must be unique per node, required if registering a service. May be omitted if registering a node level check.
    service_name: String?
    /// The port on which the service is listening. Can optionally be supplied for registration of a service, that is if O(service_name) or O(service_id) is set.
    service_port: Int?
    /// Register or deregister the consul service, defaults to present.
    state: ("present"|"absent")?
    /// Tags that will be attached to the service registration.
    tags: Listing<String>?
    /// Checks can be registered with a TCP port. This means that consul will check if the connection attempt to that port is successful (that is, the port is currently accepting connections). The format is V(host:port), for example V(localhost:80).
    /// Requires O(interval) to be provided.
    /// Mutually exclusive with O(script), O(ttl) and O(http).
    tcp: String?
    /// A custom HTTP check timeout. The consul default is 10 seconds. Similar to the interval this is a number with a V(s) or V(m) suffix to signify the units of seconds or minutes, for example V(15s) or V(1m). If no suffix is supplied V(s) will be used by default, for example V(10) will be V(10s).
    timeout: String?
    /// The token key identifying an ACL rule set. May be required to register services.
    token: String?
    /// Checks can be registered with a TTL instead of a O(script) and O(interval) this means that the service will check in with the agent before the TTL expires. If it doesn't the check will be considered failed. Required if registering a check and the script an interval are missing Similar to the interval this is a number with a V(s) or V(m) suffix to signify the units of seconds or minutes, for example V(15s) or V(1m). If no suffix is supplied V(s) will be used by default, for example V(10) will be V(10s).
    /// Mutually exclusive with O(script), O(tcp) and O(http).
    ttl: String?
    /// Whether to verify the TLS certificate of the consul agent.
    validate_certs: Boolean?
}

/// Task class for consul
class ConsulTask extends Playbook.Task {
    /// todo doc
    `community.general.consul`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.consul"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.consul`
}

/// TaskBuilder class for consul
class Consul extends Playbook.TaskBuilder {
    /// Options for community.general.consul
    options: ConsulOptions?
    /// todo doc
    function Task(): ConsulTask = this
        .toMap()
        .put("community.general.consul", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ConsulTask)
}

/// Manipulate Consul ACL keys and rules
/// Allows the addition, modification and deletion of ACL keys and associated rules in a consul cluster via the agent. For more details on using and configuring ACLs, see https://www.consul.io/docs/guides/acl.html.
class ConsulAclOptions {
    /// host of the consul agent defaults to localhost
    host: String?
    /// a management token is required to manipulate the acl lists
    mgmt_token: String
    /// the name that should be associated with the acl key, this is opaque to Consul
    name: String?
    /// the port on which the consul agent is running
    port: Int?
    /// rules that should be associated with a given token
    rules: Listing<Any>?
    /// the protocol scheme on which the consul agent is running
    scheme: String?
    /// whether the ACL pair should be present or absent
    state: ("present"|"absent")?
    /// the token key identifying an ACL rule set. If generated by consul this will be a UUID
    token: String?
    /// the type of token that should be created
    token_type: ("client"|"management")?
    /// whether to verify the tls certificate of the consul agent
    validate_certs: Boolean?
}

/// Task class for consul_acl
class ConsulAclTask extends Playbook.Task {
    /// todo doc
    `community.general.consul_acl`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.consul_acl"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.consul_acl`
}

/// TaskBuilder class for consul_acl
class ConsulAcl extends Playbook.TaskBuilder {
    /// Options for community.general.consul_acl
    options: ConsulAclOptions?
    /// todo doc
    function Task(): ConsulAclTask = this
        .toMap()
        .put("community.general.consul_acl", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ConsulAclTask)
}

/// Bootstrap ACLs in Consul
/// Allows bootstrapping of ACLs in a Consul cluster, see U(https://developer.hashicorp.com/consul/api-docs/acl#bootstrap-acls) for details.
class ConsulAclBootstrapOptions {
    /// The secret to be used as secret ID for the initial token.
    /// Needs to be an UUID.
    bootstrap_secret: String?
    /// Whether the token should be present or absent.
    state: ("present"|"bootstrapped")?
}

/// Task class for consul_acl_bootstrap
class ConsulAclBootstrapTask extends Playbook.Task {
    /// todo doc
    `community.general.consul_acl_bootstrap`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.consul_acl_bootstrap"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.consul_acl_bootstrap`
}

/// TaskBuilder class for consul_acl_bootstrap
class ConsulAclBootstrap extends Playbook.TaskBuilder {
    /// Options for community.general.consul_acl_bootstrap
    options: ConsulAclBootstrapOptions?
    /// todo doc
    function Task(): ConsulAclBootstrapTask = this
        .toMap()
        .put("community.general.consul_acl_bootstrap", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ConsulAclBootstrapTask)
}

/// Manipulate Consul auth methods
/// Allows the addition, modification and deletion of auth methods in a consul cluster via the agent. For more details on using and configuring ACLs, see U(https://www.consul.io/docs/guides/acl.html).
class ConsulAuthMethodOptions {
    /// The raw configuration to use for the chosen auth method.
    /// Contents will vary depending upon the type chosen.
    /// Required when the auth method is created.
    config: Any?
    /// Free form human readable description of the auth method.
    description: String?
    /// An optional name to use instead of O(name) when displaying information about this auth method.
    display_name: String?
    /// This specifies the maximum life of any token created by this auth method.
    /// Can be specified in the form of V(60s) or V(5m) (that is, 60 seconds or 5 minutes, respectively).
    max_token_ttl: String?
    /// Specifies a name for the ACL auth method.
    /// The name can contain alphanumeric characters, dashes C(-), and underscores C(_).
    name: String
    /// Whether the token should be present or absent.
    state: ("present"|"absent")?
    /// Defines the kind of token that this auth method should produce.
    token_locality: ("local"|"global")?
    /// The type of auth method being configured.
    /// This field is immutable.
    /// Required when the auth method is created.
    type: ("kubernetes"|"jwt"|"oidc"|"aws-iam")?
}

/// Task class for consul_auth_method
class ConsulAuthMethodTask extends Playbook.Task {
    /// todo doc
    `community.general.consul_auth_method`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.consul_auth_method"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.consul_auth_method`
}

/// TaskBuilder class for consul_auth_method
class ConsulAuthMethod extends Playbook.TaskBuilder {
    /// Options for community.general.consul_auth_method
    options: ConsulAuthMethodOptions?
    /// todo doc
    function Task(): ConsulAuthMethodTask = this
        .toMap()
        .put("community.general.consul_auth_method", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ConsulAuthMethodTask)
}

/// Manipulate Consul binding rules
/// Allows the addition, modification and deletion of binding rules in a consul cluster via the agent. For more details on using and configuring binding rules, see U(https://developer.hashicorp.com/consul/api-docs/acl/binding-rules).
class ConsulBindingRuleOptions {
    /// The name of the auth method that this rule applies to.
    auth_method: String
    /// The name to bind to a token at login-time.
    /// What it binds to can be adjusted with different values of the O(bind_type) parameter.
    bind_name: String?
    /// Specifies the way the binding rule affects a token created at login.
    bind_type: ("service"|"node"|"role"|"templated-policy")?
    /// Specifies the templated policy variables when O(bind_type) is set to V(templated-policy).
    bind_vars: Any?
    /// Free form human readable description of the binding rule.
    description: String?
    /// Specifies a name for the binding rule.
    /// Note: This is used to identify the binding rule. But since the API does not support a name, it is prefixed to the description.
    name: String
    /// Specifies the expression used to match this rule against valid identities returned from an auth method validation.
    /// If empty this binding rule matches all valid identities returned from the auth method.
    selector: String?
    /// Whether the binding rule should be present or absent.
    state: ("present"|"absent")?
}

/// Task class for consul_binding_rule
class ConsulBindingRuleTask extends Playbook.Task {
    /// todo doc
    `community.general.consul_binding_rule`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.consul_binding_rule"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.consul_binding_rule`
}

/// TaskBuilder class for consul_binding_rule
class ConsulBindingRule extends Playbook.TaskBuilder {
    /// Options for community.general.consul_binding_rule
    options: ConsulBindingRuleOptions?
    /// todo doc
    function Task(): ConsulBindingRuleTask = this
        .toMap()
        .put("community.general.consul_binding_rule", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ConsulBindingRuleTask)
}

/// Manipulate entries in the key/value store of a consul cluster
/// Allows the retrieval, addition, modification and deletion of key/value entries in a consul cluster via the agent. The entire contents of the record, including the indices, flags and session are returned as C(value).
/// If the O(key) represents a prefix then note that when a value is removed, the existing value if any is returned as part of the results.
/// See http://www.consul.io/docs/agent/http.html#kv for more details.
class ConsulKvOptions {
    /// Used when acquiring a lock with a session. If the O(cas) is V(0), then Consul will only put the key if it does not already exist. If the O(cas) value is non-zero, then the key is only set if the index matches the ModifyIndex of that key.
    cas: String?
    /// Opaque positive integer value that can be passed when setting a value.
    flags: String?
    /// Host of the consul agent.
    host: String?
    /// The key at which the value should be stored.
    key: String
    /// The port on which the consul agent is running.
    port: Int?
    /// If the key represents a prefix, each entry with the prefix can be retrieved by setting this to V(true).
    recurse: Boolean?
    /// If the O(state) is V(present) and O(value) is set, perform a read after setting the value and return this value.
    retrieve: Boolean?
    /// The protocol scheme on which the consul agent is running.
    scheme: String?
    /// The session that should be used to acquire or release a lock associated with a key/value pair.
    session: String?
    /// The action to take with the supplied key and value. If the state is V(present) and O(value) is set, the key contents will be set to the value supplied and C(changed) will be set to V(true) only if the value was different to the current contents. If the state is V(present) and O(value) is not set, the existing value associated to the key will be returned. The state V(absent) will remove the key/value pair, again C(changed) will be set to V(true) only if the key actually existed prior to the removal. An attempt can be made to obtain or free the lock associated with a key/value pair with the states V(acquire) or V(release) respectively. a valid session must be supplied to make the attempt changed will be true if the attempt is successful, false otherwise.
    state: ("absent"|"acquire"|"present"|"release")?
    /// The token key identifying an ACL rule set that controls access to the key value pair
    token: String?
    /// Whether to verify the tls certificate of the consul agent.
    validate_certs: Boolean?
    /// The value should be associated with the given key, required if O(state) is V(present).
    value: String?
}

/// Task class for consul_kv
class ConsulKvTask extends Playbook.Task {
    /// todo doc
    `community.general.consul_kv`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.consul_kv"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.consul_kv`
}

/// TaskBuilder class for consul_kv
class ConsulKv extends Playbook.TaskBuilder {
    /// Options for community.general.consul_kv
    options: ConsulKvOptions?
    /// todo doc
    function Task(): ConsulKvTask = this
        .toMap()
        .put("community.general.consul_kv", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ConsulKvTask)
}

/// Manipulate Consul policies
/// Allows the addition, modification and deletion of policies in a consul cluster via the agent. For more details on using and configuring ACLs, see U(https://www.consul.io/docs/guides/acl.html).
class ConsulPolicyOptions {
    /// Description of the policy.
    description: String?
    /// The name that should be associated with the policy, this is opaque to Consul.
    name: String
    /// Rule document that should be associated with the current policy.
    rules: String?
    /// Whether the policy should be present or absent.
    state: ("present"|"absent")?
    /// Valid datacenters for the policy. All if list is empty.
    valid_datacenters: Listing<String>?
}

/// Task class for consul_policy
class ConsulPolicyTask extends Playbook.Task {
    /// todo doc
    `community.general.consul_policy`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.consul_policy"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.consul_policy`
}

/// TaskBuilder class for consul_policy
class ConsulPolicy extends Playbook.TaskBuilder {
    /// Options for community.general.consul_policy
    options: ConsulPolicyOptions?
    /// todo doc
    function Task(): ConsulPolicyTask = this
        .toMap()
        .put("community.general.consul_policy", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ConsulPolicyTask)
}

/// Manipulate Consul roles
/// Allows the addition, modification and deletion of roles in a consul cluster via the agent. For more details on using and configuring ACLs, see U(https://www.consul.io/docs/guides/acl.html).
class ConsulRoleOptions {
    /// Description of the role.
    /// If not specified, the assigned description will not be changed.
    description: String?
    /// A name used to identify the role.
    name: String
    /// List of node identities to attach to the role.
    /// If not specified, any node identities currently assigned will not be changed.
    /// If the parameter is an empty array (V([])), any node identities assigned will be unassigned.
    node_identities: Listing<Any>?
    /// List of policies to attach to the role. Each policy is a dict.
    /// If the parameter is left blank, any policies currently assigned will not be changed.
    /// Any empty array (V([])) will clear any policies previously set.
    policies: Listing<Any>?
    /// List of service identities to attach to the role.
    /// If not specified, any service identities currently assigned will not be changed.
    /// If the parameter is an empty array (V([])), any node identities assigned will be unassigned.
    service_identities: Listing<Any>?
    /// whether the role should be present or absent.
    state: ("present"|"absent")?
    /// The list of templated policies that should be applied to the role.
    templated_policies: Listing<Any>?
}

/// Task class for consul_role
class ConsulRoleTask extends Playbook.Task {
    /// todo doc
    `community.general.consul_role`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.consul_role"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.consul_role`
}

/// TaskBuilder class for consul_role
class ConsulRole extends Playbook.TaskBuilder {
    /// Options for community.general.consul_role
    options: ConsulRoleOptions?
    /// todo doc
    function Task(): ConsulRoleTask = this
        .toMap()
        .put("community.general.consul_role", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ConsulRoleTask)
}

/// Manipulate consul sessions
/// Allows the addition, modification and deletion of sessions in a consul cluster. These sessions can then be used in conjunction with key value pairs to implement distributed locks. In depth documentation for working with sessions can be found at http://www.consul.io/docs/internals/sessions.html
class ConsulSessionOptions {
    /// The optional behavior that can be attached to the session when it is created. This controls the behavior when a session is invalidated.
    behavior: ("delete"|"release")?
    /// Checks that will be used to verify the session health. If all the checks fail, the session will be invalidated and any locks associated with the session will be release and can be acquired once the associated lock delay has expired.
    checks: Listing<String>?
    /// The name of the datacenter in which the session exists or should be created.
    datacenter: String?
    /// The optional lock delay that can be attached to the session when it is created. Locks for invalidated sessions ar blocked from being acquired until this delay has expired. Durations are in seconds.
    delay: Int?
    /// ID of the session, required when O(state) is either V(info) or V(remove).
    id: String?
    /// The name that should be associated with the session. Required when O(state=node) is used.
    name: String?
    /// The name of the node that with which the session will be associated. by default this is the name of the agent.
    node: String?
    /// Whether the session should be present i.e. created if it doesn't exist, or absent, removed if present. If created, the O(id) for the session is returned in the output. If V(absent), O(id) is required to remove the session. Info for a single session, all the sessions for a node or all available sessions can be retrieved by specifying V(info), V(node) or V(list) for the O(state); for V(node) or V(info), the node O(name) or session O(id) is required as parameter.
    state: ("absent"|"info"|"list"|"node"|"present")?
    token: Any?
    /// Specifies the duration of a session in seconds (between 10 and 86400).
    ttl: Int?
}

/// Task class for consul_session
class ConsulSessionTask extends Playbook.Task {
    /// todo doc
    `community.general.consul_session`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.consul_session"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.consul_session`
}

/// TaskBuilder class for consul_session
class ConsulSession extends Playbook.TaskBuilder {
    /// Options for community.general.consul_session
    options: ConsulSessionOptions?
    /// todo doc
    function Task(): ConsulSessionTask = this
        .toMap()
        .put("community.general.consul_session", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ConsulSessionTask)
}

/// Manipulate Consul tokens
/// Allows the addition, modification and deletion of tokens in a consul cluster via the agent. For more details on using and configuring ACLs, see U(https://www.consul.io/docs/guides/acl.html).
class ConsulTokenOptions {
    /// Specifies a UUID to use as the token's Accessor ID. If not specified a UUID will be generated for this field.
    accessor_id: String?
    /// Free form human readable description of the token.
    description: String?
    /// This is a convenience field and if set will initialize the C(expiration_time). Can be specified in the form of V(60s) or V(5m) (that is, 60 seconds or 5 minutes, respectively). Ingored when the token is updated!
    expiration_ttl: String?
    /// If true, indicates that the token should not be replicated globally and instead be local to the current datacenter.
    `local`: Boolean?
    /// List of node identities to attach to the token.
    /// If not specified, any node identities currently assigned will not be changed.
    /// If the parameter is an empty array (V([])), any node identities assigned will be unassigned.
    node_identities: Listing<Any>?
    /// List of policies to attach to the token. Each policy is a dict.
    /// If the parameter is left blank, any policies currently assigned will not be changed.
    /// Any empty array (V([])) will clear any policies previously set.
    policies: Listing<Any>?
    /// List of roles to attach to the token. Each role is a dict.
    /// If the parameter is left blank, any roles currently assigned will not be changed.
    /// Any empty array (V([])) will clear any roles previously set.
    roles: Listing<Any>?
    /// Specifies a UUID to use as the token's Secret ID. If not specified a UUID will be generated for this field.
    secret_id: String?
    /// List of service identities to attach to the token.
    /// If not specified, any service identities currently assigned will not be changed.
    /// If the parameter is an empty array (V([])), any node identities assigned will be unassigned.
    service_identities: Listing<Any>?
    /// Whether the token should be present or absent.
    state: ("present"|"absent")?
    /// The list of templated policies that should be applied to the role.
    templated_policies: Listing<Any>?
}

/// Task class for consul_token
class ConsulTokenTask extends Playbook.Task {
    /// todo doc
    `community.general.consul_token`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.consul_token"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.consul_token`
}

/// TaskBuilder class for consul_token
class ConsulToken extends Playbook.TaskBuilder {
    /// Options for community.general.consul_token
    options: ConsulTokenOptions?
    /// todo doc
    function Task(): ConsulTokenTask = this
        .toMap()
        .put("community.general.consul_token", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ConsulTokenTask)
}

/// Manage one of the Copr repositories
/// This module can enable, disable or remove the specified repository.
class CoprOptions {
    /// The name of the chroot that you want to enable/disable/remove in the project, for example V(epel-7-x86_64). Default chroot is determined by the operating system, version of the operating system, and architecture on which the module is run.
    chroot: String?
    /// The Copr host to work with.
    host: String?
    /// Copr directory name, for example C(@copr/copr-dev).
    name: String
    /// This indicate which protocol to use with the host.
    protocol: String?
    /// Whether to set this project as V(enabled), V(disabled), or V(absent).
    state: ("absent"|"enabled"|"disabled")?
}

/// Task class for copr
class CoprTask extends Playbook.Task {
    /// todo doc
    `community.general.copr`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.copr"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.copr`
}

/// TaskBuilder class for copr
class Copr extends Playbook.TaskBuilder {
    /// Options for community.general.copr
    options: CoprOptions?
    /// todo doc
    function Task(): CoprTask = this
        .toMap()
        .put("community.general.copr", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(CoprTask)
}

/// Manages Perl library dependencies
/// Manage Perl library dependencies using cpanminus.
class CpanmOptions {
    /// Override the path to the cpanm executable.
    executable: String?
    /// The local directory or C(tar.gz) file to install from.
    from_path: String?
    /// Only install dependencies.
    installdeps: Boolean?
    /// Specify the install base to install modules.
    locallib: String?
    /// Specifies the base URL for the CPAN mirror to use.
    mirror: String?
    /// Use the mirror's index file instead of the CPAN Meta DB.
    mirror_only: Boolean?
    /// Controls the module behavior. See notes below for more details.
    /// Default is V(compatibility) but that behavior is deprecated and will be changed to V(new) in community.general 9.0.0.
    mode: ("compatibility"|"new")?
    /// The Perl library to install. Valid values change according to the O(mode), see notes for more details.
    /// Note that for installing from a local path the parameter O(from_path) should be used.
    name: String?
    /// When O(mode=new), this parameter can be used to check if there is a module O(name) installed (at O(version), when specified).
    name_check: String?
    /// Do not run unit tests.
    notest: Boolean?
    /// Version specification for the perl module. When O(mode) is V(new), C(cpanm) version operators are accepted.
    version: String?
}

/// Task class for cpanm
class CpanmTask extends Playbook.Task {
    /// todo doc
    `community.general.cpanm`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.cpanm"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.cpanm`
}

/// TaskBuilder class for cpanm
class Cpanm extends Playbook.TaskBuilder {
    /// Options for community.general.cpanm
    options: CpanmOptions?
    /// todo doc
    function Task(): CpanmTask = this
        .toMap()
        .put("community.general.cpanm", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(CpanmTask)
}

/// Manage variables in crontabs
/// Use this module to manage crontab variables.
/// This module allows you to create, update, or delete cron variable definitions.
class CronvarOptions {
    /// If set, create a backup of the crontab before it is modified. The location of the backup is returned in the C(backup) variable by this module.
    backup: Boolean?
    /// If specified, uses this file instead of an individual user's crontab.
    /// Without a leading V(/), this is assumed to be in C(/etc/cron.d).
    /// With a leading V(/), this is taken as absolute.
    cron_file: String?
    /// If specified, the variable will be inserted after the variable specified.
    /// Used with O(state=present).
    insertafter: String?
    /// Used with O(state=present). If specified, the variable will be inserted just before the variable specified.
    insertbefore: String?
    /// Name of the crontab variable.
    name: String
    /// Whether to ensure that the variable is present or absent.
    state: ("absent"|"present")?
    /// The specific user whose crontab should be modified.
    /// This parameter defaults to V(root) when unset.
    user: String?
    /// The value to set this variable to.
    /// Required if O(state=present).
    value: String?
}

/// Task class for cronvar
class CronvarTask extends Playbook.Task {
    /// todo doc
    `community.general.cronvar`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.cronvar"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.cronvar`
}

/// TaskBuilder class for cronvar
class Cronvar extends Playbook.TaskBuilder {
    /// Options for community.general.cronvar
    options: CronvarOptions?
    /// todo doc
    function Task(): CronvarTask = this
        .toMap()
        .put("community.general.cronvar", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(CronvarTask)
}

/// Encrypted Linux block devices
/// Control Linux encrypted block devices that are set up during system boot in C(/etc/crypttab).
class CrypttabOptions {
    /// Path to the underlying block device or file, or the UUID of a block-device prefixed with V(UUID=).
    backing_device: String?
    /// Name of the encrypted block device as it appears in the C(/etc/crypttab) file, or optionally prefixed with V(/dev/mapper/), as it appears in the filesystem. V(/dev/mapper/) will be stripped from O(name).
    name: String
    /// A comma-delimited list of options. See V(crypttab(5\)) for details.
    opts: String?
    /// Encryption password, the path to a file containing the password, or V(-) or unset if the password should be entered at boot.
    password: String?
    /// Path to file to use instead of V(/etc/crypttab).
    /// This might be useful in a chroot environment.
    path: String?
    /// Use V(present) to add a line to C(/etc/crypttab) or update its definition if already present.
    /// Use V(absent) to remove a line with matching O(name).
    /// Use V(opts_present) to add options to those already present; options with different values will be updated.
    /// Use V(opts_absent) to remove options from the existing set.
    state: ("absent"|"opts_absent"|"opts_present"|"present")
}

/// Task class for crypttab
class CrypttabTask extends Playbook.Task {
    /// todo doc
    `community.general.crypttab`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.crypttab"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.crypttab`
}

/// TaskBuilder class for crypttab
class Crypttab extends Playbook.TaskBuilder {
    /// Options for community.general.crypttab
    options: CrypttabOptions?
    /// todo doc
    function Task(): CrypttabTask = this
        .toMap()
        .put("community.general.crypttab", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(CrypttabTask)
}

/// Manages Datadog downtimes
/// Manages downtimes within Datadog.
/// Options as described on U(https://docs.datadoghq.com/api/v1/downtimes/).
class DatadogDowntimeOptions {
    /// The URL to the Datadog API.
    /// This value can also be set with the E(DATADOG_HOST) environment variable.
    api_host: String?
    /// Your Datadog API key.
    api_key: String
    /// Your Datadog app key.
    app_key: String
    /// A message to include with notifications for this downtime.
    /// Email notifications can be sent to specific users by using the same "@username" notation as events.
    downtime_message: String?
    /// POSIX timestamp to end the downtime. If not provided, the downtime is in effect until you cancel it.
    end: Int?
    /// The identifier of the downtime.
    /// If empty, a new downtime gets created, otherwise it is either updated or deleted depending of the O(state).
    /// To keep your playbook idempotent, you should save the identifier in a file and read it in a lookup.
    id: Int?
    /// The ID of the monitor to mute. If not provided, the downtime applies to all monitors.
    monitor_id: Int?
    /// A list of monitor tags to which the downtime applies.
    /// The resulting downtime applies to monitors that match ALL provided monitor tags.
    monitor_tags: Listing<String>?
    /// The C(RRULE) standard for defining recurring events.
    /// For example, to have a recurring event on the first day of each month, select a type of rrule and set the C(FREQ) to C(MONTHLY) and C(BYMONTHDAY) to C(1).
    /// Most common rrule options from the iCalendar Spec are supported.
    /// Attributes specifying the duration in C(RRULE) are not supported (for example C(DTSTART), C(DTEND), C(DURATION)).
    rrule: String?
    /// A list of scopes to which the downtime applies.
    /// The resulting downtime applies to sources that matches ALL provided scopes.
    scope: Listing<String>?
    /// POSIX timestamp to start the downtime. If not provided, the downtime starts the moment it is created.
    start: Int?
    /// The designated state of the downtime.
    state: ("present"|"absent")?
    /// The timezone for the downtime.
    timezone: String?
}

/// Task class for datadog_downtime
class DatadogDowntimeTask extends Playbook.Task {
    /// todo doc
    `community.general.datadog_downtime`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.datadog_downtime"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.datadog_downtime`
}

/// TaskBuilder class for datadog_downtime
class DatadogDowntime extends Playbook.TaskBuilder {
    /// Options for community.general.datadog_downtime
    options: DatadogDowntimeOptions?
    /// todo doc
    function Task(): DatadogDowntimeTask = this
        .toMap()
        .put("community.general.datadog_downtime", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(DatadogDowntimeTask)
}

/// Posts events to Datadog  service
/// Allows to post events to Datadog (www.datadoghq.com) service.
/// Uses http://docs.datadoghq.com/api/#events API.
class DatadogEventOptions {
    /// An arbitrary string to use for aggregation.
    aggregation_key: String?
    /// Type of alert.
    alert_type: ("error"|"warning"|"info"|"success")?
    /// DataDog API endpoint URL.
    api_host: String?
    /// Your DataDog API key.
    api_key: String
    /// Your DataDog app key.
    app_key: String
    /// POSIX timestamp of the event.
    /// Default value is now.
    date_happened: Int?
    /// Host name to associate with the event.
    /// If not specified, it defaults to the remote system's hostname.
    host: String?
    /// The priority of the event.
    priority: ("normal"|"low")?
    /// Comma separated list of tags to apply to the event.
    tags: Listing<String>?
    /// The body of the event.
    text: String
    /// The event title.
    title: String
    /// If V(false), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
    validate_certs: Boolean?
}

/// Task class for datadog_event
class DatadogEventTask extends Playbook.Task {
    /// todo doc
    `community.general.datadog_event`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.datadog_event"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.datadog_event`
}

/// TaskBuilder class for datadog_event
class DatadogEvent extends Playbook.TaskBuilder {
    /// Options for community.general.datadog_event
    options: DatadogEventOptions?
    /// todo doc
    function Task(): DatadogEventTask = this
        .toMap()
        .put("community.general.datadog_event", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(DatadogEventTask)
}

/// Manages Datadog monitors
/// Manages monitors within Datadog.
/// Options as described on https://docs.datadoghq.com/api/.
class DatadogMonitorOptions {
    /// The URL to the Datadog API. Default value is V(https://api.datadoghq.com).
    /// This value can also be set with the E(DATADOG_HOST) environment variable.
    api_host: String?
    /// Your Datadog API key.
    api_key: String
    /// Your Datadog app key.
    app_key: String
    /// A message to include with a re-notification. Supports the '@username' notification we allow elsewhere.
    /// Not applicable if O(renotify_interval=none).
    escalation_message: String?
    /// Time to delay evaluation (in seconds).
    /// Effective for sparse values.
    evaluation_delay: String?
    /// The ID of the alert.
    /// If set, will be used instead of the name to locate the alert.
    id: String?
    /// Whether notifications from this monitor automatically inserts its triggering tags into the title.
    include_tags: Boolean?
    /// Whether changes to this monitor should be restricted to the creator or admins.
    locked: Boolean?
    /// The name of the alert.
    name: String
    /// A positive integer representing the number of seconds to wait before evaluating the monitor for new hosts.
    /// This gives the host time to fully initialize.
    new_host_delay: String?
    /// The number of minutes before a monitor will notify when data stops reporting.
    /// Must be at least 2x the monitor timeframe for metric alerts or 2 minutes for service checks.
    /// If not specified, it defaults to 2x timeframe for metric, 2 minutes for service.
    no_data_timeframe: String?
    /// A message to include with notifications for this monitor.
    /// Email notifications can be sent to specific users by using the same '@username' notation as events.
    /// Monitor message template variables can be accessed by using double square brackets, i.e '[[' and ']]'.
    notification_message: String?
    /// Toggles the display of additional content sent in the monitor notification.
    notification_preset_name: ("show_all"|"hide_query"|"hide_handles"|"hide_all")?
    /// Whether tagged users will be notified on changes to this monitor.
    notify_audit: Boolean?
    /// Whether this monitor will notify when data stops reporting.
    notify_no_data: Boolean?
    /// Integer from 1 (high) to 5 (low) indicating alert severity.
    priority: Int?
    /// The monitor query to notify on.
    /// Syntax varies depending on what type of monitor you are creating.
    query: String?
    /// The number of minutes after the last notification before a monitor will re-notify on the current status.
    /// It will only re-notify if it is not resolved.
    renotify_interval: String?
    /// The number of times re-notification messages should be sent on the current status at the provided re-notification interval.
    renotify_occurrences: Int?
    /// The types of monitor statuses for which re-notification messages are sent.
    renotify_statuses: Listing<("alert"|"warn"|"no data")>?
    /// Whether this monitor needs a full window of data before it gets evaluated.
    /// We highly recommend you set this to False for sparse metrics, otherwise some evaluations will be skipped.
    require_full_window: Boolean?
    /// Dictionary of scopes to silence, with timestamps or None.
    /// Each scope will be muted until the given POSIX timestamp or forever if the value is None.
    silenced: Any?
    /// The designated state of the monitor.
    state: ("present"|"absent"|"mute"|"unmute")
    /// A list of tags to associate with your monitor when creating or updating.
    /// This can help you categorize and filter monitors.
    tags: Listing<String>?
    /// A dictionary of thresholds by status.
    /// Only available for service checks and metric alerts.
    /// Because each of them can have multiple thresholds, we do not define them directly in the query.
    /// If not specified, it defaults to: V({'ok': 1, 'critical': 1, 'warning': 1}).
    thresholds: Any?
    /// The number of hours of the monitor not reporting data before it will automatically resolve from a triggered state.
    timeout_h: String?
    /// The type of the monitor.
    /// The types V(query alert), V(trace-analytics alert) and V(rum alert) were added in community.general 2.1.0.
    /// The type V(composite) was added in community.general 3.4.0.
    /// The type V(event-v2 alert) was added in community.general 4.8.0.
    type: ("metric alert"|"service check"|"event alert"|"event-v2 alert"|"process alert"|"log alert"|"query alert"|"trace-analytics alert"|"rum alert"|"composite")?
}

/// Task class for datadog_monitor
class DatadogMonitorTask extends Playbook.Task {
    /// todo doc
    `community.general.datadog_monitor`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.datadog_monitor"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.datadog_monitor`
}

/// TaskBuilder class for datadog_monitor
class DatadogMonitor extends Playbook.TaskBuilder {
    /// Options for community.general.datadog_monitor
    options: DatadogMonitorOptions?
    /// todo doc
    function Task(): DatadogMonitorTask = this
        .toMap()
        .put("community.general.datadog_monitor", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(DatadogMonitorTask)
}

/// Modify and read dconf database
/// This module allows modifications and reading of C(dconf) database. The module is implemented as a wrapper around C(dconf) tool. Please see the dconf(1) man page for more details.
/// Since C(dconf) requires a running D-Bus session to change values, the module will try to detect an existing session and reuse it, or run the tool via C(dbus-run-session).
class DconfOptions {
    /// A dconf key to modify or read from the dconf database.
    key: String
    /// The action to take upon the key/value.
    state: ("read"|"present"|"absent")?
    /// Value to set for the specified dconf key. Value should be specified in GVariant format. Due to complexity of this format, it is best to have a look at existing values in the dconf database.
    /// Required for O(state=present).
    /// Although the type is specified as "raw", it should typically be specified as a string. However, boolean values in particular are handled properly even when specified as booleans rather than strings (in fact, handling booleans properly is why the type of this parameter is "raw").
    value: String?
}

/// Task class for dconf
class DconfTask extends Playbook.Task {
    /// todo doc
    `community.general.dconf`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.dconf"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.dconf`
}

/// TaskBuilder class for dconf
class Dconf extends Playbook.TaskBuilder {
    /// Options for community.general.dconf
    options: DconfOptions?
    /// todo doc
    function Task(): DconfTask = this
        .toMap()
        .put("community.general.dconf", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(DconfTask)
}

/// Manages some of the steps common in deploying projects
/// The Deploy Helper manages some of the steps common in deploying software. It creates a folder structure, manages a symlink for the current release and cleans up old releases.
/// Running it with the O(state=query) or O(state=present) will return the C(deploy_helper) fact. C(project_path), whatever you set in the O(path) parameter, C(current_path), the path to the symlink that points to the active release, C(releases_path), the path to the folder to keep releases in, C(shared_path), the path to the folder to keep shared resources in, C(unfinished_filename), the file to check for to recognize unfinished builds, C(previous_release), the release the 'current' symlink is pointing to, C(previous_release_path), the full path to the 'current' symlink target, C(new_release), either the 'release' parameter or a generated timestamp, C(new_release_path), the path to the new release folder (not created by the module).
class DeployHelperOptions {
    /// Whether to run the clean procedure in case of O(state=finalize).
    clean: Boolean?
    /// The name of the symlink that is created when the deploy is finalized. Used in O(state=finalize) and O(state=clean). Returned in the C(deploy_helper.current_path) fact.
    current_path: String?
    /// The number of old releases to keep when cleaning. Used in O(state=finalize) and O(state=clean). Any unfinished builds will be deleted first, so only correct releases will count. The current version will not count.
    keep_releases: Int?
    /// The root path of the project. Returned in the C(deploy_helper.project_path) fact.
    path: String
    /// The release version that is being deployed. Defaults to a timestamp format C(%Y%m%d%H%M%S) (for example V(20141119223359)). This parameter is optional during O(state=present), but needs to be set explicitly for O(state=finalize). You can use the generated fact C(release={{ deploy_helper.new_release }}).
    release: String?
    /// The name of the folder that will hold the releases. This can be relative to O(path) or absolute. Returned in the C(deploy_helper.releases_path) fact.
    releases_path: String?
    /// The name of the folder that will hold the shared resources. This can be relative to O(path) or absolute. If this is set to an empty string, no shared folder will be created. Returned in the C(deploy_helper.shared_path) fact.
    shared_path: String?
    /// The state of the project.
    /// V(query) will only gather facts.
    /// V(present) will create the project C(root) folder, and in it the C(releases) and C(shared) folders.
    /// V(finalize) will remove the unfinished_filename file, create a symlink to the newly deployed release and optionally clean old releases.
    /// V(clean) will remove failed & old releases.
    /// V(absent) will remove the project folder (synonymous to the M(ansible.builtin.file) module with O(state=absent)).
    state: ("present"|"finalize"|"absent"|"clean"|"query")?
    /// The name of the file that indicates a deploy has not finished. All folders in the O(releases_path) that contain this file will be deleted on O(state=finalize) with O(clean=true), or O(state=clean). This file is automatically deleted from the C(new_release_path) during O(state=finalize).
    unfinished_filename: String?
}

/// Task class for deploy_helper
class DeployHelperTask extends Playbook.Task {
    /// todo doc
    `community.general.deploy_helper`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.deploy_helper"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.deploy_helper`
}

/// TaskBuilder class for deploy_helper
class DeployHelper extends Playbook.TaskBuilder {
    /// Options for community.general.deploy_helper
    options: DeployHelperOptions?
    /// todo doc
    function Task(): DeployHelperTask = this
        .toMap()
        .put("community.general.deploy_helper", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(DeployHelperTask)
}

/// Create, update, and delete MCP 1.0 & 2.0 networks
/// Create, update, and delete MCP 1.0 & 2.0 networks
class DimensiondataNetworkOptions {
    /// Additional description of the network domain.
    description: String?
    /// The name of the network domain to create.
    name: String
    /// The service plan, either "ESSENTIALS" or "ADVANCED".
    /// MCP 2.0 Only.
    service_plan: ("ESSENTIALS"|"ADVANCED")?
    /// Should the resource be present or absent.
    state: ("present"|"absent")?
}

/// Task class for dimensiondata_network
class DimensiondataNetworkTask extends Playbook.Task {
    /// todo doc
    `community.general.dimensiondata_network`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.dimensiondata_network"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.dimensiondata_network`
}

/// TaskBuilder class for dimensiondata_network
class DimensiondataNetwork extends Playbook.TaskBuilder {
    /// Options for community.general.dimensiondata_network
    options: DimensiondataNetworkOptions?
    /// todo doc
    function Task(): DimensiondataNetworkTask = this
        .toMap()
        .put("community.general.dimensiondata_network", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(DimensiondataNetworkTask)
}

/// Manage a VLAN in a Cloud Control network domain
/// Manage VLANs in Cloud Control network domains.
class DimensiondataVlanOptions {
    /// Permit expansion of the target VLAN's network if the module parameters specify a larger network than the VLAN currently possesses.
    /// If V(false), the module will fail under these conditions.
    /// This is intended to prevent accidental expansion of a VLAN's network (since this operation is not reversible).
    allow_expand: Boolean?
    /// A description of the VLAN.
    description: String?
    /// The name of the target VLAN.
    name: String
    /// The Id or name of the target network domain.
    network_domain: String
    /// The base address for the VLAN's IPv4 network (e.g. 192.168.1.0).
    private_ipv4_base_address: String?
    /// The size of the IPv4 address space, e.g 24.
    /// Required, if O(private_ipv4_base_address) is specified.
    private_ipv4_prefix_size: Int?
    /// The desired state for the target VLAN.
    /// V(readonly) ensures that the state is only ever read, not modified (the module will fail if the resource does not exist).
    state: ("present"|"absent"|"readonly")?
}

/// Task class for dimensiondata_vlan
class DimensiondataVlanTask extends Playbook.Task {
    /// todo doc
    `community.general.dimensiondata_vlan`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.dimensiondata_vlan"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.dimensiondata_vlan`
}

/// TaskBuilder class for dimensiondata_vlan
class DimensiondataVlan extends Playbook.TaskBuilder {
    /// Options for community.general.dimensiondata_vlan
    options: DimensiondataVlanOptions?
    /// todo doc
    function Task(): DimensiondataVlanTask = this
        .toMap()
        .put("community.general.dimensiondata_vlan", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(DimensiondataVlanTask)
}

/// Send Discord messages
/// Sends a message to a Discord channel using the Discord webhook API.
class DiscordOptions {
    /// Overrides the default avatar of the webhook.
    avatar_url: String?
    /// Content of the message to the Discord channel.
    /// At least one of O(content) and O(embeds) must be specified.
    content: String?
    /// Send messages as Embeds to the Discord channel.
    /// Embeds can have a colored border, embedded images, text fields and more.
    /// Allowed parameters are described in the Discord Docs: U(https://discord.com/developers/docs/resources/channel#embed-object)
    /// At least one of O(content) and O(embeds) must be specified.
    embeds: Listing<Any>?
    /// Set this to V(true) if this is a TTS (Text to Speech) message.
    tts: Boolean?
    /// Overrides the default username of the webhook.
    username: String?
    /// The webhook ID.
    /// Format from Discord webhook URL: C(/webhooks/{webhook.id}/{webhook.token}).
    webhook_id: String
    /// The webhook token.
    /// Format from Discord webhook URL: C(/webhooks/{webhook.id}/{webhook.token}).
    webhook_token: String
}

/// Task class for discord
class DiscordTask extends Playbook.Task {
    /// todo doc
    `community.general.discord`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.discord"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.discord`
}

/// TaskBuilder class for discord
class Discord extends Playbook.TaskBuilder {
    /// Options for community.general.discord
    options: DiscordOptions?
    /// todo doc
    function Task(): DiscordTask = this
        .toMap()
        .put("community.general.discord", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(DiscordTask)
}

/// Manages a Django application
/// Manages a Django application using the C(manage.py) application frontend to C(django-admin). With the O(virtualenv) parameter, all management commands will be executed by the given C(virtualenv) installation.
class DjangoManageOptions {
    /// When a O(virtualenv) is set but the virtual environment does not exist, the current behavior is to create a new virtual environment. That behavior is deprecated and if that case happens it will generate a deprecation warning. Set this flag to V(true) to suppress the deprecation warning.
    /// Please note that you will receive no further warning about this being removed until the module will start failing in such cases from community.general 9.0.0 on.
    ack_venv_creation_deprecation: Boolean?
    /// A list of space-delimited apps to target. Used by the V(test) command.
    apps: String?
    /// The name of the table used for database-backed caching. Used by the V(createcachetable) command.
    cache_table: String?
    /// Clear the existing files before trying to copy or link the original file.
    /// Used only with the V(collectstatic) command. The C(--noinput) argument will be added automatically.
    clear: Boolean?
    /// The name of the Django management command to run. The commands listed below are built in this module and have some basic parameter validation.
    /// V(cleanup) - clean up old data from the database (deprecated in Django 1.5). This parameter will be removed in community.general 9.0.0. Use V(clearsessions) instead.
    /// V(collectstatic) - Collects the static files into C(STATIC_ROOT).
    /// V(createcachetable) - Creates the cache tables for use with the database cache backend.
    /// V(flush) - Removes all data from the database.
    /// V(loaddata) - Searches for and loads the contents of the named O(fixtures) into the database.
    /// V(migrate) - Synchronizes the database state with models and migrations.
    /// V(syncdb) - Synchronizes the database state with models and migrations (deprecated in Django 1.7). This parameter will be removed in community.general 9.0.0. Use V(migrate) instead.
    /// V(test) - Runs tests for all installed apps.
    /// V(validate) - Validates all installed models (deprecated in Django 1.7). This parameter will be removed in community.general 9.0.0. Use V(check) instead.
    /// Other commands can be entered, but will fail if they are unknown to Django.  Other commands that may prompt for user input should be run with the C(--noinput) flag.
    command: String
    /// The database to target. Used by the V(createcachetable), V(flush), V(loaddata), V(syncdb), and V(migrate) commands.
    database: String?
    /// Fail the command immediately if a test fails. Used by the V(test) command.
    failfast: Boolean?
    /// A space-delimited list of fixture file names to load in the database. B(Required) by the V(loaddata) command.
    fixtures: String?
    /// Will create links to the files instead of copying them, you can only use this parameter with V(collectstatic) command.
    link: Boolean?
    /// Will run out-of-order or missing migrations as they are not rollback migrations, you can only use this parameter with V(migrate) command.
    merge: Boolean?
    /// The path to the root of the Django application where C(manage.py) lives.
    project_path: String
    /// A directory to add to the Python path. Typically used to include the settings module if it is located external to the application directory.
    /// This would be equivalent to adding O(pythonpath)'s value to the E(PYTHONPATH) environment variable.
    pythonpath: String?
    /// The Python path to the application's settings module, such as V(myapp.settings).
    settings: String?
    /// Will skip over out-of-order missing migrations, you can only use this parameter with V(migrate) command.
    skip: Boolean?
    /// Controls the test runner class that is used to execute tests.
    /// This parameter is passed as-is to C(manage.py).
    testrunner: String?
    /// An optional path to a C(virtualenv) installation to use while running the manage application.
    virtualenv: String?
}

/// Task class for django_manage
class DjangoManageTask extends Playbook.Task {
    /// todo doc
    `community.general.django_manage`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.django_manage"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.django_manage`
}

/// TaskBuilder class for django_manage
class DjangoManage extends Playbook.TaskBuilder {
    /// Options for community.general.django_manage
    options: DjangoManageOptions?
    /// todo doc
    function Task(): DjangoManageTask = this
        .toMap()
        .put("community.general.django_manage", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(DjangoManageTask)
}

/// Enable or disable dnf repositories using config-manager
/// This module enables or disables repositories using the C(dnf config-manager) sub-command.
class DnfConfigManagerOptions {
    /// Repository ID, for example V(crb).
    name: Listing<String>?
    /// Whether the repositories should be V(enabled) or V(disabled).
    state: ("enabled"|"disabled")?
}

/// Task class for dnf_config_manager
class DnfConfigManagerTask extends Playbook.Task {
    /// todo doc
    `community.general.dnf_config_manager`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.dnf_config_manager"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.dnf_config_manager`
}

/// TaskBuilder class for dnf_config_manager
class DnfConfigManager extends Playbook.TaskBuilder {
    /// Options for community.general.dnf_config_manager
    options: DnfConfigManagerOptions?
    /// todo doc
    function Task(): DnfConfigManagerTask = this
        .toMap()
        .put("community.general.dnf_config_manager", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(DnfConfigManagerTask)
}

/// Locks package versions in C(dnf) based systems
/// Locks package versions using the C(versionlock) plugin in C(dnf) based systems. This plugin takes a set of name and versions for packages and excludes all other versions of those packages. This allows you to for example protect packages from being updated by newer versions. The state of the plugin that reflects locking of packages is the C(locklist).
class DnfVersionlockOptions {
    /// Package name spec to add or exclude to or delete from the C(locklist) using the format expected by the C(dnf repoquery) command.
    /// This parameter is mutually exclusive with O(state=clean).
    name: Listing<String>?
    /// Do not resolve package name specs to NEVRAs to find specific version to lock to. Instead the package name specs are used as they are. This enables locking to not yet available versions of the package.
    raw: Boolean?
    /// Whether to add (V(present) or V(excluded)) to or remove (V(absent) or V(clean)) from the C(locklist).
    /// V(present) will add a package name spec to the C(locklist). If there is a installed package that matches, then only that version will be added. Otherwise, all available package versions will be added.
    /// V(excluded) will add a package name spec as excluded to the C(locklist). It means that packages represented by the package name spec will be excluded from transaction operations. All available package versions will be added.
    /// V(absent) will delete entries in the C(locklist) that match the package name spec.
    /// V(clean) will delete all entries in the C(locklist). This option is mutually exclusive with O(name).
    state: ("absent"|"clean"|"excluded"|"present")?
}

/// Task class for dnf_versionlock
class DnfVersionlockTask extends Playbook.Task {
    /// todo doc
    `community.general.dnf_versionlock`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.dnf_versionlock"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.dnf_versionlock`
}

/// TaskBuilder class for dnf_versionlock
class DnfVersionlock extends Playbook.TaskBuilder {
    /// Options for community.general.dnf_versionlock
    options: DnfVersionlockOptions?
    /// todo doc
    function Task(): DnfVersionlockTask = this
        .toMap()
        .put("community.general.dnf_versionlock", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(DnfVersionlockTask)
}

/// Interface with dnsimple.com (a DNS hosting service)
/// Manages domains and records via the DNSimple API, see the docs: U(http://developer.dnsimple.com/).
class DnsimpleOptions {
    /// Account API token. See O(account_email) for more information.
    account_api_token: String?
    /// Account email. If omitted, the environment variables E(DNSIMPLE_EMAIL) and E(DNSIMPLE_API_TOKEN) will be looked for.
    /// If those aren't found, a C(.dnsimple) file will be looked for, see: U(https://github.com/mikemaccana/dnsimple-python#getting-started).
    /// C(.dnsimple) config files are only supported in dnsimple-python<2.0.0
    account_email: String?
    /// Domain to work with. Can be the domain name (e.g. "mydomain.com") or the numeric ID of the domain in DNSimple.
    /// If omitted, a list of domains will be returned.
    /// If domain is present but the domain doesn't exist, it will be created.
    domain: String?
    /// Record priority.
    priority: Int?
    /// Record to add, if blank a record for the domain will be created, supports the wildcard (*).
    `record`: String?
    /// List of records to ensure they either exist or do not exist.
    record_ids: Listing<String>?
    /// Use the DNSimple sandbox environment.
    /// Requires a dedicated account in the dnsimple sandbox environment.
    /// Check U(https://developer.dnsimple.com/sandbox/) for more information.
    sandbox: Boolean?
    /// Whether the record should be the only one for that record type and record name.
    /// Only use with O(state) is set to V(present) on a record.
    solo: Boolean?
    /// whether the record should exist or not.
    state: ("present"|"absent")?
    /// The TTL to give the new record in seconds.
    ttl: Int?
    /// The type of DNS record to create.
    type: ("A"|"ALIAS"|"CNAME"|"MX"|"SPF"|"URL"|"TXT"|"NS"|"SRV"|"NAPTR"|"PTR"|"AAAA"|"SSHFP"|"HINFO"|"POOL"|"CAA")?
    /// Record value.
    /// Must be specified when trying to ensure a record exists.
    value: String?
}

/// Task class for dnsimple
class DnsimpleTask extends Playbook.Task {
    /// todo doc
    `community.general.dnsimple`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.dnsimple"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.dnsimple`
}

/// TaskBuilder class for dnsimple
class Dnsimple extends Playbook.TaskBuilder {
    /// Options for community.general.dnsimple
    options: DnsimpleOptions?
    /// todo doc
    function Task(): DnsimpleTask = this
        .toMap()
        .put("community.general.dnsimple", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(DnsimpleTask)
}

/// Pull basic info from DNSimple API
/// Retrieve existing records and domains from DNSimple API.
class DnsimpleInfoOptions {
    /// The account ID to query.
    account_id: String
    /// The API key to use.
    api_key: String
    /// The domain name to retrieve info from.
    /// Will return all associated records for this domain if specified.
    /// If not specified, will return all domains associated with the account ID.
    name: String?
    /// The record to find.
    /// If specified, only this record will be returned instead of all records.
    `record`: String?
    /// Whether or not to use sandbox environment.
    sandbox: Boolean?
}

/// Task class for dnsimple_info
class DnsimpleInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.dnsimple_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.dnsimple_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.dnsimple_info`
}

/// TaskBuilder class for dnsimple_info
class DnsimpleInfo extends Playbook.TaskBuilder {
    /// Options for community.general.dnsimple_info
    options: DnsimpleInfoOptions?
    /// todo doc
    function Task(): DnsimpleInfoTask = this
        .toMap()
        .put("community.general.dnsimple_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(DnsimpleInfoTask)
}

/// Interface with dnsmadeeasy.com (a DNS hosting service)
/// Manages DNS records via the v2 REST API of the DNS Made Easy service.  It handles records only; there is no manipulation of domains or monitor/account support yet. See: U(https://www.dnsmadeeasy.com/integration/restapi/)
class DnsmadeeasyOptions {
    /// Account API Key.
    account_key: String
    /// Account Secret Key.
    account_secret: String
    /// If true, fallback to the primary IP address is manual after a failover.
    /// If false, fallback to the primary IP address is automatic after a failover.
    autoFailover: Boolean?
    /// Name or id of the contact list that the monitor will notify.
    /// The default V('') means the Account Owner.
    contactList: String?
    /// Domain to work with. Can be the domain name (e.g. "mydomain.com") or the numeric ID of the domain in DNS Made Easy (e.g. "839989") for faster resolution
    domain: String
    /// If V(true), add or change the failover.  This is applicable only for A records.
    failover: Boolean?
    /// The file at the Fqdn that the monitor queries for HTTP or HTTPS.
    httpFile: String?
    /// The fully qualified domain name used by the monitor.
    httpFqdn: String?
    /// The string in the httpFile that the monitor queries for HTTP or HTTPS.
    httpQueryString: String?
    /// Primary IP address for the failover.
    /// Required if adding or changing the monitor or failover.
    ip1: String?
    /// Secondary IP address for the failover.
    /// Required if adding or changing the failover.
    ip2: String?
    /// Tertiary IP address for the failover.
    ip3: String?
    /// Quaternary IP address for the failover.
    ip4: String?
    /// Quinary IP address for the failover.
    ip5: String?
    /// Number of emails sent to the contact list by the monitor.
    maxEmails: Int?
    /// If V(true), add or change the monitor.  This is applicable only for A records.
    monitor: Boolean?
    /// Port used by the monitor.
    port: Int?
    /// Protocol used by the monitor.
    protocol: ("TCP"|"UDP"|"HTTP"|"DNS"|"SMTP"|"HTTPS")?
    /// Record name to get/create/delete/update. If record_name is not specified; all records for the domain will be returned in "result" regardless of the state argument.
    record_name: String?
    /// record's "Time to live".  Number of seconds the record remains cached in DNS servers.
    record_ttl: Int?
    /// Record type.
    record_type: ("A"|"AAAA"|"CNAME"|"ANAME"|"HTTPRED"|"MX"|"NS"|"PTR"|"SRV"|"TXT")?
    /// Record value. HTTPRED: <redirection URL>, MX: <priority> <target name>, NS: <name server>, PTR: <target name>, SRV: <priority> <weight> <port> <target name>, TXT: <text value>"
    /// If record_value is not specified; no changes will be made and the record will be returned in 'result' (in other words, this module can be used to fetch a record's current id, type, and ttl)
    record_value: String?
    /// Decides if the sandbox API should be used. Otherwise (default) the production API of DNS Made Easy is used.
    sandbox: Boolean?
    /// Number of checks the monitor performs before a failover occurs where Low = 8, Medium = 5,and High = 3.
    sensitivity: ("Low"|"Medium"|"High")?
    /// whether the record should exist or not
    state: ("present"|"absent")
    /// Description used by the monitor.
    systemDescription: String?
    /// If V(false), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
    validate_certs: Boolean?
}

/// Task class for dnsmadeeasy
class DnsmadeeasyTask extends Playbook.Task {
    /// todo doc
    `community.general.dnsmadeeasy`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.dnsmadeeasy"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.dnsmadeeasy`
}

/// TaskBuilder class for dnsmadeeasy
class Dnsmadeeasy extends Playbook.TaskBuilder {
    /// Options for community.general.dnsmadeeasy
    options: DnsmadeeasyOptions?
    /// todo doc
    function Task(): DnsmadeeasyTask = this
        .toMap()
        .put("community.general.dnsmadeeasy", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(DnsmadeeasyTask)
}

/// Override a debian package's version of a file
/// A diversion is for C(dpkg) the knowledge that only a given package (or the local administrator) is allowed to install a file at a given location. Other packages shipping their own version of this file will be forced to O(divert) it, that is to install it at another location. It allows one to keep changes in a file provided by a debian package by preventing its overwrite at package upgrade.
/// This module manages diversions of debian packages files using the C(dpkg-divert) commandline tool. It can either create or remove a diversion for a given file, but also update an existing diversion to modify its O(holder) and/or its O(divert) location.
class DpkgDivertOptions {
    /// The location where the versions of file will be diverted.
    /// Default is to add suffix C(.distrib) to the file path.
    /// This parameter is ignored when O(state=absent).
    divert: String?
    /// When O(rename=true) and O(force=true), renaming is performed even if the target of the renaming exists, i.e. the existing contents of the file at this location will be lost.
    /// This parameter is ignored when O(rename=false).
    force: Boolean?
    /// The name of the package whose copy of file is not diverted, also known as the diversion holder or the package the diversion belongs to.
    /// The actual package does not have to be installed or even to exist for its name to be valid. If not specified, the diversion is hold by 'LOCAL', that is reserved by/for dpkg for local diversions.
    /// This parameter is ignored when O(state=absent).
    holder: String?
    /// The original and absolute path of the file to be diverted or undiverted. This path is unique, i.e. it is not possible to get two diversions for the same O(path).
    path: String
    /// Actually move the file aside (when O(state=present)) or back (when O(state=absent)), but only when changing the state of the diversion. This parameter has no effect when attempting to add a diversion that already exists or when removing an unexisting one.
    /// Unless O(force=true), renaming fails if the destination file already exists (this lock being a dpkg-divert feature, and bypassing it being a module feature).
    rename: Boolean?
    /// When O(state=absent), remove the diversion of the specified O(path); when O(state=present), create the diversion if it does not exist, or update its package O(holder) or O(divert) location, if it already exists.
    state: ("absent"|"present")?
}

/// Task class for dpkg_divert
class DpkgDivertTask extends Playbook.Task {
    /// todo doc
    `community.general.dpkg_divert`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.dpkg_divert"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.dpkg_divert`
}

/// TaskBuilder class for dpkg_divert
class DpkgDivert extends Playbook.TaskBuilder {
    /// Options for community.general.dpkg_divert
    options: DpkgDivertOptions?
    /// todo doc
    function Task(): DpkgDivertTask = this
        .toMap()
        .put("community.general.dpkg_divert", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(DpkgDivertTask)
}

/// Installs Python libraries
/// Installs Python libraries, optionally in a C(virtualenv)
class EasyInstallOptions {
    /// The explicit executable or a pathname to the executable to be used to run easy_install for a specific version of Python installed in the system. For example V(easy_install-3.3), if there are both Python 2.7 and 3.3 installations in the system and you want to run easy_install for the Python 3.3 installation.
    executable: String?
    /// A Python library name.
    name: String
    /// The desired state of the library. V(latest) ensures that the latest version is installed.
    state: ("present"|"latest")?
    /// An optional O(virtualenv) directory path to install into. If the O(virtualenv) does not exist, it is created automatically.
    virtualenv: String?
    /// The command to create the virtual environment with. For example V(pyvenv), V(virtualenv), V(virtualenv2).
    virtualenv_command: String?
    /// Whether the virtual environment will inherit packages from the global site-packages directory.  Note that if this setting is changed on an already existing virtual environment it will not have any effect, the environment must be deleted and newly created.
    virtualenv_site_packages: Boolean?
}

/// Task class for easy_install
class EasyInstallTask extends Playbook.Task {
    /// todo doc
    `community.general.easy_install`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.easy_install"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.easy_install`
}

/// TaskBuilder class for easy_install
class EasyInstall extends Playbook.TaskBuilder {
    /// Options for community.general.easy_install
    options: EasyInstallOptions?
    /// todo doc
    function Task(): EasyInstallTask = this
        .toMap()
        .put("community.general.easy_install", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(EasyInstallTask)
}

/// Manages users for ejabberd servers
/// This module provides user management for ejabberd servers
class EjabberdUserOptions {
    /// the ejabberd host associated with this username
    host: String
    /// enables or disables the local syslog facility for this module
    logging: Boolean?
    /// the password to assign to the username
    password: String?
    /// describe the desired state of the user to be managed
    state: ("present"|"absent")?
    /// the name of the user to manage
    username: String
}

/// Task class for ejabberd_user
class EjabberdUserTask extends Playbook.Task {
    /// todo doc
    `community.general.ejabberd_user`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ejabberd_user"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ejabberd_user`
}

/// TaskBuilder class for ejabberd_user
class EjabberdUser extends Playbook.TaskBuilder {
    /// Options for community.general.ejabberd_user
    options: EjabberdUserOptions?
    /// todo doc
    function Task(): EjabberdUserTask = this
        .toMap()
        .put("community.general.ejabberd_user", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(EjabberdUserTask)
}

/// Manage Elasticsearch plugins
/// Manages Elasticsearch plugins.
class ElasticsearchPluginOptions {
    /// Force batch mode when installing plugins. This is only necessary if a plugin requires additional permissions and console detection fails.
    force: Boolean?
    /// Name of the plugin to install.
    name: String
    /// Location of the plugin binary. If this file is not found, the default plugin binaries will be used.
    plugin_bin: String?
    /// Your configured plugin directory specified in Elasticsearch
    plugin_dir: String?
    /// Proxy host to use during plugin installation
    proxy_host: String?
    /// Proxy port to use during plugin installation
    proxy_port: String?
    /// Optionally set the source location to retrieve the plugin from. This can be a file:// URL to install from a local file, or a remote URL. If this is not set, the plugin location is just based on the name.
    /// The name parameter must match the descriptor in the plugin ZIP specified.
    /// Is only used if the state would change, which is solely checked based on the name parameter. If, for example, the plugin is already installed, changing this has no effect.
    /// For ES 1.x use url.
    src: String?
    /// Desired state of a plugin.
    state: ("present"|"absent")?
    /// Timeout setting: 30s, 1m, 1h...
    /// Only valid for Elasticsearch < 5.0. This option is ignored for Elasticsearch > 5.0.
    timeout: String?
    /// Set exact URL to download the plugin from (Only works for ES 1.x).
    /// For ES 2.x and higher, use src.
    url: String?
    /// Version of the plugin to be installed. If plugin exists with previous version, it will NOT be updated
    version: String?
}

/// Task class for elasticsearch_plugin
class ElasticsearchPluginTask extends Playbook.Task {
    /// todo doc
    `community.general.elasticsearch_plugin`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.elasticsearch_plugin"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.elasticsearch_plugin`
}

/// TaskBuilder class for elasticsearch_plugin
class ElasticsearchPlugin extends Playbook.TaskBuilder {
    /// Options for community.general.elasticsearch_plugin
    options: ElasticsearchPluginOptions?
    /// todo doc
    function Task(): ElasticsearchPluginTask = this
        .toMap()
        .put("community.general.elasticsearch_plugin", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ElasticsearchPluginTask)
}

/// Manage storage group member on EMC VNX
/// This module manages the members of an existing storage group.
class EmcVnxSgMemberOptions {
    /// Lun id to be added.
    lunid: Int
    /// Name of the Storage group to manage.
    name: String
    /// Indicates the desired lunid state.
    /// V(present) ensures specified lunid is present in the Storage Group.
    /// V(absent) ensures specified lunid is absent from Storage Group.
    state: ("present"|"absent")?
}

/// Task class for emc_vnx_sg_member
class EmcVnxSgMemberTask extends Playbook.Task {
    /// todo doc
    `community.general.emc_vnx_sg_member`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.emc_vnx_sg_member"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.emc_vnx_sg_member`
}

/// TaskBuilder class for emc_vnx_sg_member
class EmcVnxSgMember extends Playbook.TaskBuilder {
    /// Options for community.general.emc_vnx_sg_member
    options: EmcVnxSgMemberOptions?
    /// todo doc
    function Task(): EmcVnxSgMemberTask = this
        .toMap()
        .put("community.general.emc_vnx_sg_member", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(EmcVnxSgMemberTask)
}

/// Set or delete key value pairs from an etcd3 cluster
/// Sets or deletes values in etcd3 cluster using its v3 api.
/// Needs python etcd3 lib to work
class Etcd3Options {
    /// The Certificate Authority to use to verify the etcd host.
    /// Required if O(client_cert) and O(client_key) are defined.
    ca_cert: String?
    /// PEM formatted certificate chain file to be used for SSL client authentication.
    /// Required if O(client_key) is defined.
    client_cert: String?
    /// PEM formatted file that contains your private key to be used for SSL client authentication.
    /// Required if O(client_cert) is defined.
    client_key: String?
    /// the IP address of the cluster
    host: String?
    /// the key where the information is stored in the cluster
    key: String
    /// The password to use for authentication.
    /// Required if O(user) is defined.
    password: String?
    /// the port number used to connect to the cluster
    port: Int?
    /// the state of the value for the key.
    /// can be present or absent
    state: ("present"|"absent")
    /// The socket level timeout in seconds.
    timeout: Int?
    /// The etcd user to authenticate with.
    user: String?
    /// the information stored
    value: String
}

/// Task class for etcd3
class Etcd3Task extends Playbook.Task {
    /// todo doc
    `community.general.etcd3`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.etcd3"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.etcd3`
}

/// TaskBuilder class for etcd3
class Etcd3 extends Playbook.TaskBuilder {
    /// Options for community.general.etcd3
    options: Etcd3Options?
    /// todo doc
    function Task(): Etcd3Task = this
        .toMap()
        .put("community.general.etcd3", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(Etcd3Task)
}

/// Runs the discovery program C(facter) on the remote system
/// Runs the C(facter) discovery program (U(https://github.com/puppetlabs/facter)) on the remote system, returning JSON data that can be useful for inventory purposes.
class FacterOptions {
    /// Specifies arguments for facter.
    arguments: Listing<String>?
}

/// Task class for facter
class FacterTask extends Playbook.Task {
    /// todo doc
    `community.general.facter`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.facter"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.facter`
}

/// TaskBuilder class for facter
class Facter extends Playbook.TaskBuilder {
    /// Options for community.general.facter
    options: FacterOptions?
    /// todo doc
    function Task(): FacterTask = this
        .toMap()
        .put("community.general.facter", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(FacterTask)
}

/// Runs the discovery program C(facter) on the remote system and return Ansible facts
/// Runs the C(facter) discovery program (U(https://github.com/puppetlabs/facter)) on the remote system, returning Ansible facts from the JSON data that can be useful for inventory purposes.
class FacterFactsOptions {
    /// Specifies arguments for facter.
    arguments: Listing<String>?
}

/// Task class for facter_facts
class FacterFactsTask extends Playbook.Task {
    /// todo doc
    `community.general.facter_facts`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.facter_facts"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.facter_facts`
}

/// TaskBuilder class for facter_facts
class FacterFacts extends Playbook.TaskBuilder {
    /// Options for community.general.facter_facts
    options: FacterFactsOptions?
    /// todo doc
    function Task(): FacterFactsTask = this
        .toMap()
        .put("community.general.facter_facts", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(FacterFactsTask)
}

/// Create a file with a given size, or resize it if it exists
/// This module is a simple wrapper around C(dd) to create, extend or truncate a file, given its size. It can be used to manage swap files (that require contiguous blocks) or alternatively, huge sparse files.
class FilesizeOptions {
    /// Size of blocks, in bytes if not followed by a multiplicative suffix.
    /// The numeric value (before the unit) B(MUST) be an integer (or a C(float) if it equals an integer).
    /// If not set, the size of blocks is guessed from the OS and commonly results in V(512) or V(4096) bytes, that is used internally by the module or when O(size) has no unit.
    blocksize: String?
    /// Whether or not to overwrite the file if it exists, in other words, to truncate it from 0. When V(true), the module is not idempotent, that means it always reports C(changed=true).
    /// O(force=true) and O(sparse=true) are mutually exclusive.
    force: Boolean?
    /// Path of the regular file to create or resize.
    path: String
    /// Requested size of the file.
    /// The value is a number (either C(int) or C(float)) optionally followed by a multiplicative suffix, that can be one of V(B) (bytes), V(KB) or V(kB) (= 1000B), V(MB) or V(mB) (= 1000kB), V(GB) or V(gB) (= 1000MB), and so on for V(T), V(P), V(E), V(Z) and V(Y); or alternatively one of V(K), V(k) or V(KiB) (= 1024B); V(M), V(m) or V(MiB) (= 1024KiB); V(G), V(g) or V(GiB) (= 1024MiB); and so on.
    /// If the multiplicative suffix is not provided, the value is treated as an integer number of blocks of O(blocksize) bytes each (float values are rounded to the closest integer).
    /// When the O(size) value is equal to the current file size, does nothing.
    /// When the O(size) value is bigger than the current file size, bytes from O(source) (if O(sparse) is not V(false)) are appended to the file without truncating it, in other words, without modifying the existing bytes of the file.
    /// When the O(size) value is smaller than the current file size, it is truncated to the requested value without modifying bytes before this value.
    /// That means that a file of any arbitrary size can be grown to any other arbitrary size, and then resized down to its initial size without modifying its initial content.
    size: String
    /// Device or file that provides input data to provision the file.
    /// This parameter is ignored when O(sparse=true).
    source: String?
    /// Whether or not the file to create should be a sparse file.
    /// This option is effective only on newly created files, or when growing a file, only for the bytes to append.
    /// This option is not supported on OSes or filesystems not supporting sparse files.
    /// O(force=true) and O(sparse=true) are mutually exclusive.
    sparse: Boolean?
    /// This option is silently ignored. This module always modifies file size in-place.
    unsafe_writes: Any?
}

/// Task class for filesize
class FilesizeTask extends Playbook.Task {
    /// todo doc
    `community.general.filesize`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.filesize"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.filesize`
}

/// TaskBuilder class for filesize
class Filesize extends Playbook.TaskBuilder {
    /// Options for community.general.filesize
    options: FilesizeOptions?
    /// todo doc
    function Task(): FilesizeTask = this
        .toMap()
        .put("community.general.filesize", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(FilesizeTask)
}

/// Makes a filesystem
/// This module creates a filesystem.
class FilesystemOptions {
    /// Target path to block device (Linux) or character device (FreeBSD) or regular file (both).
    /// When setting Linux-specific filesystem types on FreeBSD, this module only works when applying to regular files, aka disk images.
    /// Currently V(lvm) (Linux-only) and V(ufs) (FreeBSD-only) do not support a regular file as their target O(dev).
    /// Support for character devices on FreeBSD has been added in community.general 3.4.0.
    dev: String
    /// If V(true), allows to create new filesystem on devices that already has filesystem.
    force: Boolean?
    /// Filesystem type to be created. This option is required with O(state=present) (or if O(state) is omitted).
    /// ufs support has been added in community.general 3.4.0.
    /// bcachefs support has been added in community.general 8.6.0.
    fstype: ("bcachefs"|"btrfs"|"ext2"|"ext3"|"ext4"|"ext4dev"|"f2fs"|"lvm"|"ocfs2"|"reiserfs"|"xfs"|"vfat"|"swap"|"ufs")?
    /// List of options to be passed to C(mkfs) command.
    opts: String?
    /// If V(true), if the block device and filesystem size differ, grow the filesystem into the space.
    /// Supported for C(bcachefs), C(btrfs), C(ext2), C(ext3), C(ext4), C(ext4dev), C(f2fs), C(lvm), C(xfs), C(ufs) and C(vfat) filesystems. Attempts to resize other filesystem types will fail.
    /// XFS Will only grow if mounted. Currently, the module is based on commands from C(util-linux) package to perform operations, so resizing of XFS is not supported on FreeBSD systems.
    /// vFAT will likely fail if C(fatresize < 1.04).
    /// Mutually exclusive with O(uuid).
    resizefs: Boolean?
    /// If O(state=present), the filesystem is created if it doesn't already exist, that is the default behaviour if O(state) is omitted.
    /// If O(state=absent), filesystem signatures on O(dev) are wiped if it contains a filesystem (as known by C(blkid)).
    /// When O(state=absent), all other options but O(dev) are ignored, and the module does not fail if the device O(dev) doesn't actually exist.
    state: ("present"|"absent")?
    /// Set filesystem's UUID to the given value.
    /// The UUID options specified in O(opts) take precedence over this value.
    /// See xfs_admin(8) (C(xfs)), tune2fs(8) (C(ext2), C(ext3), C(ext4), C(ext4dev)) for possible values.
    /// For O(fstype=lvm) the value is ignored, it resets the PV UUID if set.
    /// Supported for O(fstype) being one of C(bcachefs), C(ext2), C(ext3), C(ext4), C(ext4dev), C(lvm), or C(xfs).
    /// This is B(not idempotent). Specifying this option will always result in a change.
    /// Mutually exclusive with O(resizefs).
    uuid: String?
}

/// Task class for filesystem
class FilesystemTask extends Playbook.Task {
    /// todo doc
    `community.general.filesystem`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.filesystem"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.filesystem`
}

/// TaskBuilder class for filesystem
class Filesystem extends Playbook.TaskBuilder {
    /// Options for community.general.filesystem
    options: FilesystemOptions?
    /// todo doc
    function Task(): FilesystemTask = this
        .toMap()
        .put("community.general.filesystem", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(FilesystemTask)
}

/// Manage flatpaks
/// Allows users to add or remove flatpaks.
/// See the M(community.general.flatpak_remote) module for managing flatpak remotes.
class FlatpakOptions {
    /// The path to the C(flatpak) executable to use.
    /// By default, this module looks for the C(flatpak) executable on the path.
    executable: String?
    /// The installation method to use.
    /// Defines if the C(flatpak) is supposed to be installed globally for the whole V(system) or only for the current V(user).
    method: ("system"|"user")?
    /// The name of the flatpak to manage. To operate on several packages this can accept a list of packages.
    /// When used with O(state=present), O(name) can be specified as a URL to a C(flatpakref) file or the unique reverse DNS name that identifies a flatpak.
    /// Both C(https://) and C(http://) URLs are supported.
    /// When supplying a reverse DNS name, you can use the O(remote) option to specify on what remote to look for the flatpak. An example for a reverse DNS name is C(org.gnome.gedit).
    /// When used with O(state=absent) or O(state=latest), it is recommended to specify the name in the reverse DNS format.
    /// When supplying a URL with O(state=absent) or O(state=latest), the module will try to match the installed flatpak based on the name of the flatpakref to remove or update it. However, there is no guarantee that the names of the flatpakref file and the reverse DNS name of the installed flatpak do match.
    name: Listing<String>
    /// If installing runtime dependencies should be omitted or not
    /// This parameter is primarily implemented for integration testing this module. There might however be some use cases where you would want to have this, like when you are packaging your own flatpaks.
    no_dependencies: Boolean?
    /// The flatpak remote (repository) to install the flatpak from.
    /// By default, V(flathub) is assumed, but you do need to add the flathub flatpak_remote before you can use this.
    /// See the M(community.general.flatpak_remote) module for managing flatpak remotes.
    remote: String?
    /// Indicates the desired package state.
    /// The value V(latest) is supported since community.general 8.6.0.
    state: ("absent"|"present"|"latest")?
}

/// Task class for flatpak
class FlatpakTask extends Playbook.Task {
    /// todo doc
    `community.general.flatpak`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.flatpak"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.flatpak`
}

/// TaskBuilder class for flatpak
class Flatpak extends Playbook.TaskBuilder {
    /// Options for community.general.flatpak
    options: FlatpakOptions?
    /// todo doc
    function Task(): FlatpakTask = this
        .toMap()
        .put("community.general.flatpak", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(FlatpakTask)
}

/// Manage flatpak repository remotes
/// Allows users to add or remove flatpak remotes.
/// The flatpak remotes concept is comparable to what is called repositories in other packaging formats.
/// Currently, remote addition is only supported via C(flatpakrepo) file URLs.
/// Existing remotes will not be updated.
/// See the M(community.general.flatpak) module for managing flatpaks.
class FlatpakRemoteOptions {
    /// Indicates whether this remote is enabled.
    enabled: Boolean?
    /// The path to the C(flatpak) executable to use.
    /// By default, this module looks for the C(flatpak) executable on the path.
    executable: String?
    /// The URL to the C(flatpakrepo) file representing the repository remote to add.
    /// When used with O(state=present), the flatpak remote specified under the O(flatpakrepo_url) is added using the specified installation O(method).
    /// When used with O(state=absent), this is not required.
    /// Required when O(state=present).
    flatpakrepo_url: String?
    /// The installation method to use.
    /// Defines if the C(flatpak) is supposed to be installed globally for the whole V(system) or only for the current V(user).
    method: ("system"|"user")?
    /// The desired name for the flatpak remote to be registered under on the managed host.
    /// When used with O(state=present), the remote will be added to the managed host under the specified O(name).
    /// When used with O(state=absent) the remote with that name will be removed.
    name: String
    /// Indicates the desired package state.
    state: ("absent"|"present")?
}

/// Task class for flatpak_remote
class FlatpakRemoteTask extends Playbook.Task {
    /// todo doc
    `community.general.flatpak_remote`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.flatpak_remote"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.flatpak_remote`
}

/// TaskBuilder class for flatpak_remote
class FlatpakRemote extends Playbook.TaskBuilder {
    /// Options for community.general.flatpak_remote
    options: FlatpakRemoteOptions?
    /// todo doc
    function Task(): FlatpakRemoteTask = this
        .toMap()
        .put("community.general.flatpak_remote", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(FlatpakRemoteTask)
}

/// Send a message to a flowdock
/// Send a message to a flowdock team inbox or chat using the push API (see https://www.flowdock.com/api/team-inbox and https://www.flowdock.com/api/chat)
class FlowdockOptions {
    /// (chat only - required) Name of the "user" sending the message
    external_user_name: String?
    /// (inbox only - required) Email address of the message sender
    from_address: String?
    /// (inbox only) Name of the message sender
    from_name: String?
    /// (inbox only) Link associated with the message. This will be used to link the message subject in Team Inbox.
    link: String?
    /// Content of the message
    msg: String
    /// (inbox only) Human readable identifier for more detailed message categorization
    project: String?
    /// (inbox only) Email address for replies
    reply_to: String?
    /// (inbox only - required) Human readable identifier of the application that uses the Flowdock API
    source: String?
    /// (inbox only - required) Subject line of the message
    subject: String?
    /// tags of the message, separated by commas
    tags: String?
    /// API token.
    token: String
    /// Whether to post to 'inbox' or 'chat'
    type: ("inbox"|"chat")
    /// If V(false), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
    validate_certs: Boolean?
}

/// Task class for flowdock
class FlowdockTask extends Playbook.Task {
    /// todo doc
    `community.general.flowdock`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.flowdock"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.flowdock`
}

/// TaskBuilder class for flowdock
class Flowdock extends Playbook.TaskBuilder {
    /// Options for community.general.flowdock
    options: FlowdockOptions?
    /// todo doc
    function Task(): FlowdockTask = this
        .toMap()
        .put("community.general.flowdock", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(FlowdockTask)
}

/// Manage Gandi LiveDNS records
/// Manages DNS records by the Gandi LiveDNS API, see the docs: U(https://doc.livedns.gandi.net/).
class GandiLivednsOptions {
    /// Account API token.
    api_key: String
    /// The name of the Domain to work with (for example, "example.com").
    domain: String
    /// Record to add.
    `record`: String
    /// Whether the record(s) should exist or not.
    state: ("absent"|"present")?
    /// The TTL to give the new record.
    /// Required when O(state=present).
    ttl: Int?
    /// The type of DNS record to create.
    type: String
    /// The record values.
    /// Required when O(state=present).
    values: Listing<String>?
}

/// Task class for gandi_livedns
class GandiLivednsTask extends Playbook.Task {
    /// todo doc
    `community.general.gandi_livedns`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.gandi_livedns"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.gandi_livedns`
}

/// TaskBuilder class for gandi_livedns
class GandiLivedns extends Playbook.TaskBuilder {
    /// Options for community.general.gandi_livedns
    options: GandiLivednsOptions?
    /// todo doc
    function Task(): GandiLivednsTask = this
        .toMap()
        .put("community.general.gandi_livedns", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GandiLivednsTask)
}

/// Edit GNOME Configurations
/// This module allows for the manipulation of GNOME 2 Configuration via gconftool-2.  Please see the gconftool-2(1) man pages for more details.
class Gconftool2Options {
    /// Specify a configuration source to use rather than the default path. See man gconftool-2(1).
    config_source: String?
    /// Access the config database directly, bypassing server.  If O(direct) is specified then the O(config_source) must be specified as well. See man gconftool-2(1).
    direct: Boolean?
    /// A GConf preference key is an element in the GConf repository that corresponds to an application preference. See man gconftool-2(1).
    key: String
    /// The action to take upon the key/value.
    state: ("absent"|"present")
    /// Preference keys typically have simple values such as strings, integers, or lists of strings and integers. This is ignored unless O(state=present). See man gconftool-2(1).
    value: String?
    /// The type of value being set. This is ignored unless O(state=present). See man gconftool-2(1).
    value_type: ("bool"|"float"|"int"|"string")?
}

/// Task class for gconftool2
class Gconftool2Task extends Playbook.Task {
    /// todo doc
    `community.general.gconftool2`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.gconftool2"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.gconftool2`
}

/// TaskBuilder class for gconftool2
class Gconftool2 extends Playbook.TaskBuilder {
    /// Options for community.general.gconftool2
    options: Gconftool2Options?
    /// todo doc
    function Task(): Gconftool2Task = this
        .toMap()
        .put("community.general.gconftool2", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(Gconftool2Task)
}

/// Retrieve GConf configurations
/// This module allows retrieving application preferences from the GConf database, with the help of C(gconftool-2).
class Gconftool2InfoOptions {
    /// The key name for an element in the GConf database.
    key: String
}

/// Task class for gconftool2_info
class Gconftool2InfoTask extends Playbook.Task {
    /// todo doc
    `community.general.gconftool2_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.gconftool2_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.gconftool2_info`
}

/// TaskBuilder class for gconftool2_info
class Gconftool2Info extends Playbook.TaskBuilder {
    /// Options for community.general.gconftool2_info
    options: Gconftool2InfoOptions?
    /// todo doc
    function Task(): Gconftool2InfoTask = this
        .toMap()
        .put("community.general.gconftool2_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(Gconftool2InfoTask)
}

/// Manage Ruby gems
/// Manage installation and uninstallation of Ruby gems.
class GemOptions {
    /// Install executables into a specific directory.
    bindir: String?
    /// Allow adding build flags for gem compilation
    build_flags: String?
    /// Rewrite the shebang line on installed scripts to use /usr/bin/env.
    env_shebang: Boolean?
    /// Override the path to the gem executable
    executable: String?
    /// Force gem to (un-)install, bypassing dependency checks.
    force: Boolean?
    /// The path to a local gem used as installation source.
    gem_source: String?
    /// Whether to include dependencies or not.
    include_dependencies: Boolean?
    /// Install with or without docs.
    include_doc: Boolean?
    /// Install the gems into a specific directory. These gems will be independent from the global installed ones. Specifying this requires user_install to be false.
    install_dir: String?
    /// The name of the gem to be managed.
    name: String
    /// Avoid loading any C(.gemrc) file. Ignored for RubyGems prior to 2.5.2.
    /// The default changed from V(false) to V(true) in community.general 6.0.0.
    norc: Boolean?
    /// Allow installation of pre-release versions of the gem.
    pre_release: Boolean?
    /// The repository from which the gem will be installed
    repository: String?
    /// The desired state of the gem. V(latest) ensures that the latest version is installed.
    state: ("present"|"absent"|"latest")?
    /// Install gem in user's local gems cache or for all users
    user_install: Boolean?
    /// Version of the gem to be installed/removed.
    version: String?
}

/// Task class for gem
class GemTask extends Playbook.Task {
    /// todo doc
    `community.general.gem`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.gem"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.gem`
}

/// TaskBuilder class for gem
class Gem extends Playbook.TaskBuilder {
    /// Options for community.general.gem
    options: GemOptions?
    /// todo doc
    function Task(): GemTask = this
        .toMap()
        .put("community.general.gem", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GemTask)
}

/// Set default handler for MIME type, for applications using Gnome GIO
/// This module allows configuring the default handler for a specific MIME type, to be used by applications built with th Gnome GIO API.
class GioMimeOptions {
    /// Default handler will be set for the MIME type.
    handler: String
    /// MIME type for which a default handler will be set.
    mime_type: String
}

/// Task class for gio_mime
class GioMimeTask extends Playbook.Task {
    /// todo doc
    `community.general.gio_mime`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.gio_mime"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.gio_mime`
}

/// TaskBuilder class for gio_mime
class GioMime extends Playbook.TaskBuilder {
    /// Options for community.general.gio_mime
    options: GioMimeOptions?
    /// todo doc
    function Task(): GioMimeTask = this
        .toMap()
        .put("community.general.gio_mime", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GioMimeTask)
}

/// Read and write git configuration
/// The M(community.general.git_config) module changes git configuration by invoking C(git config). This is needed if you do not want to use M(ansible.builtin.template) for the entire git config file (for example because you need to change just C(user.email) in /etc/.git/config).  Solutions involving M(ansible.builtin.command) are cumbersome or do not work correctly in check mode.
class GitConfigOptions {
    /// Specify if a value should replace the existing value(s) or if the new value should be added alongside other values with the same name.
    /// This option is only relevant when adding/replacing values. If O(state=absent) or values are just read out, this option is not considered.
    add_mode: ("add"|"replace-all")?
    /// Path to an adhoc git configuration file to be managed using the V(file) scope.
    file: String?
    /// List all settings (optionally limited to a given O(scope)).
    list_all: Boolean?
    /// The name of the setting. If no value is supplied, the value will be read from the config if it has been set.
    name: String?
    /// Path to a git repository for reading and writing values from a specific repo.
    repo: String?
    /// Specify which scope to read/set values from.
    /// This is required when setting config values.
    /// If this is set to V(local), you must also specify the O(repo) parameter.
    /// If this is set to V(file), you must also specify the O(file) parameter.
    /// It defaults to system only when not using O(list_all=true).
    scope: ("file"|"local"|"global"|"system")?
    /// Indicates the setting should be set/unset. This parameter has higher precedence than O(value) parameter: when O(state=absent) and O(value) is defined, O(value) is discarded.
    state: ("present"|"absent")?
    /// When specifying the name of a single setting, supply a value to set that setting to the given value.
    value: String?
}

/// Task class for git_config
class GitConfigTask extends Playbook.Task {
    /// todo doc
    `community.general.git_config`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.git_config"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.git_config`
}

/// TaskBuilder class for git_config
class GitConfig extends Playbook.TaskBuilder {
    /// Options for community.general.git_config
    options: GitConfigOptions?
    /// todo doc
    function Task(): GitConfigTask = this
        .toMap()
        .put("community.general.git_config", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GitConfigTask)
}

/// Read git configuration
/// The M(community.general.git_config_info) module reads the git configuration by invoking C(git config).
class GitConfigInfoOptions {
    /// The name of the setting to read.
    /// If not provided, all settings will be returned as RV(config_values).
    name: String?
    /// Path to a git repository or file for reading values from a specific repo.
    /// If O(scope) is V(local), this must point to a repository to read from.
    /// If O(scope) is V(file), this must point to specific git config file to read from.
    /// Otherwise O(path) is ignored if set.
    path: String?
    /// Specify which scope to read values from.
    /// If set to V(global), the global git config is used. O(path) is ignored.
    /// If set to V(system), the system git config is used. O(path) is ignored.
    /// If set to V(local), O(path) must be set to the repo to read from.
    /// If set to V(file), O(path) must be set to the config file to read from.
    scope: ("global"|"system"|"local"|"file")?
}

/// Task class for git_config_info
class GitConfigInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.git_config_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.git_config_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.git_config_info`
}

/// TaskBuilder class for git_config_info
class GitConfigInfo extends Playbook.TaskBuilder {
    /// Options for community.general.git_config_info
    options: GitConfigInfoOptions?
    /// todo doc
    function Task(): GitConfigInfoTask = this
        .toMap()
        .put("community.general.git_config_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GitConfigInfoTask)
}

/// Manages deploy keys for GitHub repositories
/// Adds or removes deploy keys for GitHub repositories. Supports authentication using username and password, username and password and 2-factor authentication code (OTP), OAuth2 token, or personal access token. Admin rights on the repository are required.
class GithubDeployKeyOptions {
    /// If V(true), forcefully adds the deploy key by deleting any existing deploy key with the same public key or title.
    force: Boolean?
    /// The base URL of the GitHub API
    github_url: String?
    /// The SSH public key to add to the repository as a deploy key.
    key: String
    /// The name for the deploy key.
    name: String
    /// The 6 digit One Time Password for 2-Factor Authentication. Required together with O(username) and O(password).
    otp: Int?
    /// The name of the individual account or organization that owns the GitHub repository.
    owner: String
    /// The password to authenticate with. Alternatively, a personal access token can be used instead of O(username) and O(password) combination.
    password: String?
    /// If V(true), the deploy key will only be able to read repository contents. Otherwise, the deploy key will be able to read and write.
    read_only: Boolean?
    /// The name of the GitHub repository.
    repo: String
    /// The state of the deploy key.
    state: ("present"|"absent")?
    /// The OAuth2 token or personal access token to authenticate with. Mutually exclusive with O(password).
    token: String?
    /// The username to authenticate with. Should not be set when using personal access token
    username: String?
}

/// Task class for github_deploy_key
class GithubDeployKeyTask extends Playbook.Task {
    /// todo doc
    `community.general.github_deploy_key`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.github_deploy_key"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.github_deploy_key`
}

/// TaskBuilder class for github_deploy_key
class GithubDeployKey extends Playbook.TaskBuilder {
    /// Options for community.general.github_deploy_key
    options: GithubDeployKeyOptions?
    /// todo doc
    function Task(): GithubDeployKeyTask = this
        .toMap()
        .put("community.general.github_deploy_key", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GithubDeployKeyTask)
}

/// View GitHub issue
/// View GitHub issue for a given repository and organization.
class GithubIssueOptions {
    /// Get various details about issue depending upon action specified.
    action: ("get_status")?
    /// Issue number for which information is required.
    issue: Int
    /// Name of the GitHub organization in which the repository is hosted.
    organization: String
    /// Name of repository from which issue needs to be retrieved.
    repo: String
}

/// Task class for github_issue
class GithubIssueTask extends Playbook.Task {
    /// todo doc
    `community.general.github_issue`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.github_issue"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.github_issue`
}

/// TaskBuilder class for github_issue
class GithubIssue extends Playbook.TaskBuilder {
    /// Options for community.general.github_issue
    options: GithubIssueOptions?
    /// todo doc
    function Task(): GithubIssueTask = this
        .toMap()
        .put("community.general.github_issue", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GithubIssueTask)
}

/// Manage GitHub access keys
/// Creates, removes, or updates GitHub access keys.
class GithubKeyOptions {
    /// The default is V(true), which will replace the existing remote key if it is different than O(pubkey). If V(false), the key will only be set if no key with the given O(name) exists.
    force: Boolean?
    /// SSH key name
    name: String
    /// SSH public key value. Required when O(state=present).
    pubkey: String?
    /// Whether to remove a key, ensure that it exists, or update its value.
    state: ("present"|"absent")?
    /// GitHub Access Token with permission to list and create public keys.
    token: String
}

/// Task class for github_key
class GithubKeyTask extends Playbook.Task {
    /// todo doc
    `community.general.github_key`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.github_key"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.github_key`
}

/// TaskBuilder class for github_key
class GithubKey extends Playbook.TaskBuilder {
    /// Options for community.general.github_key
    options: GithubKeyOptions?
    /// todo doc
    function Task(): GithubKeyTask = this
        .toMap()
        .put("community.general.github_key", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GithubKeyTask)
}

/// Interact with GitHub Releases
/// Fetch metadata about GitHub Releases
class GithubReleaseOptions {
    /// Action to perform
    action: ("latest_release"|"create_release")
    /// Description of the release when creating a release
    body: String?
    /// Sets if the release is a draft or not. (boolean)
    draft: Boolean?
    /// Name of release when creating a release
    name: String?
    /// The GitHub account password for the user. Mutually exclusive with O(token).
    password: String?
    /// Sets if the release is a prerelease or not. (boolean)
    prerelease: Boolean?
    /// Repository name
    repo: String
    /// Tag name when creating a release. Required when using O(action=create_release).
    tag: String?
    /// Target of release when creating a release
    target: String?
    /// GitHub Personal Access Token for authenticating. Mutually exclusive with O(password).
    token: String?
    /// The GitHub account that owns the repository
    user: String
}

/// Task class for github_release
class GithubReleaseTask extends Playbook.Task {
    /// todo doc
    `community.general.github_release`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.github_release"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.github_release`
}

/// TaskBuilder class for github_release
class GithubRelease extends Playbook.TaskBuilder {
    /// Options for community.general.github_release
    options: GithubReleaseOptions?
    /// todo doc
    function Task(): GithubReleaseTask = this
        .toMap()
        .put("community.general.github_release", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GithubReleaseTask)
}

/// Manage your repositories on Github
/// Manages Github repositories using PyGithub library.
/// Authentication can be done with O(access_token) or with O(username) and O(password).
class GithubRepoOptions {
    /// Token parameter for authentication.
    /// This is only needed when not using O(username) and O(password).
    access_token: String?
    /// URL to the GitHub API if not using github.com but you own instance.
    api_url: String?
    /// Description for the repository.
    /// Defaults to empty if O(force_defaults=true), which is the default in this module.
    /// Defaults to empty if O(force_defaults=false) when creating a new repository.
    /// This is only used when O(state) is V(present).
    description: String?
    /// Overwrite current O(description) and O(private) attributes with defaults if set to V(true), which currently is the default.
    /// The default for this option will be deprecated in a future version of this collection, and eventually change to V(false).
    force_defaults: Boolean?
    /// Repository name.
    name: String
    /// Organization for the repository.
    /// When O(state=present), the repository will be created in the current user profile.
    organization: String?
    /// Password used for authentication.
    /// This is only needed when not using O(access_token).
    password: String?
    /// Whether the repository should be private or not.
    /// Defaults to V(false) if O(force_defaults=true), which is the default in this module.
    /// Defaults to V(false) if O(force_defaults=false) when creating a new repository.
    /// This is only used when O(state=present).
    private: Boolean?
    /// Whether the repository should exist or not.
    state: ("absent"|"present")?
    /// Username used for authentication.
    /// This is only needed when not using O(access_token).
    username: String?
}

/// Task class for github_repo
class GithubRepoTask extends Playbook.Task {
    /// todo doc
    `community.general.github_repo`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.github_repo"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.github_repo`
}

/// TaskBuilder class for github_repo
class GithubRepo extends Playbook.TaskBuilder {
    /// Options for community.general.github_repo
    options: GithubRepoOptions?
    /// todo doc
    function Task(): GithubRepoTask = this
        .toMap()
        .put("community.general.github_repo", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GithubRepoTask)
}

/// Manage GitHub webhooks
/// Create and delete GitHub webhooks
class GithubWebhookOptions {
    /// Whether or not the hook is active
    active: Boolean?
    /// The media type used to serialize the payloads
    content_type: ("form"|"json")?
    /// A list of GitHub events the hook is triggered for. Events are listed at U(https://developer.github.com/v3/activity/events/types/). Required unless O(state=absent)
    events: Listing<String>?
    /// Base URL of the GitHub API
    github_url: String?
    /// Flag to indicate that GitHub should skip SSL verification when calling the hook.
    insecure_ssl: Boolean?
    /// Password to authenticate to GitHub with
    password: String?
    /// Full name of the repository to configure a hook for
    repository: String
    /// The shared secret between GitHub and the payload URL.
    secret: String?
    /// Whether the hook should be present or absent
    state: ("absent"|"present")?
    /// Token to authenticate to GitHub with
    token: String?
    /// URL to which payloads will be delivered
    url: String
    /// User to authenticate to GitHub as
    user: String
}

/// Task class for github_webhook
class GithubWebhookTask extends Playbook.Task {
    /// todo doc
    `community.general.github_webhook`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.github_webhook"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.github_webhook`
}

/// TaskBuilder class for github_webhook
class GithubWebhook extends Playbook.TaskBuilder {
    /// Options for community.general.github_webhook
    options: GithubWebhookOptions?
    /// todo doc
    function Task(): GithubWebhookTask = this
        .toMap()
        .put("community.general.github_webhook", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GithubWebhookTask)
}

/// Query information about GitHub webhooks
/// Query information about GitHub webhooks
class GithubWebhookInfoOptions {
    /// Base URL of the github api
    github_url: String?
    /// Password to authenticate to GitHub with
    password: String?
    /// Full name of the repository to configure a hook for
    repository: String
    /// Token to authenticate to GitHub with
    token: String?
    /// User to authenticate to GitHub as
    user: String
}

/// Task class for github_webhook_info
class GithubWebhookInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.github_webhook_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.github_webhook_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.github_webhook_info`
}

/// TaskBuilder class for github_webhook_info
class GithubWebhookInfo extends Playbook.TaskBuilder {
    /// Options for community.general.github_webhook_info
    options: GithubWebhookInfoOptions?
    /// todo doc
    function Task(): GithubWebhookInfoTask = this
        .toMap()
        .put("community.general.github_webhook_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GithubWebhookInfoTask)
}

/// Create or delete a branch
/// This module allows to create or delete branches.
class GitlabBranchOptions {
    /// The name of the branch that needs to be created.
    branch: String
    /// The path or name of the project.
    project: String
    /// Reference branch to create from.
    /// This must be specified if O(state=present).
    ref_branch: String?
    /// Create or delete branch.
    state: ("present"|"absent")?
}

/// Task class for gitlab_branch
class GitlabBranchTask extends Playbook.Task {
    /// todo doc
    `community.general.gitlab_branch`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.gitlab_branch"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.gitlab_branch`
}

/// TaskBuilder class for gitlab_branch
class GitlabBranch extends Playbook.TaskBuilder {
    /// Options for community.general.gitlab_branch
    options: GitlabBranchOptions?
    /// todo doc
    function Task(): GitlabBranchTask = this
        .toMap()
        .put("community.general.gitlab_branch", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GitlabBranchTask)
}

/// Manages GitLab project deploy keys
/// Adds, updates and removes project deploy keys
class GitlabDeployKeyOptions {
    /// Whether this key can push to the project.
    can_push: Boolean?
    /// Deploy key
    key: String
    /// Id or Full path of project in the form of group/name.
    project: String
    /// When V(present) the deploy key added to the project if it doesn't exist.
    /// When V(absent) it will be removed from the project if it exists.
    state: ("present"|"absent")?
    /// Deploy key's title.
    title: String
}

/// Task class for gitlab_deploy_key
class GitlabDeployKeyTask extends Playbook.Task {
    /// todo doc
    `community.general.gitlab_deploy_key`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.gitlab_deploy_key"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.gitlab_deploy_key`
}

/// TaskBuilder class for gitlab_deploy_key
class GitlabDeployKey extends Playbook.TaskBuilder {
    /// Options for community.general.gitlab_deploy_key
    options: GitlabDeployKeyOptions?
    /// todo doc
    function Task(): GitlabDeployKeyTask = this
        .toMap()
        .put("community.general.gitlab_deploy_key", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GitlabDeployKeyTask)
}

/// Creates/updates/deletes GitLab Groups
/// When the group does not exist in GitLab, it will be created.
/// When the group does exist and state=absent, the group will be deleted.
class GitlabGroupOptions {
    /// Default to Auto DevOps pipeline for all projects within this group.
    auto_devops_enabled: Boolean?
    /// Absolute path image to configure avatar. File size should not exceed 200 kb.
    /// This option is only used on creation, not for updates.
    avatar_path: String?
    /// A description for the group.
    description: String?
    /// Force delete group even if projects in it.
    /// Used only when O(state=absent).
    force_delete: Boolean?
    /// Name of the group you want to create.
    name: String
    /// Allow to create subgroups
    /// Id or Full path of parent group in the form of group/name
    parent: String?
    /// The path of the group you want to create, this will be api_url/group_path
    /// If not supplied, the group_name will be used.
    path: String?
    /// Determine if developers can create projects in the group.
    project_creation_level: ("developer"|"maintainer"|"noone")?
    /// Require all users in this group to setup two-factor authentication.
    require_two_factor_authentication: Boolean?
    /// create or delete group.
    /// Possible values are present and absent.
    state: ("present"|"absent")?
    /// Allowed to create subgroups.
    subgroup_creation_level: ("maintainer"|"owner")?
    /// Default visibility of the group
    visibility: ("private"|"internal"|"public")?
}

/// Task class for gitlab_group
class GitlabGroupTask extends Playbook.Task {
    /// todo doc
    `community.general.gitlab_group`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.gitlab_group"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.gitlab_group`
}

/// TaskBuilder class for gitlab_group
class GitlabGroup extends Playbook.TaskBuilder {
    /// Options for community.general.gitlab_group
    options: GitlabGroupOptions?
    /// todo doc
    function Task(): GitlabGroupTask = this
        .toMap()
        .put("community.general.gitlab_group", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GitlabGroupTask)
}

/// Manages GitLab group access tokens
/// Creates and revokes group access tokens.
class GitlabGroupAccessTokenOptions {
    /// Access level of the access token.
    access_level: ("guest"|"reporter"|"developer"|"maintainer"|"owner")?
    /// Expiration date of the access token in C(YYYY-MM-DD) format.
    /// Make sure to quote this value in YAML to ensure it is kept as a string and not interpreted as a YAML date.
    expires_at: String
    /// ID or full path of group in the form of group/subgroup.
    group: String
    /// Access token's name.
    name: String
    /// Whether the access token will be recreated if it already exists.
    /// When V(never) the token will never be recreated.
    /// When V(always) the token will always be recreated.
    /// When V(state_change) the token will be recreated if there is a difference between desired state and actual state.
    recreate: ("never"|"always"|"state_change")?
    /// Scope of the access token.
    scopes: Listing<("api"|"read_api"|"read_registry"|"write_registry"|"read_repository"|"write_repository"|"create_runner"|"ai_features"|"k8s_proxy")>
    /// When V(present) the access token will be added to the group if it does not exist.
    /// When V(absent) it will be removed from the group if it exists.
    state: ("present"|"absent")?
}

/// Task class for gitlab_group_access_token
class GitlabGroupAccessTokenTask extends Playbook.Task {
    /// todo doc
    `community.general.gitlab_group_access_token`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.gitlab_group_access_token"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.gitlab_group_access_token`
}

/// TaskBuilder class for gitlab_group_access_token
class GitlabGroupAccessToken extends Playbook.TaskBuilder {
    /// Options for community.general.gitlab_group_access_token
    options: GitlabGroupAccessTokenOptions?
    /// todo doc
    function Task(): GitlabGroupAccessTokenTask = this
        .toMap()
        .put("community.general.gitlab_group_access_token", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GitlabGroupAccessTokenTask)
}

/// Manage group members on GitLab Server
/// This module allows to add and remove members to/from a group, or change a member's access level in a group on GitLab.
class GitlabGroupMembersOptions {
    /// The access level for the user.
    /// Required if O(state=present), user state is set to present.
    /// Mutually exclusive with O(gitlab_users_access).
    access_level: ("guest"|"reporter"|"developer"|"maintainer"|"owner")?
    /// The C(full_path) of the GitLab group the member is added to/removed from.
    /// Setting this to C(name) or C(path) has been disallowed since community.general 6.0.0. Use C(full_path) instead.
    gitlab_group: String
    /// A username or a list of usernames to add to/remove from the GitLab group.
    /// Mutually exclusive with O(gitlab_users_access).
    gitlab_user: Listing<String>?
    /// Provide a list of user to access level mappings.
    /// Every dictionary in this list specifies a user (by username) and the access level the user should have.
    /// Mutually exclusive with O(gitlab_user) and O(access_level).
    /// Use together with O(purge_users) to remove all users not specified here from the group.
    gitlab_users_access: Listing<Any>?
    /// Adds/remove users of the given access_level to match the given O(gitlab_user)/O(gitlab_users_access) list. If omitted do not purge orphaned members.
    /// Is only used when O(state=present).
    purge_users: Listing<("guest"|"reporter"|"developer"|"maintainer"|"owner")>?
    /// State of the member in the group.
    /// On V(present), it adds a user to a GitLab group.
    /// On V(absent), it removes a user from a GitLab group.
    state: ("present"|"absent")?
}

/// Task class for gitlab_group_members
class GitlabGroupMembersTask extends Playbook.Task {
    /// todo doc
    `community.general.gitlab_group_members`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.gitlab_group_members"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.gitlab_group_members`
}

/// TaskBuilder class for gitlab_group_members
class GitlabGroupMembers extends Playbook.TaskBuilder {
    /// Options for community.general.gitlab_group_members
    options: GitlabGroupMembersOptions?
    /// todo doc
    function Task(): GitlabGroupMembersTask = this
        .toMap()
        .put("community.general.gitlab_group_members", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GitlabGroupMembersTask)
}

/// Creates, updates, or deletes GitLab groups variables
/// Creates a group variable if it does not exist.
/// When a group variable does exist, its value will be updated when the values are different.
/// Variables which are untouched in the playbook, but are not untouched in the GitLab group, they stay untouched (O(purge=false)) or will be deleted (O(purge=true)).
class GitlabGroupVariableOptions {
    /// The path and name of the group.
    group: String
    /// When set to V(true), delete all variables which are not untouched in the task.
    purge: Boolean?
    /// Create or delete group variable.
    state: ("present"|"absent")?
    /// A list of dictionaries that represents CI/CD variables.
    /// This modules works internal with this structure, even if the older O(vars) parameter is used.
    variables: Listing<Any>?
    /// When the list element is a simple key-value pair, masked, raw and protected will be set to false.
    /// When the list element is a dict with the keys C(value), C(masked), C(raw) and C(protected), the user can have full control about whether a value should be masked, raw, protected or both.
    /// Support for group variables requires GitLab >= 9.5.
    /// Support for environment_scope requires GitLab Premium >= 13.11.
    /// Support for protected values requires GitLab >= 9.3.
    /// Support for masked values requires GitLab >= 11.10.
    /// Support for raw values requires GitLab >= 15.7.
    /// A C(value) must be a string or a number.
    /// Field C(variable_type) must be a string with either V(env_var), which is the default, or V(file).
    /// When a value is masked, it must be in Base64 and have a length of at least 8 characters. See GitLab documentation on acceptable values for a masked variable (U(https://docs.gitlab.com/ce/ci/variables/#masked-variables)).
    vars: Any?
}

/// Task class for gitlab_group_variable
class GitlabGroupVariableTask extends Playbook.Task {
    /// todo doc
    `community.general.gitlab_group_variable`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.gitlab_group_variable"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.gitlab_group_variable`
}

/// TaskBuilder class for gitlab_group_variable
class GitlabGroupVariable extends Playbook.TaskBuilder {
    /// Options for community.general.gitlab_group_variable
    options: GitlabGroupVariableOptions?
    /// todo doc
    function Task(): GitlabGroupVariableTask = this
        .toMap()
        .put("community.general.gitlab_group_variable", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GitlabGroupVariableTask)
}

/// Manages GitLab project hooks
/// Adds, updates and removes project hook
class GitlabHookOptions {
    /// The url that you want GitLab to post to, this is used as the primary key for updates and deletion.
    hook_url: String
    /// Whether GitLab will do SSL verification when triggering the hook.
    hook_validate_certs: Boolean?
    /// Trigger hook on issues events.
    issues_events: Boolean?
    /// Trigger hook on job events.
    job_events: Boolean?
    /// Trigger hook on merge requests events.
    merge_requests_events: Boolean?
    /// Trigger hook on note events or when someone adds a comment.
    note_events: Boolean?
    /// Trigger hook on pipeline events.
    pipeline_events: Boolean?
    /// Id or Full path of the project in the form of group/name.
    project: String
    /// Trigger hook on push events.
    push_events: Boolean?
    /// Branch name of wildcard to trigger hook on push events
    push_events_branch_filter: String?
    /// Trigger hook on release events.
    releases_events: Boolean?
    /// When V(present) the hook will be updated to match the input or created if it doesn't exist.
    /// When V(absent) hook will be deleted if it exists.
    state: ("present"|"absent")?
    /// Trigger hook on tag push events.
    tag_push_events: Boolean?
    /// Secret token to validate hook messages at the receiver.
    /// If this is present it will always result in a change as it cannot be retrieved from GitLab.
    /// Will show up in the X-GitLab-Token HTTP request header.
    token: String?
    /// Trigger hook on wiki events.
    wiki_page_events: Boolean?
}

/// Task class for gitlab_hook
class GitlabHookTask extends Playbook.Task {
    /// todo doc
    `community.general.gitlab_hook`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.gitlab_hook"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.gitlab_hook`
}

/// TaskBuilder class for gitlab_hook
class GitlabHook extends Playbook.TaskBuilder {
    /// Options for community.general.gitlab_hook
    options: GitlabHookOptions?
    /// todo doc
    function Task(): GitlabHookTask = this
        .toMap()
        .put("community.general.gitlab_hook", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GitlabHookTask)
}

/// Creates, updates, or deletes GitLab instance variables
/// Creates a instance variable if it does not exist.
/// When a instance variable does exist, its value will be updated if the values are different.
/// Support for instance variables requires GitLab >= 13.0.
/// Variables which are not mentioned in the modules options, but are present on the GitLab instance, will either stay (O(purge=false)) or will be deleted (O(purge=true)).
class GitlabInstanceVariableOptions {
    /// When set to V(true), delete all variables which are not mentioned in the task.
    purge: Boolean?
    /// Create or delete instance variable.
    state: ("present"|"absent")?
    /// A list of dictionaries that represents CI/CD variables.
    variables: Listing<Any>?
}

/// Task class for gitlab_instance_variable
class GitlabInstanceVariableTask extends Playbook.Task {
    /// todo doc
    `community.general.gitlab_instance_variable`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.gitlab_instance_variable"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.gitlab_instance_variable`
}

/// TaskBuilder class for gitlab_instance_variable
class GitlabInstanceVariable extends Playbook.TaskBuilder {
    /// Options for community.general.gitlab_instance_variable
    options: GitlabInstanceVariableOptions?
    /// todo doc
    function Task(): GitlabInstanceVariableTask = this
        .toMap()
        .put("community.general.gitlab_instance_variable", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GitlabInstanceVariableTask)
}

/// Create, update, or delete GitLab issues
/// Creates an issue if it does not exist.
/// When an issue does exist, it will be updated if the provided parameters are different.
/// When an issue does exist and O(state=absent), the issue will be deleted.
/// When multiple issues are detected, the task fails.
/// Existing issues are matched based on O(title) and O(state_filter) filters.
class GitlabIssueOptions {
    /// A list of assignee usernames omitting V(@) character.
    /// Set to an empty array to unassign all assignees.
    assignee_ids: Listing<String>?
    /// A description of the issue.
    /// Gets overridden by a content of file specified at O(description_path), if found.
    description: String?
    /// A path of file containing issue's description.
    /// Accepts MarkDown formatted files.
    description_path: String?
    /// Type of the issue.
    issue_type: ("issue"|"incident"|"test_case")?
    /// A list of label names.
    /// Set to an empty array to remove all labels.
    labels: Listing<String>?
    /// The path or numeric ID of the group hosting desired milestone.
    milestone_group_id: String?
    /// The name of the milestone.
    /// Set to empty string to unassign milestone.
    milestone_search: String?
    /// The path or name of the project.
    project: String
    /// Create or delete issue.
    state: ("present"|"absent")?
    /// Filter specifying state of issues while searching.
    state_filter: ("opened"|"closed")?
    /// A title for the issue. The title is used as a unique identifier to ensure idempotency.
    title: String
}

/// Task class for gitlab_issue
class GitlabIssueTask extends Playbook.Task {
    /// todo doc
    `community.general.gitlab_issue`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.gitlab_issue"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.gitlab_issue`
}

/// TaskBuilder class for gitlab_issue
class GitlabIssue extends Playbook.TaskBuilder {
    /// Options for community.general.gitlab_issue
    options: GitlabIssueOptions?
    /// todo doc
    function Task(): GitlabIssueTask = this
        .toMap()
        .put("community.general.gitlab_issue", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GitlabIssueTask)
}

/// Creates/updates/deletes GitLab Labels belonging to project or group.
/// When a label does not exist, it will be created.
/// When a label does exist, its value will be updated when the values are different.
/// Labels can be purged.
class GitlabLabelOptions {
    /// The path of the group.  Either this or O(project) is required.
    group: String?
    /// A list of dictionaries that represents gitlab project's or group's labels.
    labels: Listing<Any>?
    /// The path and name of the project.  Either this or O(group) is required.
    project: String?
    /// When set to V(true), delete all labels which are not mentioned in the task.
    purge: Boolean?
    /// Create or delete project or group label.
    state: ("present"|"absent")?
}

/// Task class for gitlab_label
class GitlabLabelTask extends Playbook.Task {
    /// todo doc
    `community.general.gitlab_label`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.gitlab_label"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.gitlab_label`
}

/// TaskBuilder class for gitlab_label
class GitlabLabel extends Playbook.TaskBuilder {
    /// Options for community.general.gitlab_label
    options: GitlabLabelOptions?
    /// todo doc
    function Task(): GitlabLabelTask = this
        .toMap()
        .put("community.general.gitlab_label", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GitlabLabelTask)
}

/// Create, update, or delete GitLab merge requests
/// Creates a merge request if it does not exist.
/// When a single merge request does exist, it will be updated if the provided parameters are different.
/// When a single merge request does exist and O(state=absent), the merge request will be deleted.
/// When multiple merge requests are detected, the task fails.
/// Existing merge requests are matched based on O(title), O(source_branch), O(target_branch), and O(state_filter) filters.
class GitlabMergeRequestOptions {
    /// Comma separated list of assignees usernames omitting V(@) character.
    /// Set to empty string to unassign all assignees.
    assignee_ids: String?
    /// A description for the merge request.
    /// Gets overridden by a content of file specified at O(description_path), if found.
    description: String?
    /// A path of file containing merge request's description.
    /// Accepts MarkDown formatted files.
    description_path: String?
    /// Comma separated list of label names.
    labels: String?
    /// The path or name of the project.
    project: String
    /// Flag indicating if a merge request should remove the source branch when merging.
    remove_source_branch: Boolean?
    /// Comma separated list of reviewers usernames omitting V(@) character.
    /// Set to empty string to unassign all reviewers.
    reviewer_ids: String?
    /// Merge request's source branch.
    /// Ignored while updating existing merge request.
    source_branch: String
    /// Create or delete merge request.
    state: ("present"|"absent")?
    /// Filter specifying state of merge requests while searching.
    state_filter: ("opened"|"closed"|"locked"|"merged")?
    /// Merge request's target branch.
    target_branch: String
    /// A title for the merge request.
    title: String
}

/// Task class for gitlab_merge_request
class GitlabMergeRequestTask extends Playbook.Task {
    /// todo doc
    `community.general.gitlab_merge_request`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.gitlab_merge_request"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.gitlab_merge_request`
}

/// TaskBuilder class for gitlab_merge_request
class GitlabMergeRequest extends Playbook.TaskBuilder {
    /// Options for community.general.gitlab_merge_request
    options: GitlabMergeRequestOptions?
    /// todo doc
    function Task(): GitlabMergeRequestTask = this
        .toMap()
        .put("community.general.gitlab_merge_request", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GitlabMergeRequestTask)
}

/// Creates/updates/deletes GitLab Milestones belonging to project or group
/// When a milestone does not exist, it will be created.
/// When a milestone does exist, its value will be updated when the values are different.
/// Milestones can be purged.
class GitlabMilestoneOptions {
    /// The path of the group. Either this or O(project) is required.
    group: String?
    /// A list of dictionaries that represents gitlab project's or group's milestones.
    milestones: Listing<Any>?
    /// The path and name of the project. Either this or O(group) is required.
    project: String?
    /// When set to V(true), delete all milestone which are not mentioned in the task.
    purge: Boolean?
    /// Create or delete milestone.
    state: ("present"|"absent")?
}

/// Task class for gitlab_milestone
class GitlabMilestoneTask extends Playbook.Task {
    /// todo doc
    `community.general.gitlab_milestone`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.gitlab_milestone"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.gitlab_milestone`
}

/// TaskBuilder class for gitlab_milestone
class GitlabMilestone extends Playbook.TaskBuilder {
    /// Options for community.general.gitlab_milestone
    options: GitlabMilestoneOptions?
    /// todo doc
    function Task(): GitlabMilestoneTask = this
        .toMap()
        .put("community.general.gitlab_milestone", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GitlabMilestoneTask)
}

/// Creates/updates/deletes GitLab Projects
/// When the project does not exist in GitLab, it will be created.
/// When the project does exists and O(state=absent), the project will be deleted.
/// When changes are made to the project, the project will be updated.
class GitlabProjectOptions {
    /// Allow merge when skipped pipelines exist.
    allow_merge_on_skipped_pipeline: Boolean?
    /// Absolute path image to configure avatar. File size should not exceed 200 kb.
    /// This option is only used on creation, not for updates.
    avatar_path: String?
    /// V(private) means that repository CI/CD is allowed only to project members.
    /// V(disabled) means that repository CI/CD is disabled.
    /// V(enabled) means that repository CI/CD is enabled.
    builds_access_level: ("private"|"disabled"|"enabled")?
    /// Custom path to the CI configuration file for this project.
    ci_config_path: String?
    /// V(private) means that container registry is allowed only to project members.
    /// V(disabled) means that container registry is disabled.
    /// V(enabled) means that container registry is enabled.
    container_registry_access_level: ("private"|"disabled"|"enabled")?
    /// The default branch name for this project.
    /// For project creation, this option requires O(initialize_with_readme=true).
    /// For project update, the branch must exist.
    /// Supports project's default branch update since community.general 8.0.0.
    default_branch: String?
    /// An description for the project.
    description: String?
    /// V(private) means that deployment to environment is allowed only to project members.
    /// V(disabled) means that deployment to environment is disabled.
    /// V(enabled) means that deployment to environment is enabled.
    environments_access_level: ("private"|"disabled"|"enabled")?
    /// V(private) means that feature rollout is allowed only to project members.
    /// V(disabled) means that feature rollout is disabled.
    /// V(enabled) means that feature rollout is enabled.
    feature_flags_access_level: ("private"|"disabled"|"enabled")?
    /// V(private) means that repository forks is allowed only to project members.
    /// V(disabled) means that repository forks are disabled.
    /// V(enabled) means that repository forks are enabled.
    forking_access_level: ("private"|"disabled"|"enabled")?
    /// Id or the full path of the group of which this projects belongs to.
    group: String?
    /// Git repository which will be imported into gitlab.
    /// GitLab server needs read access to this git repository.
    import_url: String?
    /// V(private) means that configuring infrastructure is allowed only to project members.
    /// V(disabled) means that configuring infrastructure is disabled.
    /// V(enabled) means that configuring infrastructure is enabled.
    infrastructure_access_level: ("private"|"disabled"|"enabled")?
    /// Will initialize the project with a default C(README.md).
    /// Is only used when the project is created, and ignored otherwise.
    initialize_with_readme: Boolean?
    /// Whether you want to create issues or not.
    /// Possible values are true and false.
    issues_enabled: Boolean?
    /// Enable Git large file systems to manages large files such as audio, video, and graphics files.
    lfs_enabled: Boolean?
    /// What requirements are placed upon merges.
    /// Possible values are V(merge), V(rebase_merge) merge commit with semi-linear history, V(ff) fast-forward merges only.
    merge_method: ("ff"|"merge"|"rebase_merge")?
    /// If merge requests can be made or not.
    /// Possible values are true and false.
    merge_requests_enabled: Boolean?
    /// V(private) means that monitoring health is allowed only to project members.
    /// V(disabled) means that monitoring health is disabled.
    /// V(enabled) means that monitoring health is enabled.
    monitor_access_level: ("private"|"disabled"|"enabled")?
    /// The name of the project.
    name: String
    /// All discussions on a merge request (MR) have to be resolved.
    only_allow_merge_if_all_discussions_are_resolved: Boolean?
    /// Only allow merges if pipeline succeeded.
    only_allow_merge_if_pipeline_succeeds: Boolean?
    /// Enable GitLab package repository.
    packages_enabled: Boolean?
    /// The path of the project you want to create, this will be server_url/<group>/path.
    /// If not supplied, name will be used.
    path: String?
    /// V(private) means that accessing release is allowed only to project members.
    /// V(disabled) means that accessing release is disabled.
    /// V(enabled) means that accessing release is enabled.
    releases_access_level: ("private"|"disabled"|"enabled")?
    /// Remove the source branch after merge.
    remove_source_branch_after_merge: Boolean?
    /// V(private) means that accessing security and complicance tab is allowed only to project members.
    /// V(disabled) means that accessing security and complicance tab is disabled.
    /// V(enabled) means that accessing security and complicance tab is enabled.
    security_and_compliance_access_level: ("private"|"disabled"|"enabled")?
    /// Enable shared runners for this project.
    shared_runners_enabled: Boolean?
    /// If creating snippets should be available or not.
    snippets_enabled: Boolean?
    /// Squash commits when merging.
    squash_option: ("never"|"always"|"default_off"|"default_on")?
    /// Create or delete project.
    /// Possible values are present and absent.
    state: ("present"|"absent")?
    /// A topic or list of topics to be assigned to a project.
    /// It is compatible with old GitLab server releases (versions before 14, correspond to C(tag_list)).
    topics: Listing<String>?
    /// Used to create a personal project under a user's name.
    username: String?
    /// V(private) Project access must be granted explicitly for each user.
    /// V(internal) The project can be cloned by any logged in user.
    /// V(public) The project can be cloned without any authentication.
    visibility: ("private"|"internal"|"public")?
    /// If an wiki for this project should be available or not.
    wiki_enabled: Boolean?
}

/// Task class for gitlab_project
class GitlabProjectTask extends Playbook.Task {
    /// todo doc
    `community.general.gitlab_project`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.gitlab_project"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.gitlab_project`
}

/// TaskBuilder class for gitlab_project
class GitlabProject extends Playbook.TaskBuilder {
    /// Options for community.general.gitlab_project
    options: GitlabProjectOptions?
    /// todo doc
    function Task(): GitlabProjectTask = this
        .toMap()
        .put("community.general.gitlab_project", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GitlabProjectTask)
}

/// Manages GitLab project access tokens
/// Creates and revokes project access tokens.
class GitlabProjectAccessTokenOptions {
    /// Access level of the access token.
    access_level: ("guest"|"reporter"|"developer"|"maintainer"|"owner")?
    /// Expiration date of the access token in C(YYYY-MM-DD) format.
    /// Make sure to quote this value in YAML to ensure it is kept as a string and not interpreted as a YAML date.
    expires_at: String
    /// Access token's name.
    name: String
    /// ID or full path of project in the form of group/name.
    project: String
    /// Whether the access token will be recreated if it already exists.
    /// When V(never) the token will never be recreated.
    /// When V(always) the token will always be recreated.
    /// When V(state_change) the token will be recreated if there is a difference between desired state and actual state.
    recreate: ("never"|"always"|"state_change")?
    /// Scope of the access token.
    scopes: Listing<("api"|"read_api"|"read_registry"|"write_registry"|"read_repository"|"write_repository"|"create_runner"|"ai_features"|"k8s_proxy")>
    /// When V(present) the access token will be added to the project if it does not exist.
    /// When V(absent) it will be removed from the project if it exists.
    state: ("present"|"absent")?
}

/// Task class for gitlab_project_access_token
class GitlabProjectAccessTokenTask extends Playbook.Task {
    /// todo doc
    `community.general.gitlab_project_access_token`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.gitlab_project_access_token"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.gitlab_project_access_token`
}

/// TaskBuilder class for gitlab_project_access_token
class GitlabProjectAccessToken extends Playbook.TaskBuilder {
    /// Options for community.general.gitlab_project_access_token
    options: GitlabProjectAccessTokenOptions?
    /// todo doc
    function Task(): GitlabProjectAccessTokenTask = this
        .toMap()
        .put("community.general.gitlab_project_access_token", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GitlabProjectAccessTokenTask)
}

/// Manage project badges on GitLab Server
/// This module allows to add and remove badges to/from a project.
class GitlabProjectBadgeOptions {
    /// The image URL of the badge.
    /// A badge is identified by this URL.
    image_url: String
    /// The URL associated with the badge.
    link_url: String
    /// The name (or full path) of the GitLab project the badge is added to/removed from.
    project: String
    /// State of the badge in the project.
    /// On V(present), it adds a badge to a GitLab project.
    /// On V(absent), it removes a badge from a GitLab project.
    state: ("present"|"absent")?
}

/// Task class for gitlab_project_badge
class GitlabProjectBadgeTask extends Playbook.Task {
    /// todo doc
    `community.general.gitlab_project_badge`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.gitlab_project_badge"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.gitlab_project_badge`
}

/// TaskBuilder class for gitlab_project_badge
class GitlabProjectBadge extends Playbook.TaskBuilder {
    /// Options for community.general.gitlab_project_badge
    options: GitlabProjectBadgeOptions?
    /// todo doc
    function Task(): GitlabProjectBadgeTask = this
        .toMap()
        .put("community.general.gitlab_project_badge", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GitlabProjectBadgeTask)
}

/// Manage project members on GitLab Server
/// This module allows to add and remove members to/from a project, or change a member's access level in a project on GitLab.
class GitlabProjectMembersOptions {
    /// The access level for the user.
    /// Required if O(state=present), user state is set to present.
    access_level: ("guest"|"reporter"|"developer"|"maintainer")?
    /// A username or a list of usernames to add to/remove from the GitLab project.
    /// Mutually exclusive with O(gitlab_users_access).
    gitlab_user: Listing<String>?
    /// Provide a list of user to access level mappings.
    /// Every dictionary in this list specifies a user (by username) and the access level the user should have.
    /// Mutually exclusive with O(gitlab_user) and O(access_level).
    /// Use together with O(purge_users) to remove all users not specified here from the project.
    gitlab_users_access: Listing<Any>?
    /// The name (or full path) of the GitLab project the member is added to/removed from.
    project: String
    /// Adds/remove users of the given access_level to match the given O(gitlab_user)/O(gitlab_users_access) list. If omitted do not purge orphaned members.
    /// Is only used when O(state=present).
    purge_users: Listing<("guest"|"reporter"|"developer"|"maintainer")>?
    /// State of the member in the project.
    /// On V(present), it adds a user to a GitLab project.
    /// On V(absent), it removes a user from a GitLab project.
    state: ("present"|"absent")?
}

/// Task class for gitlab_project_members
class GitlabProjectMembersTask extends Playbook.Task {
    /// todo doc
    `community.general.gitlab_project_members`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.gitlab_project_members"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.gitlab_project_members`
}

/// TaskBuilder class for gitlab_project_members
class GitlabProjectMembers extends Playbook.TaskBuilder {
    /// Options for community.general.gitlab_project_members
    options: GitlabProjectMembersOptions?
    /// todo doc
    function Task(): GitlabProjectMembersTask = this
        .toMap()
        .put("community.general.gitlab_project_members", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GitlabProjectMembersTask)
}

/// Creates/updates/deletes GitLab Projects Variables
/// When a project variable does not exist, it will be created.
/// When a project variable does exist, its value will be updated when the values are different.
/// Variables which are untouched in the playbook, but are not untouched in the GitLab project, they stay untouched (O(purge=false)) or will be deleted (O(purge=true)).
class GitlabProjectVariableOptions {
    /// The path and name of the project.
    project: String
    /// When set to true, all variables which are not untouched in the task will be deleted.
    purge: Boolean?
    /// Create or delete project variable.
    /// Possible values are present and absent.
    state: ("present"|"absent")?
    /// A list of dictionaries that represents CI/CD variables.
    /// This module works internal with this structure, even if the older O(vars) parameter is used.
    variables: Listing<Any>?
    /// When the list element is a simple key-value pair, masked, raw and protected will be set to false.
    /// When the list element is a dict with the keys C(value), C(masked), C(raw) and C(protected), the user can have full control about whether a value should be masked, raw, protected or both.
    /// Support for protected values requires GitLab >= 9.3.
    /// Support for masked values requires GitLab >= 11.10.
    /// Support for raw values requires GitLab >= 15.7.
    /// Support for environment_scope requires GitLab Premium >= 13.11.
    /// Support for variable_type requires GitLab >= 11.11.
    /// A C(value) must be a string or a number.
    /// Field C(variable_type) must be a string with either V(env_var), which is the default, or V(file).
    /// Field C(environment_scope) must be a string defined by scope environment.
    /// When a value is masked, it must be in Base64 and have a length of at least 8 characters. See GitLab documentation on acceptable values for a masked variable (https://docs.gitlab.com/ce/ci/variables/#masked-variables).
    vars: Any?
}

/// Task class for gitlab_project_variable
class GitlabProjectVariableTask extends Playbook.Task {
    /// todo doc
    `community.general.gitlab_project_variable`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.gitlab_project_variable"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.gitlab_project_variable`
}

/// TaskBuilder class for gitlab_project_variable
class GitlabProjectVariable extends Playbook.TaskBuilder {
    /// Options for community.general.gitlab_project_variable
    options: GitlabProjectVariableOptions?
    /// todo doc
    function Task(): GitlabProjectVariableTask = this
        .toMap()
        .put("community.general.gitlab_project_variable", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GitlabProjectVariableTask)
}

/// Manage protection of existing branches
/// (un)Marking existing branches for protection.
class GitlabProtectedBranchOptions {
    /// Access levels allowed to merge.
    merge_access_levels: ("maintainer"|"developer"|"nobody")?
    /// The name of the branch that needs to be protected.
    /// Can make use a wildcard character for like V(production/*) or just have V(main) or V(develop) as value.
    name: String
    /// The path and name of the project.
    project: String
    /// Access levels allowed to push.
    push_access_level: ("maintainer"|"developer"|"nobody")?
    /// Create or delete protected branch.
    state: ("present"|"absent")?
}

/// Task class for gitlab_protected_branch
class GitlabProtectedBranchTask extends Playbook.Task {
    /// todo doc
    `community.general.gitlab_protected_branch`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.gitlab_protected_branch"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.gitlab_protected_branch`
}

/// TaskBuilder class for gitlab_protected_branch
class GitlabProtectedBranch extends Playbook.TaskBuilder {
    /// Options for community.general.gitlab_protected_branch
    options: GitlabProtectedBranchOptions?
    /// todo doc
    function Task(): GitlabProtectedBranchTask = this
        .toMap()
        .put("community.general.gitlab_protected_branch", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GitlabProtectedBranchTask)
}

/// Create, modify and delete GitLab Runners
/// Register, update and delete runners with the GitLab API.
/// All operations are performed using the GitLab API v4.
/// For details, consult the full API documentation at U(https://docs.gitlab.com/ee/api/runners.html).
/// A valid private API token is required for all operations. You can create as many tokens as you like using the GitLab web interface at U(https://$GITLAB_URL/profile/personal_access_tokens).
/// A valid registration token is required for registering a new runner. To create shared runners, you need to ask your administrator to give you this token. It can be found at U(https://$GITLAB_URL/admin/runners/).
class GitlabRunnerOptions {
    /// Determines if a runner can pick up jobs only from protected branches.
    /// If O(access_level_on_creation) is not explicitly set to V(true), this option is ignored on registration and is only applied on updates.
    /// If set to V(not_protected), runner can pick up jobs from both protected and unprotected branches.
    /// If set to V(ref_protected), runner can pick up jobs only from protected branches.
    /// Before community.general 8.0.0 the default was V(ref_protected). This was changed to no default in community.general 8.0.0. If this option is not specified explicitly, GitLab will use V(not_protected) on creation, and the value set will not be changed on any updates.
    access_level: ("not_protected"|"ref_protected")?
    /// Whether the runner should be registered with an access level or not.
    /// If set to V(true), the value of O(access_level) is used for runner registration.
    /// If set to V(false), GitLab registers the runner with the default access level.
    /// The default of this option changed to V(true) in community.general 7.0.0. Before, it was V(false).
    access_level_on_creation: Boolean?
    /// Define if the runners is immediately active after creation.
    /// Mutually exclusive with O(paused).
    active: Boolean?
    /// The unique name of the runner.
    description: String
    /// ID or full path of the group in the form group/subgroup.
    /// Mutually exclusive with O(owned) and O(project).
    /// Must be group's numeric ID if O(registration_token) is not set and O(state=present).
    group: String?
    /// Determines if the runner is locked or not.
    locked: Boolean?
    /// The maximum time that a runner has to complete a specific job.
    maximum_timeout: Int?
    /// Searches only runners available to the user when searching for existing, when false admin token required.
    /// Mutually exclusive with O(project) since community.general 4.5.0.
    /// Mutually exclusive with O(group).
    owned: Boolean?
    /// Define if the runners is active or paused after creation.
    /// Mutually exclusive with O(active).
    paused: Boolean?
    /// ID or full path of the project in the form of group/name.
    /// Mutually exclusive with O(owned) since community.general 4.5.0.
    /// Mutually exclusive with O(group).
    /// Must be project's numeric ID if O(registration_token) is not set and O(state=present).
    project: String?
    /// The registration token is used to register new runners before GitLab 16.0.
    /// Required if O(state=present) for GitLab < 16.0.
    /// If set, the runner will be created using the old runner creation workflow.
    /// If not set, the runner will be created using the new runner creation workflow, introduced in GitLab 16.0.
    /// If not set, requires python-gitlab >= 4.0.0.
    registration_token: String?
    /// Run untagged jobs or not.
    run_untagged: Boolean?
    /// Make sure that the runner with the same name exists with the same configuration or delete the runner with the same name.
    state: ("present"|"absent")?
    /// The tags that apply to the runner.
    tag_list: Listing<String>?
}

/// Task class for gitlab_runner
class GitlabRunnerTask extends Playbook.Task {
    /// todo doc
    `community.general.gitlab_runner`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.gitlab_runner"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.gitlab_runner`
}

/// TaskBuilder class for gitlab_runner
class GitlabRunner extends Playbook.TaskBuilder {
    /// Options for community.general.gitlab_runner
    options: GitlabRunnerOptions?
    /// todo doc
    function Task(): GitlabRunnerTask = this
        .toMap()
        .put("community.general.gitlab_runner", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GitlabRunnerTask)
}

/// Creates/updates/deletes/blocks/unblocks GitLab Users
/// When the user does not exist in GitLab, it will be created.
/// When the user exists and state=absent, the user will be deleted.
/// When the user exists and state=blocked, the user will be blocked.
/// When changes are made to user, the user will be updated.
class GitlabUserOptions {
    /// The access level to the group. One of the following can be used.
    /// guest
    /// reporter
    /// developer
    /// master (alias for maintainer)
    /// maintainer
    /// owner
    access_level: ("guest"|"reporter"|"developer"|"master"|"maintainer"|"owner")?
    /// Require confirmation.
    confirm: Boolean?
    /// The email that belongs to the user.
    /// Required only if O(state=present).
    email: String?
    /// Define external parameter for this user.
    `external`: Boolean?
    /// Id or Full path of parent group in the form of group/name.
    /// Add user as a member to this group.
    group: String?
    /// List of identities to be added/updated for this user.
    /// To remove all other identities from this user, set O(overwrite_identities=true).
    identities: Listing<Any>?
    /// Grant admin privileges to the user.
    isadmin: Boolean?
    /// Name of the user you want to create.
    /// Required only if O(state=present).
    name: String?
    /// Overwrite identities with identities added in this module.
    /// This means that all identities that the user has and that are not listed in O(identities) are removed from the user.
    /// This is only done if a list is provided for O(identities). To remove all identities, provide an empty list.
    overwrite_identities: Boolean?
    /// The password of the user.
    /// GitLab server enforces minimum password length to 8, set this value with 8 or more characters.
    password: String?
    /// Whether the user can change its password or not.
    reset_password: Boolean?
    /// The expiration date of the SSH public key in ISO 8601 format C(YYYY-MM-DDTHH:MM:SSZ).
    /// This is only used when adding new SSH public keys.
    sshkey_expires_at: String?
    /// The SSH public key itself.
    sshkey_file: String?
    /// The name of the SSH public key.
    sshkey_name: String?
    /// Create, delete or block a user.
    state: ("present"|"absent"|"blocked"|"unblocked")?
    /// The username of the user.
    username: String
}

/// Task class for gitlab_user
class GitlabUserTask extends Playbook.Task {
    /// todo doc
    `community.general.gitlab_user`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.gitlab_user"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.gitlab_user`
}

/// TaskBuilder class for gitlab_user
class GitlabUser extends Playbook.TaskBuilder {
    /// Options for community.general.gitlab_user
    options: GitlabUserOptions?
    /// todo doc
    function Task(): GitlabUserTask = this
        .toMap()
        .put("community.general.gitlab_user", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GitlabUserTask)
}

/// Sends a notification to a grove.io channel
/// The C(grove) module sends a message for a service to a Grove.io channel.
class GroveOptions {
    /// Token of the channel to post to.
    channel_token: String
    /// Icon for the service
    icon_url: String?
    /// Message content.
    /// The alias O(ignore:message) has been removed in community.general 4.0.0.
    message_content: String
    /// Name of the service (displayed as the "user" in the message)
    service: String?
    /// Service URL for the web client
    url: String?
    /// If V(false), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
    validate_certs: Boolean?
}

/// Task class for grove
class GroveTask extends Playbook.Task {
    /// todo doc
    `community.general.grove`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.grove"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.grove`
}

/// TaskBuilder class for grove
class Grove extends Playbook.TaskBuilder {
    /// Options for community.general.grove
    options: GroveOptions?
    /// todo doc
    function Task(): GroveTask = this
        .toMap()
        .put("community.general.grove", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GroveTask)
}

/// Run gunicorn with various settings
/// Starts gunicorn with the parameters specified. Common settings for gunicorn configuration are supported. For additional configuration use a config file See U(https://gunicorn-docs.readthedocs.io/en/latest/settings.html) for more options. It's recommended to always use the chdir option to avoid problems with the location of the app.
class GunicornOptions {
    /// The app module. A name refers to a WSGI callable that should be found in the specified module.
    app: String
    /// Chdir to specified directory before apps loading.
    chdir: String?
    /// Path to the gunicorn configuration file.
    config: String?
    /// A filename to use for the PID file. If not set and not found on the configuration file a tmp pid file will be created to check a successful run of gunicorn.
    pid: String?
    /// Switch worker processes to run as this user.
    user: String?
    /// Path to the virtualenv directory.
    venv: String?
    /// The type of workers to use. The default class (sync) should handle most "normal" types of workloads.
    worker: ("sync"|"eventlet"|"gevent"|"tornado "|"gthread"|"gaiohttp")?
}

/// Task class for gunicorn
class GunicornTask extends Playbook.Task {
    /// todo doc
    `community.general.gunicorn`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.gunicorn"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.gunicorn`
}

/// TaskBuilder class for gunicorn
class Gunicorn extends Playbook.TaskBuilder {
    /// Options for community.general.gunicorn
    options: GunicornOptions?
    /// todo doc
    function Task(): GunicornTask = this
        .toMap()
        .put("community.general.gunicorn", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(GunicornTask)
}

/// Enable, disable, and set weights for HAProxy backend servers using socket commands
/// Enable, disable, drain and set weights for HAProxy backend servers using socket commands.
class HaproxyOptions {
    /// Disable/enable agent checks (depending on O(state) value).
    agent: Boolean?
    /// Name of the HAProxy backend pool.
    /// If this parameter is unset, it will be auto-detected.
    backend: String?
    /// Wait until the server has no active connections or until the timeout determined by wait_interval and wait_retries is reached.
    /// Continue only after the status changes to C(MAINT).
    /// This overrides the shutdown_sessions option.
    drain: Boolean?
    /// Fail whenever trying to enable/disable a backend host that does not exist.
    fail_on_not_found: Boolean?
    /// Disable/enable health checks (depending on O(state) value).
    health: Boolean?
    /// Name of the backend host to change.
    host: String
    /// When disabling a server, immediately terminate all the sessions attached to the specified server.
    /// This can be used to terminate long-running sessions after a server is put into maintenance mode. Overridden by the drain option.
    shutdown_sessions: Boolean?
    /// Path to the HAProxy socket file.
    socket: String?
    /// Desired state of the provided backend host.
    /// Note that V(drain) state was added in version 2.4.
    /// It is supported only by HAProxy version 1.5 or later,
    /// When used on versions < 1.5, it will be ignored.
    state: ("disabled"|"drain"|"enabled")
    /// Wait until the server reports a status of C(UP) when O(state=enabled), status of C(MAINT) when O(state=disabled) or status of C(DRAIN) when O(state=drain).
    wait: Boolean?
    /// Number of seconds to wait between retries.
    wait_interval: Int?
    /// Number of times to check for status after changing the state.
    wait_retries: Int?
    /// The value passed in argument.
    /// If the value ends with the V(%) sign, then the new weight will be relative to the initially configured weight.
    /// Relative weights are only permitted between 0 and 100% and absolute weights are permitted between 0 and 256.
    weight: String?
}

/// Task class for haproxy
class HaproxyTask extends Playbook.Task {
    /// todo doc
    `community.general.haproxy`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.haproxy"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.haproxy`
}

/// TaskBuilder class for haproxy
class Haproxy extends Playbook.TaskBuilder {
    /// Options for community.general.haproxy
    options: HaproxyOptions?
    /// todo doc
    function Task(): HaproxyTask = this
        .toMap()
        .put("community.general.haproxy", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(HaproxyTask)
}

/// Add or delete app collaborators on Heroku
/// Manages collaborators for Heroku apps.
/// If set to V(present) and heroku user is already collaborator, then do nothing.
/// If set to V(present) and heroku user is not collaborator, then add user to app.
/// If set to V(absent) and heroku user is collaborator, then delete user from app.
class HerokuCollaboratorOptions {
    /// Heroku API key
    api_key: String?
    /// List of Heroku App names
    apps: Listing<String>
    /// Create or remove the heroku collaborator
    state: ("present"|"absent")?
    /// Suppress email invitation when creating collaborator
    suppress_invitation: Boolean?
    /// User ID or e-mail
    user: String
}

/// Task class for heroku_collaborator
class HerokuCollaboratorTask extends Playbook.Task {
    /// todo doc
    `community.general.heroku_collaborator`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.heroku_collaborator"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.heroku_collaborator`
}

/// TaskBuilder class for heroku_collaborator
class HerokuCollaborator extends Playbook.TaskBuilder {
    /// Options for community.general.heroku_collaborator
    options: HerokuCollaboratorOptions?
    /// todo doc
    function Task(): HerokuCollaboratorTask = this
        .toMap()
        .put("community.general.heroku_collaborator", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(HerokuCollaboratorTask)
}

/// Manages Mercurial (hg) repositories
/// Manages Mercurial (hg) repositories. Supports SSH, HTTP/S and local address.
class HgOptions {
    /// If V(false), do not clone the repository if it does not exist locally.
    clone: Boolean?
    /// Absolute path of where the repository should be cloned to. This parameter is required, unless clone and update are set to no
    dest: String?
    /// Path to hg executable to use. If not supplied, the normal mechanism for resolving binary paths will be used.
    executable: String?
    /// Discards uncommitted changes. Runs C(hg update -C).
    force: Boolean?
    /// Deletes untracked files. Runs C(hg purge).
    purge: Boolean?
    /// The repository address.
    repo: String
    /// Equivalent C(-r) option in hg command which could be the changeset, revision number, branch name or even tag.
    revision: String?
    /// If V(false), do not retrieve new revisions from the origin repository
    update: Boolean?
}

/// Task class for hg
class HgTask extends Playbook.Task {
    /// todo doc
    `community.general.hg`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.hg"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.hg`
}

/// TaskBuilder class for hg
class Hg extends Playbook.TaskBuilder {
    /// Options for community.general.hg
    options: HgOptions?
    /// todo doc
    function Task(): HgTask = this
        .toMap()
        .put("community.general.hg", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(HgTask)
}

/// Send a message to Hipchat
/// Send a message to a Hipchat room, with options to control the formatting.
class HipchatOptions {
    /// API url if using a self-hosted hipchat server. For Hipchat API version 2 use the default URI with C(/v2) instead of C(/v1).
    api: String?
    /// Background color for the message.
    color: ("yellow"|"red"|"green"|"purple"|"gray"|"random")?
    /// The message body.
    msg: String
    /// Message format.
    msg_format: ("text"|"html")?
    /// Name the message will appear to be sent from. Max length is 15 characters - above this it will be truncated.
    msg_from: String?
    /// If true, a notification will be triggered for users in the room.
    notify: Boolean?
    /// ID or name of the room.
    room: String
    /// API token.
    token: String
    /// If V(false), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
    validate_certs: Boolean?
}

/// Task class for hipchat
class HipchatTask extends Playbook.Task {
    /// todo doc
    `community.general.hipchat`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.hipchat"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.hipchat`
}

/// TaskBuilder class for hipchat
class Hipchat extends Playbook.TaskBuilder {
    /// Options for community.general.hipchat
    options: HipchatOptions?
    /// todo doc
    function Task(): HipchatTask = this
        .toMap()
        .put("community.general.hipchat", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(HipchatTask)
}

/// Package manager for Homebrew
/// Manages Homebrew packages
class HomebrewOptions {
    /// options flags to install a package.
    install_options: Listing<String>?
    /// A list of names of packages to install/remove.
    name: Listing<String>?
    /// A V(:) separated list of paths to search for C(brew) executable. Since a package (I(formula) in homebrew parlance) location is prefixed relative to the actual path of C(brew) command, providing an alternative C(brew) path enables managing different set of packages in an alternative location in the system.
    path: String?
    /// state of the package.
    state: ("absent"|"head"|"installed"|"latest"|"linked"|"present"|"removed"|"uninstalled"|"unlinked"|"upgraded")?
    /// update homebrew itself first.
    update_homebrew: Boolean?
    /// upgrade all homebrew packages.
    upgrade_all: Boolean?
    /// Option flags to upgrade.
    upgrade_options: Listing<String>?
}

/// Task class for homebrew
class HomebrewTask extends Playbook.Task {
    /// todo doc
    `community.general.homebrew`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.homebrew"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.homebrew`
}

/// TaskBuilder class for homebrew
class Homebrew extends Playbook.TaskBuilder {
    /// Options for community.general.homebrew
    options: HomebrewOptions?
    /// todo doc
    function Task(): HomebrewTask = this
        .toMap()
        .put("community.general.homebrew", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(HomebrewTask)
}

/// Install and uninstall homebrew casks
/// Manages Homebrew casks.
class HomebrewCaskOptions {
    /// Allow external apps.
    accept_external_apps: Boolean?
    /// Upgrade casks that auto update.
    /// Passes C(--greedy) to C(brew outdated --cask) when checking if an installed cask has a newer version available, or to C(brew upgrade --cask) when upgrading all casks.
    greedy: Boolean?
    /// Options flags to install a package.
    install_options: Listing<String>?
    /// Name of cask to install or remove.
    name: Listing<String>?
    /// ':' separated list of paths to search for 'brew' executable.
    path: String?
    /// State of the cask.
    state: ("absent"|"installed"|"latest"|"present"|"removed"|"uninstalled"|"upgraded")?
    /// The sudo password to be passed to SUDO_ASKPASS.
    sudo_password: String?
    /// Update homebrew itself first.
    /// Note that C(brew cask update) is a synonym for C(brew update).
    update_homebrew: Boolean?
    /// Upgrade all casks.
    /// Mutually exclusive with C(upgraded) state.
    upgrade_all: Boolean?
}

/// Task class for homebrew_cask
class HomebrewCaskTask extends Playbook.Task {
    /// todo doc
    `community.general.homebrew_cask`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.homebrew_cask"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.homebrew_cask`
}

/// TaskBuilder class for homebrew_cask
class HomebrewCask extends Playbook.TaskBuilder {
    /// Options for community.general.homebrew_cask
    options: HomebrewCaskOptions?
    /// todo doc
    function Task(): HomebrewCaskTask = this
        .toMap()
        .put("community.general.homebrew_cask", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(HomebrewCaskTask)
}

/// Tap a Homebrew repository
/// Tap external Homebrew repositories.
class HomebrewTapOptions {
    /// The GitHub user/organization repository to tap.
    name: Listing<String>
    /// A V(:) separated list of paths to search for C(brew) executable.
    path: String?
    /// state of the repository.
    state: ("present"|"absent")?
    /// The optional git URL of the repository to tap. The URL is not assumed to be on GitHub, and the protocol doesn't have to be HTTP. Any location and protocol that git can handle is fine.
    /// O(name) option may not be a list of multiple taps (but a single tap instead) when this option is provided.
    url: String?
}

/// Task class for homebrew_tap
class HomebrewTapTask extends Playbook.Task {
    /// todo doc
    `community.general.homebrew_tap`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.homebrew_tap"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.homebrew_tap`
}

/// TaskBuilder class for homebrew_tap
class HomebrewTap extends Playbook.TaskBuilder {
    /// Options for community.general.homebrew_tap
    options: HomebrewTapOptions?
    /// todo doc
    function Task(): HomebrewTapTask = this
        .toMap()
        .put("community.general.homebrew_tap", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(HomebrewTapTask)
}

/// Manage user accounts with systemd-homed
/// Manages a user's home directory managed by systemd-homed.
class HomectlOptions {
    /// The intended home directory disk space.
    /// Human readable value such as V(10G), V(10M), or V(10B).
    disksize: String?
    /// The email address of the user.
    email: String?
    /// String separated by comma each containing an environment variable and its value to set for the user's login session, in a format compatible with ``putenv()``.
    /// Any environment variable listed here is automatically set by pam_systemd for all login sessions of the user.
    environment: String?
    /// Sets the gid of the user.
    /// If using O(uid) homed requires the value to be the same.
    /// Only used when a user is first created.
    gid: Int?
    /// Path to use as home directory for the user.
    /// This is the directory the user's home directory is mounted to while the user is logged in.
    /// This is not where the user's data is actually stored, see O(imagepath) for that.
    /// Only used when a user is first created.
    homedir: String?
    /// The name of an icon picked by the user, for example for the purpose of an avatar.
    /// Should follow the semantics defined in the Icon Naming Specification.
    /// See U(https://specifications.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html) for specifics.
    iconname: String?
    /// Path to place the user's home directory.
    /// See U(https://www.freedesktop.org/software/systemd/man/homectl.html#--image-path=PATH) for more information.
    /// Only used when a user is first created.
    imagepath: String?
    /// The preferred language/locale for the user.
    /// This should be in a format compatible with the E(LANG) environment variable.
    language: String?
    /// A free-form location string describing the location of the user.
    location: String?
    /// Whether the user account should be locked or not.
    locked: Boolean?
    /// String separated by comma each indicating a UNIX group this user shall be a member of.
    /// Groups the user should be a member of should be supplied as comma separated list.
    memberof: String?
    /// String separated by comma each indicating mount options for a users home directory.
    /// Valid options are V(nosuid), V(nodev) or V(noexec).
    /// Homed by default uses V(nodev) and V(nosuid) while V(noexec) is off.
    mountopts: String?
    /// The user name to create, remove, or update.
    name: String
    /// A time since the UNIX epoch after which the record should be considered invalid for the purpose of logging in.
    notafter: Int?
    /// A time since the UNIX epoch before which the record should be considered invalid for the purpose of logging in.
    notbefore: Int?
    /// Set the user's password to this.
    /// Homed requires this value to be in cleartext on user creation and updating a user.
    /// The module takes the password and generates a password hash in SHA-512 with 10000 rounds of salt generation using crypt.
    /// See U(https://systemd.io/USER_RECORD/).
    /// This is required for O(state=present). When an existing user is updated this is checked against the stored hash in homed.
    password: String?
    /// Password hint for the given user.
    passwordhint: String?
    /// The 'realm' a user is defined in.
    realm: String?
    /// The user's real ('human') name.
    /// This can also be used to add a comment to maintain compatibility with C(useradd).
    realname: String?
    /// When used with O(disksize) this will attempt to resize the home directory immediately.
    resize: Boolean?
    /// Shell binary to use for terminal logins of given user.
    /// If not specified homed by default uses V(/bin/bash).
    shell: String?
    /// The absolute path to the skeleton directory to populate a new home directory from.
    /// This is only used when a home directory is first created.
    /// If not specified homed by default uses V(/etc/skel).
    skeleton: String?
    /// String separated by comma each listing a SSH public key that is authorized to access the account.
    /// The keys should follow the same format as the lines in a traditional C(~/.ssh/authorized_key) file.
    sshkeys: String?
    /// The operation to take on the user.
    state: ("absent"|"present")?
    /// Indicates the storage mechanism for the user's home directory.
    /// If the storage type is not specified, ``homed.conf(5)`` defines which default storage to use.
    /// Only used when a user is first created.
    storage: ("classic"|"luks"|"directory"|"subvolume"|"fscrypt"|"cifs")?
    /// Preferred timezone to use for the user.
    /// Should be a tzdata compatible location string such as V(America/New_York).
    timezone: String?
    /// Sets the UID of the user.
    /// If using O(gid) homed requires the value to be the same.
    /// Only used when a user is first created.
    uid: Int?
    /// Sets the umask for the user's login sessions
    /// Value from V(0000) to V(0777).
    umask: Int?
}

/// Task class for homectl
class HomectlTask extends Playbook.Task {
    /// todo doc
    `community.general.homectl`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.homectl"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.homectl`
}

/// TaskBuilder class for homectl
class Homectl extends Playbook.TaskBuilder {
    /// Options for community.general.homectl
    options: HomectlOptions?
    /// todo doc
    function Task(): HomectlTask = this
        .toMap()
        .put("community.general.homectl", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(HomectlTask)
}

/// Notify Honeybadger.io about app deployments
/// Notify Honeybadger.io about app deployments (see U(http://docs.honeybadger.io/article/188-deployment-tracking)).
class HoneybadgerDeploymentOptions {
    /// The environment name, typically 'production', 'staging', etc.
    environment: String
    /// URL of the project repository
    repo: String?
    /// A hash, number, tag, or other identifier showing what revision was deployed
    revision: String?
    /// API token.
    token: String
    /// Optional URL to submit the notification to.
    url: String?
    /// The username of the person doing the deployment
    user: String?
    /// If V(false), SSL certificates for the target url will not be validated. This should only be used on personally controlled sites using self-signed certificates.
    validate_certs: Boolean?
}

/// Task class for honeybadger_deployment
class HoneybadgerDeploymentTask extends Playbook.Task {
    /// todo doc
    `community.general.honeybadger_deployment`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.honeybadger_deployment"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.honeybadger_deployment`
}

/// TaskBuilder class for honeybadger_deployment
class HoneybadgerDeployment extends Playbook.TaskBuilder {
    /// Options for community.general.honeybadger_deployment
    options: HoneybadgerDeploymentOptions?
    /// todo doc
    function Task(): HoneybadgerDeploymentTask = this
        .toMap()
        .put("community.general.honeybadger_deployment", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(HoneybadgerDeploymentTask)
}

/// Boot system using specific media through HP iLO interface
/// This module boots a system through its HP iLO interface. The boot media can be one of: cdrom, floppy, hdd, network or usb.
/// This module requires the hpilo python module.
class HpiloBootOptions {
    /// Whether to force a reboot (even when the system is already booted).
    /// As a safeguard, without force, hpilo_boot will refuse to reboot a server that is already running.
    force: Boolean?
    /// The HP iLO hostname/address that is linked to the physical system.
    host: String
    /// The URL of a cdrom, floppy or usb boot media image. protocol://username:password@hostname:port/filename
    /// protocol is either 'http' or 'https'
    /// username:password is optional
    /// port is optional
    image: String?
    /// The login name to authenticate to the HP iLO interface.
    login: String?
    /// The boot media to boot the system from
    media: ("cdrom"|"floppy"|"rbsu"|"hdd"|"network"|"normal"|"usb")?
    /// The password to authenticate to the HP iLO interface.
    password: String?
    /// Change the ssl_version used.
    ssl_version: ("SSLv3"|"SSLv23"|"TLSv1"|"TLSv1_1"|"TLSv1_2")?
    /// The state of the boot media.
    /// no_boot: Do not boot from the device
    /// boot_once: Boot from the device once and then notthereafter
    /// boot_always: Boot from the device each time the server is rebooted
    /// connect: Connect the virtual media device and set to boot_always
    /// disconnect: Disconnects the virtual media device and set to no_boot
    /// poweroff: Power off the server
    state: ("boot_always"|"boot_once"|"connect"|"disconnect"|"no_boot"|"poweroff")?
}

/// Task class for hpilo_boot
class HpiloBootTask extends Playbook.Task {
    /// todo doc
    `community.general.hpilo_boot`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.hpilo_boot"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.hpilo_boot`
}

/// TaskBuilder class for hpilo_boot
class HpiloBoot extends Playbook.TaskBuilder {
    /// Options for community.general.hpilo_boot
    options: HpiloBootOptions?
    /// todo doc
    function Task(): HpiloBootTask = this
        .toMap()
        .put("community.general.hpilo_boot", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(HpiloBootTask)
}

/// Gather information through an HP iLO interface
/// This module gathers information on a specific system using its HP iLO interface. These information includes hardware and network related information useful for provisioning (e.g. macaddress, uuid).
/// This module requires the C(hpilo) python module.
class HpiloInfoOptions {
    /// The HP iLO hostname/address that is linked to the physical system.
    host: String
    /// The login name to authenticate to the HP iLO interface.
    login: String?
    /// The password to authenticate to the HP iLO interface.
    password: String?
    /// Change the ssl_version used.
    ssl_version: ("SSLv3"|"SSLv23"|"TLSv1"|"TLSv1_1"|"TLSv1_2")?
}

/// Task class for hpilo_info
class HpiloInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.hpilo_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.hpilo_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.hpilo_info`
}

/// TaskBuilder class for hpilo_info
class HpiloInfo extends Playbook.TaskBuilder {
    /// Options for community.general.hpilo_info
    options: HpiloInfoOptions?
    /// todo doc
    function Task(): HpiloInfoTask = this
        .toMap()
        .put("community.general.hpilo_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(HpiloInfoTask)
}

/// Configure HP iLO interface using hponcfg
/// This modules configures the HP iLO interface using hponcfg.
class HponcfgOptions {
    /// Path to the hponcfg executable (C(hponcfg) which uses $PATH).
    executable: String?
    /// The minimum firmware level needed.
    minfw: String?
    /// The XML file as accepted by hponcfg.
    path: String
    /// Run hponcfg in verbose mode (-v).
    verbose: Boolean?
}

/// Task class for hponcfg
class HponcfgTask extends Playbook.Task {
    /// todo doc
    `community.general.hponcfg`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.hponcfg"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.hponcfg`
}

/// TaskBuilder class for hponcfg
class Hponcfg extends Playbook.TaskBuilder {
    /// Options for community.general.hponcfg
    options: HponcfgOptions?
    /// todo doc
    function Task(): HponcfgTask = this
        .toMap()
        .put("community.general.hponcfg", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(HponcfgTask)
}

/// Manage user files for basic authentication
/// Add and remove username/password entries in a password file using htpasswd.
/// This is used by web servers such as Apache and Nginx for basic authentication.
class HtpasswdOptions {
    /// Used with O(state=present). If V(true), the file will be created if it does not exist. Conversely, if set to V(false) and the file does not exist it will fail.
    create: Boolean?
    /// Hashing scheme to be used. As well as the four choices listed here, you can also use any other hash supported by passlib, such as V(portable_apache22) and V(host_apache24); or V(md5_crypt) and V(sha256_crypt), which are Linux passwd hashes. Only some schemes in addition to the four choices below will be compatible with Apache or Nginx, and supported schemes depend on passlib version and its dependencies.
    /// See U(https://passlib.readthedocs.io/en/stable/lib/passlib.apache.html#passlib.apache.HtpasswdFile) parameter C(default_scheme).
    /// Some of the available choices might be: V(apr_md5_crypt), V(des_crypt), V(ldap_sha1), V(plaintext).
    hash_scheme: String?
    /// User name to add or remove.
    name: String
    /// Password associated with user.
    /// Must be specified if user does not exist yet.
    password: String?
    /// Path to the file that contains the usernames and passwords.
    path: String
    /// Whether the user entry should be present or not.
    state: ("present"|"absent")?
}

/// Task class for htpasswd
class HtpasswdTask extends Playbook.Task {
    /// todo doc
    `community.general.htpasswd`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.htpasswd"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.htpasswd`
}

/// TaskBuilder class for htpasswd
class Htpasswd extends Playbook.TaskBuilder {
    /// Options for community.general.htpasswd
    options: HtpasswdOptions?
    /// todo doc
    function Task(): HtpasswdTask = this
        .toMap()
        .put("community.general.htpasswd", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(HtpasswdTask)
}

/// Creates a resource of Ecs/Instance in Huawei Cloud
/// instance management.
class HwcEcsInstanceOptions {
    /// Specifies the initial login password of the administrator account for logging in to an ECS using password authentication. The Linux administrator is root, and the Windows administrator is Administrator. Password complexity requirements, consists of 8 to 26 characters. The password must contain at least three of the following character types 'uppercase letters, lowercase letters, digits, and special characters (!@$%^-_=+[{}]:,./?)'. The password cannot contain the username or the username in reverse. The Windows ECS password cannot contain the username, the username in reverse, or more than two consecutive characters in the username.
    admin_pass: String?
    /// Specifies the name of the AZ where the ECS is located.
    availability_zone: String
    /// Specifies the data disks of ECS instance.
    data_volumes: Listing<Any>?
    /// Specifies the description of an ECS, which is a null string by default. Can contain a maximum of 85 characters. Cannot contain special characters, such as < and >.
    description: String?
    /// Specifies the ID of the elastic IP address assigned to the ECS. Only elastic IP addresses in the DOWN state can be assigned.
    eip_id: String?
    /// Specifies whether automatic recovery is enabled on the ECS.
    enable_auto_recovery: Boolean?
    /// Specifies the ID of the enterprise project to which the ECS belongs.
    enterprise_project_id: String?
    /// Specifies the name of the system flavor.
    flavor_name: String
    /// Specifies the ID of the system image.
    image_id: String
    /// Specifies the ECS name. Value requirements consists of 1 to 64 characters, including letters, digits, underscores (V(_)), hyphens (V(-)), periods (V(.)).
    name: String
    /// Specifies the NIC information of the ECS. Constraints the network of the NIC must belong to the VPC specified by vpc_id. A maximum of 12 NICs can be attached to an ECS.
    nics: Listing<Any>
    /// Specifies the configuration of the ECS's system disks.
    root_volume: Any
    /// Specifies the security groups of the ECS. If this parameter is left blank, the default security group is bound to the ECS by default.
    security_groups: Listing<String>?
    /// Specifies the metadata of ECS to be created.
    server_metadata: Any?
    /// Specifies the tags of an ECS. When you create ECSs, one ECS supports up to 10 tags.
    server_tags: Any?
    /// Specifies the name of the SSH key used for logging in to the ECS.
    ssh_key_name: String?
    /// Whether the given object should exist in Huawei Cloud.
    state: ("present"|"absent")?
    /// The timeouts for each operations.
    timeouts: Any?
    /// Specifies the user data to be injected during the ECS creation process. Text, text files, and gzip files can be injected. The content to be injected must be encoded with base64. The maximum size of the content to be injected (before encoding) is 32 KB. For Linux ECSs, this parameter does not take effect when adminPass is used.
    user_data: String?
    /// Specifies the ID of the VPC to which the ECS belongs.
    vpc_id: String
}

/// Task class for hwc_ecs_instance
class HwcEcsInstanceTask extends Playbook.Task {
    /// todo doc
    `community.general.hwc_ecs_instance`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.hwc_ecs_instance"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.hwc_ecs_instance`
}

/// TaskBuilder class for hwc_ecs_instance
class HwcEcsInstance extends Playbook.TaskBuilder {
    /// Options for community.general.hwc_ecs_instance
    options: HwcEcsInstanceOptions?
    /// todo doc
    function Task(): HwcEcsInstanceTask = this
        .toMap()
        .put("community.general.hwc_ecs_instance", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(HwcEcsInstanceTask)
}

/// Creates a resource of Evs/Disk in Huawei Cloud
/// block storage management.
class HwcEvsDiskOptions {
    /// Specifies the AZ where you want to create the disk.
    availability_zone: String
    /// Specifies the ID of the backup that can be used to create a disk. This parameter is mandatory when you use a backup to create the disk.
    backup_id: String?
    /// Specifies the disk description. The value can contain a maximum of 255 bytes.
    description: String?
    /// If the disk is created from a snapshot and linked cloning needs to be used, set this parameter to True.
    enable_full_clone: Boolean?
    /// If this parameter is set to True, the disk device type will be SCSI, which allows ECS OSs to directly access underlying storage media. SCSI reservation command is supported. If this parameter is set to False, the disk device type will be VBD, which supports only simple SCSI read/write commands.
    /// If parameter enable_share is set to True and this parameter is not specified, shared SCSI disks are created. SCSI EVS disks cannot be created from backups, which means that this parameter cannot be True if backup_id has been specified.
    enable_scsi: Boolean?
    /// Specifies whether the disk is shareable. The default value is False.
    enable_share: Boolean?
    /// Specifies the encryption ID. The length of it fixes at 36 bytes.
    encryption_id: String?
    /// Specifies the enterprise project ID. This ID is associated with the disk during the disk creation. If it is not specified, the disk is bound to the default enterprise project.
    enterprise_project_id: String?
    /// Specifies the image ID. If this parameter is specified, the disk is created from an image. BMS system disks cannot be created from BMS images.
    image_id: String?
    /// Specifies the disk name. The value can contain a maximum of 255 bytes.
    name: String
    /// Specifies the disk size, in GB. Its values are as follows, System disk 1 GB to 1024 GB, Data disk 10 GB to 32768 GB. This parameter is mandatory when you create an empty disk or use an image or a snapshot to create a disk. If you use an image or a snapshot to create a disk, the disk size must be greater than or equal to the image or snapshot size. This parameter is optional when you use a backup to create a disk. If this parameter is not specified, the disk size is equal to the backup size.
    size: Int?
    /// Specifies the snapshot ID. If this parameter is specified, the disk is created from a snapshot.
    snapshot_id: String?
    /// Whether the given object should exist in Huaweicloud Cloud.
    state: ("present"|"absent")?
    /// The timeouts for each operations.
    timeouts: Any?
    /// Specifies the disk type. Currently, the value can be SSD, SAS, or SATA.
    /// SSD specifies the ultra-high I/O disk type.
    /// SAS specifies the high I/O disk type.
    /// SATA specifies the common I/O disk type.
    /// If the specified disk type is not available in the AZ, the disk will fail to create. If the EVS disk is created from a snapshot, the volume_type field must be the same as that of the snapshot's source disk.
    volume_type: String
}

/// Task class for hwc_evs_disk
class HwcEvsDiskTask extends Playbook.Task {
    /// todo doc
    `community.general.hwc_evs_disk`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.hwc_evs_disk"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.hwc_evs_disk`
}

/// TaskBuilder class for hwc_evs_disk
class HwcEvsDisk extends Playbook.TaskBuilder {
    /// Options for community.general.hwc_evs_disk
    options: HwcEvsDiskOptions?
    /// todo doc
    function Task(): HwcEvsDiskTask = this
        .toMap()
        .put("community.general.hwc_evs_disk", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(HwcEvsDiskTask)
}

/// Creates a Huawei Cloud VPC
/// Represents an vpc resource.
class HwcNetworkVpcOptions {
    /// The range of available subnets in the vpc.
    cidr: String
    /// The name of vpc.
    name: String
    /// Whether the given object should exist in vpc.
    state: ("present"|"absent")?
    /// The timeouts for each operations.
    timeouts: Any?
}

/// Task class for hwc_network_vpc
class HwcNetworkVpcTask extends Playbook.Task {
    /// todo doc
    `community.general.hwc_network_vpc`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.hwc_network_vpc"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.hwc_network_vpc`
}

/// TaskBuilder class for hwc_network_vpc
class HwcNetworkVpc extends Playbook.TaskBuilder {
    /// Options for community.general.hwc_network_vpc
    options: HwcNetworkVpcOptions?
    /// todo doc
    function Task(): HwcNetworkVpcTask = this
        .toMap()
        .put("community.general.hwc_network_vpc", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(HwcNetworkVpcTask)
}

/// Creates a resource of SMNTopic in Huaweicloud Cloud
/// Represents a SMN notification topic resource.
class HwcSmnTopicOptions {
    /// Topic display name, which is presented as the name of the email sender in an email message. The topic display name contains a maximum of 192 bytes.
    display_name: String?
    /// Name of the topic to be created. The topic name is a string of 1 to 256 characters. It must contain upper- or lower-case letters, digits, hyphens (V(-)), and underscores (V(_)), and must start with a letter or digit.
    name: String
    /// Whether the given object should exist in Huaweicloud Cloud.
    state: ("present"|"absent")?
}

/// Task class for hwc_smn_topic
class HwcSmnTopicTask extends Playbook.Task {
    /// todo doc
    `community.general.hwc_smn_topic`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.hwc_smn_topic"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.hwc_smn_topic`
}

/// TaskBuilder class for hwc_smn_topic
class HwcSmnTopic extends Playbook.TaskBuilder {
    /// Options for community.general.hwc_smn_topic
    options: HwcSmnTopicOptions?
    /// todo doc
    function Task(): HwcSmnTopicTask = this
        .toMap()
        .put("community.general.hwc_smn_topic", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(HwcSmnTopicTask)
}

/// Creates a resource of Vpc/EIP in Huawei Cloud
/// elastic ip management.
class HwcVpcEipOptions {
    /// Specifies the dedicated bandwidth object.
    dedicated_bandwidth: Any?
    /// Specifies the enterprise project ID.
    enterprise_project_id: String?
    /// The value can be 4 (IPv4 address) or 6 (IPv6 address). If this parameter is left blank, an IPv4 address will be assigned.
    ip_version: Int?
    /// Specifies the obtained IPv4 EIP. The system automatically assigns an EIP if you do not specify it.
    ipv4_address: String?
    /// Specifies the port ID. This parameter is returned only when a private IP address is bound with the EIP.
    port_id: String?
    /// Specifies the ID of shared bandwidth.
    shared_bandwidth_id: String?
    /// Whether the given object should exist in Huawei Cloud.
    state: ("present"|"absent")?
    /// The timeouts for each operations.
    timeouts: Any?
    /// Specifies the EIP type.
    type: String
}

/// Task class for hwc_vpc_eip
class HwcVpcEipTask extends Playbook.Task {
    /// todo doc
    `community.general.hwc_vpc_eip`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.hwc_vpc_eip"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.hwc_vpc_eip`
}

/// TaskBuilder class for hwc_vpc_eip
class HwcVpcEip extends Playbook.TaskBuilder {
    /// Options for community.general.hwc_vpc_eip
    options: HwcVpcEipOptions?
    /// todo doc
    function Task(): HwcVpcEipTask = this
        .toMap()
        .put("community.general.hwc_vpc_eip", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(HwcVpcEipTask)
}

/// Creates a resource of Vpc/PeeringConnect in Huawei Cloud
/// vpc peering management.
class HwcVpcPeeringConnectOptions {
    /// The description of vpc peering connection.
    description: String?
    /// Specifies the ID of local VPC.
    local_vpc_id: String
    /// Specifies the name of the VPC peering connection. The value can contain 1 to 64 characters.
    name: String
    /// Specifies information about the peering VPC.
    peering_vpc: Any
    /// Whether the given object should exist in Huawei Cloud.
    state: ("present"|"absent")?
    /// The timeouts for each operations.
    timeouts: Any?
}

/// Task class for hwc_vpc_peering_connect
class HwcVpcPeeringConnectTask extends Playbook.Task {
    /// todo doc
    `community.general.hwc_vpc_peering_connect`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.hwc_vpc_peering_connect"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.hwc_vpc_peering_connect`
}

/// TaskBuilder class for hwc_vpc_peering_connect
class HwcVpcPeeringConnect extends Playbook.TaskBuilder {
    /// Options for community.general.hwc_vpc_peering_connect
    options: HwcVpcPeeringConnectOptions?
    /// todo doc
    function Task(): HwcVpcPeeringConnectTask = this
        .toMap()
        .put("community.general.hwc_vpc_peering_connect", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(HwcVpcPeeringConnectTask)
}

/// Creates a resource of Vpc/Port in Huawei Cloud
/// vpc port management.
class HwcVpcPortOptions {
    /// Specifies the administrative state of the port.
    admin_state_up: Boolean?
    /// Specifies a set of zero or more allowed address pairs.
    allowed_address_pairs: Listing<Any>?
    /// Specifies the extended option of DHCP.
    extra_dhcp_opts: Listing<Any>?
    /// Specifies the port IP address.
    ip_address: String?
    /// Specifies the port name. The value can contain no more than 255 characters.
    name: String?
    /// Specifies the ID of the security group.
    security_groups: Listing<String>?
    /// Whether the given object should exist in Huawei Cloud.
    state: ("present"|"absent")?
    /// Specifies the ID of the subnet to which the port belongs.
    subnet_id: String
    /// The timeouts for each operations.
    timeouts: Any?
}

/// Task class for hwc_vpc_port
class HwcVpcPortTask extends Playbook.Task {
    /// todo doc
    `community.general.hwc_vpc_port`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.hwc_vpc_port"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.hwc_vpc_port`
}

/// TaskBuilder class for hwc_vpc_port
class HwcVpcPort extends Playbook.TaskBuilder {
    /// Options for community.general.hwc_vpc_port
    options: HwcVpcPortOptions?
    /// todo doc
    function Task(): HwcVpcPortTask = this
        .toMap()
        .put("community.general.hwc_vpc_port", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(HwcVpcPortTask)
}

/// Creates a resource of Vpc/PrivateIP in Huawei Cloud
/// vpc private ip management.
class HwcVpcPrivateIpOptions {
    /// Specifies the target IP address. The value can be an available IP address in the subnet. If it is not specified, the system automatically assigns an IP address. Cannot be changed after creating the private ip.
    ip_address: String?
    /// Whether the given object should exist in Huawei Cloud.
    state: ("present"|"absent")?
    /// Specifies the ID of the subnet from which IP addresses are assigned. Cannot be changed after creating the private ip.
    subnet_id: String
}

/// Task class for hwc_vpc_private_ip
class HwcVpcPrivateIpTask extends Playbook.Task {
    /// todo doc
    `community.general.hwc_vpc_private_ip`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.hwc_vpc_private_ip"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.hwc_vpc_private_ip`
}

/// TaskBuilder class for hwc_vpc_private_ip
class HwcVpcPrivateIp extends Playbook.TaskBuilder {
    /// Options for community.general.hwc_vpc_private_ip
    options: HwcVpcPrivateIpOptions?
    /// todo doc
    function Task(): HwcVpcPrivateIpTask = this
        .toMap()
        .put("community.general.hwc_vpc_private_ip", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(HwcVpcPrivateIpTask)
}

/// Creates a resource of Vpc/Route in Huawei Cloud
/// vpc route management.
class HwcVpcRouteOptions {
    /// Specifies the destination IP address or CIDR block.
    destination: String
    /// Specifies the next hop. The value is VPC peering connection ID.
    next_hop: String
    /// Whether the given object should exist in Huawei Cloud.
    state: ("present"|"absent")?
    /// Specifies the type of route.
    type: String?
    /// Specifies the VPC ID to which route is added.
    vpc_id: String
}

/// Task class for hwc_vpc_route
class HwcVpcRouteTask extends Playbook.Task {
    /// todo doc
    `community.general.hwc_vpc_route`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.hwc_vpc_route"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.hwc_vpc_route`
}

/// TaskBuilder class for hwc_vpc_route
class HwcVpcRoute extends Playbook.TaskBuilder {
    /// Options for community.general.hwc_vpc_route
    options: HwcVpcRouteOptions?
    /// todo doc
    function Task(): HwcVpcRouteTask = this
        .toMap()
        .put("community.general.hwc_vpc_route", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(HwcVpcRouteTask)
}

/// Creates a resource of Vpc/SecurityGroup in Huawei Cloud
/// vpc security group management.
class HwcVpcSecurityGroupOptions {
    /// Specifies the enterprise project ID. When creating a security group, associate the enterprise project ID with the security group.s
    enterprise_project_id: String?
    /// Specifies the security group name. The value is a string of 1 to 64 characters that can contain letters, digits, underscores (V(_)), hyphens (V(-)), and periods (V(.)).
    name: String
    /// Whether the given object should exist in Huawei Cloud.
    state: ("present"|"absent")?
    /// Specifies the resource ID of the VPC to which the security group belongs.
    vpc_id: String?
}

/// Task class for hwc_vpc_security_group
class HwcVpcSecurityGroupTask extends Playbook.Task {
    /// todo doc
    `community.general.hwc_vpc_security_group`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.hwc_vpc_security_group"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.hwc_vpc_security_group`
}

/// TaskBuilder class for hwc_vpc_security_group
class HwcVpcSecurityGroup extends Playbook.TaskBuilder {
    /// Options for community.general.hwc_vpc_security_group
    options: HwcVpcSecurityGroupOptions?
    /// todo doc
    function Task(): HwcVpcSecurityGroupTask = this
        .toMap()
        .put("community.general.hwc_vpc_security_group", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(HwcVpcSecurityGroupTask)
}

/// Creates a resource of Vpc/SecurityGroupRule in Huawei Cloud
/// vpc security group management.
class HwcVpcSecurityGroupRuleOptions {
    /// Provides supplementary information about the security group rule. The value is a string of no more than 255 characters that can contain letters and digits.
    description: String?
    /// Specifies the direction of access control. The value can be egress or ingress.
    direction: String
    /// Specifies the IP protocol version. The value can be IPv4 or IPv6. If you do not set this parameter, IPv4 is used by default.
    ethertype: String?
    /// Specifies the end port number. The value ranges from 1 to 65535. If the protocol is not icmp, the value cannot be smaller than the port_range_min value. An empty value indicates all ports.
    port_range_max: Int?
    /// Specifies the start port number. The value ranges from 1 to 65535. The value cannot be greater than the port_range_max value. An empty value indicates all ports.
    port_range_min: Int?
    /// Specifies the protocol type. The value can be icmp, tcp, or udp. If the parameter is left blank, the security group supports all protocols.
    protocol: String?
    /// Specifies the ID of the peer security group. The value is exclusive with parameter remote_ip_prefix.
    remote_group_id: String?
    /// Specifies the remote IP address. If the access control direction is set to egress, the parameter specifies the source IP address. If the access control direction is set to ingress, the parameter specifies the destination IP address. The value can be in the CIDR format or IP addresses. The parameter is exclusive with parameter remote_group_id.
    remote_ip_prefix: String?
    /// Specifies the security group rule ID, which uniquely identifies the security group rule.
    security_group_id: String
    /// Whether the given object should exist in Huawei Cloud.
    state: ("present"|"absent")?
}

/// Task class for hwc_vpc_security_group_rule
class HwcVpcSecurityGroupRuleTask extends Playbook.Task {
    /// todo doc
    `community.general.hwc_vpc_security_group_rule`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.hwc_vpc_security_group_rule"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.hwc_vpc_security_group_rule`
}

/// TaskBuilder class for hwc_vpc_security_group_rule
class HwcVpcSecurityGroupRule extends Playbook.TaskBuilder {
    /// Options for community.general.hwc_vpc_security_group_rule
    options: HwcVpcSecurityGroupRuleOptions?
    /// todo doc
    function Task(): HwcVpcSecurityGroupRuleTask = this
        .toMap()
        .put("community.general.hwc_vpc_security_group_rule", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(HwcVpcSecurityGroupRuleTask)
}

/// Creates a resource of Vpc/Subnet in Huawei Cloud
/// subnet management.
class HwcVpcSubnetOptions {
    /// Specifies the AZ to which the subnet belongs. Cannot be changed after creating the subnet.
    availability_zone: String?
    /// Specifies the subnet CIDR block. The value must be within the VPC CIDR block and be in CIDR format. The subnet mask cannot be greater than 28. Cannot be changed after creating the subnet.
    cidr: String
    /// Specifies whether DHCP is enabled for the subnet. The value can be true (enabled) or false(disabled), and default value is true. If this parameter is set to false, newly created ECSs cannot obtain IP addresses, and usernames and passwords cannot be injected using Cloud-init.
    dhcp_enable: Boolean?
    /// Specifies the DNS server addresses for subnet. The address in the head will be used first.
    dns_address: Listing<String>?
    /// Specifies the gateway of the subnet. The value must be an IP address in the subnet. Cannot be changed after creating the subnet.
    gateway_ip: String
    /// Specifies the subnet name. The value is a string of 1 to 64 characters that can contain letters, digits, underscores (V(_)), hyphens (V(-)), and periods (V(.)).
    name: String
    /// Whether the given object should exist in Huawei Cloud.
    state: ("present"|"absent")?
    /// The timeouts for each operations.
    timeouts: Any?
    /// Specifies the ID of the VPC to which the subnet belongs. Cannot be changed after creating the subnet.
    vpc_id: String
}

/// Task class for hwc_vpc_subnet
class HwcVpcSubnetTask extends Playbook.Task {
    /// todo doc
    `community.general.hwc_vpc_subnet`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.hwc_vpc_subnet"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.hwc_vpc_subnet`
}

/// TaskBuilder class for hwc_vpc_subnet
class HwcVpcSubnet extends Playbook.TaskBuilder {
    /// Options for community.general.hwc_vpc_subnet
    options: HwcVpcSubnetOptions?
    /// todo doc
    function Task(): HwcVpcSubnetTask = this
        .toMap()
        .put("community.general.hwc_vpc_subnet", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(HwcVpcSubnetTask)
}

/// Manages domains on IBM Spectrum Accelerate Family storage systems
/// This module can be used to add domains to or removes them from IBM Spectrum Accelerate Family storage systems.
class IbmSaDomainOptions {
    /// Name of the domain to be managed.
    domain: String
    /// Hard capacity of the domain.
    hard_capacity: String?
    /// ldap id to add to the domain.
    ldap_id: String?
    /// Number of max cgs.
    max_cgs: String?
    /// Number of max dms.
    max_dms: String?
    /// Number of max_mirrors.
    max_mirrors: String?
    /// Number of max_pools.
    max_pools: String?
    /// Number of max_volumes.
    max_volumes: String?
    /// Add the domain to a performance class.
    perf_class: String?
    /// Size of the domain.
    size: String?
    /// Soft capacity of the domain.
    soft_capacity: String?
    /// The desired state of the domain.
    state: ("present"|"absent")?
}

/// Task class for ibm_sa_domain
class IbmSaDomainTask extends Playbook.Task {
    /// todo doc
    `community.general.ibm_sa_domain`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ibm_sa_domain"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ibm_sa_domain`
}

/// TaskBuilder class for ibm_sa_domain
class IbmSaDomain extends Playbook.TaskBuilder {
    /// Options for community.general.ibm_sa_domain
    options: IbmSaDomainOptions?
    /// todo doc
    function Task(): IbmSaDomainTask = this
        .toMap()
        .put("community.general.ibm_sa_domain", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IbmSaDomainTask)
}

/// Adds hosts to or removes them from IBM Spectrum Accelerate Family storage systems
/// This module adds hosts to or removes them from IBM Spectrum Accelerate Family storage systems.
class IbmSaHostOptions {
    /// The name of the cluster to include the host.
    cluster: String?
    /// The domains the cluster will be attached to. To include more than one domain, separate domain names with commas. To include all existing domains, use an asterisk ("*").
    domain: String?
    /// Host name.
    host: String
    /// The host's CHAP name identifier
    iscsi_chap_name: String?
    /// The password of the initiator used to authenticate to the system when CHAP is enable
    iscsi_chap_secret: String?
    /// Host state.
    state: ("present"|"absent")?
}

/// Task class for ibm_sa_host
class IbmSaHostTask extends Playbook.Task {
    /// todo doc
    `community.general.ibm_sa_host`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ibm_sa_host"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ibm_sa_host`
}

/// TaskBuilder class for ibm_sa_host
class IbmSaHost extends Playbook.TaskBuilder {
    /// Options for community.general.ibm_sa_host
    options: IbmSaHostOptions?
    /// todo doc
    function Task(): IbmSaHostTask = this
        .toMap()
        .put("community.general.ibm_sa_host", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IbmSaHostTask)
}

/// Add host ports on IBM Spectrum Accelerate Family storage systems
/// This module adds ports to or removes them from the hosts on IBM Spectrum Accelerate Family storage systems.
class IbmSaHostPortsOptions {
    /// Fiber channel address.
    fcaddress: String?
    /// Host name.
    host: String
    /// iSCSI initiator name.
    iscsi_name: String?
    /// Number of visible targets.
    num_of_visible_targets: String?
    /// Host ports state.
    state: ("present"|"absent")?
}

/// Task class for ibm_sa_host_ports
class IbmSaHostPortsTask extends Playbook.Task {
    /// todo doc
    `community.general.ibm_sa_host_ports`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ibm_sa_host_ports"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ibm_sa_host_ports`
}

/// TaskBuilder class for ibm_sa_host_ports
class IbmSaHostPorts extends Playbook.TaskBuilder {
    /// Options for community.general.ibm_sa_host_ports
    options: IbmSaHostPortsOptions?
    /// todo doc
    function Task(): IbmSaHostPortsTask = this
        .toMap()
        .put("community.general.ibm_sa_host_ports", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IbmSaHostPortsTask)
}

/// Handles pools on IBM Spectrum Accelerate Family storage systems
/// This module creates or deletes pools to be used on IBM Spectrum Accelerate Family storage systems
class IbmSaPoolOptions {
    /// Adds the pool to the specified domain.
    domain: String?
    /// Assigns a perf_class to the pool.
    perf_class: String?
    /// Pool name.
    pool: String
    /// Pool size in GB
    size: String?
    /// Pool snapshot size in GB
    snapshot_size: String?
    /// Pool state.
    state: ("present"|"absent")?
}

/// Task class for ibm_sa_pool
class IbmSaPoolTask extends Playbook.Task {
    /// todo doc
    `community.general.ibm_sa_pool`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ibm_sa_pool"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ibm_sa_pool`
}

/// TaskBuilder class for ibm_sa_pool
class IbmSaPool extends Playbook.TaskBuilder {
    /// Options for community.general.ibm_sa_pool
    options: IbmSaPoolOptions?
    /// todo doc
    function Task(): IbmSaPoolTask = this
        .toMap()
        .put("community.general.ibm_sa_pool", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IbmSaPoolTask)
}

/// Handle volumes on IBM Spectrum Accelerate Family storage systems
/// This module creates or deletes volumes to be used on IBM Spectrum Accelerate Family storage systems.
class IbmSaVolOptions {
    /// Volume pool.
    pool: String?
    /// Volume size.
    size: String?
    /// Volume state.
    state: ("present"|"absent")?
    /// Volume name.
    vol: String
}

/// Task class for ibm_sa_vol
class IbmSaVolTask extends Playbook.Task {
    /// todo doc
    `community.general.ibm_sa_vol`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ibm_sa_vol"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ibm_sa_vol`
}

/// TaskBuilder class for ibm_sa_vol
class IbmSaVol extends Playbook.TaskBuilder {
    /// Options for community.general.ibm_sa_vol
    options: IbmSaVolOptions?
    /// todo doc
    function Task(): IbmSaVolTask = this
        .toMap()
        .put("community.general.ibm_sa_vol", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IbmSaVolTask)
}

/// Handles volume mapping on IBM Spectrum Accelerate Family storage systems
/// This module maps volumes to or unmaps them from the hosts on IBM Spectrum Accelerate Family storage systems.
class IbmSaVolMapOptions {
    /// Maps the volume to a cluster.
    cluster: String?
    /// Maps the volume to a host.
    host: String?
    /// The LUN identifier.
    lun: String?
    /// Overrides the existing volume mapping.
    `override`: String?
    /// When the state is present the volume is mapped. When the state is absent, the volume is meant to be unmapped.
    state: ("present"|"absent")?
    /// Volume name.
    vol: String
}

/// Task class for ibm_sa_vol_map
class IbmSaVolMapTask extends Playbook.Task {
    /// todo doc
    `community.general.ibm_sa_vol_map`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ibm_sa_vol_map"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ibm_sa_vol_map`
}

/// TaskBuilder class for ibm_sa_vol_map
class IbmSaVolMap extends Playbook.TaskBuilder {
    /// Options for community.general.ibm_sa_vol_map
    options: IbmSaVolMapOptions?
    /// todo doc
    function Task(): IbmSaVolMapTask = this
        .toMap()
        .put("community.general.ibm_sa_vol_map", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IbmSaVolMapTask)
}

/// Manage Icinga2 feature
/// This module can be used to enable or disable an Icinga2 feature.
class Icinga2FeatureOptions {
    /// This is the feature name to enable or disable.
    name: String
    /// If set to V(present) and feature is disabled, then feature is enabled.
    /// If set to V(present) and feature is already enabled, then nothing is changed.
    /// If set to V(absent) and feature is enabled, then feature is disabled.
    /// If set to V(absent) and feature is already disabled, then nothing is changed.
    state: ("present"|"absent")?
}

/// Task class for icinga2_feature
class Icinga2FeatureTask extends Playbook.Task {
    /// todo doc
    `community.general.icinga2_feature`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.icinga2_feature"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.icinga2_feature`
}

/// TaskBuilder class for icinga2_feature
class Icinga2Feature extends Playbook.TaskBuilder {
    /// Options for community.general.icinga2_feature
    options: Icinga2FeatureOptions?
    /// todo doc
    function Task(): Icinga2FeatureTask = this
        .toMap()
        .put("community.general.icinga2_feature", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(Icinga2FeatureTask)
}

/// Manage a host in Icinga2
/// Add or remove a host to Icinga2 through the API.
/// See U(https://www.icinga.com/docs/icinga2/latest/doc/12-icinga2-api/)
class Icinga2HostOptions {
    /// The command used to check if the host is alive.
    check_command: String?
    /// PEM formatted certificate chain file to be used for SSL client authentication. This file can also include the key as well, and if the key is included, O(client_key) is not required.
    client_cert: String?
    /// PEM formatted file that contains your private key to be used for SSL client authentication. If O(client_cert) contains both the certificate and key, this option is not required.
    client_key: String?
    /// The name used to display the host.
    /// If not specified, it defaults to the value of the O(name) parameter.
    display_name: String?
    /// httplib2, the library used by the uri module only sends authentication information when a webservice responds to an initial request with a 401 status. Since some basic auth services do not properly send a 401, logins will fail. This option forces the sending of the Basic authentication header upon initial request.
    force_basic_auth: Boolean?
    /// The IP address of the host.
    /// This is no longer required since community.general 8.0.0.
    ip: String?
    /// Name used to create / delete the host. This does not need to be the FQDN, but does needs to be unique.
    name: String
    /// Apply feature state.
    state: ("present"|"absent")?
    /// The template used to define the host.
    /// Template cannot be modified after object creation.
    template: String?
    /// HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path
    url: String?
    /// The password for use in HTTP basic authentication.
    /// If the O(url_username) parameter is not specified, the O(url_password) parameter will not be used.
    url_password: String?
    /// The username for use in HTTP basic authentication.
    /// This parameter can be used without O(url_password) for sites that allow empty passwords.
    url_username: String?
    /// If V(false), it will not use a proxy, even if one is defined in an environment variable on the target hosts.
    use_proxy: Boolean?
    /// If V(false), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
    validate_certs: Boolean?
    /// Dictionary of variables.
    variables: Any?
    /// The zone from where this host should be polled.
    zone: String?
}

/// Task class for icinga2_host
class Icinga2HostTask extends Playbook.Task {
    /// todo doc
    `community.general.icinga2_host`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.icinga2_host"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.icinga2_host`
}

/// TaskBuilder class for icinga2_host
class Icinga2Host extends Playbook.TaskBuilder {
    /// Options for community.general.icinga2_host
    options: Icinga2HostOptions?
    /// todo doc
    function Task(): Icinga2HostTask = this
        .toMap()
        .put("community.general.icinga2_host", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(Icinga2HostTask)
}

/// Manages Out-Of-Band controllers using iDRAC OEM Redfish APIs
/// Builds Redfish URIs locally and sends them to remote OOB controllers to perform an action.
/// For use with Dell iDRAC operations that require Redfish OEM extensions.
class IdracRedfishCommandOptions {
    /// Security token for authenticating to iDRAC.
    auth_token: String?
    /// Base URI of iDRAC.
    baseuri: String
    /// Category to execute on iDRAC.
    category: String
    /// List of commands to execute on iDRAC.
    command: Listing<String>
    /// Password for authenticating to iDRAC.
    password: String?
    /// ID of the System, Manager or Chassis to modify.
    resource_id: String?
    /// Timeout in seconds for HTTP requests to iDRAC.
    timeout: Int?
    /// Username for authenticating to iDRAC.
    username: String?
}

/// Task class for idrac_redfish_command
class IdracRedfishCommandTask extends Playbook.Task {
    /// todo doc
    `community.general.idrac_redfish_command`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.idrac_redfish_command"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.idrac_redfish_command`
}

/// TaskBuilder class for idrac_redfish_command
class IdracRedfishCommand extends Playbook.TaskBuilder {
    /// Options for community.general.idrac_redfish_command
    options: IdracRedfishCommandOptions?
    /// todo doc
    function Task(): IdracRedfishCommandTask = this
        .toMap()
        .put("community.general.idrac_redfish_command", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IdracRedfishCommandTask)
}

/// Manages servers through iDRAC using Dell Redfish APIs
/// For use with Dell iDRAC operations that require Redfish OEM extensions
/// Builds Redfish URIs locally and sends them to remote iDRAC controllers to set or update a configuration attribute.
class IdracRedfishConfigOptions {
    /// Security token for authenticating to iDRAC.
    auth_token: String?
    /// Base URI of iDRAC.
    baseuri: String
    /// Category to execute on iDRAC.
    category: String
    /// List of commands to execute on iDRAC.
    /// V(SetManagerAttributes), V(SetLifecycleControllerAttributes) and V(SetSystemAttributes) are mutually exclusive commands when O(category) is V(Manager).
    command: Listing<String>
    /// Dictionary of iDRAC attribute name and value pairs to update.
    manager_attributes: Any?
    /// Password for authenticating to iDRAC.
    password: String?
    /// ID of the System, Manager or Chassis to modify.
    resource_id: String?
    /// Timeout in seconds for HTTP requests to iDRAC.
    timeout: Int?
    /// Username for authenticating to iDRAC.
    username: String?
}

/// Task class for idrac_redfish_config
class IdracRedfishConfigTask extends Playbook.Task {
    /// todo doc
    `community.general.idrac_redfish_config`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.idrac_redfish_config"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.idrac_redfish_config`
}

/// TaskBuilder class for idrac_redfish_config
class IdracRedfishConfig extends Playbook.TaskBuilder {
    /// Options for community.general.idrac_redfish_config
    options: IdracRedfishConfigOptions?
    /// todo doc
    function Task(): IdracRedfishConfigTask = this
        .toMap()
        .put("community.general.idrac_redfish_config", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IdracRedfishConfigTask)
}

/// Gather PowerEdge server information through iDRAC using Redfish APIs
/// Builds Redfish URIs locally and sends them to remote iDRAC controllers to get information back.
/// For use with Dell EMC iDRAC operations that require Redfish OEM extensions.
class IdracRedfishInfoOptions {
    /// Security token for authenticating to iDRAC.
    auth_token: String?
    /// Base URI of iDRAC.
    baseuri: String
    /// Category to execute on iDRAC.
    category: String
    /// List of commands to execute on iDRAC.
    /// V(GetManagerAttributes) returns the list of dicts containing iDRAC, LifecycleController and System attributes.
    command: Listing<String>
    /// Password for authenticating to iDRAC.
    password: String?
    /// Timeout in seconds for HTTP requests to iDRAC.
    timeout: Int?
    /// Username for authenticating to iDRAC.
    username: String?
}

/// Task class for idrac_redfish_info
class IdracRedfishInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.idrac_redfish_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.idrac_redfish_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.idrac_redfish_info`
}

/// TaskBuilder class for idrac_redfish_info
class IdracRedfishInfo extends Playbook.TaskBuilder {
    /// Options for community.general.idrac_redfish_info
    options: IdracRedfishInfoOptions?
    /// todo doc
    function Task(): IdracRedfishInfoTask = this
        .toMap()
        .put("community.general.idrac_redfish_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IdracRedfishInfoTask)
}

/// Manages Out-Of-Band controllers using Redfish APIs
/// Builds Redfish URIs locally and sends them to remote OOB controllers to perform an action.
class IloRedfishCommandOptions {
    /// Security token for authenticating to iLO.
    auth_token: String?
    /// Base URI of OOB controller.
    baseuri: String
    /// Category to execute on OOB controller.
    category: ("Systems")
    /// List of commands to execute on OOB controller.
    command: Listing<String>
    /// Password for authenticating to iLO.
    password: String?
    /// Timeout in seconds for HTTP requests to iLO.
    timeout: Int?
    /// Username for authenticating to iLO.
    username: String?
}

/// Task class for ilo_redfish_command
class IloRedfishCommandTask extends Playbook.Task {
    /// todo doc
    `community.general.ilo_redfish_command`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ilo_redfish_command"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ilo_redfish_command`
}

/// TaskBuilder class for ilo_redfish_command
class IloRedfishCommand extends Playbook.TaskBuilder {
    /// Options for community.general.ilo_redfish_command
    options: IloRedfishCommandOptions?
    /// todo doc
    function Task(): IloRedfishCommandTask = this
        .toMap()
        .put("community.general.ilo_redfish_command", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IloRedfishCommandTask)
}

/// Sets or updates configuration attributes on HPE iLO with Redfish OEM extensions
/// Builds Redfish URIs locally and sends them to iLO to set or update a configuration attribute.
/// For use with HPE iLO operations that require Redfish OEM extensions.
class IloRedfishConfigOptions {
    /// Name of the attribute to be configured.
    attribute_name: String
    /// Value of the attribute to be configured.
    attribute_value: String?
    /// Security token for authenticating to iLO.
    auth_token: String?
    /// Base URI of iLO.
    baseuri: String
    /// Command category to execute on iLO.
    category: ("Manager")
    /// List of commands to execute on iLO.
    command: Listing<String>
    /// Password for authenticating to iLO.
    password: String?
    /// Timeout in seconds for HTTP requests to iLO.
    timeout: Int?
    /// Username for authenticating to iLO.
    username: String?
}

/// Task class for ilo_redfish_config
class IloRedfishConfigTask extends Playbook.Task {
    /// todo doc
    `community.general.ilo_redfish_config`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ilo_redfish_config"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ilo_redfish_config`
}

/// TaskBuilder class for ilo_redfish_config
class IloRedfishConfig extends Playbook.TaskBuilder {
    /// Options for community.general.ilo_redfish_config
    options: IloRedfishConfigOptions?
    /// todo doc
    function Task(): IloRedfishConfigTask = this
        .toMap()
        .put("community.general.ilo_redfish_config", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IloRedfishConfigTask)
}

/// Gathers server information through iLO using Redfish APIs
/// Builds Redfish URIs locally and sends them to iLO to get information back.
/// For use with HPE iLO operations that require Redfish OEM extensions.
class IloRedfishInfoOptions {
    /// Security token for authenticating to iLO.
    auth_token: String?
    /// Base URI of iLO.
    baseuri: String
    /// List of categories to execute on iLO.
    category: Listing<String>
    /// List of commands to execute on iLO.
    command: Listing<String>
    /// Password for authenticating to iLO.
    password: String?
    /// Timeout in seconds for HTTP requests to iLO.
    timeout: Int?
    /// Username for authenticating to iLO.
    username: String?
}

/// Task class for ilo_redfish_info
class IloRedfishInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.ilo_redfish_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ilo_redfish_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ilo_redfish_info`
}

/// TaskBuilder class for ilo_redfish_info
class IloRedfishInfo extends Playbook.TaskBuilder {
    /// Options for community.general.ilo_redfish_info
    options: IloRedfishInfoOptions?
    /// todo doc
    function Task(): IloRedfishInfoTask = this
        .toMap()
        .put("community.general.ilo_redfish_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IloRedfishInfoTask)
}

/// Manage Cisco IMC hardware through its REST API
/// Provides direct access to the Cisco IMC REST API.
/// Perform any configuration changes and actions that the Cisco IMC supports.
/// More information about the IMC REST API is available from U(http://www.cisco.com/c/en/us/td/docs/unified_computing/ucs/c/sw/api/3_0/b_Cisco_IMC_api_301.html).
class ImcRestOptions {
    /// When used instead of O(path), sets the content of the API requests directly.
    /// This may be convenient to template simple requests, for anything complex use the M(ansible.builtin.template) module.
    /// You can collate multiple IMC XML fragments and they will be processed sequentially in a single stream, the Cisco IMC output is subsequently merged.
    /// Parameter O(content) is mutual exclusive with parameter O(path).
    content: String?
    /// IP Address or hostname of Cisco IMC, resolvable by Ansible control host.
    hostname: String
    /// The password to use for authentication.
    password: String?
    /// Name of the absolute path of the filename that includes the body of the http request being sent to the Cisco IMC REST API.
    /// Parameter O(path) is mutual exclusive with parameter O(content).
    path: String?
    /// Connection protocol to use.
    protocol: ("http"|"https")?
    /// The socket level timeout in seconds.
    /// This is the time that every single connection (every fragment) can spend. If this O(timeout) is reached, the module will fail with a C(Connection failure) indicating that C(The read operation timed out).
    timeout: Int?
    /// Username used to login to the switch.
    username: String?
    /// If V(false), SSL certificates will not be validated.
    /// This should only set to V(false) used on personally controlled sites using self-signed certificates.
    validate_certs: Boolean?
}

/// Task class for imc_rest
class ImcRestTask extends Playbook.Task {
    /// todo doc
    `community.general.imc_rest`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.imc_rest"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.imc_rest`
}

/// TaskBuilder class for imc_rest
class ImcRest extends Playbook.TaskBuilder {
    /// Options for community.general.imc_rest
    options: ImcRestOptions?
    /// todo doc
    function Task(): ImcRestTask = this
        .toMap()
        .put("community.general.imc_rest", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ImcRestTask)
}

/// Manage SmartOS images
/// Manage SmartOS virtual machine images through imgadm(1M)
class ImgadmOptions {
    /// Force a given operation (where supported by imgadm(1M)).
    force: Boolean?
    /// zpool to import to or delete images from.
    pool: String?
    /// URI for the image source.
    source: String?
    /// State the object operated on should be in. V(imported) is an alias for for V(present) and V(deleted) for V(absent). When set to V(vacuumed) and O(uuid=*), it will remove all unused images.
    state: ("present"|"absent"|"deleted"|"imported"|"updated"|"vacuumed")
    /// Type for image sources.
    type: ("imgapi"|"docker"|"dsapi")?
    /// Image UUID. Can either be a full UUID or V(*) for all images.
    uuid: String?
}

/// Task class for imgadm
class ImgadmTask extends Playbook.Task {
    /// todo doc
    `community.general.imgadm`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.imgadm"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.imgadm`
}

/// TaskBuilder class for imgadm
class Imgadm extends Playbook.TaskBuilder {
    /// Options for community.general.imgadm
    options: ImgadmOptions?
    /// todo doc
    function Task(): ImgadmTask = this
        .toMap()
        .put("community.general.imgadm", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ImgadmTask)
}

/// Manage Infinity IPAM using Rest API
/// Manage Infinity IPAM using REST API.
class InfinityOptions {
    /// Action to perform
    action: ("add_network"|"delete_network"|"get_network"|"get_network_id"|"release_ip"|"release_network"|"reserve_network"|"reserve_next_available_ip")
    /// IP Address for a reservation or a release.
    ip_address: String?
    /// Network address with CIDR format (e.g., 192.168.310.0).
    network_address: String?
    /// Network family defined by Infinity, e.g. IPv4, IPv6 and Dual stack
    network_family: ("4"|"6"|"dual")?
    /// Network ID.
    network_id: String?
    /// The parent network id for a given network.
    network_location: Int?
    /// The name of a network.
    network_name: String?
    /// Network bitmask (e.g. 255.255.255.220) or CIDR format (e.g., /26).
    network_size: String?
    /// Network type defined by Infinity
    network_type: ("lan"|"shared_lan"|"supernet")?
    /// Infinity password.
    password: String
    /// Infinity server_ip with IP address.
    server_ip: String
    /// Username to access Infinity.
    /// The user must have REST API privileges.
    username: String
}

/// Task class for infinity
class InfinityTask extends Playbook.Task {
    /// todo doc
    `community.general.infinity`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.infinity"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.infinity`
}

/// TaskBuilder class for infinity
class Infinity extends Playbook.TaskBuilder {
    /// Options for community.general.infinity
    options: InfinityOptions?
    /// todo doc
    function Task(): InfinityTask = this
        .toMap()
        .put("community.general.infinity", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(InfinityTask)
}

/// Manage InfluxDB databases
/// Manage InfluxDB databases.
class InfluxdbDatabaseOptions {
    /// Name of the database.
    database_name: String
    /// Determines if the database should be created or destroyed.
    state: ("absent"|"present")?
}

/// Task class for influxdb_database
class InfluxdbDatabaseTask extends Playbook.Task {
    /// todo doc
    `community.general.influxdb_database`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.influxdb_database"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.influxdb_database`
}

/// TaskBuilder class for influxdb_database
class InfluxdbDatabase extends Playbook.TaskBuilder {
    /// Options for community.general.influxdb_database
    options: InfluxdbDatabaseOptions?
    /// todo doc
    function Task(): InfluxdbDatabaseTask = this
        .toMap()
        .put("community.general.influxdb_database", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(InfluxdbDatabaseTask)
}

/// Query data points from InfluxDB
/// Query data points from InfluxDB.
class InfluxdbQueryOptions {
    /// Name of the database.
    database_name: String
    /// Query to be executed.
    query: String
}

/// Task class for influxdb_query
class InfluxdbQueryTask extends Playbook.Task {
    /// todo doc
    `community.general.influxdb_query`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.influxdb_query"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.influxdb_query`
}

/// TaskBuilder class for influxdb_query
class InfluxdbQuery extends Playbook.TaskBuilder {
    /// Options for community.general.influxdb_query
    options: InfluxdbQueryOptions?
    /// todo doc
    function Task(): InfluxdbQueryTask = this
        .toMap()
        .put("community.general.influxdb_query", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(InfluxdbQueryTask)
}

/// Manage InfluxDB retention policies
/// Manage InfluxDB retention policies.
class InfluxdbRetentionPolicyOptions {
    /// Name of the database.
    database_name: String
    /// Sets the retention policy as default retention policy.
    default: Boolean?
    /// Determines how long InfluxDB should keep the data. If specified, it should be V(INF) or at least one hour. If not specified, V(INF) is assumed. Supports complex duration expressions with multiple units.
    /// Required only if O(state) is set to V(present).
    duration: String?
    /// Name of the retention policy.
    policy_name: String
    /// Determines how many independent copies of each point are stored in the cluster.
    /// Required only if O(state) is set to V(present).
    replication: Int?
    /// Determines the time range covered by a shard group. If specified it must be at least one hour. If none, it's determined by InfluxDB by the rentention policy's duration. Supports complex duration expressions with multiple units.
    shard_group_duration: String?
    /// State of the retention policy.
    state: ("absent"|"present")?
}

/// Task class for influxdb_retention_policy
class InfluxdbRetentionPolicyTask extends Playbook.Task {
    /// todo doc
    `community.general.influxdb_retention_policy`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.influxdb_retention_policy"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.influxdb_retention_policy`
}

/// TaskBuilder class for influxdb_retention_policy
class InfluxdbRetentionPolicy extends Playbook.TaskBuilder {
    /// Options for community.general.influxdb_retention_policy
    options: InfluxdbRetentionPolicyOptions?
    /// todo doc
    function Task(): InfluxdbRetentionPolicyTask = this
        .toMap()
        .put("community.general.influxdb_retention_policy", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(InfluxdbRetentionPolicyTask)
}

/// Manage InfluxDB users
/// Manage InfluxDB users.
class InfluxdbUserOptions {
    /// Whether the user should be in the admin role or not.
    /// Since version 2.8, the role will also be updated.
    admin: Boolean?
    /// Privileges to grant to this user.
    /// Takes a list of dicts containing the "database" and "privilege" keys.
    /// If this argument is not provided, the current grants will be left alone.
    /// If an empty list is provided, all grants for the user will be removed.
    grants: Listing<Any>?
    /// State of the user.
    state: ("absent"|"present")?
    /// Name of the user.
    user_name: String
    /// Password to be set for the user.
    user_password: String?
}

/// Task class for influxdb_user
class InfluxdbUserTask extends Playbook.Task {
    /// todo doc
    `community.general.influxdb_user`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.influxdb_user"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.influxdb_user`
}

/// TaskBuilder class for influxdb_user
class InfluxdbUser extends Playbook.TaskBuilder {
    /// Options for community.general.influxdb_user
    options: InfluxdbUserOptions?
    /// todo doc
    function Task(): InfluxdbUserTask = this
        .toMap()
        .put("community.general.influxdb_user", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(InfluxdbUserTask)
}

/// Write data points into InfluxDB
/// Write data points into InfluxDB.
class InfluxdbWriteOptions {
    /// Data points as dict to write into the database.
    data_points: Listing<Any>
    /// Name of the database.
    database_name: String
}

/// Task class for influxdb_write
class InfluxdbWriteTask extends Playbook.Task {
    /// todo doc
    `community.general.influxdb_write`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.influxdb_write"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.influxdb_write`
}

/// TaskBuilder class for influxdb_write
class InfluxdbWrite extends Playbook.TaskBuilder {
    /// Options for community.general.influxdb_write
    options: InfluxdbWriteOptions?
    /// todo doc
    function Task(): InfluxdbWriteTask = this
        .toMap()
        .put("community.general.influxdb_write", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(InfluxdbWriteTask)
}

/// Tweak settings in INI files
/// Manage (add, remove, change) individual settings in an INI-style file without having to manage the file as a whole with, say, M(ansible.builtin.template) or M(ansible.builtin.assemble).
/// Adds missing sections if they don't exist.
/// This module adds missing ending newlines to files to keep in line with the POSIX standard, even when no other modifications need to be applied.
class IniFileOptions {
    /// Allow option without value and without '=' symbol.
    allow_no_value: Boolean?
    /// Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.
    backup: Boolean?
    /// If set to V(false), the module will fail if the file does not already exist.
    /// By default it will create the file if it is missing.
    create: Boolean?
    /// If set to V(true) (default), all matching O(option) lines are removed when O(state=absent), or replaced when O(state=present).
    /// If set to V(false), only the specified O(value)/O(values) are added when O(state=present), or removed when O(state=absent), and existing ones are not modified.
    exclusive: Boolean?
    /// This flag indicates that filesystem links, if they exist, should be followed.
    /// O(follow=true) can modify O(path) when combined with parameters such as O(mode).
    follow: Boolean?
    /// Do not change a line if doing so would only add or remove spaces before or after the V(=) symbol.
    ignore_spaces: Boolean?
    /// By default the module replaces a commented line that matches the given option.
    /// Set this option to V(false) to avoid this. This is useful when you want to keep commented example C(key=value) pairs for documentation purposes.
    modify_inactive_option: Boolean?
    /// Do not insert spaces before and after '=' symbol.
    no_extra_spaces: Boolean?
    /// If set (required for changing a O(value)), this is the name of the option.
    /// May be omitted if adding/removing a whole O(section).
    option: String?
    /// Path to the INI-style file; this file is created if required.
    path: String
    /// Section name in INI file. This is added if O(state=present) automatically when a single value is being set.
    /// If being omitted, the O(option) will be placed before the first O(section).
    /// Omitting O(section) is also required if the config format does not support sections.
    section: String?
    /// Among possibly multiple sections of the same name, select the first one that contains matching options and values.
    /// With O(state=present), if a suitable section is not found, a new section will be added, including the required options.
    /// With O(state=absent), at most one O(section) is removed if it contains the values.
    section_has_values: Listing<Any>?
    /// If set to V(absent) and O(exclusive) set to V(true) all matching O(option) lines are removed.
    /// If set to V(absent) and O(exclusive) set to V(false) the specified O(option=value) lines are removed, but the other O(option)s with the same name are not touched.
    /// If set to V(present) and O(exclusive) set to V(false) the specified O(option=values) lines are added, but the other O(option)s with the same name are not touched.
    /// If set to V(present) and O(exclusive) set to V(true) all given O(option=values) lines will be added and the other O(option)s with the same name are removed.
    state: ("absent"|"present")?
    /// The string value to be associated with an O(option).
    /// May be omitted when removing an O(option).
    /// Mutually exclusive with O(values).
    /// O(value=v) is equivalent to O(values=[v]).
    value: String?
    /// The string value to be associated with an O(option).
    /// May be omitted when removing an O(option).
    /// Mutually exclusive with O(value).
    /// O(value=v) is equivalent to O(values=[v]).
    values: Listing<String>?
}

/// Task class for ini_file
class IniFileTask extends Playbook.Task {
    /// todo doc
    `community.general.ini_file`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ini_file"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ini_file`
}

/// TaskBuilder class for ini_file
class IniFile extends Playbook.TaskBuilder {
    /// Options for community.general.ini_file
    options: IniFileOptions?
    /// todo doc
    function Task(): IniFileTask = this
        .toMap()
        .put("community.general.ini_file", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IniFileTask)
}

/// Manage packages on AIX
/// Manage packages using 'installp' on AIX
class InstallpOptions {
    /// Whether to accept the license for the package(s).
    accept_license: Boolean?
    /// One or more packages to install or remove.
    /// Use V(all) to install all packages available on informed O(repository_path).
    name: Listing<String>
    /// Path with AIX packages (required to install).
    repository_path: String?
    /// Whether the package needs to be present on or absent from the system.
    state: ("absent"|"present")?
}

/// Task class for installp
class InstallpTask extends Playbook.Task {
    /// todo doc
    `community.general.installp`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.installp"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.installp`
}

/// TaskBuilder class for installp
class Installp extends Playbook.TaskBuilder {
    /// Options for community.general.installp
    options: InstallpOptions?
    /// todo doc
    function Task(): InstallpTask = this
        .toMap()
        .put("community.general.installp", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(InstallpTask)
}

/// Tweak settings in C(/etc/network/interfaces) files
/// Manage (add, remove, change) individual interface options in an interfaces-style file without having to manage the file as a whole with, say, M(ansible.builtin.template) or M(ansible.builtin.assemble). Interface has to be presented in a file.
/// Read information about interfaces from interfaces-styled files.
class InterfacesFileOptions {
    /// Address family of the interface, useful if same interface name is used for both V(inet) and V(inet6).
    address_family: String?
    /// Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.
    backup: Boolean?
    /// Path to the interfaces file.
    dest: String?
    /// Name of the interface, required for value changes or option remove.
    iface: String?
    /// Name of the option, required for value changes or option remove.
    option: String?
    /// If set to V(absent) the option or section will be removed if present instead of created.
    state: ("present"|"absent")?
    /// If O(option) is not presented for the O(iface) and O(state) is V(present) option will be added. If O(option) already exists and is not V(pre-up), V(up), V(post-up) or V(down), it's value will be updated. V(pre-up), V(up), V(post-up) and V(down) options cannot be updated, only adding new options, removing existing ones or cleaning the whole option set are supported.
    value: String?
}

/// Task class for interfaces_file
class InterfacesFileTask extends Playbook.Task {
    /// todo doc
    `community.general.interfaces_file`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.interfaces_file"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.interfaces_file`
}

/// TaskBuilder class for interfaces_file
class InterfacesFile extends Playbook.TaskBuilder {
    /// Options for community.general.interfaces_file
    options: InterfacesFileOptions?
    /// todo doc
    function Task(): InterfacesFileTask = this
        .toMap()
        .put("community.general.interfaces_file", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(InterfacesFileTask)
}

/// Manage network namespaces
/// Create or delete network namespaces using the ip command.
class IpNetnsOptions {
    /// Name of the namespace
    name: String?
    /// Whether the namespace should exist
    state: ("present"|"absent")?
}

/// Task class for ip_netns
class IpNetnsTask extends Playbook.Task {
    /// todo doc
    `community.general.ip_netns`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ip_netns"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ip_netns`
}

/// TaskBuilder class for ip_netns
class IpNetns extends Playbook.TaskBuilder {
    /// Options for community.general.ip_netns
    options: IpNetnsOptions?
    /// todo doc
    function Task(): IpNetnsTask = this
        .toMap()
        .put("community.general.ip_netns", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IpNetnsTask)
}

/// Manage Global FreeIPA Configuration Settings
/// Modify global configuration settings of a FreeIPA Server.
class IpaConfigOptions {
    /// Extra hashes to generate in password plug-in.
    ipaconfigstring: Listing<("AllowNThash"|"KDC:Disable Last Success"|"KDC:Disable Lockout"|"KDC:Disable Default Preauth for SPNs")>?
    /// Default e-mail domain for new users.
    ipadefaultemaildomain: String?
    /// Default shell for new users.
    ipadefaultloginshell: String?
    /// Default group for new users.
    ipadefaultprimarygroup: String?
    /// A list of group objectclasses.
    ipagroupobjectclasses: Listing<String>?
    /// A list of fields to search in when searching for groups.
    ipagroupsearchfields: Listing<String>?
    /// Default location of home directories.
    ipahomesrootdir: String?
    /// Default types of PAC supported for services.
    ipakrbauthzdata: Listing<("MS-PAC"|"PAD"|"nfs:NONE")>?
    /// Maximum length of usernames.
    ipamaxusernamelength: Int?
    /// Notice of impending password expiration, in days.
    ipapwdexpadvnotify: Int?
    /// Maximum number of records to search (-1 or 0 is unlimited).
    ipasearchrecordslimit: Int?
    /// Maximum amount of time (seconds) for a search (-1 or 0 is unlimited).
    ipasearchtimelimit: Int?
    /// The SELinux user map order (order in increasing priority of SELinux users).
    ipaselinuxusermaporder: Listing<String>?
    /// The authentication type to use by default.
    /// The choice V(idp) has been added in community.general 7.3.0.
    /// The choice V(passkey) has been added in community.general 8.1.0.
    ipauserauthtype: Listing<("password"|"radius"|"otp"|"pkinit"|"hardened"|"idp"|"passkey"|"disabled")>?
    /// A list of user objectclasses.
    ipauserobjectclasses: Listing<String>?
    /// A list of fields to search in when searching for users.
    ipausersearchfields: Listing<String>?
}

/// Task class for ipa_config
class IpaConfigTask extends Playbook.Task {
    /// todo doc
    `community.general.ipa_config`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ipa_config"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ipa_config`
}

/// TaskBuilder class for ipa_config
class IpaConfig extends Playbook.TaskBuilder {
    /// Options for community.general.ipa_config
    options: IpaConfigOptions?
    /// todo doc
    function Task(): IpaConfigTask = this
        .toMap()
        .put("community.general.ipa_config", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IpaConfigTask)
}

/// Manage FreeIPA DNS records
/// Add, modify and delete an IPA DNS Record using IPA API.
class IpaDnsrecordOptions {
    /// The DNS record name to manage.
    record_name: String
    /// Set the TTL for the record.
    /// Applies only when adding a new or changing the value of O(record_value) or O(record_values).
    record_ttl: Int?
    /// The type of DNS record name.
    /// Currently, 'A', 'AAAA', 'A6', 'CNAME', 'DNAME', 'NS', 'PTR', 'TXT', 'SRV' and 'MX' are supported.
    /// 'A6', 'CNAME', 'DNAME' and 'TXT' are added in version 2.5.
    /// 'SRV' and 'MX' are added in version 2.8.
    /// 'NS' are added in comunity.general 8.2.0.
    record_type: ("A"|"AAAA"|"A6"|"CNAME"|"DNAME"|"MX"|"NS"|"PTR"|"SRV"|"TXT")?
    /// Manage DNS record name with this value.
    /// Mutually exclusive with O(record_values), and exactly one of O(record_value) and O(record_values) has to be specified.
    /// Use O(record_values) if you need to specify multiple values.
    /// In the case of 'A' or 'AAAA' record types, this will be the IP address.
    /// In the case of 'A6' record type, this will be the A6 Record data.
    /// In the case of 'CNAME' record type, this will be the hostname.
    /// In the case of 'DNAME' record type, this will be the DNAME target.
    /// In the case of 'NS' record type, this will be the name server hostname. Hostname must already have a valid A or AAAA record.
    /// In the case of 'PTR' record type, this will be the hostname.
    /// In the case of 'TXT' record type, this will be a text.
    /// In the case of 'SRV' record type, this will be a service record.
    /// In the case of 'MX' record type, this will be a mail exchanger record.
    record_value: String?
    /// Manage DNS record name with this value.
    /// Mutually exclusive with O(record_value), and exactly one of O(record_value) and O(record_values) has to be specified.
    /// In the case of 'A' or 'AAAA' record types, this will be the IP address.
    /// In the case of 'A6' record type, this will be the A6 Record data.
    /// In the case of 'CNAME' record type, this will be the hostname.
    /// In the case of 'DNAME' record type, this will be the DNAME target.
    /// In the case of 'NS' record type, this will be the name server hostname. Hostname must already have a valid A or AAAA record.
    /// In the case of 'PTR' record type, this will be the hostname.
    /// In the case of 'TXT' record type, this will be a text.
    /// In the case of 'SRV' record type, this will be a service record.
    /// In the case of 'MX' record type, this will be a mail exchanger record.
    record_values: Listing<String>?
    /// State to ensure
    state: ("absent"|"present")?
    /// The DNS zone name to which DNS record needs to be managed.
    zone_name: String
}

/// Task class for ipa_dnsrecord
class IpaDnsrecordTask extends Playbook.Task {
    /// todo doc
    `community.general.ipa_dnsrecord`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ipa_dnsrecord"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ipa_dnsrecord`
}

/// TaskBuilder class for ipa_dnsrecord
class IpaDnsrecord extends Playbook.TaskBuilder {
    /// Options for community.general.ipa_dnsrecord
    options: IpaDnsrecordOptions?
    /// todo doc
    function Task(): IpaDnsrecordTask = this
        .toMap()
        .put("community.general.ipa_dnsrecord", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IpaDnsrecordTask)
}

/// Manage FreeIPA DNS Zones
/// Add and delete an IPA DNS Zones using IPA API
class IpaDnszoneOptions {
    /// Allow synchronization of forward and reverse records in the zone.
    allowsyncptr: Boolean?
    /// Apply dynamic update to zone.
    dynamicupdate: Boolean?
    /// State to ensure
    state: ("absent"|"present")?
    /// The DNS zone name to which needs to be managed.
    zone_name: String
}

/// Task class for ipa_dnszone
class IpaDnszoneTask extends Playbook.Task {
    /// todo doc
    `community.general.ipa_dnszone`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ipa_dnszone"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ipa_dnszone`
}

/// TaskBuilder class for ipa_dnszone
class IpaDnszone extends Playbook.TaskBuilder {
    /// Options for community.general.ipa_dnszone
    options: IpaDnszoneOptions?
    /// todo doc
    function Task(): IpaDnszoneTask = this
        .toMap()
        .put("community.general.ipa_dnszone", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IpaDnszoneTask)
}

/// Manage FreeIPA group
/// Add, modify and delete group within IPA server
class IpaGroupOptions {
    /// If V(true), add the listed O(user) and O(group) to the group members.
    /// If V(false), only the listed O(user) and O(group) will be group members, removing any other members.
    append: Boolean?
    /// Canonical name.
    /// Can not be changed as it is the unique identifier.
    cn: String
    /// Description of the group.
    description: String?
    /// Allow adding external non-IPA members from trusted domains.
    `external`: Boolean?
    /// List of external users assigned to this group.
    /// Behaves identically to O(user) with respect to O(append) attribute.
    /// List entries can be in V(DOMAIN\\\\username) or SID format.
    /// Unless SIDs are provided, the module will always attempt to make changes even if the group already has all the users. This is because only SIDs are returned by IPA query.
    /// O(external=true) is needed for this option to work.
    external_user: Listing<String>?
    /// GID (use this option to set it manually).
    gidnumber: String?
    /// List of group names assigned to this group.
    /// If O(append=false) and an empty list is passed all groups will be removed from this group.
    /// Groups that are already assigned but not passed will be removed.
    /// If O(append=true) the listed groups will be assigned without removing other groups.
    /// If option is omitted assigned groups will not be checked or changed.
    group: Listing<String>?
    /// Create as a non-POSIX group.
    nonposix: Boolean?
    /// State to ensure
    state: ("absent"|"present")?
    /// List of user names assigned to this group.
    /// If O(append=false) and an empty list is passed all users will be removed from this group.
    /// Users that are already assigned but not passed will be removed.
    /// If O(append=true) the listed users will be assigned without removing other users.
    /// If option is omitted assigned users will not be checked or changed.
    user: Listing<String>?
}

/// Task class for ipa_group
class IpaGroupTask extends Playbook.Task {
    /// todo doc
    `community.general.ipa_group`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ipa_group"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ipa_group`
}

/// TaskBuilder class for ipa_group
class IpaGroup extends Playbook.TaskBuilder {
    /// Options for community.general.ipa_group
    options: IpaGroupOptions?
    /// todo doc
    function Task(): IpaGroupTask = this
        .toMap()
        .put("community.general.ipa_group", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IpaGroupTask)
}

/// Manage FreeIPA HBAC rule
/// Add, modify or delete an IPA HBAC rule using IPA API.
class IpaHbacruleOptions {
    /// Canonical name.
    /// Can not be changed as it is the unique identifier.
    cn: String
    /// Description
    description: String?
    /// List of host names to assign.
    /// If an empty list is passed all hosts will be removed from the rule.
    /// If option is omitted hosts will not be checked or changed.
    host: Listing<String>?
    /// Host category
    hostcategory: ("all")?
    /// List of hostgroup names to assign.
    /// If an empty list is passed all hostgroups will be removed. from the rule
    /// If option is omitted hostgroups will not be checked or changed.
    hostgroup: Listing<String>?
    /// List of service names to assign.
    /// If an empty list is passed all services will be removed from the rule.
    /// If option is omitted services will not be checked or changed.
    service: Listing<String>?
    /// Service category
    servicecategory: ("all")?
    /// List of service group names to assign.
    /// If an empty list is passed all assigned service groups will be removed from the rule.
    /// If option is omitted service groups will not be checked or changed.
    servicegroup: Listing<String>?
    /// List of source host names to assign.
    /// If an empty list if passed all assigned source hosts will be removed from the rule.
    /// If option is omitted source hosts will not be checked or changed.
    sourcehost: Listing<String>?
    /// Source host category
    sourcehostcategory: ("all")?
    /// List of source host group names to assign.
    /// If an empty list if passed all assigned source host groups will be removed from the rule.
    /// If option is omitted source host groups will not be checked or changed.
    sourcehostgroup: Listing<String>?
    /// State to ensure
    state: ("absent"|"disabled"|"enabled"|"present")?
    /// List of user names to assign.
    /// If an empty list if passed all assigned users will be removed from the rule.
    /// If option is omitted users will not be checked or changed.
    user: Listing<String>?
    /// User category
    usercategory: ("all")?
    /// List of user group names to assign.
    /// If an empty list if passed all assigned user groups will be removed from the rule.
    /// If option is omitted user groups will not be checked or changed.
    usergroup: Listing<String>?
}

/// Task class for ipa_hbacrule
class IpaHbacruleTask extends Playbook.Task {
    /// todo doc
    `community.general.ipa_hbacrule`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ipa_hbacrule"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ipa_hbacrule`
}

/// TaskBuilder class for ipa_hbacrule
class IpaHbacrule extends Playbook.TaskBuilder {
    /// Options for community.general.ipa_hbacrule
    options: IpaHbacruleOptions?
    /// todo doc
    function Task(): IpaHbacruleTask = this
        .toMap()
        .put("community.general.ipa_hbacrule", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IpaHbacruleTask)
}

/// Manage FreeIPA host
/// Add, modify and delete an IPA host using IPA API.
class IpaHostOptions {
    /// A description of this host.
    description: String?
    /// Force host name even if not in DNS.
    force: Boolean?
    /// Full qualified domain name.
    /// Can not be changed as it is the unique identifier.
    fqdn: String
    /// Add the host to DNS with this IP address.
    ip_address: String?
    /// List of Hardware MAC address(es) off this host.
    /// If option is omitted MAC addresses will not be checked or changed.
    /// If an empty list is passed all assigned MAC addresses will be removed.
    /// MAC addresses that are already assigned but not passed will be removed.
    mac_address: Listing<String>?
    /// Host hardware platform (e.g. "Lenovo T61")
    ns_hardware_platform: String?
    /// Host location (e.g. "Lab 2")
    ns_host_location: String?
    /// Host operating system and version (e.g. "Fedora 9")
    ns_os_version: String?
    /// Generate a random password to be used in bulk enrollment.
    random_password: Boolean?
    /// State to ensure.
    state: ("absent"|"disabled"|"enabled"|"present")?
    /// If set V(true) with O(state=absent), then removes DNS records of the host managed by FreeIPA DNS.
    /// This option has no effect for states other than "absent".
    update_dns: Boolean?
    /// List of Base-64 encoded server certificates.
    /// If option is omitted certificates will not be checked or changed.
    /// If an empty list is passed all assigned certificates will be removed.
    /// Certificates already assigned but not passed will be removed.
    user_certificate: Listing<String>?
}

/// Task class for ipa_host
class IpaHostTask extends Playbook.Task {
    /// todo doc
    `community.general.ipa_host`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ipa_host"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ipa_host`
}

/// TaskBuilder class for ipa_host
class IpaHost extends Playbook.TaskBuilder {
    /// Options for community.general.ipa_host
    options: IpaHostOptions?
    /// todo doc
    function Task(): IpaHostTask = this
        .toMap()
        .put("community.general.ipa_host", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IpaHostTask)
}

/// Manage FreeIPA host-group
/// Add, modify and delete an IPA host-group using IPA API.
class IpaHostgroupOptions {
    /// If V(true), add the listed O(host) to the O(hostgroup).
    /// If V(false), only the listed O(host) will be in O(hostgroup), removing any other hosts.
    append: Boolean?
    /// Name of host-group.
    /// Can not be changed as it is the unique identifier.
    cn: String
    /// Description.
    description: String?
    /// List of hosts that belong to the host-group.
    /// If an empty list is passed all hosts will be removed from the group.
    /// If option is omitted hosts will not be checked or changed.
    /// If option is passed all assigned hosts that are not passed will be unassigned from the group.
    host: Listing<String>?
    /// List of host-groups than belong to that host-group.
    /// If an empty list is passed all host-groups will be removed from the group.
    /// If option is omitted host-groups will not be checked or changed.
    /// If option is passed all assigned hostgroups that are not passed will be unassigned from the group.
    hostgroup: Listing<String>?
    /// State to ensure.
    state: ("absent"|"disabled"|"enabled"|"present")?
}

/// Task class for ipa_hostgroup
class IpaHostgroupTask extends Playbook.Task {
    /// todo doc
    `community.general.ipa_hostgroup`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ipa_hostgroup"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ipa_hostgroup`
}

/// TaskBuilder class for ipa_hostgroup
class IpaHostgroup extends Playbook.TaskBuilder {
    /// Options for community.general.ipa_hostgroup
    options: IpaHostgroupOptions?
    /// todo doc
    function Task(): IpaHostgroupTask = this
        .toMap()
        .put("community.general.ipa_hostgroup", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IpaHostgroupTask)
}

/// Manage FreeIPA OTP Configuration Settings
/// Modify global configuration settings of a FreeIPA Server with respect to OTP (One Time Passwords).
class IpaOtpconfigOptions {
    /// HOTP authentication window in number of hops.
    ipatokenhotpauthwindow: Int?
    /// HOTP synchronization window in hops.
    ipatokenhotpsyncwindow: Int?
    /// TOTP authentication window in seconds.
    ipatokentotpauthwindow: Int?
    /// TOTP synchronization window in seconds.
    ipatokentotpsyncwindow: Int?
}

/// Task class for ipa_otpconfig
class IpaOtpconfigTask extends Playbook.Task {
    /// todo doc
    `community.general.ipa_otpconfig`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ipa_otpconfig"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ipa_otpconfig`
}

/// TaskBuilder class for ipa_otpconfig
class IpaOtpconfig extends Playbook.TaskBuilder {
    /// Options for community.general.ipa_otpconfig
    options: IpaOtpconfigOptions?
    /// todo doc
    function Task(): IpaOtpconfigTask = this
        .toMap()
        .put("community.general.ipa_otpconfig", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IpaOtpconfigTask)
}

/// Manage FreeIPA OTPs
/// Add, modify, and delete One Time Passwords in IPA.
class IpaOtptokenOptions {
    /// Token hash algorithm.
    /// B(Note:) Cannot be modified after OTP is created.
    algorithm: ("sha1"|"sha256"|"sha384"|"sha512")?
    /// Initial counter for the HOTP token.
    /// B(Note:) Cannot be modified after OTP is created.
    counter: Int?
    /// Description of the token (informational only).
    description: String?
    /// Number of digits each token code will have.
    /// B(Note:) Cannot be modified after OTP is created.
    digits: Int?
    /// Mark the token as enabled (default V(true)).
    enabled: Boolean?
    /// Length of TOTP token code validity in seconds.
    /// B(Note:) Cannot be modified after OTP is created.
    interval: Int?
    /// Token model (informational only).
    model: String?
    /// If specified, the unique id specified will be changed to this.
    newuniqueid: String?
    /// Last date/time the token can be used.
    /// In the format C(YYYYMMddHHmmss).
    /// For example, C(20200121182022) will allow the token to be used until 21 January 2020 at 18:20:22.
    notafter: String?
    /// First date/time the token can be used.
    /// In the format C(YYYYMMddHHmmss).
    /// For example, C(20180121182022) will allow the token to be used starting on 21 January 2018 at 18:20:22.
    notbefore: String?
    /// TOTP token / IPA server time difference.
    /// B(Note:) Cannot be modified after OTP is created.
    offset: Int?
    /// Type of OTP.
    /// B(Note:) Cannot be modified after OTP is created.
    otptype: ("totp"|"hotp")?
    /// Assigned user of the token.
    owner: String?
    /// Token secret (Base64).
    /// If OTP is created and this is not specified, a random secret will be generated by IPA.
    /// B(Note:) Cannot be modified after OTP is created.
    secretkey: String?
    /// Token serial (informational only).
    serial: String?
    /// State to ensure.
    state: ("present"|"absent")?
    /// Unique ID of the token in IPA.
    uniqueid: String
    /// Token vendor name (informational only).
    vendor: String?
}

/// Task class for ipa_otptoken
class IpaOtptokenTask extends Playbook.Task {
    /// todo doc
    `community.general.ipa_otptoken`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ipa_otptoken"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ipa_otptoken`
}

/// TaskBuilder class for ipa_otptoken
class IpaOtptoken extends Playbook.TaskBuilder {
    /// Options for community.general.ipa_otptoken
    options: IpaOtptokenOptions?
    /// todo doc
    function Task(): IpaOtptokenTask = this
        .toMap()
        .put("community.general.ipa_otptoken", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IpaOtptokenTask)
}

/// Manage FreeIPA password policies
/// Add, modify, or delete a password policy using the IPA API.
class IpaPwpolicyOptions {
    /// Check whether the password (with possible modifications) matches a word in a dictionary (using cracklib).
    dictcheck: Boolean?
    /// Period (in seconds) after which the number of failed login attempts is reset.
    failinterval: String?
    /// Maximum number of LDAP logins after password expiration.
    gracelimit: Int?
    /// Name of the group that the policy applies to.
    /// If omitted, the global policy is used.
    group: String?
    /// Number of previous passwords that are remembered.
    /// Users cannot reuse remembered passwords.
    historylength: String?
    /// Period (in seconds) for which users are locked out.
    lockouttime: String?
    /// Maximum number of consecutive failures before lockout.
    maxfailcount: String?
    /// Maximum password lifetime (in days).
    maxpwdlife: String?
    /// Maximum number of allowed same consecutive characters in the new password.
    maxrepeat: Int?
    /// Maximum length of monotonic character sequences in the new password. An example of a monotonic sequence of length 5 is V(12345).
    maxsequence: Int?
    /// Minimum number of character classes.
    minclasses: String?
    /// Minimum password length.
    minlength: String?
    /// Minimum password lifetime (in hours).
    minpwdlife: String?
    /// Priority of the policy.
    /// High number means lower priority.
    /// Required when C(cn) is not the global policy.
    priority: String?
    /// State to ensure.
    state: ("absent"|"present")?
    /// Check whether the password (with possible modifications) contains the user name in some form (if the name has > 3 characters).
    usercheck: Boolean?
}

/// Task class for ipa_pwpolicy
class IpaPwpolicyTask extends Playbook.Task {
    /// todo doc
    `community.general.ipa_pwpolicy`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ipa_pwpolicy"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ipa_pwpolicy`
}

/// TaskBuilder class for ipa_pwpolicy
class IpaPwpolicy extends Playbook.TaskBuilder {
    /// Options for community.general.ipa_pwpolicy
    options: IpaPwpolicyOptions?
    /// todo doc
    function Task(): IpaPwpolicyTask = this
        .toMap()
        .put("community.general.ipa_pwpolicy", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IpaPwpolicyTask)
}

/// Manage FreeIPA role
/// Add, modify and delete a role within FreeIPA server using FreeIPA API.
class IpaRoleOptions {
    /// Role name.
    /// Can not be changed as it is the unique identifier.
    cn: String
    /// A description of this role-group.
    description: String?
    /// List of group names assign to this role.
    /// If an empty list is passed all assigned groups will be unassigned from the role.
    /// If option is omitted groups will not be checked or changed.
    /// If option is passed all assigned groups that are not passed will be unassigned from the role.
    group: Listing<String>?
    /// List of host names to assign.
    /// If an empty list is passed all assigned hosts will be unassigned from the role.
    /// If option is omitted hosts will not be checked or changed.
    /// If option is passed all assigned hosts that are not passed will be unassigned from the role.
    host: Listing<String>?
    /// List of host group names to assign.
    /// If an empty list is passed all assigned host groups will be removed from the role.
    /// If option is omitted host groups will not be checked or changed.
    /// If option is passed all assigned hostgroups that are not passed will be unassigned from the role.
    hostgroup: Listing<String>?
    /// List of privileges granted to the role.
    /// If an empty list is passed all assigned privileges will be removed.
    /// If option is omitted privileges will not be checked or changed.
    /// If option is passed all assigned privileges that are not passed will be removed.
    privilege: Listing<String>?
    /// List of service names to assign.
    /// If an empty list is passed all assigned services will be removed from the role.
    /// If option is omitted services will not be checked or changed.
    /// If option is passed all assigned services that are not passed will be removed from the role.
    service: Listing<String>?
    /// State to ensure.
    state: ("absent"|"present")?
    /// List of user names to assign.
    /// If an empty list is passed all assigned users will be removed from the role.
    /// If option is omitted users will not be checked or changed.
    user: Listing<String>?
}

/// Task class for ipa_role
class IpaRoleTask extends Playbook.Task {
    /// todo doc
    `community.general.ipa_role`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ipa_role"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ipa_role`
}

/// TaskBuilder class for ipa_role
class IpaRole extends Playbook.TaskBuilder {
    /// Options for community.general.ipa_role
    options: IpaRoleOptions?
    /// todo doc
    function Task(): IpaRoleTask = this
        .toMap()
        .put("community.general.ipa_role", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IpaRoleTask)
}

/// Manage FreeIPA service
/// Add and delete an IPA service using IPA API.
class IpaServiceOptions {
    /// Force principal name even if host is not in DNS.
    force: Boolean?
    /// Defines the list of 'ManagedBy' hosts.
    hosts: Listing<String>?
    /// Principal of the service.
    /// Can not be changed as it is the unique identifier.
    krbcanonicalname: String
    /// Force service to be created even when host object does not exist to manage it.
    /// This is only used on creation, not for updating existing services.
    skip_host_check: Boolean?
    /// State to ensure.
    state: ("absent"|"present")?
}

/// Task class for ipa_service
class IpaServiceTask extends Playbook.Task {
    /// todo doc
    `community.general.ipa_service`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ipa_service"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ipa_service`
}

/// TaskBuilder class for ipa_service
class IpaService extends Playbook.TaskBuilder {
    /// Options for community.general.ipa_service
    options: IpaServiceOptions?
    /// todo doc
    function Task(): IpaServiceTask = this
        .toMap()
        .put("community.general.ipa_service", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IpaServiceTask)
}

/// Manage FreeIPA Lightweight Sub Certificate Authorities
/// Add, modify, enable, disable and delete an IPA Lightweight Sub Certificate Authorities using IPA API.
class IpaSubcaOptions {
    /// State to ensure.
    /// State 'disable' and 'enable' is available for FreeIPA 4.4.2 version and onwards.
    state: ("absent"|"disabled"|"enabled"|"present")?
    /// The Sub Certificate Authority's description.
    subca_desc: String?
    /// The Sub Certificate Authority name which needs to be managed.
    subca_name: String
    /// The Sub Certificate Authority's Subject. e.g., 'CN=SampleSubCA1,O=testrelm.test'.
    subca_subject: String
}

/// Task class for ipa_subca
class IpaSubcaTask extends Playbook.Task {
    /// todo doc
    `community.general.ipa_subca`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ipa_subca"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ipa_subca`
}

/// TaskBuilder class for ipa_subca
class IpaSubca extends Playbook.TaskBuilder {
    /// Options for community.general.ipa_subca
    options: IpaSubcaOptions?
    /// todo doc
    function Task(): IpaSubcaTask = this
        .toMap()
        .put("community.general.ipa_subca", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IpaSubcaTask)
}

/// Manage FreeIPA sudo command
/// Add, modify or delete sudo command within FreeIPA server using FreeIPA API.
class IpaSudocmdOptions {
    /// A description of this command.
    description: String?
    /// State to ensure.
    state: ("absent"|"disabled"|"enabled"|"present")?
    /// Sudo command.
    sudocmd: String
}

/// Task class for ipa_sudocmd
class IpaSudocmdTask extends Playbook.Task {
    /// todo doc
    `community.general.ipa_sudocmd`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ipa_sudocmd"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ipa_sudocmd`
}

/// TaskBuilder class for ipa_sudocmd
class IpaSudocmd extends Playbook.TaskBuilder {
    /// Options for community.general.ipa_sudocmd
    options: IpaSudocmdOptions?
    /// todo doc
    function Task(): IpaSudocmdTask = this
        .toMap()
        .put("community.general.ipa_sudocmd", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IpaSudocmdTask)
}

/// Manage FreeIPA sudo command group
/// Add, modify or delete sudo command group within IPA server using IPA API.
class IpaSudocmdgroupOptions {
    /// Sudo Command Group.
    cn: String
    /// Group description.
    description: String?
    /// State to ensure.
    state: ("absent"|"disabled"|"enabled"|"present")?
    /// List of sudo commands to assign to the group.
    /// If an empty list is passed all assigned commands will be removed from the group.
    /// If option is omitted sudo commands will not be checked or changed.
    sudocmd: Listing<String>?
}

/// Task class for ipa_sudocmdgroup
class IpaSudocmdgroupTask extends Playbook.Task {
    /// todo doc
    `community.general.ipa_sudocmdgroup`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ipa_sudocmdgroup"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ipa_sudocmdgroup`
}

/// TaskBuilder class for ipa_sudocmdgroup
class IpaSudocmdgroup extends Playbook.TaskBuilder {
    /// Options for community.general.ipa_sudocmdgroup
    options: IpaSudocmdgroupOptions?
    /// todo doc
    function Task(): IpaSudocmdgroupTask = this
        .toMap()
        .put("community.general.ipa_sudocmdgroup", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IpaSudocmdgroupTask)
}

/// Manage FreeIPA sudo rule
/// Add, modify or delete sudo rule within IPA server using IPA API.
class IpaSudoruleOptions {
    /// List of commands assigned to the rule.
    /// If an empty list is passed all commands will be removed from the rule.
    /// If option is omitted commands will not be checked or changed.
    cmd: Listing<String>?
    /// Command category the rule applies to.
    cmdcategory: ("all")?
    /// List of command groups assigned to the rule.
    /// If an empty list is passed all command groups will be removed from the rule.
    /// If option is omitted command groups will not be checked or changed.
    cmdgroup: Listing<String>?
    /// Canonical name.
    /// Can not be changed as it is the unique identifier.
    cn: String
    /// List of denied commands assigned to the rule.
    /// If an empty list is passed all commands will be removed from the rule.
    /// If option is omitted commands will not be checked or changed.
    deny_cmd: Listing<String>?
    /// List of denied command groups assigned to the rule.
    /// If an empty list is passed all command groups will be removed from the rule.
    /// If option is omitted command groups will not be checked or changed.
    deny_cmdgroup: Listing<String>?
    /// Description of the sudo rule.
    description: String?
    /// List of hosts assigned to the rule.
    /// If an empty list is passed all hosts will be removed from the rule.
    /// If option is omitted hosts will not be checked or changed.
    /// Option O(hostcategory) must be omitted to assign hosts.
    host: Listing<String>?
    /// Host category the rule applies to.
    /// If V(all) is passed one must omit O(host) and O(hostgroup).
    /// Option O(host) and O(hostgroup) must be omitted to assign V(all).
    hostcategory: ("all")?
    /// List of host groups assigned to the rule.
    /// If an empty list is passed all host groups will be removed from the rule.
    /// If option is omitted host groups will not be checked or changed.
    /// Option O(hostcategory) must be omitted to assign host groups.
    hostgroup: Listing<String>?
    /// List of external RunAs users
    runasextusers: Listing<String>?
    /// RunAs Group category the rule applies to.
    runasgroupcategory: ("all")?
    /// RunAs User category the rule applies to.
    runasusercategory: ("all")?
    /// State to ensure.
    state: ("absent"|"disabled"|"enabled"|"present")?
    /// List of options to add to the sudo rule.
    sudoopt: Listing<String>?
    /// List of users assigned to the rule.
    /// If an empty list is passed all users will be removed from the rule.
    /// If option is omitted users will not be checked or changed.
    user: Listing<String>?
    /// User category the rule applies to.
    usercategory: ("all")?
    /// List of user groups assigned to the rule.
    /// If an empty list is passed all user groups will be removed from the rule.
    /// If option is omitted user groups will not be checked or changed.
    usergroup: Listing<String>?
}

/// Task class for ipa_sudorule
class IpaSudoruleTask extends Playbook.Task {
    /// todo doc
    `community.general.ipa_sudorule`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ipa_sudorule"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ipa_sudorule`
}

/// TaskBuilder class for ipa_sudorule
class IpaSudorule extends Playbook.TaskBuilder {
    /// Options for community.general.ipa_sudorule
    options: IpaSudoruleOptions?
    /// todo doc
    function Task(): IpaSudoruleTask = this
        .toMap()
        .put("community.general.ipa_sudorule", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IpaSudoruleTask)
}

/// Manage FreeIPA users
/// Add, modify and delete user within IPA server.
class IpaUserOptions {
    /// Display name.
    displayname: String?
    /// Posix Group ID.
    gidnumber: String?
    /// First name.
    /// If user does not exist and O(state=present), the usage of O(givenname) is required.
    givenname: String?
    /// Default home directory of the user.
    homedirectory: String?
    /// Date at which the user password will expire.
    /// In the format YYYYMMddHHmmss.
    /// e.g. 20180121182022 will expire on 21 January 2018 at 18:20:22.
    krbpasswordexpiration: String?
    /// Login shell.
    loginshell: String?
    /// List of mail addresses assigned to the user.
    /// If an empty list is passed all assigned email addresses will be deleted.
    /// If None is passed email addresses will not be checked or changed.
    mail: Listing<String>?
    /// Password for a user.
    /// Will not be set for an existing user unless O(update_password=always), which is the default.
    password: String?
    /// Surname.
    /// If user does not exist and O(state=present), the usage of O(sn) is required.
    sn: String?
    /// List of public SSH key.
    /// If an empty list is passed all assigned public keys will be deleted.
    /// If None is passed SSH public keys will not be checked or changed.
    sshpubkey: Listing<String>?
    /// State to ensure.
    state: ("absent"|"disabled"|"enabled"|"present")?
    /// List of telephone numbers assigned to the user.
    /// If an empty list is passed all assigned telephone numbers will be deleted.
    /// If None is passed telephone numbers will not be checked or changed.
    telephonenumber: Listing<String>?
    /// Title.
    title: String?
    /// uid of the user.
    uid: String
    /// Account Settings UID/Posix User ID number.
    uidnumber: String?
    /// Set password for a user.
    update_password: ("always"|"on_create")?
    /// The authentication type to use for the user.
    /// To remove all authentication types from the user, use an empty list V([]).
    /// The choice V(idp) and V(passkey) has been added in community.general 8.1.0.
    userauthtype: Listing<("password"|"radius"|"otp"|"pkinit"|"hardened"|"idp"|"passkey")>?
}

/// Task class for ipa_user
class IpaUserTask extends Playbook.Task {
    /// todo doc
    `community.general.ipa_user`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ipa_user"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ipa_user`
}

/// TaskBuilder class for ipa_user
class IpaUser extends Playbook.TaskBuilder {
    /// Options for community.general.ipa_user
    options: IpaUserOptions?
    /// todo doc
    function Task(): IpaUserTask = this
        .toMap()
        .put("community.general.ipa_user", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IpaUserTask)
}

/// Manage FreeIPA vaults
/// Add, modify and delete vaults and secret vaults.
/// KRA service should be enabled to use this module.
class IpaVaultOptions {
    /// Vault name.
    /// Can not be changed as it is the unique identifier.
    cn: String
    /// Description.
    description: String?
    /// Public key.
    ipavaultpublickey: String?
    /// Vault Salt.
    ipavaultsalt: String?
    /// Vault types are based on security level.
    ipavaulttype: ("asymmetric"|"standard"|"symmetric")?
    /// Force replace the existent vault on IPA server.
    replace: Boolean?
    /// Any service can own one or more service vaults.
    /// Mutually exclusive with user.
    service: String?
    /// State to ensure.
    state: ("absent"|"present")?
    /// Any user can own one or more user vaults.
    /// Mutually exclusive with service.
    username: Listing<String>?
    /// Validate IPA server certificates.
    validate_certs: Boolean?
}

/// Task class for ipa_vault
class IpaVaultTask extends Playbook.Task {
    /// todo doc
    `community.general.ipa_vault`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ipa_vault"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ipa_vault`
}

/// TaskBuilder class for ipa_vault
class IpaVault extends Playbook.TaskBuilder {
    /// Options for community.general.ipa_vault
    options: IpaVaultOptions?
    /// todo doc
    function Task(): IpaVaultTask = this
        .toMap()
        .put("community.general.ipa_vault", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IpaVaultTask)
}

/// Retrieve IP geolocation and other facts of a host's IP address using the ipbase.com API
/// Retrieve IP geolocation and other facts of a host's IP address using the ipbase.com API
class IpbaseInfoOptions {
    /// The API key for the request if you need more requests.
    apikey: String?
    /// If the O(hostname) parameter is set to V(true), the API response will contain the hostname of the IP.
    hostname: Boolean?
    /// The IP you want to get the info for. If not specified the API will detect the IP automatically.
    ip: String?
    /// An ISO Alpha 2 Language Code for localizing the IP data
    language: String?
}

/// Task class for ipbase_info
class IpbaseInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.ipbase_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ipbase_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ipbase_info`
}

/// TaskBuilder class for ipbase_info
class IpbaseInfo extends Playbook.TaskBuilder {
    /// Options for community.general.ipbase_info
    options: IpbaseInfoOptions?
    /// todo doc
    function Task(): IpbaseInfoTask = this
        .toMap()
        .put("community.general.ipbase_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IpbaseInfoTask)
}

/// Retrieve the public IP of your internet gateway
/// If behind NAT and need to know the public IP of your internet gateway.
class IpifyFactsOptions {
    /// URL of the ipify.org API service.
    /// C(?format=json) will be appended per default.
    api_url: String?
    /// HTTP connection timeout in seconds.
    timeout: Int?
    /// When set to V(false), SSL certificates will not be validated.
    validate_certs: Boolean?
}

/// Task class for ipify_facts
class IpifyFactsTask extends Playbook.Task {
    /// todo doc
    `community.general.ipify_facts`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ipify_facts"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ipify_facts`
}

/// TaskBuilder class for ipify_facts
class IpifyFacts extends Playbook.TaskBuilder {
    /// Options for community.general.ipify_facts
    options: IpifyFactsOptions?
    /// todo doc
    function Task(): IpifyFactsTask = this
        .toMap()
        .put("community.general.ipify_facts", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IpifyFactsTask)
}

/// Retrieve IP geolocation facts of a host's IP address
/// Gather IP geolocation facts of a host's IP address using ipinfo.io API
class IpinfoioFactsOptions {
    /// Set http user agent
    http_agent: String?
    /// HTTP connection timeout in seconds
    timeout: Int?
}

/// Task class for ipinfoio_facts
class IpinfoioFactsTask extends Playbook.Task {
    /// todo doc
    `community.general.ipinfoio_facts`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ipinfoio_facts"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ipinfoio_facts`
}

/// TaskBuilder class for ipinfoio_facts
class IpinfoioFacts extends Playbook.TaskBuilder {
    /// Options for community.general.ipinfoio_facts
    options: IpinfoioFactsOptions?
    /// todo doc
    function Task(): IpinfoioFactsTask = this
        .toMap()
        .put("community.general.ipinfoio_facts", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IpinfoioFactsTask)
}

/// Management of order of boot devices
/// Use this module to manage order of boot devices
class IpmiBootOptions {
    /// Set boot device to use on next reboot
    /// The choices for the device are: - network -- Request network boot - floppy -- Boot from floppy - hd -- Boot from hard drive - safe -- Boot from hard drive, requesting 'safe mode' - optical -- boot from CD/DVD/BD drive - setup -- Boot into setup utility - default -- remove any IPMI directed boot device request
    bootdev: ("network"|"floppy"|"hd"|"safe"|"optical"|"setup"|"default")
    /// Encryption key to connect to the BMC in hex format.
    key: String?
    /// Hostname or ip address of the BMC.
    name: String
    /// Password to connect to the BMC.
    password: String
    /// If set, ask that system firmware uses this device beyond next boot. Be aware many systems do not honor this.
    persistent: Boolean?
    /// Remote RMCP port.
    port: Int?
    /// Whether to ensure that boot devices is desired.
    /// The choices for the state are: - present -- Request system turn on - absent -- Request system turn on
    state: ("present"|"absent")?
    /// If set, request UEFI boot explicitly. Strictly speaking, the spec suggests that if not set, the system should BIOS boot and offers no "don't care" option. In practice, this flag not being set does not preclude UEFI boot on any system I've encountered.
    uefiboot: Boolean?
    /// Username to use to connect to the BMC.
    user: String
}

/// Task class for ipmi_boot
class IpmiBootTask extends Playbook.Task {
    /// todo doc
    `community.general.ipmi_boot`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ipmi_boot"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ipmi_boot`
}

/// TaskBuilder class for ipmi_boot
class IpmiBoot extends Playbook.TaskBuilder {
    /// Options for community.general.ipmi_boot
    options: IpmiBootOptions?
    /// todo doc
    function Task(): IpmiBootTask = this
        .toMap()
        .put("community.general.ipmi_boot", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IpmiBootTask)
}

/// Power management for machine
/// Use this module for power management
class IpmiPowerOptions {
    /// Encryption key to connect to the BMC in hex format.
    key: String?
    /// Provide a list of the remote target address for the bridge IPMI request, and the power status.
    /// Either this option or O(state) is required.
    machine: Listing<Any>?
    /// Hostname or ip address of the BMC.
    name: String
    /// Password to connect to the BMC.
    password: String
    /// Remote RMCP port.
    port: Int?
    /// Whether to ensure that the machine in desired state.
    /// The choices for state are: - on -- Request system turn on - off -- Request system turn off without waiting for OS to shutdown - shutdown -- Have system request OS proper shutdown - reset -- Request system reset without waiting for OS - boot -- If system is off, then 'on', else 'reset'
    /// Either this option or O(machine) is required.
    state: ("on"|"off"|"shutdown"|"reset"|"boot")?
    /// Maximum number of seconds before interrupt request.
    timeout: Int?
    /// Username to use to connect to the BMC.
    user: String
}

/// Task class for ipmi_power
class IpmiPowerTask extends Playbook.Task {
    /// todo doc
    `community.general.ipmi_power`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ipmi_power"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ipmi_power`
}

/// TaskBuilder class for ipmi_power
class IpmiPower extends Playbook.TaskBuilder {
    /// Options for community.general.ipmi_power
    options: IpmiPowerOptions?
    /// todo doc
    function Task(): IpmiPowerTask = this
        .toMap()
        .put("community.general.ipmi_power", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IpmiPowerTask)
}

/// Save iptables state into a file or restore it from a file
/// C(iptables) is used to set up, maintain, and inspect the tables of IP packet filter rules in the Linux kernel.
/// This module handles the saving and/or loading of rules. This is the same as the behaviour of the C(iptables-save) and C(iptables-restore) (or C(ip6tables-save) and C(ip6tables-restore) for IPv6) commands which this module uses internally.
/// Modifying the state of the firewall remotely may lead to loose access to the host in case of mistake in new ruleset. This module embeds a rollback feature to avoid this, by telling the host to restore previous rules if a cookie is still there after a given delay, and all this time telling the controller to try to remove this cookie on the host through a new connection.
class IptablesStateOptions {
    /// Save or restore the values of all packet and byte counters.
    /// When V(true), the module is not idempotent.
    counters: Boolean?
    /// Which version of the IP protocol this module should apply to.
    ip_version: ("ipv4"|"ipv6")?
    /// Specify the path to the C(modprobe) program internally used by iptables related commands to load kernel modules.
    /// By default, V(/proc/sys/kernel/modprobe) is inspected to determine the executable's path.
    modprobe: String?
    /// For O(state=restored), ignored otherwise.
    /// If V(false), restoring iptables rules from a file flushes (deletes) all previous contents of the respective table(s). If V(true), the previous rules are left untouched (but policies are updated anyway, for all built-in chains).
    noflush: Boolean?
    /// The file the iptables state should be saved to.
    /// The file the iptables state should be restored from.
    path: String
    /// Whether the firewall state should be saved (into a file) or restored (from a file).
    state: ("saved"|"restored")
    /// When O(state=restored), restore only the named table even if the input file contains other tables. Fail if the named table is not declared in the file.
    /// When O(state=saved), restrict output to the specified table. If not specified, output includes all active tables.
    table: ("filter"|"nat"|"mangle"|"raw"|"security")?
    /// Wait N seconds for the xtables lock to prevent instant failure in case multiple instances of the program are running concurrently.
    wait: Int?
}

/// Task class for iptables_state
class IptablesStateTask extends Playbook.Task {
    /// todo doc
    `community.general.iptables_state`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.iptables_state"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.iptables_state`
}

/// TaskBuilder class for iptables_state
class IptablesState extends Playbook.TaskBuilder {
    /// Options for community.general.iptables_state
    options: IptablesStateOptions?
    /// todo doc
    function Task(): IptablesStateTask = this
        .toMap()
        .put("community.general.iptables_state", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IptablesStateTask)
}

/// Manage DNS Records for Ericsson IPWorks via ipwcli
/// Manage DNS records for the Ericsson IPWorks DNS server. The module will use the ipwcli to deploy the DNS records.
class IpwcliDnsOptions {
    /// The IP address for the A or AAAA record.
    /// Required for O(type=A) or O(type=AAAA).
    address: String?
    /// Sets the container zone for the record.
    container: String
    /// Name of the record.
    dnsname: String
    /// Sets one of the possible flags of NAPTR record.
    /// Required for O(type=NAPTR).
    flags: ("S"|"A"|"U"|"P")?
    /// Sets the order of the NAPTR record.
    /// Required for O(type=NAPTR).
    order: Int?
    /// Password to login on ipwcli.
    password: String
    /// Sets the port of the SRV record.
    /// Required for O(type=SRV).
    port: Int?
    /// Sets the preference of the NAPTR record.
    /// Required for O(type=NAPTR).
    preference: Int?
    /// Sets the priority of the SRV record.
    priority: Int?
    /// Sets the replacement of the NAPTR record.
    /// Required for O(type=NAPTR).
    replacement: String?
    /// Sets the service of the NAPTR record.
    /// Required for O(type=NAPTR).
    service: String?
    /// Whether the record should exist or not.
    state: ("absent"|"present")?
    /// Sets the target of the SRV record.
    /// Required for O(type=SRV).
    target: String?
    /// Sets the TTL of the record.
    ttl: Int?
    /// Type of the record.
    type: ("NAPTR"|"SRV"|"A"|"AAAA")
    /// Username to login on ipwcli.
    username: String
    /// Sets the weight of the SRV record.
    weight: Int?
}

/// Task class for ipwcli_dns
class IpwcliDnsTask extends Playbook.Task {
    /// todo doc
    `community.general.ipwcli_dns`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ipwcli_dns"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ipwcli_dns`
}

/// TaskBuilder class for ipwcli_dns
class IpwcliDns extends Playbook.TaskBuilder {
    /// Options for community.general.ipwcli_dns
    options: IpwcliDnsOptions?
    /// todo doc
    function Task(): IpwcliDnsTask = this
        .toMap()
        .put("community.general.ipwcli_dns", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IpwcliDnsTask)
}

/// Send a message to an IRC channel or a nick
/// Send a message to an IRC channel or a nick. This is a very simplistic implementation.
class IrcOptions {
    /// Channel name.  One of nick_to or channel needs to be set.  When both are set, the message will be sent to both of them.
    channel: String?
    /// Text color for the message.
    color: ("none"|"white"|"black"|"blue"|"green"|"red"|"brown"|"purple"|"orange"|"yellow"|"light_green"|"teal"|"light_cyan"|"light_blue"|"pink"|"gray"|"light_gray")?
    /// Channel key
    key: String?
    /// The message body.
    msg: String
    /// Nickname to send the message from. May be shortened, depending on server's NICKLEN setting.
    nick: String?
    /// A list of nicknames to send the message to. One of nick_to or channel needs to be set.  When both are defined, the message will be sent to both of them.
    nick_to: Listing<String>?
    /// Designates whether user should part from channel after sending message or not. Useful for when using a faux bot and not wanting join/parts between messages.
    part: Boolean?
    /// Server password
    passwd: String?
    /// IRC server port number
    port: Int?
    /// IRC server name/address
    server: String?
    /// Text style for the message. Note italic does not work on some clients
    style: ("bold"|"underline"|"reverse"|"italic"|"none")?
    /// Timeout to use while waiting for successful registration and join messages, this is to prevent an endless loop
    timeout: Int?
    /// Set the channel topic
    topic: String?
    /// Designates whether TLS/SSL should be used when connecting to the IRC server
    /// O(use_tls) is available since community.general 8.1.0, before the option was exlusively called O(use_ssl). The latter is now an alias of O(use_tls).
    /// B(Note:) for security reasons, you should always set O(use_tls=true) and O(validate_certs=true) whenever possible.
    use_tls: Boolean?
    /// If set to V(false), the SSL certificates will not be validated.
    /// This should always be set to V(true). Using V(false) is unsafe and should only be done if the network between between Ansible and the IRC server is known to be safe.
    /// B(Note:) for security reasons, you should always set O(use_tls=true) and O(validate_certs=true) whenever possible.
    validate_certs: Boolean?
}

/// Task class for irc
class IrcTask extends Playbook.Task {
    /// todo doc
    `community.general.irc`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.irc"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.irc`
}

/// TaskBuilder class for irc
class Irc extends Playbook.TaskBuilder {
    /// Options for community.general.irc
    options: IrcOptions?
    /// todo doc
    function Task(): IrcTask = this
        .toMap()
        .put("community.general.irc", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IrcTask)
}

/// Generate ISO file with specified files or folders
/// This module is used to generate ISO file with specified path of files.
class IsoCreateOptions {
    /// The absolute path with file name of the new generated ISO file on local machine.
    /// Will create intermediate folders when they does not exist.
    dest_iso: String
    /// The ISO9660 interchange level to use, it dictates the rules on the names of files.
    /// Levels and valid values V(1), V(2), V(3), V(4) are supported.
    /// The default value is level V(1), which is the most conservative, level V(3) is recommended.
    /// ISO9660 file names at interchange level V(1) cannot have more than 8 characters or 3 characters in the extension.
    interchange_level: Int?
    /// Support levels and valid values are V(1), V(2), or V(3).
    /// Level V(3) is by far the most common.
    /// If not specified, then no Joliet support is added.
    joliet: Int?
    /// Whether to make this ISO have the Rock Ridge extensions or not.
    /// Valid values are V(1.09), V(1.10) or V(1.12), means adding the specified Rock Ridge version to the ISO.
    /// If unsure, set V(1.09) to ensure maximum compatibility.
    /// If not specified, then not add Rock Ridge extension to the ISO.
    rock_ridge: ("1.09"|"1.10"|"1.12")?
    /// This is a list of absolute paths of source files or folders which will be contained in the new generated ISO file.
    /// Will fail if specified file or folder in O(src_files) does not exist on local machine.
    /// Note: With all ISO9660 levels from 1 to 3, all file names are restricted to uppercase letters, numbers and underscores (_). File names are limited to 31 characters, directory nesting is limited to 8 levels, and path names are limited to 255 characters.
    src_files: Listing<String>
    /// Whether to add UDF support to this ISO.
    /// If set to V(true), then version 2.60 of the UDF spec is used.
    /// If not specified or set to V(false), then no UDF support is added.
    udf: Boolean?
    /// The volume identification string to use on the new generated ISO image.
    vol_ident: String?
}

/// Task class for iso_create
class IsoCreateTask extends Playbook.Task {
    /// todo doc
    `community.general.iso_create`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.iso_create"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.iso_create`
}

/// TaskBuilder class for iso_create
class IsoCreate extends Playbook.TaskBuilder {
    /// Options for community.general.iso_create
    options: IsoCreateOptions?
    /// todo doc
    function Task(): IsoCreateTask = this
        .toMap()
        .put("community.general.iso_create", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IsoCreateTask)
}

/// Add/remove/change files in ISO file
/// This module is used to add/remove/change files in ISO file.
/// The file inside ISO will be overwritten if it exists by option O(add_files).
class IsoCustomizeOptions {
    /// Allows to add and replace files in the ISO file.
    /// Will create intermediate folders inside the ISO file when they do not exist.
    add_files: Listing<Any>?
    /// Absolute paths for files inside the ISO file that should be removed.
    delete_files: Listing<String>?
    /// The path of the customized ISO file.
    dest_iso: String
    /// This is the path of source ISO file.
    src_iso: String
}

/// Task class for iso_customize
class IsoCustomizeTask extends Playbook.Task {
    /// todo doc
    `community.general.iso_customize`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.iso_customize"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.iso_customize`
}

/// TaskBuilder class for iso_customize
class IsoCustomize extends Playbook.TaskBuilder {
    /// Options for community.general.iso_customize
    options: IsoCustomizeOptions?
    /// todo doc
    function Task(): IsoCustomizeTask = this
        .toMap()
        .put("community.general.iso_customize", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IsoCustomizeTask)
}

/// Extract files from an ISO image
/// This module has two possible ways of operation.
/// If 7zip is installed on the system, this module extracts files from an ISO into a temporary directory and copies files to a given destination, if needed.
/// If the user has mount-capabilities (CAP_SYS_ADMIN on Linux) this module mounts the ISO image to a temporary location, and copies files to a given destination, if needed.
class IsoExtractOptions {
    /// The destination directory to extract files to.
    dest: String
    /// The path to the C(7z) executable to use for extracting files from the ISO.
    /// If not provided, it will assume the value V(7z).
    executable: String?
    /// A list of files to extract from the image.
    /// Extracting directories does not work.
    files: Listing<String>
    /// If V(true), which will replace the remote file when contents are different than the source.
    /// If V(false), the file will only be extracted and copied if the destination does not already exist.
    force: Boolean?
    /// The ISO image to extract files from.
    image: String
}

/// Task class for iso_extract
class IsoExtractTask extends Playbook.Task {
    /// todo doc
    `community.general.iso_extract`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.iso_extract"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.iso_extract`
}

/// TaskBuilder class for iso_extract
class IsoExtract extends Playbook.TaskBuilder {
    /// Options for community.general.iso_extract
    options: IsoExtractOptions?
    /// todo doc
    function Task(): IsoExtractTask = this
        .toMap()
        .put("community.general.iso_extract", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(IsoExtractTask)
}

/// Send a message to jabber user or chat room
/// Send a message to jabber
class JabberOptions {
    /// message encoding
    encoding: String?
    /// host to connect, overrides user info
    host: String?
    /// The message body.
    msg: String
    /// password for user to connect
    password: String
    /// port to connect to, overrides default
    port: Int?
    /// user ID or name of the room, when using room use a slash to indicate your nick.
    to: String
    /// User as which to connect
    user: String
}

/// Task class for jabber
class JabberTask extends Playbook.Task {
    /// todo doc
    `community.general.jabber`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.jabber"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.jabber`
}

/// TaskBuilder class for jabber
class Jabber extends Playbook.TaskBuilder {
    /// Options for community.general.jabber
    options: JabberOptions?
    /// todo doc
    function Task(): JabberTask = this
        .toMap()
        .put("community.general.jabber", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(JabberTask)
}

/// Uses keytool to import/remove certificate to/from java keystore (cacerts)
/// This is a wrapper module around keytool, which can be used to import certificates and optionally private keys to a given java keystore, or remove them from it.
class JavaCertOptions {
    attributes: Any?
    /// Imported certificate alias.
    /// The alias is used when checking for the presence of a certificate in the keystore.
    cert_alias: String?
    /// Content of the certificate used to create the keystore.
    /// Exactly one of O(cert_url), O(cert_path), O(cert_content), or O(pkcs12_path) is required to load certificate.
    cert_content: String?
    /// Local path to load certificate from.
    /// Exactly one of O(cert_url), O(cert_path), O(cert_content), or O(pkcs12_path) is required to load certificate.
    cert_path: String?
    /// Port to connect to URL.
    /// This will be used to create server URL:PORT.
    cert_port: Int?
    /// Basic URL to fetch SSL certificate from.
    /// Exactly one of O(cert_url), O(cert_path), O(cert_content), or O(pkcs12_path) is required to load certificate.
    cert_url: String?
    /// Path to keytool binary if not used we search in PATH for it.
    executable: String?
    group: Any?
    /// Create keystore if it does not exist.
    keystore_create: Boolean?
    /// Keystore password.
    keystore_pass: String
    /// Path to keystore.
    keystore_path: String?
    /// Keystore type (JCEKS, JKS).
    keystore_type: String?
    mode: Any?
    owner: Any?
    /// Alias in the PKCS12 keystore.
    pkcs12_alias: String?
    /// Password for importing from PKCS12 keystore.
    pkcs12_password: String?
    /// Local path to load PKCS12 keystore from.
    /// Unlike O(cert_url), O(cert_path) and O(cert_content), the PKCS12 keystore embeds the private key matching the certificate, and is used to import both the certificate and its private key into the java keystore.
    /// Exactly one of O(cert_url), O(cert_path), O(cert_content), or O(pkcs12_path) is required to load certificate.
    pkcs12_path: String?
    selevel: Any?
    serole: Any?
    setype: Any?
    seuser: Any?
    /// Defines action which can be either certificate import or removal.
    /// When state is present, the certificate will always idempotently be inserted into the keystore, even if there already exists a cert alias that is different.
    state: ("absent"|"present")?
    /// Trust imported cert as CAcert.
    trust_cacert: Boolean?
    unsafe_writes: Any?
}

/// Task class for java_cert
class JavaCertTask extends Playbook.Task {
    /// todo doc
    `community.general.java_cert`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.java_cert"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.java_cert`
}

/// TaskBuilder class for java_cert
class JavaCert extends Playbook.TaskBuilder {
    /// Options for community.general.java_cert
    options: JavaCertOptions?
    /// todo doc
    function Task(): JavaCertTask = this
        .toMap()
        .put("community.general.java_cert", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(JavaCertTask)
}

/// Create a Java keystore in JKS format
/// Bundle a x509 certificate and its private key into a Java Keystore in JKS format.
class JavaKeystoreOptions {
    /// Content of the certificate used to create the keystore.
    /// If the fingerprint of the provided certificate does not match the fingerprint of the certificate bundled in the keystore, the keystore is regenerated with the provided certificate.
    /// Exactly one of O(certificate) or O(certificate_path) is required.
    certificate: String?
    /// Location of the certificate used to create the keystore.
    /// If the fingerprint of the provided certificate does not match the fingerprint of the certificate bundled in the keystore, the keystore is regenerated with the provided certificate.
    /// Exactly one of O(certificate) or O(certificate_path) is required.
    certificate_path: String?
    /// Absolute path of the generated keystore.
    dest: String
    /// Keystore is created even if it already exists.
    force: Boolean?
    /// Name of the group that should own jks file.
    group: Any?
    /// Type of the Java keystore.
    /// When this option is omitted and the keystore doesn't already exist, the behavior follows C(keytool)'s default store type which depends on Java version; V(pkcs12) since Java 9 and V(jks) prior (may also be V(pkcs12) if new default has been backported to this version).
    /// When this option is omitted and the keystore already exists, the current type is left untouched, unless another option leads to overwrite the keystore (in that case, this option behaves like for keystore creation).
    /// When O(keystore_type) is set, the keystore is created with this type if it does not already exist, or is overwritten to match the given type in case of mismatch.
    keystore_type: ("jks"|"pkcs12")?
    /// Mode the file should be.
    mode: Any?
    /// Name of the certificate in the keystore.
    /// If the provided name does not exist in the keystore, the module will re-create the keystore. This behavior changed in community.general 3.0.0, before that the module would fail when the name did not match.
    name: String
    /// Name of the user that should own jks file.
    owner: Any?
    /// Password that should be used to secure the keystore.
    /// If the provided password fails to unlock the keystore, the module will re-create the keystore with the new passphrase. This behavior changed in community.general 3.0.0, before that the module would fail when the password did not match.
    password: String
    /// Content of the private key used to create the keystore.
    /// Exactly one of O(private_key) or O(private_key_path) is required.
    private_key: String?
    /// Passphrase used to read the private key, if required.
    private_key_passphrase: String?
    /// Location of the private key used to create the keystore.
    /// Exactly one of O(private_key) or O(private_key_path) is required.
    private_key_path: String?
    /// Backend for loading private keys and certificates.
    ssl_backend: ("openssl"|"cryptography")?
}

/// Task class for java_keystore
class JavaKeystoreTask extends Playbook.Task {
    /// todo doc
    `community.general.java_keystore`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.java_keystore"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.java_keystore`
}

/// TaskBuilder class for java_keystore
class JavaKeystore extends Playbook.TaskBuilder {
    /// Options for community.general.java_keystore
    options: JavaKeystoreOptions?
    /// todo doc
    function Task(): JavaKeystoreTask = this
        .toMap()
        .put("community.general.java_keystore", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(JavaKeystoreTask)
}

/// Deploy applications to JBoss
/// Deploy applications to JBoss standalone using the filesystem.
class JbossOptions {
    /// The location in the filesystem where the deployment scanner listens.
    deploy_path: String?
    /// The name of the deployment.
    deployment: String
    /// The remote path of the application ear or war to deploy.
    /// Required when O(state=present).
    /// Ignored when O(state=absent).
    src: String?
    /// Whether the application should be deployed or undeployed.
    state: ("present"|"absent")?
}

/// Task class for jboss
class JbossTask extends Playbook.Task {
    /// todo doc
    `community.general.jboss`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.jboss"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.jboss`
}

/// TaskBuilder class for jboss
class Jboss extends Playbook.TaskBuilder {
    /// Options for community.general.jboss
    options: JbossOptions?
    /// todo doc
    function Task(): JbossTask = this
        .toMap()
        .put("community.general.jboss", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(JbossTask)
}

/// Manage jenkins builds
/// Manage Jenkins builds with Jenkins REST API.
class JenkinsBuildOptions {
    /// A list of parameters to pass to the build.
    args: Any?
    /// An integer which specifies a build of a job. Is required to remove a build from the queue.
    build_number: Int?
    /// Enable detached mode to not wait for the build end.
    detach: Boolean?
    /// Name of the Jenkins job to build.
    name: String
    /// Password to authenticate with the Jenkins server.
    password: String?
    /// Attribute that specifies if the build is to be created, deleted or stopped.
    /// The V(stopped) state has been added in community.general 3.3.0.
    state: ("present"|"absent"|"stopped")?
    /// Time in seconds to wait between requests to the Jenkins server.
    /// This times must be higher than the configured quiet time for the job.
    time_between_checks: Int?
    /// API token used to authenticate with the Jenkins server.
    token: String?
    /// URL of the Jenkins server.
    url: String?
    /// User to authenticate with the Jenkins server.
    user: String?
}

/// Task class for jenkins_build
class JenkinsBuildTask extends Playbook.Task {
    /// todo doc
    `community.general.jenkins_build`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.jenkins_build"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.jenkins_build`
}

/// TaskBuilder class for jenkins_build
class JenkinsBuild extends Playbook.TaskBuilder {
    /// Options for community.general.jenkins_build
    options: JenkinsBuildOptions?
    /// todo doc
    function Task(): JenkinsBuildTask = this
        .toMap()
        .put("community.general.jenkins_build", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(JenkinsBuildTask)
}

/// Get information about Jenkins builds
/// Get information about Jenkins builds with Jenkins REST API.
class JenkinsBuildInfoOptions {
    /// An integer which specifies a build of a job.
    /// If not specified the last build information will be returned.
    build_number: Int?
    /// Name of the Jenkins job to which the build belongs.
    name: String
    /// Password to authenticate with the Jenkins server.
    password: String?
    /// API token used to authenticate with the Jenkins server.
    token: String?
    /// URL of the Jenkins server.
    url: String?
    /// User to authenticate with the Jenkins server.
    user: String?
}

/// Task class for jenkins_build_info
class JenkinsBuildInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.jenkins_build_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.jenkins_build_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.jenkins_build_info`
}

/// TaskBuilder class for jenkins_build_info
class JenkinsBuildInfo extends Playbook.TaskBuilder {
    /// Options for community.general.jenkins_build_info
    options: JenkinsBuildInfoOptions?
    /// todo doc
    function Task(): JenkinsBuildInfoTask = this
        .toMap()
        .put("community.general.jenkins_build_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(JenkinsBuildInfoTask)
}

/// Manage jenkins jobs
/// Manage Jenkins jobs by using Jenkins REST API.
class JenkinsJobOptions {
    /// config in XML format.
    /// Required if job does not yet exist.
    /// Mutually exclusive with O(enabled).
    /// Considered if O(state=present).
    config: String?
    /// Whether the job should be enabled or disabled.
    /// Mutually exclusive with O(config).
    /// Considered if O(state=present).
    enabled: Boolean?
    /// Name of the Jenkins job.
    name: String
    /// Password to authenticate with the Jenkins server.
    password: String?
    /// Attribute that specifies if the job has to be created or deleted.
    state: ("present"|"absent")?
    /// API token used to authenticate alternatively to password.
    token: String?
    /// URL where the Jenkins server is accessible.
    url: String?
    /// User to authenticate with the Jenkins server.
    user: String?
    /// If set to V(false), the SSL certificates will not be validated. This should only set to V(false) used on personally controlled sites using self-signed certificates as it avoids verifying the source site.
    /// The C(python-jenkins) library only handles this by using the environment variable E(PYTHONHTTPSVERIFY).
    validate_certs: Boolean?
}

/// Task class for jenkins_job
class JenkinsJobTask extends Playbook.Task {
    /// todo doc
    `community.general.jenkins_job`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.jenkins_job"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.jenkins_job`
}

/// TaskBuilder class for jenkins_job
class JenkinsJob extends Playbook.TaskBuilder {
    /// Options for community.general.jenkins_job
    options: JenkinsJobOptions?
    /// todo doc
    function Task(): JenkinsJobTask = this
        .toMap()
        .put("community.general.jenkins_job", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(JenkinsJobTask)
}

/// Get information about Jenkins jobs
/// This module can be used to query information about which Jenkins jobs which already exists.
class JenkinsJobInfoOptions {
    /// Only fetch jobs with the given status color.
    color: String?
    /// A shell glob of Jenkins job names to fetch information about.
    glob: String?
    /// Exact name of the Jenkins job to fetch information about.
    name: String?
    /// Password to authenticate with the Jenkins server.
    /// This is mutually exclusive with O(token).
    password: String?
    /// API token used to authenticate with the Jenkins server.
    /// This is mutually exclusive with O(password).
    token: String?
    /// URL where the Jenkins server is accessible.
    url: String?
    /// User to authenticate with the Jenkins server.
    user: String?
    /// If set to V(false), the SSL certificates will not be validated.
    /// This should only set to V(false) used on personally controlled sites using self-signed certificates.
    validate_certs: Boolean?
}

/// Task class for jenkins_job_info
class JenkinsJobInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.jenkins_job_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.jenkins_job_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.jenkins_job_info`
}

/// TaskBuilder class for jenkins_job_info
class JenkinsJobInfo extends Playbook.TaskBuilder {
    /// Options for community.general.jenkins_job_info
    options: JenkinsJobInfoOptions?
    /// todo doc
    function Task(): JenkinsJobInfoTask = this
        .toMap()
        .put("community.general.jenkins_job_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(JenkinsJobInfoTask)
}

/// Add or remove Jenkins plugin
/// Ansible module which helps to manage Jenkins plugins.
class JenkinsPluginOptions {
    /// GID or name of the Jenkins group on the OS.
    group: String?
    /// Home directory of the Jenkins user.
    jenkins_home: String?
    /// Path inside the O(updates_url) to get latest plugins from.
    latest_plugins_url_segments: Listing<String>?
    /// File mode applied on versioned plugins.
    mode: String?
    /// Plugin name.
    name: String
    /// UID or name of the Jenkins user on the OS.
    owner: String?
    /// Desired plugin state.
    /// If set to V(latest), the check for new version will be performed every time. This is suitable to keep the plugin up-to-date.
    state: ("absent"|"present"|"pinned"|"unpinned"|"enabled"|"disabled"|"latest")?
    /// Server connection timeout in secs.
    timeout: Int?
    /// A list of URL segment(s) to retrieve the update center json file from.
    update_json_url_segment: Listing<String>?
    /// Number of seconds after which a new copy of the C(update-center.json) file is downloaded. This is used to avoid the need to download the plugin to calculate its checksum when O(state=latest) is specified.
    /// Set it to V(0) if no cache file should be used. In that case, the plugin file will always be downloaded to calculate its checksum when O(state=latest) is specified.
    updates_expiration: Int?
    /// A list of base URL(s) to retrieve C(update-center.json), and direct plugin files from.
    /// This can be a list since community.general 3.3.0.
    updates_url: Listing<String>?
    /// URL of the Jenkins server.
    url: String?
    /// Plugin version number.
    /// If this option is specified, all plugin dependencies must be installed manually.
    /// It might take longer to verify that the correct version is installed. This is especially true if a specific version number is specified.
    /// Quote the version to prevent the value to be interpreted as float. For example if V(1.20) would be unquoted, it would become V(1.2).
    version: String?
    /// Path inside the O(updates_url) to get specific version of plugins from.
    versioned_plugins_url_segments: Listing<String>?
    /// Defines whether to install plugin dependencies.
    /// This option takes effect only if the O(version) is not defined.
    with_dependencies: Boolean?
}

/// Task class for jenkins_plugin
class JenkinsPluginTask extends Playbook.Task {
    /// todo doc
    `community.general.jenkins_plugin`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.jenkins_plugin"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.jenkins_plugin`
}

/// TaskBuilder class for jenkins_plugin
class JenkinsPlugin extends Playbook.TaskBuilder {
    /// Options for community.general.jenkins_plugin
    options: JenkinsPluginOptions?
    /// todo doc
    function Task(): JenkinsPluginTask = this
        .toMap()
        .put("community.general.jenkins_plugin", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(JenkinsPluginTask)
}

/// Executes a groovy script in the jenkins instance
/// The C(jenkins_script) module takes a script plus a dict of values to use within the script and returns the result of the script being run.
class JenkinsScriptOptions {
    /// A dict of key-value pairs used in formatting the script using string.Template (see https://docs.python.org/2/library/string.html#template-strings).
    args: Any?
    /// The password to connect to the jenkins server with.
    password: String?
    /// The groovy script to be executed. This gets passed as a string Template if args is defined.
    script: String
    /// The request timeout in seconds
    timeout: Int?
    /// The jenkins server to execute the script against. The default is a local jenkins instance that is not being proxied through a webserver.
    url: String?
    /// The username to connect to the jenkins server with.
    user: String?
    /// If set to V(false), the SSL certificates will not be validated. This should only set to V(false) used on personally controlled sites using self-signed certificates as it avoids verifying the source site.
    validate_certs: Boolean?
}

/// Task class for jenkins_script
class JenkinsScriptTask extends Playbook.Task {
    /// todo doc
    `community.general.jenkins_script`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.jenkins_script"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.jenkins_script`
}

/// TaskBuilder class for jenkins_script
class JenkinsScript extends Playbook.TaskBuilder {
    /// Options for community.general.jenkins_script
    options: JenkinsScriptOptions?
    /// todo doc
    function Task(): JenkinsScriptTask = this
        .toMap()
        .put("community.general.jenkins_script", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(JenkinsScriptTask)
}

/// Create and modify issues in a JIRA instance
/// Create and modify issues in a JIRA instance.
class JiraOptions {
    /// Sets the account identifier for the assignee when O(operation) is V(create), V(transition), or V(edit).
    /// Note that JIRA may not allow changing field values on specific transitions or states.
    account_id: String?
    /// Sets the the assignee when O(operation) is V(create), V(transition), or V(edit).
    /// Recent versions of JIRA no longer accept a user name as a user identifier. In that case, use O(account_id) instead.
    /// Note that JIRA may not allow changing field values on specific transitions or states.
    assignee: String?
    /// Information about the attachment being uploaded.
    attachment: Any?
    /// The comment text to add.
    /// Note that JIRA may not allow changing field values on specific transitions or states.
    comment: String?
    /// Used to specify comment comment visibility.
    /// See U(https://developer.atlassian.com/cloud/jira/platform/rest/v2/api-group-issue-comments/#api-rest-api-2-issue-issueidorkey-comment-post) for details.
    comment_visibility: Any?
    /// The issue description, where appropriate.
    /// Note that JIRA may not allow changing field values on specific transitions or states.
    description: String?
    /// This is a free-form data structure that can contain arbitrary data. This is passed directly to the JIRA REST API (possibly after merging with other required data, as when passed to create). See examples for more information, and the JIRA REST API for the structure required for various fields.
    /// When passed to comment, the data structure is merged at the first level since community.general 4.6.0. Useful to add JIRA properties for example.
    /// Note that JIRA may not allow changing field values on specific transitions or states.
    fields: Any?
    /// Set issue from which link will be created.
    inwardissue: String?
    /// An existing issue key to operate on.
    issue: String?
    /// The issue type, for issue creation.
    issuetype: String?
    /// Query JIRA in JQL Syntax, e.g. 'CMDB Hostname'='test.example.com'.
    jql: String?
    /// Set type of link, when action 'link' selected.
    linktype: String?
    /// Limit the result of O(operation=search). If no value is specified, the default jira limit will be used.
    /// Used when O(operation=search) only, ignored otherwise.
    maxresults: Int?
    /// The operation to perform.
    /// V(worklog) was added in community.general 6.5.0.
    operation: ("attach"|"comment"|"create"|"edit"|"fetch"|"link"|"search"|"transition"|"update"|"worklog")
    /// Set issue to which link will be created.
    outwardissue: String?
    /// The password to log-in with.
    /// Must be used with O(username).  Mutually exclusive with O(token).
    password: String?
    /// The project for this operation. Required for issue creation.
    project: String?
    /// Only used when O(operation) is V(transition), and a bit of a misnomer, it actually refers to the transition name.
    status: String?
    /// The issue summary, where appropriate.
    /// Note that JIRA may not allow changing field values on specific transitions or states.
    summary: String?
    /// Set timeout, in seconds, on requests to JIRA API.
    timeout: Any?
    /// The personal access token to log-in with.
    /// Mutually exclusive with O(username) and O(password).
    token: String?
    /// Base URI for the JIRA instance.
    uri: String
    /// The username to log-in with.
    /// Must be used with O(password). Mutually exclusive with O(token).
    username: String?
    /// Require valid SSL certificates (set to V(false) if you would like to use self-signed certificates)
    validate_certs: Boolean?
}

/// Task class for jira
class JiraTask extends Playbook.Task {
    /// todo doc
    `community.general.jira`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.jira"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.jira`
}

/// TaskBuilder class for jira
class Jira extends Playbook.TaskBuilder {
    /// Options for community.general.jira
    options: JiraOptions?
    /// todo doc
    function Task(): JiraTask = this
        .toMap()
        .put("community.general.jira", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(JiraTask)
}

/// Manage KDE configuration files
/// Add or change individual settings in KDE configuration files.
/// It uses B(kwriteconfig) under the hood.
class KdeconfigOptions {
    /// Create a backup file.
    backup: Boolean?
    /// Path to the kwriteconfig executable. If not specified, Ansible will try to discover it.
    kwriteconfig_path: String?
    /// Path to the config file. If the file does not exist it will be created.
    path: String
    /// List of values to set.
    values: Listing<Any>
}

/// Task class for kdeconfig
class KdeconfigTask extends Playbook.Task {
    /// todo doc
    `community.general.kdeconfig`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.kdeconfig"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.kdeconfig`
}

/// TaskBuilder class for kdeconfig
class Kdeconfig extends Playbook.TaskBuilder {
    /// Options for community.general.kdeconfig
    options: KdeconfigOptions?
    /// todo doc
    function Task(): KdeconfigTask = this
        .toMap()
        .put("community.general.kdeconfig", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(KdeconfigTask)
}

/// Blacklist kernel modules
/// Add or remove kernel modules from blacklist.
class KernelBlacklistOptions {
    /// If specified, use this blacklist file instead of C(/etc/modprobe.d/blacklist-ansible.conf).
    blacklist_file: String?
    /// Name of kernel module to black- or whitelist.
    name: String
    /// Whether the module should be present in the blacklist or absent.
    state: ("absent"|"present")?
}

/// Task class for kernel_blacklist
class KernelBlacklistTask extends Playbook.Task {
    /// todo doc
    `community.general.kernel_blacklist`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.kernel_blacklist"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.kernel_blacklist`
}

/// TaskBuilder class for kernel_blacklist
class KernelBlacklist extends Playbook.TaskBuilder {
    /// Options for community.general.kernel_blacklist
    options: KernelBlacklistOptions?
    /// todo doc
    function Task(): KernelBlacklistTask = this
        .toMap()
        .put("community.general.kernel_blacklist", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(KernelBlacklistTask)
}

/// Configure authentication in Keycloak
/// This module actually can only make a copy of an existing authentication flow, add an execution to it and configure it.
/// It can also delete the flow.
class KeycloakAuthenticationOptions {
    /// Alias for the authentication flow.
    alias: String
    /// Configuration structure for the executions.
    authenticationExecutions: Listing<Any>?
    /// C(flowAlias) of the authentication flow to use for the copy.
    copyFrom: String?
    /// Description of the flow.
    description: String?
    /// If V(true), allows to remove the authentication flow and recreate it.
    force: Boolean?
    /// C(providerId) for the new flow when not copied from an existing flow.
    providerId: ("basic-flow"|"client-flow")?
    /// The name of the realm in which is the authentication.
    realm: String
    /// Control if the authentication flow must exists or not.
    state: ("present"|"absent")?
}

/// Task class for keycloak_authentication
class KeycloakAuthenticationTask extends Playbook.Task {
    /// todo doc
    `community.general.keycloak_authentication`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.keycloak_authentication"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.keycloak_authentication`
}

/// TaskBuilder class for keycloak_authentication
class KeycloakAuthentication extends Playbook.TaskBuilder {
    /// Options for community.general.keycloak_authentication
    options: KeycloakAuthenticationOptions?
    /// todo doc
    function Task(): KeycloakAuthenticationTask = this
        .toMap()
        .put("community.general.keycloak_authentication", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(KeycloakAuthenticationTask)
}

/// Allows administration of Keycloak authentication required actions
/// This module can register, update and delete required actions.
/// It also filters out any duplicate required actions by their alias. The first occurrence is preserved.
class KeycloakAuthenticationRequiredActionsOptions {
    /// The name of the realm in which are the authentication required actions.
    realm: String
    /// Authentication required action.
    required_actions: Listing<Any>?
    /// Control if the realm authentication required actions are going to be registered/updated (V(present)) or deleted (V(absent)).
    state: ("absent"|"present")
}

/// Task class for keycloak_authentication_required_actions
class KeycloakAuthenticationRequiredActionsTask extends Playbook.Task {
    /// todo doc
    `community.general.keycloak_authentication_required_actions`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.keycloak_authentication_required_actions"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.keycloak_authentication_required_actions`
}

/// TaskBuilder class for keycloak_authentication_required_actions
class KeycloakAuthenticationRequiredActions extends Playbook.TaskBuilder {
    /// Options for community.general.keycloak_authentication_required_actions
    options: KeycloakAuthenticationRequiredActionsOptions?
    /// todo doc
    function Task(): KeycloakAuthenticationRequiredActionsTask = this
        .toMap()
        .put("community.general.keycloak_authentication_required_actions", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(KeycloakAuthenticationRequiredActionsTask)
}

/// Allows administration of Keycloak client authorization scopes via Keycloak API
/// This module allows the administration of Keycloak client Authorization Scopes via the Keycloak REST API. Authorization Scopes are only available if a client has Authorization enabled.
/// This module requires access to the REST API via OpenID Connect; the user connecting and the realm being used must have the requisite access rights. In a default Keycloak installation, admin-cli and an admin user would work, as would a separate realm definition with the scope tailored to your needs and a user having the expected roles.
/// The names of module options are snake_cased versions of the camelCase options used by Keycloak. The Authorization Services paths and payloads have not officially been documented by the Keycloak project. U(https://www.puppeteers.net/blog/keycloak-authorization-services-rest-api-paths-and-payload/)
class KeycloakAuthzAuthorizationScopeOptions {
    /// The C(clientId) of the Keycloak client that should have the authorization scope.
    /// This is usually a human-readable name of the Keycloak client.
    client_id: String
    /// The display name of the authorization scope.
    display_name: String?
    /// The icon URI for the authorization scope.
    icon_uri: String?
    /// Name of the authorization scope to create.
    name: String
    /// The name of the Keycloak realm the Keycloak client is in.
    realm: String
    /// State of the authorization scope.
    /// On V(present), the authorization scope will be created (or updated if it exists already).
    /// On V(absent), the authorization scope will be removed if it exists.
    state: ("present"|"absent")?
}

/// Task class for keycloak_authz_authorization_scope
class KeycloakAuthzAuthorizationScopeTask extends Playbook.Task {
    /// todo doc
    `community.general.keycloak_authz_authorization_scope`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.keycloak_authz_authorization_scope"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.keycloak_authz_authorization_scope`
}

/// TaskBuilder class for keycloak_authz_authorization_scope
class KeycloakAuthzAuthorizationScope extends Playbook.TaskBuilder {
    /// Options for community.general.keycloak_authz_authorization_scope
    options: KeycloakAuthzAuthorizationScopeOptions?
    /// todo doc
    function Task(): KeycloakAuthzAuthorizationScopeTask = this
        .toMap()
        .put("community.general.keycloak_authz_authorization_scope", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(KeycloakAuthzAuthorizationScopeTask)
}

/// Allows administration of Keycloak client custom Javascript policies via Keycloak API
/// This module allows the administration of Keycloak client custom Javascript via the Keycloak REST API. Custom Javascript policies are only available if a client has Authorization enabled and if they have been deployed to the Keycloak server as JAR files.
/// This module requires access to the REST API via OpenID Connect; the user connecting and the realm being used must have the requisite access rights. In a default Keycloak installation, admin-cli and an admin user would work, as would a separate realm definition with the scope tailored to your needs and a user having the expected roles.
/// The names of module options are snake_cased versions of the camelCase options used by Keycloak. The Authorization Services paths and payloads have not officially been documented by the Keycloak project. U(https://www.puppeteers.net/blog/keycloak-authorization-services-rest-api-paths-and-payload/)
class KeycloakAuthzCustomPolicyOptions {
    /// The V(clientId) of the Keycloak client that should have the custom policy attached to it.
    /// This is usually a human-readable name of the Keycloak client.
    client_id: String
    /// Name of the custom policy to create.
    name: String
    /// The type of the policy. This must match the name of the custom policy deployed to the server.
    /// Multiple policies pointing to the same policy type can be created, but their names have to differ.
    policy_type: String
    /// The name of the Keycloak realm the Keycloak client is in.
    realm: String
    /// State of the custom policy.
    /// On V(present), the custom policy will be created (or updated if it exists already).
    /// On V(absent), the custom policy will be removed if it exists.
    state: ("present"|"absent")?
}

/// Task class for keycloak_authz_custom_policy
class KeycloakAuthzCustomPolicyTask extends Playbook.Task {
    /// todo doc
    `community.general.keycloak_authz_custom_policy`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.keycloak_authz_custom_policy"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.keycloak_authz_custom_policy`
}

/// TaskBuilder class for keycloak_authz_custom_policy
class KeycloakAuthzCustomPolicy extends Playbook.TaskBuilder {
    /// Options for community.general.keycloak_authz_custom_policy
    options: KeycloakAuthzCustomPolicyOptions?
    /// todo doc
    function Task(): KeycloakAuthzCustomPolicyTask = this
        .toMap()
        .put("community.general.keycloak_authz_custom_policy", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(KeycloakAuthzCustomPolicyTask)
}

/// Allows administration of Keycloak client authorization permissions via Keycloak API
/// This module allows the administration of Keycloak client authorization permissions via the Keycloak REST API. Authorization permissions are only available if a client has Authorization enabled.
/// There are some peculiarities in JSON paths and payloads for authorization permissions. In particular POST and PUT operations are targeted at permission endpoints, whereas GET requests go to policies endpoint. To make matters more interesting the JSON responses from GET requests return data in a different format than what is expected for POST and PUT. The end result is that it is not possible to detect changes to things like policies, scopes or resources - at least not without a large number of additional API calls. Therefore this module always updates authorization permissions instead of attempting to determine if changes are truly needed.
/// This module requires access to the REST API via OpenID Connect; the user connecting and the realm being used must have the requisite access rights. In a default Keycloak installation, admin-cli and an admin user would work, as would a separate realm definition with the scope tailored to your needs and a user having the expected roles.
/// The names of module options are snake_cased versions of the camelCase options used by Keycloak. The Authorization Services paths and payloads have not officially been documented by the Keycloak project. U(https://www.puppeteers.net/blog/keycloak-authorization-services-rest-api-paths-and-payload/)
class KeycloakAuthzPermissionOptions {
    /// The clientId of the keycloak client that should have the authorization scope.
    /// This is usually a human-readable name of the Keycloak client.
    client_id: String
    /// The decision strategy to use with this permission.
    decision_strategy: ("UNANIMOUS"|"AFFIRMATIVE"|"CONSENSUS")?
    /// The description of the authorization permission.
    description: String?
    /// Name of the authorization permission to create.
    name: String
    /// The type of authorization permission.
    /// On V(scope) create a scope-based permission.
    /// On V(resource) create a resource-based permission.
    permission_type: ("resource"|"scope")
    /// Policy names to attach to this permission.
    policies: Listing<String>?
    /// The name of the Keycloak realm the Keycloak client is in.
    realm: String
    /// Resource names to attach to this permission.
    /// Scope-based permissions can only include one resource.
    /// Resource-based permissions can include multiple resources.
    resources: Listing<String>?
    /// Scope names to attach to this permission.
    /// Resource-based permissions cannot have scopes attached to them.
    scopes: Listing<String>?
    /// State of the authorization permission.
    /// On V(present), the authorization permission will be created (or updated if it exists already).
    /// On V(absent), the authorization permission will be removed if it exists.
    state: ("present"|"absent")?
}

/// Task class for keycloak_authz_permission
class KeycloakAuthzPermissionTask extends Playbook.Task {
    /// todo doc
    `community.general.keycloak_authz_permission`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.keycloak_authz_permission"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.keycloak_authz_permission`
}

/// TaskBuilder class for keycloak_authz_permission
class KeycloakAuthzPermission extends Playbook.TaskBuilder {
    /// Options for community.general.keycloak_authz_permission
    options: KeycloakAuthzPermissionOptions?
    /// todo doc
    function Task(): KeycloakAuthzPermissionTask = this
        .toMap()
        .put("community.general.keycloak_authz_permission", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(KeycloakAuthzPermissionTask)
}

/// Query Keycloak client authorization permissions information
/// This module allows querying information about Keycloak client authorization permissions from the resources endpoint via the Keycloak REST API. Authorization permissions are only available if a client has Authorization enabled.
/// This module requires access to the REST API via OpenID Connect; the user connecting and the realm being used must have the requisite access rights. In a default Keycloak installation, admin-cli and an admin user would work, as would a separate realm definition with the scope tailored to your needs and a user having the expected roles.
/// The names of module options are snake_cased versions of the camelCase options used by Keycloak. The Authorization Services paths and payloads have not officially been documented by the Keycloak project. U(https://www.puppeteers.net/blog/keycloak-authorization-services-rest-api-paths-and-payload/)
class KeycloakAuthzPermissionInfoOptions {
    /// The clientId of the keycloak client that should have the authorization scope.
    /// This is usually a human-readable name of the Keycloak client.
    client_id: String
    /// Name of the authorization permission to create.
    name: String
    /// The name of the Keycloak realm the Keycloak client is in.
    realm: String
}

/// Task class for keycloak_authz_permission_info
class KeycloakAuthzPermissionInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.keycloak_authz_permission_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.keycloak_authz_permission_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.keycloak_authz_permission_info`
}

/// TaskBuilder class for keycloak_authz_permission_info
class KeycloakAuthzPermissionInfo extends Playbook.TaskBuilder {
    /// Options for community.general.keycloak_authz_permission_info
    options: KeycloakAuthzPermissionInfoOptions?
    /// todo doc
    function Task(): KeycloakAuthzPermissionInfoTask = this
        .toMap()
        .put("community.general.keycloak_authz_permission_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(KeycloakAuthzPermissionInfoTask)
}

/// Allows administration of Keycloak clients via Keycloak API
/// This module allows the administration of Keycloak clients via the Keycloak REST API. It requires access to the REST API via OpenID Connect; the user connecting and the client being used must have the requisite access rights. In a default Keycloak installation, admin-cli and an admin user would work, as would a separate client definition with the scope tailored to your needs and a user having the expected roles.
/// The names of module options are snake_cased versions of the camelCase ones found in the Keycloak API and its documentation at U(https://www.keycloak.org/docs-api/8.0/rest-api/index.html). Aliases are provided so camelCased versions can be used as well.
/// The Keycloak API does not always sanity check inputs e.g. you can set SAML-specific settings on an OpenID Connect client for instance and vice versa. Be careful. If you do not specify a setting, usually a sensible default is chosen.
class KeycloakClientOptions {
    /// URL to the admin interface of the client. This is 'adminUrl' in the Keycloak REST API.
    admin_url: String?
    /// Whether or not to display this client in account console, even if the user does not have an active session.
    always_display_in_console: Boolean?
    /// A dict of further attributes for this client. This can contain various configuration settings; an example is given in the examples section. While an exhaustive list of permissible options is not available; possible options as of Keycloak 3.4 are listed below. The Keycloak API does not validate whether a given option is appropriate for the protocol used; if specified anyway, Keycloak will simply not use it.
    attributes: Any?
    /// Override realm authentication flow bindings.
    authentication_flow_binding_overrides: Any?
    /// Are authorization services enabled for this client or not (OpenID connect). This is 'authorizationServicesEnabled' in the Keycloak REST API.
    authorization_services_enabled: Boolean?
    /// a data structure defining the authorization settings for this client. For reference, please see the Keycloak API docs at U(https://www.keycloak.org/docs-api/8.0/rest-api/index.html#_resourceserverrepresentation). This is 'authorizationSettings' in the Keycloak REST API.
    authorization_settings: Any?
    /// Default URL to use when the auth server needs to redirect or link back to the client This is 'baseUrl' in the Keycloak REST API.
    base_url: String?
    /// The access type of this client is bearer-only. This is 'bearerOnly' in the Keycloak REST API.
    bearer_only: Boolean?
    /// How do clients authenticate with the auth server? Either V(client-secret) or V(client-jwt) can be chosen. When using V(client-secret), the module parameter O(secret) can set it, while for V(client-jwt), you can use the keys C(use.jwks.url), C(jwks.url), and C(jwt.credential.certificate) in the O(attributes) module parameter to configure its behavior.
    /// This is 'clientAuthenticatorType' in the Keycloak REST API.
    client_authenticator_type: ("client-secret"|"client-jwt")?
    /// Client id of client to be worked on. This is usually an alphanumeric name chosen by you. Either this or O(id) is required. If you specify both, O(id) takes precedence. This is 'clientId' in the Keycloak REST API.
    client_id: String?
    /// Client template to use for this client. If it does not exist this field will silently be dropped. This is 'clientTemplate' in the Keycloak REST API.
    client_template: String?
    /// If enabled, users have to consent to client access. This is 'consentRequired' in the Keycloak REST API.
    consent_required: Boolean?
    /// List of default client scopes.
    default_client_scopes: Listing<String>?
    /// list of default roles for this client. If the client roles referenced do not exist yet, they will be created. This is 'defaultRoles' in the Keycloak REST API.
    default_roles: Listing<String>?
    /// Description of the client in Keycloak.
    description: String?
    /// Are direct access grants enabled for this client or not (OpenID connect). This is 'directAccessGrantsEnabled' in the Keycloak REST API.
    direct_access_grants_enabled: Boolean?
    /// Is this client enabled or not?
    enabled: Boolean?
    /// Is frontchannel logout enabled for this client or not. This is 'frontchannelLogout' in the Keycloak REST API.
    frontchannel_logout: Boolean?
    /// Is the "Full Scope Allowed" feature set for this client or not. This is 'fullScopeAllowed' in the Keycloak REST API.
    full_scope_allowed: Boolean?
    /// Id of client to be worked on. This is usually an UUID. Either this or O(client_id) is required. If you specify both, this takes precedence.
    id: String?
    /// Enable implicit flow for this client or not (OpenID connect). This is 'implicitFlowEnabled' in the Keycloak REST API.
    implicit_flow_enabled: Boolean?
    /// Name of the client (this is not the same as O(client_id)).
    name: String?
    /// Cluster node re-registration timeout for this client. This is 'nodeReRegistrationTimeout' in the Keycloak REST API.
    node_re_registration_timeout: Int?
    /// Revoke any tokens issued before this date for this client (this is a UNIX timestamp). This is 'notBefore' in the Keycloak REST API.
    not_before: Int?
    /// List of optional client scopes.
    optional_client_scopes: Listing<String>?
    /// Type of client.
    /// At creation only, default value will be V(openid-connect) if O(protocol) is omitted.
    /// The V(docker-v2) value was added in community.general 8.6.0.
    protocol: ("openid-connect"|"saml"|"docker-v2")?
    /// a list of dicts defining protocol mappers for this client. This is 'protocolMappers' in the Keycloak REST API.
    protocol_mappers: Listing<Any>?
    /// Is the access type for this client public or not. This is 'publicClient' in the Keycloak REST API.
    public_client: Boolean?
    /// The realm to create the client in.
    realm: String?
    /// Acceptable redirect URIs for this client. This is 'redirectUris' in the Keycloak REST API.
    redirect_uris: Listing<String>?
    /// dict of registered cluster nodes (with C(nodename) as the key and last registration time as the value). This is 'registeredNodes' in the Keycloak REST API.
    registered_nodes: Any?
    /// The registration access token provides access for clients to the client registration service. This is 'registrationAccessToken' in the Keycloak REST API.
    registration_access_token: String?
    /// Root URL appended to relative URLs for this client. This is 'rootUrl' in the Keycloak REST API.
    root_url: String?
    /// When using O(client_authenticator_type=client-secret) (the default), you can specify a secret here (otherwise one will be generated if it does not exit). If changing this secret, the module will not register a change currently (but the changed secret will be saved).
    secret: String?
    /// Are service accounts enabled for this client or not (OpenID connect). This is 'serviceAccountsEnabled' in the Keycloak REST API.
    service_accounts_enabled: Boolean?
    /// Enable standard flow for this client or not (OpenID connect). This is 'standardFlowEnabled' in the Keycloak REST API.
    standard_flow_enabled: Boolean?
    /// State of the client
    /// On V(present), the client will be created (or updated if it exists already).
    /// On V(absent), the client will be removed if it exists
    state: ("present"|"absent")?
    /// Whether or not surrogate auth is required. This is 'surrogateAuthRequired' in the Keycloak REST API.
    surrogate_auth_required: Boolean?
    /// Whether or not to use configuration from the O(client_template). This is 'useTemplateConfig' in the Keycloak REST API.
    use_template_config: Boolean?
    /// Whether or not to use mapper configuration from the O(client_template). This is 'useTemplateMappers' in the Keycloak REST API.
    use_template_mappers: Boolean?
    /// Whether or not to use scope configuration from the O(client_template). This is 'useTemplateScope' in the Keycloak REST API.
    use_template_scope: Boolean?
    /// List of allowed CORS origins. This is 'webOrigins' in the Keycloak REST API.
    web_origins: Listing<String>?
}

/// Task class for keycloak_client
class KeycloakClientTask extends Playbook.Task {
    /// todo doc
    `community.general.keycloak_client`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.keycloak_client"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.keycloak_client`
}

/// TaskBuilder class for keycloak_client
class KeycloakClient extends Playbook.TaskBuilder {
    /// Options for community.general.keycloak_client
    options: KeycloakClientOptions?
    /// todo doc
    function Task(): KeycloakClientTask = this
        .toMap()
        .put("community.general.keycloak_client", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(KeycloakClientTask)
}

/// Allows administration of Keycloak client_rolemapping with the Keycloak API
/// This module allows you to add, remove or modify Keycloak client_rolemapping with the Keycloak REST API. It requires access to the REST API via OpenID Connect; the user connecting and the client being used must have the requisite access rights. In a default Keycloak installation, admin-cli and an admin user would work, as would a separate client definition with the scope tailored to your needs and a user having the expected roles.
/// The names of module options are snake_cased versions of the camelCase ones found in the Keycloak API and its documentation at U(https://www.keycloak.org/docs-api/8.0/rest-api/index.html).
/// Attributes are multi-valued in the Keycloak API. All attributes are lists of individual values and will be returned that way by this module. You may pass single values for attributes when calling the module, and this will be translated into a list suitable for the API.
/// When updating a client_rolemapping, where possible provide the role ID to the module. This removes a lookup to the API to translate the name into the role ID.
class KeycloakClientRolemappingOptions {
    /// Id of the client to be mapped.
    /// This parameter is not required for updating or deleting the rolemapping but providing it will reduce the number of API calls required.
    cid: String?
    /// Name of the client to be mapped (different than O(cid)).
    /// This parameter is required (can be replaced by cid for less API call).
    client_id: String?
    /// Id of the group to be mapped.
    /// This parameter is not required for updating or deleting the rolemapping but providing it will reduce the number of API calls required.
    gid: String?
    /// Name of the group to be mapped.
    /// This parameter is required (can be replaced by gid for less API call).
    group_name: String?
    /// List of parent groups for the group to handle sorted top to bottom.
    /// Set this if your group is a subgroup and you do not provide the GID in O(gid).
    parents: Listing<Any>?
    /// They Keycloak realm under which this role_representation resides.
    realm: String?
    /// Roles to be mapped to the group.
    roles: Listing<Any>?
    /// State of the client_rolemapping.
    /// On V(present), the client_rolemapping will be created if it does not yet exist, or updated with the parameters you provide.
    /// On V(absent), the client_rolemapping will be removed if it exists.
    state: ("present"|"absent")?
}

/// Task class for keycloak_client_rolemapping
class KeycloakClientRolemappingTask extends Playbook.Task {
    /// todo doc
    `community.general.keycloak_client_rolemapping`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.keycloak_client_rolemapping"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.keycloak_client_rolemapping`
}

/// TaskBuilder class for keycloak_client_rolemapping
class KeycloakClientRolemapping extends Playbook.TaskBuilder {
    /// Options for community.general.keycloak_client_rolemapping
    options: KeycloakClientRolemappingOptions?
    /// todo doc
    function Task(): KeycloakClientRolemappingTask = this
        .toMap()
        .put("community.general.keycloak_client_rolemapping", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(KeycloakClientRolemappingTask)
}

/// Allows administration of Keycloak client roles scope to restrict the usage of certain roles to a other specific client applications.
/// This module allows you to add or remove Keycloak roles from clients scope via the Keycloak REST API. It requires access to the REST API via OpenID Connect; the user connecting and the client being used must have the requisite access rights. In a default Keycloak installation, admin-cli and an admin user would work, as would a separate client definition with the scope tailored to your needs and a user having the expected roles.
/// Client O(client_id) must have O(community.general.keycloak_client#module:full_scope_allowed) set to V(false).
/// Attributes are multi-valued in the Keycloak API. All attributes are lists of individual values and will be returned that way by this module. You may pass single values for attributes when calling the module, and this will be translated into a list suitable for the API.
class KeycloakClientRolescopeOptions {
    /// Roles provided in O(role_names) while be added to this client scope.
    client_id: String
    /// If the O(role_names) are client role, the client ID under which it resides.
    /// If this parameter is absent, the roles are considered a realm role.
    client_scope_id: String?
    /// The Keycloak realm under which clients resides.
    realm: String?
    /// Names of roles to manipulate.
    /// If O(client_scope_id) is present, all roles must be under this client.
    /// If O(client_scope_id) is absent, all roles must be under the realm.
    role_names: Listing<String>
    /// State of the role mapping.
    /// On V(present), all roles in O(role_names) will be mapped if not exists yet.
    /// On V(absent), all roles mapping in O(role_names) will be removed if it exists.
    state: ("present"|"absent")?
}

/// Task class for keycloak_client_rolescope
class KeycloakClientRolescopeTask extends Playbook.Task {
    /// todo doc
    `community.general.keycloak_client_rolescope`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.keycloak_client_rolescope"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.keycloak_client_rolescope`
}

/// TaskBuilder class for keycloak_client_rolescope
class KeycloakClientRolescope extends Playbook.TaskBuilder {
    /// Options for community.general.keycloak_client_rolescope
    options: KeycloakClientRolescopeOptions?
    /// todo doc
    function Task(): KeycloakClientRolescopeTask = this
        .toMap()
        .put("community.general.keycloak_client_rolescope", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(KeycloakClientRolescopeTask)
}

/// Allows administration of Keycloak client_scopes via Keycloak API
/// This module allows you to add, remove or modify Keycloak client_scopes via the Keycloak REST API. It requires access to the REST API via OpenID Connect; the user connecting and the client being used must have the requisite access rights. In a default Keycloak installation, admin-cli and an admin user would work, as would a separate client definition with the scope tailored to your needs and a user having the expected roles.
/// The names of module options are snake_cased versions of the camelCase ones found in the Keycloak API and its documentation at U(https://www.keycloak.org/docs-api/8.0/rest-api/index.html).
/// Attributes are multi-valued in the Keycloak API. All attributes are lists of individual values and will be returned that way by this module. You may pass single values for attributes when calling the module, and this will be translated into a list suitable for the API.
/// When updating a client_scope, where possible provide the client_scope ID to the module. This removes a lookup to the API to translate the name into the client_scope ID.
class KeycloakClientscopeOptions {
    /// A dict of key/value pairs to set as custom attributes for the client_scope.
    /// Values may be single values (for example a string) or a list of strings.
    attributes: Any?
    /// Description for this client_scope.
    /// This parameter is not required for updating or deleting a client_scope.
    description: String?
    /// The unique identifier for this client_scope.
    /// This parameter is not required for updating or deleting a client_scope but providing it will reduce the number of API calls required.
    id: String?
    /// Name of the client_scope.
    /// This parameter is required only when creating or updating the client_scope.
    name: String?
    /// Type of client.
    /// The V(docker-v2) value was added in community.general 8.6.0.
    protocol: ("openid-connect"|"saml"|"wsfed"|"docker-v2")?
    /// A list of dicts defining protocol mappers for this client.
    /// This is 'protocolMappers' in the Keycloak REST API.
    protocol_mappers: Listing<Any>?
    /// They Keycloak realm under which this client_scope resides.
    realm: String?
    /// State of the client_scope.
    /// On V(present), the client_scope will be created if it does not yet exist, or updated with the parameters you provide.
    /// On V(absent), the client_scope will be removed if it exists.
    state: ("present"|"absent")?
}

/// Task class for keycloak_clientscope
class KeycloakClientscopeTask extends Playbook.Task {
    /// todo doc
    `community.general.keycloak_clientscope`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.keycloak_clientscope"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.keycloak_clientscope`
}

/// TaskBuilder class for keycloak_clientscope
class KeycloakClientscope extends Playbook.TaskBuilder {
    /// Options for community.general.keycloak_clientscope
    options: KeycloakClientscopeOptions?
    /// todo doc
    function Task(): KeycloakClientscopeTask = this
        .toMap()
        .put("community.general.keycloak_clientscope", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(KeycloakClientscopeTask)
}

/// Set the type of aclientscope in realm or client via Keycloak API
/// This module allows you to set the type (optional, default) of clientscopes via the Keycloak REST API. It requires access to the REST API via OpenID Connect; the user connecting and the client being used must have the requisite access rights. In a default Keycloak installation, admin-cli and an admin user would work, as would a separate client definition with the scope tailored to your needs and a user having the expected roles.
class KeycloakClientscopeTypeOptions {
    /// The O(client_id) of the client. If not set the clientscop types are set as a default for the realm.
    client_id: String?
    /// Client scopes that should be of type default.
    default_clientscopes: Listing<String>?
    /// Client scopes that should be of type optional.
    optional_clientscopes: Listing<String>?
    /// The Keycloak realm.
    realm: String?
}

/// Task class for keycloak_clientscope_type
class KeycloakClientscopeTypeTask extends Playbook.Task {
    /// todo doc
    `community.general.keycloak_clientscope_type`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.keycloak_clientscope_type"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.keycloak_clientscope_type`
}

/// TaskBuilder class for keycloak_clientscope_type
class KeycloakClientscopeType extends Playbook.TaskBuilder {
    /// Options for community.general.keycloak_clientscope_type
    options: KeycloakClientscopeTypeOptions?
    /// todo doc
    function Task(): KeycloakClientscopeTypeTask = this
        .toMap()
        .put("community.general.keycloak_clientscope_type", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(KeycloakClientscopeTypeTask)
}

/// Retrieve client secret via Keycloak API
/// This module allows you to get a Keycloak client secret via the Keycloak REST API. It requires access to the REST API via OpenID Connect; the user connecting and the client being used must have the requisite access rights. In a default Keycloak installation, admin-cli and an admin user would work, as would a separate client definition with the scope tailored to your needs and a user having the expected roles.
/// When retrieving a new client secret, where possible provide the client's O(id) (not O(client_id)) to the module. This removes a lookup to the API to translate the O(client_id) into the client ID.
/// Note that this module returns the client secret. To avoid this showing up in the logs, please add C(no_log: true) to the task.
class KeycloakClientsecretInfoOptions {
    /// The O(client_id) of the client. Passing this instead of O(id) results in an extra API call.
    client_id: String?
    /// The unique identifier for this client.
    /// This parameter is not required for getting or generating a client secret but providing it will reduce the number of API calls required.
    id: String?
    /// They Keycloak realm under which this client resides.
    realm: String?
}

/// Task class for keycloak_clientsecret_info
class KeycloakClientsecretInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.keycloak_clientsecret_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.keycloak_clientsecret_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.keycloak_clientsecret_info`
}

/// TaskBuilder class for keycloak_clientsecret_info
class KeycloakClientsecretInfo extends Playbook.TaskBuilder {
    /// Options for community.general.keycloak_clientsecret_info
    options: KeycloakClientsecretInfoOptions?
    /// todo doc
    function Task(): KeycloakClientsecretInfoTask = this
        .toMap()
        .put("community.general.keycloak_clientsecret_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(KeycloakClientsecretInfoTask)
}

/// Regenerate Keycloak client secret via Keycloak API
/// This module allows you to regenerate a Keycloak client secret via the Keycloak REST API. It requires access to the REST API via OpenID Connect; the user connecting and the client being used must have the requisite access rights. In a default Keycloak installation, admin-cli and an admin user would work, as would a separate client definition with the scope tailored to your needs and a user having the expected roles.
/// When regenerating a client secret, where possible provide the client's id (not client_id) to the module. This removes a lookup to the API to translate the client_id into the client ID.
/// Note that this module returns the client secret. To avoid this showing up in the logs, please add C(no_log: true) to the task.
class KeycloakClientsecretRegenerateOptions {
    /// The client_id of the client. Passing this instead of id results in an extra API call.
    client_id: String?
    /// The unique identifier for this client.
    /// This parameter is not required for getting or generating a client secret but providing it will reduce the number of API calls required.
    id: String?
    /// They Keycloak realm under which this client resides.
    realm: String?
}

/// Task class for keycloak_clientsecret_regenerate
class KeycloakClientsecretRegenerateTask extends Playbook.Task {
    /// todo doc
    `community.general.keycloak_clientsecret_regenerate`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.keycloak_clientsecret_regenerate"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.keycloak_clientsecret_regenerate`
}

/// TaskBuilder class for keycloak_clientsecret_regenerate
class KeycloakClientsecretRegenerate extends Playbook.TaskBuilder {
    /// Options for community.general.keycloak_clientsecret_regenerate
    options: KeycloakClientsecretRegenerateOptions?
    /// todo doc
    function Task(): KeycloakClientsecretRegenerateTask = this
        .toMap()
        .put("community.general.keycloak_clientsecret_regenerate", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(KeycloakClientsecretRegenerateTask)
}

/// Allows administration of Keycloak client templates via Keycloak API
/// This module allows the administration of Keycloak client templates via the Keycloak REST API. It requires access to the REST API via OpenID Connect; the user connecting and the client being used must have the requisite access rights. In a default Keycloak installation, admin-cli and an admin user would work, as would a separate client definition with the scope tailored to your needs and a user having the expected roles.
/// The names of module options are snake_cased versions of the camelCase ones found in the Keycloak API and its documentation at U(https://www.keycloak.org/docs-api/8.0/rest-api/index.html)
/// The Keycloak API does not always enforce for only sensible settings to be used -- you can set SAML-specific settings on an OpenID Connect client for instance and vice versa. Be careful. If you do not specify a setting, usually a sensible default is chosen.
class KeycloakClienttemplateOptions {
    /// A dict of further attributes for this client template. This can contain various configuration settings, though in the default installation of Keycloak as of 3.4, none are documented or known, so this is usually empty.
    attributes: Any?
    /// Description of the client template in Keycloak.
    description: String?
    /// Is the "Full Scope Allowed" feature set for this client template or not. This is 'fullScopeAllowed' in the Keycloak REST API.
    full_scope_allowed: Boolean?
    /// Id of client template to be worked on. This is usually a UUID.
    id: String?
    /// Name of the client template.
    name: String?
    /// Type of client template.
    /// The V(docker-v2) value was added in community.general 8.6.0.
    protocol: ("openid-connect"|"saml"|"docker-v2")?
    /// a list of dicts defining protocol mappers for this client template. This is 'protocolMappers' in the Keycloak REST API.
    protocol_mappers: Listing<Any>?
    /// Realm this client template is found in.
    realm: String?
    /// State of the client template.
    /// On V(present), the client template will be created (or updated if it exists already).
    /// On V(absent), the client template will be removed if it exists
    state: ("present"|"absent")?
}

/// Task class for keycloak_clienttemplate
class KeycloakClienttemplateTask extends Playbook.Task {
    /// todo doc
    `community.general.keycloak_clienttemplate`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.keycloak_clienttemplate"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.keycloak_clienttemplate`
}

/// TaskBuilder class for keycloak_clienttemplate
class KeycloakClienttemplate extends Playbook.TaskBuilder {
    /// Options for community.general.keycloak_clienttemplate
    options: KeycloakClienttemplateOptions?
    /// todo doc
    function Task(): KeycloakClienttemplateTask = this
        .toMap()
        .put("community.general.keycloak_clienttemplate", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(KeycloakClienttemplateTask)
}

/// Retrive component info in Keycloak
/// This module retrive information on component from Keycloak.
class KeycloakComponentInfoOptions {
    /// Name of the Component.
    name: String?
    /// Container ID of the components.
    parent_id: String?
    /// Provider type of components.
    /// Example: V(org.keycloak.storage.UserStorageProvider), V(org.keycloak.services.clientregistration.policy.ClientRegistrationPolicy), V(org.keycloak.keys.KeyProvider), V(org.keycloak.userprofile.UserProfileProvider), V(org.keycloak.storage.ldap.mappers.LDAPStorageMapper).
    provider_type: String?
    /// The name of the realm.
    realm: String
}

/// Task class for keycloak_component_info
class KeycloakComponentInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.keycloak_component_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.keycloak_component_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.keycloak_component_info`
}

/// TaskBuilder class for keycloak_component_info
class KeycloakComponentInfo extends Playbook.TaskBuilder {
    /// Options for community.general.keycloak_component_info
    options: KeycloakComponentInfoOptions?
    /// todo doc
    function Task(): KeycloakComponentInfoTask = this
        .toMap()
        .put("community.general.keycloak_component_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(KeycloakComponentInfoTask)
}

/// Allows administration of Keycloak groups via Keycloak API
/// This module allows you to add, remove or modify Keycloak groups via the Keycloak REST API. It requires access to the REST API via OpenID Connect; the user connecting and the client being used must have the requisite access rights. In a default Keycloak installation, admin-cli and an admin user would work, as would a separate client definition with the scope tailored to your needs and a user having the expected roles.
/// The names of module options are snake_cased versions of the camelCase ones found in the Keycloak API and its documentation at U(https://www.keycloak.org/docs-api/20.0.2/rest-api/index.html).
/// Attributes are multi-valued in the Keycloak API. All attributes are lists of individual values and will be returned that way by this module. You may pass single values for attributes when calling the module, and this will be translated into a list suitable for the API.
/// When updating a group, where possible provide the group ID to the module. This removes a lookup to the API to translate the name into the group ID.
class KeycloakGroupOptions {
    /// A dict of key/value pairs to set as custom attributes for the group.
    /// Values may be single values (e.g. a string) or a list of strings.
    attributes: Any?
    /// The unique identifier for this group.
    /// This parameter is not required for updating or deleting a group but providing it will reduce the number of API calls required.
    id: String?
    /// Name of the group.
    /// This parameter is required only when creating or updating the group.
    name: String?
    /// List of parent groups for the group to handle sorted top to bottom.
    /// Set this to create a group as a subgroup of another group or groups (parents) or when accessing an existing subgroup by name.
    /// Not necessary to set when accessing an existing subgroup by its C(ID) because in that case the group can be directly queried without necessarily knowing its parent(s).
    parents: Listing<Any>?
    /// They Keycloak realm under which this group resides.
    realm: String?
    /// State of the group.
    /// On V(present), the group will be created if it does not yet exist, or updated with the parameters you provide.
    /// On V(absent), the group will be removed if it exists. Be aware that absenting a group with subgroups will automatically delete all its subgroups too.
    state: ("present"|"absent")?
}

/// Task class for keycloak_group
class KeycloakGroupTask extends Playbook.Task {
    /// todo doc
    `community.general.keycloak_group`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.keycloak_group"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.keycloak_group`
}

/// TaskBuilder class for keycloak_group
class KeycloakGroup extends Playbook.TaskBuilder {
    /// Options for community.general.keycloak_group
    options: KeycloakGroupOptions?
    /// todo doc
    function Task(): KeycloakGroupTask = this
        .toMap()
        .put("community.general.keycloak_group", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(KeycloakGroupTask)
}

/// Allows administration of Keycloak identity providers via Keycloak API
/// This module allows you to add, remove or modify Keycloak identity providers via the Keycloak REST API. It requires access to the REST API via OpenID Connect; the user connecting and the client being used must have the requisite access rights. In a default Keycloak installation, admin-cli and an admin user would work, as would a separate client definition with the scope tailored to your needs and a user having the expected roles.
/// The names of module options are snake_cased versions of the camelCase ones found in the Keycloak API and its documentation at U(https://www.keycloak.org/docs-api/15.0/rest-api/index.html).
class KeycloakIdentityProviderOptions {
    /// Enable/disable whether new users can read any stored tokens. This assigns the C(broker.read-token) role.
    add_read_token_role_on_create: Boolean?
    /// The alias uniquely identifies an identity provider and it is also used to build the redirect URI.
    alias: String
    /// Specifies if this identity provider should be used by default for authentication even before displaying login screen.
    authenticate_by_default: Boolean?
    /// Dict specifying the configuration options for the provider; the contents differ depending on the value of O(provider_id). Examples are given below for V(oidc) and V(saml). It is easiest to obtain valid config values by dumping an already-existing identity provider configuration through check-mode in the RV(existing) field.
    config: Any?
    /// Friendly name for identity provider.
    display_name: String?
    /// Enable/disable this identity provider.
    enabled: Boolean?
    /// Alias of authentication flow, which is triggered after first login with this identity provider.
    first_broker_login_flow_alias: String?
    /// If true, users cannot log in through this provider. They can only link to this provider. This is useful if you don't want to allow login from the provider, but want to integrate with a provider.
    link_only: Boolean?
    /// A list of dicts defining mappers associated with this Identity Provider.
    mappers: Listing<Any>?
    /// Alias of authentication flow, which is triggered after each login with this identity provider.
    post_broker_login_flow_alias: String?
    /// Protocol used by this provider (supported values are V(oidc) or V(saml)).
    provider_id: String?
    /// The Keycloak realm under which this identity provider resides.
    realm: String?
    /// State of the identity provider.
    /// On V(present), the identity provider will be created if it does not yet exist, or updated with the parameters you provide.
    /// On V(absent), the identity provider will be removed if it exists.
    state: ("present"|"absent")?
    /// Enable/disable whether tokens must be stored after authenticating users.
    store_token: Boolean?
    /// If enabled, email provided by this provider is not verified even if verification is enabled for the realm.
    trust_email: Boolean?
}

/// Task class for keycloak_identity_provider
class KeycloakIdentityProviderTask extends Playbook.Task {
    /// todo doc
    `community.general.keycloak_identity_provider`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.keycloak_identity_provider"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.keycloak_identity_provider`
}

/// TaskBuilder class for keycloak_identity_provider
class KeycloakIdentityProvider extends Playbook.TaskBuilder {
    /// Options for community.general.keycloak_identity_provider
    options: KeycloakIdentityProviderOptions?
    /// todo doc
    function Task(): KeycloakIdentityProviderTask = this
        .toMap()
        .put("community.general.keycloak_identity_provider", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(KeycloakIdentityProviderTask)
}

/// Allows administration of Keycloak realm via Keycloak API
/// This module allows the administration of Keycloak realm via the Keycloak REST API. It requires access to the REST API via OpenID Connect; the user connecting and the realm being used must have the requisite access rights. In a default Keycloak installation, admin-cli and an admin user would work, as would a separate realm definition with the scope tailored to your needs and a user having the expected roles.
/// The names of module options are snake_cased versions of the camelCase ones found in the Keycloak API and its documentation at U(https://www.keycloak.org/docs-api/8.0/rest-api/index.html). Aliases are provided so camelCased versions can be used as well.
/// The Keycloak API does not always sanity check inputs e.g. you can set SAML-specific settings on an OpenID Connect client for instance and vice versa. Be careful. If you do not specify a setting, usually a sensible default is chosen.
class KeycloakRealmOptions {
    /// The realm access code lifespan.
    access_code_lifespan: Int?
    /// The realm access code lifespan login.
    access_code_lifespan_login: Int?
    /// The realm access code lifespan user action.
    access_code_lifespan_user_action: Int?
    /// The realm access token lifespan.
    access_token_lifespan: Int?
    /// The realm access token lifespan for implicit flow.
    access_token_lifespan_for_implicit_flow: Int?
    /// The realm account theme.
    account_theme: String?
    /// The realm action token generated by admin lifespan.
    action_token_generated_by_admin_lifespan: Int?
    /// The realm action token generated by user lifespan.
    action_token_generated_by_user_lifespan: Int?
    /// The realm admin events details enabled.
    admin_events_details_enabled: Boolean?
    /// The realm admin events enabled.
    admin_events_enabled: Boolean?
    /// The realm admin theme.
    admin_theme: String?
    /// The realm attributes.
    attributes: Any?
    /// The realm browser flow.
    browser_flow: String?
    /// The realm browser security headers.
    browser_security_headers: Any?
    /// The realm brute force protected.
    brute_force_protected: Boolean?
    /// The realm client authentication flow.
    client_authentication_flow: String?
    /// The realm client scope mappings.
    client_scope_mappings: Any?
    /// The realm default default client scopes.
    default_default_client_scopes: Listing<String>?
    /// The realm default groups.
    default_groups: Listing<String>?
    /// The realm default locale.
    default_locale: String?
    /// The realm default optional client scopes.
    default_optional_client_scopes: Listing<String>?
    /// The realm default roles.
    default_roles: Listing<String>?
    /// The realm default signature algorithm.
    default_signature_algorithm: String?
    /// The realm direct grant flow.
    direct_grant_flow: String?
    /// The realm display name.
    display_name: String?
    /// The realm display name HTML.
    display_name_html: String?
    /// The realm docker authentication flow.
    docker_authentication_flow: String?
    /// The realm duplicate emails allowed option.
    duplicate_emails_allowed: Boolean?
    /// The realm edit username allowed option.
    edit_username_allowed: Boolean?
    /// The realm email theme.
    email_theme: String?
    /// The realm enabled option.
    enabled: Boolean?
    /// The realm enabled event types.
    enabled_event_types: Listing<String>?
    /// Enables or disables login events for this realm.
    events_enabled: Boolean?
    /// The realm events expiration.
    events_expiration: Int?
    /// The realm events listeners.
    events_listeners: Listing<String>?
    /// The realm failure factor.
    failure_factor: Int?
    /// The realm to create.
    id: String?
    /// The realm internationalization enabled option.
    internationalization_enabled: Boolean?
    /// The realm login theme.
    login_theme: String?
    /// The realm login with email allowed option.
    login_with_email_allowed: Boolean?
    /// The realm max delta time in seconds.
    max_delta_time_seconds: Int?
    /// The realm max failure wait in seconds.
    max_failure_wait_seconds: Int?
    /// The realm minimum quick login wait in seconds.
    minimum_quick_login_wait_seconds: Int?
    /// The realm not before.
    not_before: Int?
    /// The realm offline session idle timeout.
    offline_session_idle_timeout: Int?
    /// The realm offline session max lifespan.
    offline_session_max_lifespan: Int?
    /// The realm offline session max lifespan enabled option.
    offline_session_max_lifespan_enabled: Boolean?
    /// The realm otp policy algorithm.
    otp_policy_algorithm: String?
    /// The realm otp policy digits.
    otp_policy_digits: Int?
    /// The realm otp policy initial counter.
    otp_policy_initial_counter: Int?
    /// The realm otp policy look ahead window.
    otp_policy_look_ahead_window: Int?
    /// The realm otp policy period.
    otp_policy_period: Int?
    /// The realm otp policy type.
    otp_policy_type: String?
    /// The realm otp supported applications.
    otp_supported_applications: Listing<String>?
    /// The realm password policy.
    password_policy: String?
    /// The realm permanent lockout.
    permanent_lockout: Boolean?
    /// The realm quick login check in milliseconds.
    quick_login_check_milli_seconds: Int?
    /// The realm name.
    realm: String?
    /// The realm refresh token max reuse.
    refresh_token_max_reuse: Int?
    /// The realm registration allowed option.
    registration_allowed: Boolean?
    /// The realm registration email as username option.
    registration_email_as_username: Boolean?
    /// The realm registration flow.
    registration_flow: String?
    /// The realm remember me option.
    remember_me: Boolean?
    /// The realm reset credentials flow.
    reset_credentials_flow: String?
    /// The realm reset password allowed option.
    reset_password_allowed: Boolean?
    /// The realm revoke refresh token option.
    revoke_refresh_token: Boolean?
    /// The realm smtp server.
    smtp_server: Any?
    /// The realm ssl required option.
    ssl_required: ("all"|"external"|"none")?
    /// The realm sso session idle timeout.
    sso_session_idle_timeout: Int?
    /// The realm sso session idle timeout remember me.
    sso_session_idle_timeout_remember_me: Int?
    /// The realm sso session max lifespan.
    sso_session_max_lifespan: Int?
    /// The realm sso session max lifespan remember me.
    sso_session_max_lifespan_remember_me: Int?
    /// State of the realm.
    /// On V(present), the realm will be created (or updated if it exists already).
    /// On V(absent), the realm will be removed if it exists.
    state: ("present"|"absent")?
    /// The realm supported locales.
    supported_locales: Listing<String>?
    /// The realm user managed access allowed option.
    user_managed_access_allowed: Boolean?
    /// The realm verify email option.
    verify_email: Boolean?
    /// The realm wait increment in seconds.
    wait_increment_seconds: Int?
}

/// Task class for keycloak_realm
class KeycloakRealmTask extends Playbook.Task {
    /// todo doc
    `community.general.keycloak_realm`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.keycloak_realm"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.keycloak_realm`
}

/// TaskBuilder class for keycloak_realm
class KeycloakRealm extends Playbook.TaskBuilder {
    /// Options for community.general.keycloak_realm
    options: KeycloakRealmOptions?
    /// todo doc
    function Task(): KeycloakRealmTask = this
        .toMap()
        .put("community.general.keycloak_realm", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(KeycloakRealmTask)
}

/// Allows obtaining Keycloak realm public information via Keycloak API
/// This module allows you to get Keycloak realm public information via the Keycloak REST API.
/// The names of module options are snake_cased versions of the camelCase ones found in the Keycloak API and its documentation at U(https://www.keycloak.org/docs-api/8.0/rest-api/index.html).
/// Attributes are multi-valued in the Keycloak API. All attributes are lists of individual values and will be returned that way by this module. You may pass single values for attributes when calling the module, and this will be translated into a list suitable for the API.
class KeycloakRealmInfoOptions {
    /// URL to the Keycloak instance.
    auth_keycloak_url: String
    /// They Keycloak realm ID.
    realm: String?
    /// Verify TLS certificates (do not disable this in production).
    validate_certs: Boolean?
}

/// Task class for keycloak_realm_info
class KeycloakRealmInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.keycloak_realm_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.keycloak_realm_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.keycloak_realm_info`
}

/// TaskBuilder class for keycloak_realm_info
class KeycloakRealmInfo extends Playbook.TaskBuilder {
    /// Options for community.general.keycloak_realm_info
    options: KeycloakRealmInfoOptions?
    /// todo doc
    function Task(): KeycloakRealmInfoTask = this
        .toMap()
        .put("community.general.keycloak_realm_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(KeycloakRealmInfoTask)
}

/// Allows administration of Keycloak realm keys via Keycloak API
/// This module allows the administration of Keycloak realm keys via the Keycloak REST API. It requires access to the REST API via OpenID Connect; the user connecting and the realm being used must have the requisite access rights. In a default Keycloak installation, admin-cli and an admin user would work, as would a separate realm definition with the scope tailored to your needs and a user having the expected roles.
/// The names of module options are snake_cased versions of the camelCase ones found in the Keycloak API and its documentation at U(https://www.keycloak.org/docs-api/8.0/rest-api/index.html). Aliases are provided so camelCased versions can be used as well.
/// This module is unable to detect changes to the actual cryptographic key after importing it. However, if some other property is changed alongside the cryptographic key, then the key will also get changed as a side-effect, as the JSON payload needs to include the private key. This can be considered either a bug or a feature, as the alternative would be to always update the realm key whether it has changed or not.
/// If certificate is not explicitly provided it will be dynamically created by Keycloak. Therefore comparing the current state of the certificate to the desired state (which may be empty) is not possible.
class KeycloakRealmKeyOptions {
    /// Dict specifying the key and its properties.
    config: Any?
    /// Enforce the state of the private key and certificate. This is not automatically the case as this module is unable to determine the current state of the private key and thus cannot trigger an update based on an actual divergence. That said, a private key update may happen even if force is false as a side-effect of other changes.
    force: Boolean?
    /// Name of the realm key to create.
    name: String
    /// The parent_id of the realm key. In practice the ID (name) of the realm.
    parent_id: String
    /// The name of the "provider ID" for the key.
    /// The value V(rsa-enc) has been added in community.general 8.2.0.
    provider_id: ("rsa"|"rsa-enc")?
    /// State of the keycloak realm key.
    /// On V(present), the realm key will be created (or updated if it exists already).
    /// On V(absent), the realm key will be removed if it exists.
    state: ("present"|"absent")?
}

/// Task class for keycloak_realm_key
class KeycloakRealmKeyTask extends Playbook.Task {
    /// todo doc
    `community.general.keycloak_realm_key`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.keycloak_realm_key"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.keycloak_realm_key`
}

/// TaskBuilder class for keycloak_realm_key
class KeycloakRealmKey extends Playbook.TaskBuilder {
    /// Options for community.general.keycloak_realm_key
    options: KeycloakRealmKeyOptions?
    /// todo doc
    function Task(): KeycloakRealmKeyTask = this
        .toMap()
        .put("community.general.keycloak_realm_key", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(KeycloakRealmKeyTask)
}

/// Allows administration of Keycloak realm role mappings into groups with the Keycloak API
/// This module allows you to add, remove or modify Keycloak realm role mappings into groups with the Keycloak REST API. It requires access to the REST API via OpenID Connect; the user connecting and the client being used must have the requisite access rights. In a default Keycloak installation, admin-cli and an admin user would work, as would a separate client definition with the scope tailored to your needs and a user having the expected roles.
/// The names of module options are snake_cased versions of the camelCase ones found in the Keycloak API and its documentation at U(https://www.keycloak.org/docs-api/18.0/rest-api/index.html).
/// Attributes are multi-valued in the Keycloak API. All attributes are lists of individual values and will be returned that way by this module. You may pass single values for attributes when calling the module, and this will be translated into a list suitable for the API.
/// When updating a group_rolemapping, where possible provide the role ID to the module. This removes a lookup to the API to translate the name into the role ID.
class KeycloakRealmRolemappingOptions {
    /// ID of the group to be mapped.
    /// This parameter is not required for updating or deleting the rolemapping but providing it will reduce the number of API calls required.
    gid: String?
    /// Name of the group to be mapped.
    /// This parameter is required (can be replaced by gid for less API call).
    group_name: String?
    /// List of parent groups for the group to handle sorted top to bottom.
    /// Set this if your group is a subgroup and you do not provide the GID in O(gid).
    parents: Listing<Any>?
    /// They Keycloak realm under which this role_representation resides.
    realm: String?
    /// Roles to be mapped to the group.
    roles: Listing<Any>?
    /// State of the realm_rolemapping.
    /// On C(present), the realm_rolemapping will be created if it does not yet exist, or updated with the parameters you provide.
    /// On C(absent), the realm_rolemapping will be removed if it exists.
    state: ("present"|"absent")?
}

/// Task class for keycloak_realm_rolemapping
class KeycloakRealmRolemappingTask extends Playbook.Task {
    /// todo doc
    `community.general.keycloak_realm_rolemapping`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.keycloak_realm_rolemapping"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.keycloak_realm_rolemapping`
}

/// TaskBuilder class for keycloak_realm_rolemapping
class KeycloakRealmRolemapping extends Playbook.TaskBuilder {
    /// Options for community.general.keycloak_realm_rolemapping
    options: KeycloakRealmRolemappingOptions?
    /// todo doc
    function Task(): KeycloakRealmRolemappingTask = this
        .toMap()
        .put("community.general.keycloak_realm_rolemapping", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(KeycloakRealmRolemappingTask)
}

/// Allows administration of Keycloak roles via Keycloak API
/// This module allows you to add, remove or modify Keycloak roles via the Keycloak REST API. It requires access to the REST API via OpenID Connect; the user connecting and the client being used must have the requisite access rights. In a default Keycloak installation, admin-cli and an admin user would work, as would a separate client definition with the scope tailored to your needs and a user having the expected roles.
/// The names of module options are snake_cased versions of the camelCase ones found in the Keycloak API and its documentation at U(https://www.keycloak.org/docs-api/8.0/rest-api/index.html).
/// Attributes are multi-valued in the Keycloak API. All attributes are lists of individual values and will be returned that way by this module. You may pass single values for attributes when calling the module, and this will be translated into a list suitable for the API.
class KeycloakRoleOptions {
    /// A dict of key/value pairs to set as custom attributes for the role.
    /// Values may be single values (e.g. a string) or a list of strings.
    attributes: Any?
    /// If the role is a client role, the client id under which it resides.
    /// If this parameter is absent, the role is considered a realm role.
    client_id: String?
    /// If V(true), the role is a composition of other realm and/or client role.
    composite: Boolean?
    /// List of roles to include to the composite realm role.
    /// If the composite role is a client role, the C(clientId) (not ID of the client) must be specified.
    composites: Listing<Any>?
    /// The role description.
    description: String?
    /// Name of the role.
    /// This parameter is required.
    name: String
    /// The Keycloak realm under which this role resides.
    realm: String?
    /// State of the role.
    /// On V(present), the role will be created if it does not yet exist, or updated with the parameters you provide.
    /// On V(absent), the role will be removed if it exists.
    state: ("present"|"absent")?
}

/// Task class for keycloak_role
class KeycloakRoleTask extends Playbook.Task {
    /// todo doc
    `community.general.keycloak_role`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.keycloak_role"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.keycloak_role`
}

/// TaskBuilder class for keycloak_role
class KeycloakRole extends Playbook.TaskBuilder {
    /// Options for community.general.keycloak_role
    options: KeycloakRoleOptions?
    /// todo doc
    function Task(): KeycloakRoleTask = this
        .toMap()
        .put("community.general.keycloak_role", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(KeycloakRoleTask)
}

/// Create and configure a user in Keycloak
/// This module creates, removes, or updates Keycloak users.
class KeycloakUserOptions {
    /// list user access.
    access: Any?
    /// List of user attributes.
    attributes: Listing<Any>?
    auth_username: Any?
    /// Client Authenticator Type.
    client_consents: Listing<Any>?
    /// User credentials.
    credentials: Listing<Any>?
    /// list user Credential Type.
    disableable_credential_types: Listing<String>?
    /// User email.
    email: String?
    /// Check the validity of user email.
    email_verified: Boolean?
    /// Enabled user.
    enabled: Boolean?
    /// List of IDPs of user.
    federated_identities: Listing<String>?
    /// Federation Link.
    federation_link: String?
    /// The user's first name.
    first_name: String?
    /// If V(true), allows to remove user and recreate it.
    force: Boolean?
    /// List of groups for the user.
    groups: Listing<Any>?
    /// ID of the user on the Keycloak server if known.
    id: String?
    /// The user's last name.
    last_name: String?
    /// user origin.
    origin: String?
    /// The name of the realm in which is the client.
    realm: String?
    /// RequiredActions user Auth.
    required_actions: Listing<String>?
    /// user self administration.
    self: String?
    /// Description of the client Application.
    service_account_client_id: String?
    /// Control whether the user should exists or not.
    state: ("present"|"absent")?
    /// Username for the user.
    username: String
}

/// Task class for keycloak_user
class KeycloakUserTask extends Playbook.Task {
    /// todo doc
    `community.general.keycloak_user`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.keycloak_user"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.keycloak_user`
}

/// TaskBuilder class for keycloak_user
class KeycloakUser extends Playbook.TaskBuilder {
    /// Options for community.general.keycloak_user
    options: KeycloakUserOptions?
    /// todo doc
    function Task(): KeycloakUserTask = this
        .toMap()
        .put("community.general.keycloak_user", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(KeycloakUserTask)
}

/// Allows administration of Keycloak user federations via Keycloak API
/// This module allows you to add, remove or modify Keycloak user federations via the Keycloak REST API. It requires access to the REST API via OpenID Connect; the user connecting and the client being used must have the requisite access rights. In a default Keycloak installation, admin-cli and an admin user would work, as would a separate client definition with the scope tailored to your needs and a user having the expected roles.
/// The names of module options are snake_cased versions of the camelCase ones found in the Keycloak API and its documentation at U(https://www.keycloak.org/docs-api/20.0.2/rest-api/index.html).
class KeycloakUserFederationOptions {
    /// Dict specifying the configuration options for the provider; the contents differ depending on the value of O(provider_id). Examples are given below for V(ldap), V(kerberos) and V(sssd). It is easiest to obtain valid config values by dumping an already-existing user federation configuration through check-mode in the RV(existing) field.
    /// The value V(sssd) has been supported since community.general 4.2.0.
    config: Any?
    /// The unique ID for this user federation. If left empty, the user federation will be searched by its O(name).
    id: String?
    /// A list of dicts defining mappers associated with this Identity Provider.
    mappers: Listing<Any>?
    /// Display name of provider when linked in admin console.
    name: String?
    /// Unique ID for the parent of this user federation. Realm ID will be automatically used if left blank.
    parent_id: String?
    /// Provider for this user federation. Built-in providers are V(ldap), V(kerberos), and V(sssd). Custom user storage providers can also be used.
    provider_id: String?
    /// Component type for user federation (only supported value is V(org.keycloak.storage.UserStorageProvider)).
    provider_type: String?
    /// The Keycloak realm under which this user federation resides.
    realm: String?
    /// State of the user federation.
    /// On V(present), the user federation will be created if it does not yet exist, or updated with the parameters you provide.
    /// On V(absent), the user federation will be removed if it exists.
    state: ("present"|"absent")?
}

/// Task class for keycloak_user_federation
class KeycloakUserFederationTask extends Playbook.Task {
    /// todo doc
    `community.general.keycloak_user_federation`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.keycloak_user_federation"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.keycloak_user_federation`
}

/// TaskBuilder class for keycloak_user_federation
class KeycloakUserFederation extends Playbook.TaskBuilder {
    /// Options for community.general.keycloak_user_federation
    options: KeycloakUserFederationOptions?
    /// todo doc
    function Task(): KeycloakUserFederationTask = this
        .toMap()
        .put("community.general.keycloak_user_federation", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(KeycloakUserFederationTask)
}

/// Allows administration of Keycloak user_rolemapping with the Keycloak API
/// This module allows you to add, remove or modify Keycloak user_rolemapping with the Keycloak REST API. It requires access to the REST API via OpenID Connect; the user connecting and the client being used must have the requisite access rights. In a default Keycloak installation, admin-cli and an admin user would work, as would a separate client definition with the scope tailored to your needs and a user having the expected roles.
/// The names of module options are snake_cased versions of the camelCase ones found in the Keycloak API and its documentation at U(https://www.keycloak.org/docs-api/8.0/rest-api/index.html).
/// Attributes are multi-valued in the Keycloak API. All attributes are lists of individual values and will be returned that way by this module. You may pass single values for attributes when calling the module, and this will be translated into a list suitable for the API.
/// When updating a user_rolemapping, where possible provide the role ID to the module. This removes a lookup to the API to translate the name into the role ID.
class KeycloakUserRolemappingOptions {
    /// ID of the client to be mapped.
    /// This parameter is not required for updating or deleting the rolemapping but providing it will reduce the number of API calls required.
    cid: String?
    /// Name of the client to be mapped (different than O(cid)).
    /// This parameter is required if O(cid) is not provided (can be replaced by O(cid) to reduce the number of API calls that must be made).
    client_id: String?
    /// They Keycloak realm under which this role_representation resides.
    realm: String?
    /// Roles to be mapped to the user.
    roles: Listing<Any>?
    /// Client ID of the service-account-user to be mapped.
    /// This parameter is not required for updating or deleting the rolemapping but providing it will reduce the number of API calls required.
    service_account_user_client_id: String?
    /// State of the user_rolemapping.
    /// On V(present), the user_rolemapping will be created if it does not yet exist, or updated with the parameters you provide.
    /// On V(absent), the user_rolemapping will be removed if it exists.
    state: ("present"|"absent")?
    /// Username of the user roles are mapped to.
    /// This parameter is not required (can be replaced by uid for less API call).
    target_username: String?
    /// ID of the user to be mapped.
    /// This parameter is not required for updating or deleting the rolemapping but providing it will reduce the number of API calls required.
    uid: String?
}

/// Task class for keycloak_user_rolemapping
class KeycloakUserRolemappingTask extends Playbook.Task {
    /// todo doc
    `community.general.keycloak_user_rolemapping`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.keycloak_user_rolemapping"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.keycloak_user_rolemapping`
}

/// TaskBuilder class for keycloak_user_rolemapping
class KeycloakUserRolemapping extends Playbook.TaskBuilder {
    /// Options for community.general.keycloak_user_rolemapping
    options: KeycloakUserRolemappingOptions?
    /// todo doc
    function Task(): KeycloakUserRolemappingTask = this
        .toMap()
        .put("community.general.keycloak_user_rolemapping", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(KeycloakUserRolemappingTask)
}

/// Set or delete a passphrase using the Operating System's native keyring
/// This module uses the L(keyring Python library, https://pypi.org/project/keyring/) to set or delete passphrases for a given service and username from the OS' native keyring.
class KeyringOptions {
    /// Password to unlock keyring.
    keyring_password: String
    /// The name of the service.
    service: String
    /// Whether the password should exist.
    state: ("present"|"absent")?
    /// The password to set.
    user_password: String?
    /// The user belonging to the service.
    username: String
}

/// Task class for keyring
class KeyringTask extends Playbook.Task {
    /// todo doc
    `community.general.keyring`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.keyring"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.keyring`
}

/// TaskBuilder class for keyring
class Keyring extends Playbook.TaskBuilder {
    /// Options for community.general.keyring
    options: KeyringOptions?
    /// todo doc
    function Task(): KeyringTask = this
        .toMap()
        .put("community.general.keyring", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(KeyringTask)
}

/// Get a passphrase using the Operating System's native keyring
/// This module uses the L(keyring Python library, https://pypi.org/project/keyring/) to retrieve passphrases for a given service and username from the OS' native keyring.
class KeyringInfoOptions {
    /// Password to unlock keyring.
    keyring_password: String
    /// The name of the service.
    service: String
    /// The user belonging to the service.
    username: String
}

/// Task class for keyring_info
class KeyringInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.keyring_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.keyring_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.keyring_info`
}

/// TaskBuilder class for keyring_info
class KeyringInfo extends Playbook.TaskBuilder {
    /// Options for community.general.keyring_info
    options: KeyringInfoOptions?
    /// todo doc
    function Task(): KeyringInfoTask = this
        .toMap()
        .put("community.general.keyring_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(KeyringInfoTask)
}

/// Manage Kibana plugins
/// This module can be used to manage Kibana plugins.
class KibanaPluginOptions {
    /// Whether to allow C(kibana) and C(kibana-plugin) to be run as root. Passes the C(--allow-root) flag to these commands.
    allow_root: Boolean?
    /// Delete and re-install the plugin. Can be useful for plugins update.
    force: Boolean?
    /// Name of the plugin to install.
    name: String
    /// Location of the Kibana binary.
    plugin_bin: String?
    /// Your configured plugin directory specified in Kibana.
    plugin_dir: String?
    /// Desired state of a plugin.
    state: ("present"|"absent")?
    /// Timeout setting: 30s, 1m, 1h etc.
    timeout: String?
    /// Set exact URL to download the plugin from.
    /// For local file, prefix its absolute path with file://
    url: String?
    /// Version of the plugin to be installed.
    /// If plugin exists with previous version, plugin will B(not) be updated unless O(force) is set to V(true).
    version: String?
}

/// Task class for kibana_plugin
class KibanaPluginTask extends Playbook.Task {
    /// todo doc
    `community.general.kibana_plugin`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.kibana_plugin"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.kibana_plugin`
}

/// TaskBuilder class for kibana_plugin
class KibanaPlugin extends Playbook.TaskBuilder {
    /// Options for community.general.kibana_plugin
    options: KibanaPluginOptions?
    /// todo doc
    function Task(): KibanaPluginTask = this
        .toMap()
        .put("community.general.kibana_plugin", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(KibanaPluginTask)
}

/// Manage macOS services
/// Manage launchd services on target macOS hosts.
class LaunchdOptions {
    /// Whether the service should start on boot.
    /// B(At least one of state and enabled are required.)
    enabled: Boolean?
    /// Whether the service should not be restarted automatically by launchd.
    /// Services might have the 'KeepAlive' attribute set to true in a launchd configuration. In case this is set to true, stopping a service will cause that launchd starts the service again.
    /// Set this option to V(true) to let this module change the 'KeepAlive' attribute to V(false).
    force_stop: Boolean?
    /// Name of the service.
    name: String
    /// V(started)/V(stopped) are idempotent actions that will not run commands unless necessary.
    /// Launchd does not support V(restarted) nor V(reloaded) natively. These will trigger a stop/start (restarted) or an unload/load (reloaded).
    /// V(restarted) unloads and loads the service before start to ensure that the latest job definition (plist) is used.
    /// V(reloaded) unloads and loads the service to ensure that the latest job definition (plist) is used. Whether a service is started or stopped depends on the content of the definition file.
    state: ("reloaded"|"restarted"|"started"|"stopped"|"unloaded")?
}

/// Task class for launchd
class LaunchdTask extends Playbook.Task {
    /// todo doc
    `community.general.launchd`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.launchd"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.launchd`
}

/// TaskBuilder class for launchd
class Launchd extends Playbook.TaskBuilder {
    /// Options for community.general.launchd
    options: LaunchdOptions?
    /// todo doc
    function Task(): LaunchdTask = this
        .toMap()
        .put("community.general.launchd", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(LaunchdTask)
}

/// Manage Gentoo overlays
/// Uses Layman to manage an additional repositories for the Portage package manager on Gentoo Linux. Please note that Layman must be installed on a managed node prior using this module.
class LaymanOptions {
    /// An URL of the alternative overlays list that defines the overlay to install. This list will be fetched and saved under C(${overlay_defs}/${name}.xml), where C(overlay_defs) is read from the Layman's configuration.
    list_url: String?
    /// The overlay id to install, synchronize, or uninstall. Use 'ALL' to sync all of the installed overlays (can be used only when O(state=updated)).
    name: String
    /// Whether to install (V(present)), sync (V(updated)), or uninstall (V(absent)) the overlay.
    state: ("present"|"absent"|"updated")?
    /// If V(false), SSL certificates will not be validated. This should only be set to V(false) when no other option exists.  Prior to 1.9.3 the code defaulted to V(false).
    validate_certs: Boolean?
}

/// Task class for layman
class LaymanTask extends Playbook.Task {
    /// todo doc
    `community.general.layman`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.layman"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.layman`
}

/// TaskBuilder class for layman
class Layman extends Playbook.TaskBuilder {
    /// Options for community.general.layman
    options: LaymanOptions?
    /// todo doc
    function Task(): LaymanTask = this
        .toMap()
        .put("community.general.layman", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(LaymanTask)
}

/// Local Backup Utility for Alpine Linux
/// Manage Local Backup Utility of Alpine Linux in run-from-RAM mode
class LbuOptions {
    /// Control whether to commit changed files.
    commit: Boolean?
    /// List of paths to exclude.
    exclude: Listing<String>?
    /// List of paths to include.
    include: Listing<String>?
}

/// Task class for lbu
class LbuTask extends Playbook.Task {
    /// todo doc
    `community.general.lbu`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.lbu"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.lbu`
}

/// TaskBuilder class for lbu
class Lbu extends Playbook.TaskBuilder {
    /// Options for community.general.lbu
    options: LbuOptions?
    /// todo doc
    function Task(): LbuTask = this
        .toMap()
        .put("community.general.lbu", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(LbuTask)
}

/// Add or remove multiple LDAP attribute values
/// Add or remove multiple LDAP attribute values.
class LdapAttrsOptions {
    /// The attribute(s) and value(s) to add or remove.
    /// Each attribute value can be a string for single-valued attributes or a list of strings for multi-valued attributes.
    /// If you specify values for this option in YAML, please note that you can improve readability for long string values by using YAML block modifiers as seen in the examples for this module.
    /// Note that when using values that YAML/ansible-core interprets as other types, like V(yes), V(no) (booleans), or V(2.10) (float), make sure to quote them if these are meant to be strings. Otherwise the wrong values may be sent to LDAP.
    attributes: Any
    /// If V(true), prepend list values with X-ORDERED index numbers in all attributes specified in the current task. This is useful mostly with C(olcAccess) attribute to easily manage LDAP Access Control Lists.
    ordered: Boolean?
    /// The state of the attribute values. If V(present), all given attribute values will be added if they're missing. If V(absent), all given attribute values will be removed if present. If V(exact), the set of attribute values will be forced to exactly those provided and no others. If O(state=exact) and the attribute value is empty, all values for this attribute will be removed.
    state: ("present"|"absent"|"exact")?
}

/// Task class for ldap_attrs
class LdapAttrsTask extends Playbook.Task {
    /// todo doc
    `community.general.ldap_attrs`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ldap_attrs"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ldap_attrs`
}

/// TaskBuilder class for ldap_attrs
class LdapAttrs extends Playbook.TaskBuilder {
    /// Options for community.general.ldap_attrs
    options: LdapAttrsOptions?
    /// todo doc
    function Task(): LdapAttrsTask = this
        .toMap()
        .put("community.general.ldap_attrs", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(LdapAttrsTask)
}

/// Add or remove LDAP entries
/// Add or remove LDAP entries. This module only asserts the existence or non-existence of an LDAP entry, not its attributes. To assert the attribute values of an entry, see M(community.general.ldap_attrs).
class LdapEntryOptions {
    /// If O(state=present), attributes necessary to create an entry. Existing entries are never modified. To assert specific attribute values on an existing entry, use M(community.general.ldap_attrs) module instead.
    /// Each attribute value can be a string for single-valued attributes or a list of strings for multi-valued attributes.
    /// If you specify values for this option in YAML, please note that you can improve readability for long string values by using YAML block modifiers as seen in the examples for this module.
    /// Note that when using values that YAML/ansible-core interprets as other types, like V(yes), V(no) (booleans), or V(2.10) (float), make sure to quote them if these are meant to be strings. Otherwise the wrong values may be sent to LDAP.
    attributes: Any?
    /// If O(state=present), value or list of values to use when creating the entry. It can either be a string or an actual list of strings.
    objectClass: Listing<String>?
    /// If O(state=delete), a flag indicating whether a single entry or the whole branch must be deleted.
    recursive: Boolean?
    /// The target state of the entry.
    state: ("present"|"absent")?
}

/// Task class for ldap_entry
class LdapEntryTask extends Playbook.Task {
    /// todo doc
    `community.general.ldap_entry`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ldap_entry"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ldap_entry`
}

/// TaskBuilder class for ldap_entry
class LdapEntry extends Playbook.TaskBuilder {
    /// Options for community.general.ldap_entry
    options: LdapEntryOptions?
    /// todo doc
    function Task(): LdapEntryTask = this
        .toMap()
        .put("community.general.ldap_entry", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(LdapEntryTask)
}

/// Set passwords in LDAP
/// Set a password for an LDAP entry.  This module only asserts that a given password is valid for a given entry.  To assert the existence of an entry, see M(community.general.ldap_entry).
class LdapPasswdOptions {
    /// The (plaintext) password to be set for O(dn).
    passwd: String?
}

/// Task class for ldap_passwd
class LdapPasswdTask extends Playbook.Task {
    /// todo doc
    `community.general.ldap_passwd`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ldap_passwd"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ldap_passwd`
}

/// TaskBuilder class for ldap_passwd
class LdapPasswd extends Playbook.TaskBuilder {
    /// Options for community.general.ldap_passwd
    options: LdapPasswdOptions?
    /// todo doc
    function Task(): LdapPasswdTask = this
        .toMap()
        .put("community.general.ldap_passwd", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(LdapPasswdTask)
}

/// Search for entries in a LDAP server
/// Return the results of an LDAP search.
class LdapSearchOptions {
    /// A list of attributes for limiting the result. Use an actual list or a comma-separated string.
    attrs: Listing<String>?
    /// If provided, all attribute values returned that are listed in this option will be Base64 encoded.
    /// If the special value V(*) appears in this list, all attributes will be Base64 encoded.
    /// All other attribute values will be converted to UTF-8 strings. If they contain binary data, please note that invalid UTF-8 bytes will be omitted.
    base64_attributes: Listing<String>?
    /// The LDAP DN to search in.
    dn: String
    /// Used for filtering the LDAP search result.
    filter: String?
    /// The page size when performing a simple paged result search (RFC 2696). This setting can be tuned to reduce issues with timeouts and server limits.
    /// Setting the page size to V(0) (default) disables paged searching.
    page_size: Int?
    /// Set to V(true) to return the full attribute schema of entries, not their attribute values. Overrides O(attrs) when provided.
    schema: Boolean?
    /// The LDAP scope to use.
    scope: ("base"|"onelevel"|"subordinate"|"children")?
}

/// Task class for ldap_search
class LdapSearchTask extends Playbook.Task {
    /// todo doc
    `community.general.ldap_search`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ldap_search"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ldap_search`
}

/// TaskBuilder class for ldap_search
class LdapSearch extends Playbook.TaskBuilder {
    /// Options for community.general.ldap_search
    options: LdapSearchOptions?
    /// todo doc
    function Task(): LdapSearchTask = this
        .toMap()
        .put("community.general.ldap_search", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(LdapSearchTask)
}

/// Create an annotation in librato
/// Create an annotation event on the given annotation stream :name. If the annotation stream does not exist, it will be created automatically
class LibratoAnnotationOptions {
    /// Librato account api key
    api_key: String
    /// The description contains extra metadata about a particular annotation
    /// The description should contain specifics on the individual annotation e.g. Deployed 9b562b2 shipped new feature foo!
    description: String?
    /// The unix timestamp indicating the time at which the event referenced by this annotation ended
    /// For events that have a duration, this is a useful way to annotate the duration of the event
    end_time: Int?
    /// See examples
    links: Listing<Any>?
    /// The annotation stream name
    /// If the annotation stream does not exist, it will be created automatically
    name: String?
    /// A string which describes the originating source of an annotation when that annotation is tracked across multiple members of a population
    source: String?
    /// The unix timestamp indicating the time at which the event referenced by this annotation started
    start_time: Int?
    /// The title of an annotation is a string and may contain spaces
    /// The title should be a short, high-level summary of the annotation e.g. v45 Deployment
    title: String
    /// Librato account username
    user: String
}

/// Task class for librato_annotation
class LibratoAnnotationTask extends Playbook.Task {
    /// todo doc
    `community.general.librato_annotation`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.librato_annotation"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.librato_annotation`
}

/// TaskBuilder class for librato_annotation
class LibratoAnnotation extends Playbook.TaskBuilder {
    /// Options for community.general.librato_annotation
    options: LibratoAnnotationOptions?
    /// todo doc
    function Task(): LibratoAnnotationTask = this
        .toMap()
        .put("community.general.librato_annotation", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(LibratoAnnotationTask)
}

/// Manage instances on the Linode Public Cloud
/// Manage Linode Public Cloud instances and optionally wait for it to be 'running'.
class LinodeOptions {
    /// List of dictionaries for creating additional disks that are added to the Linode configuration settings.
    /// Dictionary takes Size, Label, Type. Size is in MB.
    additional_disks: Listing<Any>?
    /// Set status of bandwidth in alerts.
    alert_bwin_enabled: Boolean?
    /// Set threshold in MB of bandwidth in alerts.
    alert_bwin_threshold: Int?
    /// Set status of bandwidth out alerts.
    alert_bwout_enabled: Boolean?
    /// Set threshold in MB of bandwidth out alerts.
    alert_bwout_threshold: Int?
    /// Set status of bandwidth quota alerts as percentage of network transfer quota.
    alert_bwquota_enabled: Boolean?
    /// Set threshold in MB of bandwidth quota alerts.
    alert_bwquota_threshold: Int?
    /// Set status of receiving CPU usage alerts.
    alert_cpu_enabled: Boolean?
    /// Set percentage threshold for receiving CPU usage alerts. Each CPU core adds 100% to total.
    alert_cpu_threshold: Int?
    /// Set status of receiving disk IO alerts.
    alert_diskio_enabled: Boolean?
    /// Set threshold for average IO ops/sec over 2 hour period.
    alert_diskio_threshold: Int?
    /// Linode API key.
    /// E(LINODE_API_KEY) environment variable can be used instead.
    api_key: String
    /// Day of the week to take backups.
    backupweeklyday: Int?
    /// The time window in which backups will be taken.
    backupwindow: Int?
    /// datacenter to create an instance in (Linode Datacenter)
    datacenter: Int?
    /// Add the instance to a Display Group in Linode Manager.
    displaygroup: String?
    /// distribution to use for the instance (Linode Distribution)
    distribution: Int?
    /// kernel to use for the instance (Linode Kernel)
    kernel_id: Int?
    /// Unique ID of a linode server. This value is read-only in the sense that if you specify it on creation of a Linode it will not be used. The Linode API generates these IDs and we can those generated value here to reference a Linode more specifically. This is useful for idempotence.
    linode_id: Int?
    /// Name to give the instance (alphanumeric, dashes, underscore).
    /// To keep sanity on the Linode Web Console, name is prepended with C(LinodeID-).
    name: String
    /// root password to apply to a new server (auto generated if missing)
    password: String?
    /// payment term to use for the instance (payment term in months)
    payment_term: Int?
    /// plan to use for the instance (Linode plan)
    plan: Int?
    /// Add private IPv4 address when Linode is created.
    /// Default is V(false).
    private_ip: Boolean?
    /// SSH public key applied to root user
    ssh_pub_key: String?
    /// Indicate desired state of the resource
    state: ("absent"|"active"|"deleted"|"present"|"restarted"|"started"|"stopped")?
    /// swap size in MB
    swap: Int?
    /// wait for the instance to be in state V(running) before returning
    wait: Boolean?
    /// how long before wait gives up, in seconds
    wait_timeout: Int?
    /// Set status of Lassie watchdog.
    watchdog: Boolean?
}

/// Task class for linode
class LinodeTask extends Playbook.Task {
    /// todo doc
    `community.general.linode`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.linode"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.linode`
}

/// TaskBuilder class for linode
class Linode extends Playbook.TaskBuilder {
    /// Options for community.general.linode
    options: LinodeOptions?
    /// todo doc
    function Task(): LinodeTask = this
        .toMap()
        .put("community.general.linode", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(LinodeTask)
}

/// Manage instances on the Linode cloud
/// Manage instances on the Linode cloud.
class LinodeV4Options {
    /// The Linode API v4 access token. It may also be specified by exposing the E(LINODE_ACCESS_TOKEN) environment variable. See U(https://www.linode.com/docs/api#access-and-authentication).
    access_token: String
    /// A list of SSH public key parts to deploy for the root user.
    authorized_keys: Listing<String>?
    /// The group that the instance should be marked under. Please note, that group labelling is deprecated but still supported. The encouraged method for marking instances is to use tags.
    group: String?
    /// The image of the instance. This is a required parameter only when creating Linode instances. See U(https://www.linode.com/docs/api/images/).
    image: String?
    /// The instance label. This label is used as the main determiner for idempotence for the module and is therefore mandatory.
    label: String
    /// If V(true), the created Linode will have private networking enabled and assigned a private IPv4 address.
    private_ip: Boolean?
    /// The region of the instance. This is a required parameter only when creating Linode instances. See U(https://www.linode.com/docs/api/regions/).
    region: String?
    /// The password for the root user. If not specified, one will be generated. This generated password will be available in the task success JSON.
    root_pass: String?
    /// An object containing arguments to any User Defined Fields present in the StackScript used when creating the instance. Only valid when a stackscript_id is provided. See U(https://www.linode.com/docs/api/stackscripts/).
    stackscript_data: Any?
    /// The numeric ID of the StackScript to use when creating the instance. See U(https://www.linode.com/docs/api/stackscripts/).
    stackscript_id: Int?
    /// The desired instance state.
    state: ("present"|"absent")
    /// The tags that the instance should be marked under. See U(https://www.linode.com/docs/api/tags/).
    tags: Listing<String>?
    /// The type of the instance. This is a required parameter only when creating Linode instances. See U(https://www.linode.com/docs/api/linode-types/).
    type: String?
}

/// Task class for linode_v4
class LinodeV4Task extends Playbook.Task {
    /// todo doc
    `community.general.linode_v4`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.linode_v4"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.linode_v4`
}

/// TaskBuilder class for linode_v4
class LinodeV4 extends Playbook.TaskBuilder {
    /// Options for community.general.linode_v4
    options: LinodeV4Options?
    /// todo doc
    function Task(): LinodeV4Task = this
        .toMap()
        .put("community.general.linode_v4", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(LinodeV4Task)
}

/// Gather facts on processes listening on TCP and UDP ports
/// Gather facts on processes listening on TCP and UDP ports using the C(netstat) or C(ss) commands.
/// This module currently supports Linux only.
class ListenPortsFactsOptions {
    /// Override which command to use for fetching listen ports.
    /// By default module will use first found supported command on the system (in alphanumerical order).
    command: ("netstat"|"ss")?
    /// Show both listening and non-listening sockets (for TCP this means established connections).
    /// Adds the return values RV(ansible_facts.tcp_listen[].state), RV(ansible_facts.udp_listen[].state), RV(ansible_facts.tcp_listen[].foreign_address), and RV(ansible_facts.udp_listen[].foreign_address) to the returned facts.
    include_non_listening: Boolean?
}

/// Task class for listen_ports_facts
class ListenPortsFactsTask extends Playbook.Task {
    /// todo doc
    `community.general.listen_ports_facts`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.listen_ports_facts"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.listen_ports_facts`
}

/// TaskBuilder class for listen_ports_facts
class ListenPortsFacts extends Playbook.TaskBuilder {
    /// Options for community.general.listen_ports_facts
    options: ListenPortsFactsOptions?
    /// todo doc
    function Task(): ListenPortsFactsTask = this
        .toMap()
        .put("community.general.listen_ports_facts", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ListenPortsFactsTask)
}

/// Get details reported by lldp
/// Reads data out of lldpctl
class LldpOptions {
}

/// Task class for lldp
class LldpTask extends Playbook.Task {
    /// todo doc
    `community.general.lldp`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.lldp"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.lldp`
}

/// TaskBuilder class for lldp
class Lldp extends Playbook.TaskBuilder {
    /// Options for community.general.lldp
    options: LldpOptions?
    /// todo doc
    function Task(): LldpTask = this
        .toMap()
        .put("community.general.lldp", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(LldpTask)
}

/// Creates or removes locales
/// Manages locales by editing /etc/locale.gen and invoking locale-gen.
class LocaleGenOptions {
    /// Name and encoding of the locale, such as "en_GB.UTF-8".
    name: String
    /// Whether the locale shall be present.
    state: ("absent"|"present")?
}

/// Task class for locale_gen
class LocaleGenTask extends Playbook.Task {
    /// todo doc
    `community.general.locale_gen`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.locale_gen"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.locale_gen`
}

/// TaskBuilder class for locale_gen
class LocaleGen extends Playbook.TaskBuilder {
    /// Options for community.general.locale_gen
    options: LocaleGenOptions?
    /// todo doc
    function Task(): LocaleGenTask = this
        .toMap()
        .put("community.general.locale_gen", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(LocaleGenTask)
}

/// Module for tracking logs via logentries.com
/// Sends logs to LogEntries in realtime
class LogentriesOptions {
    /// type of the log
    logtype: String?
    /// name of the log
    name: String?
    /// path to a log file
    path: String
    /// following state of the log
    state: ("present"|"absent"|"followed"|"unfollowed")?
}

/// Task class for logentries
class LogentriesTask extends Playbook.Task {
    /// todo doc
    `community.general.logentries`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.logentries"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.logentries`
}

/// TaskBuilder class for logentries
class Logentries extends Playbook.TaskBuilder {
    /// Options for community.general.logentries
    options: LogentriesOptions?
    /// todo doc
    function Task(): LogentriesTask = this
        .toMap()
        .put("community.general.logentries", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(LogentriesTask)
}

/// Send a message to logentries
/// Send a message to logentries
class LogentriesMsgOptions {
    /// API endpoint
    api: String?
    /// The message body.
    msg: String
    /// API endpoint port
    port: Int?
    /// Log token.
    token: String
}

/// Task class for logentries_msg
class LogentriesMsgTask extends Playbook.Task {
    /// todo doc
    `community.general.logentries_msg`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.logentries_msg"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.logentries_msg`
}

/// TaskBuilder class for logentries_msg
class LogentriesMsg extends Playbook.TaskBuilder {
    /// Options for community.general.logentries_msg
    options: LogentriesMsgOptions?
    /// todo doc
    function Task(): LogentriesMsgTask = this
        .toMap()
        .put("community.general.logentries_msg", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(LogentriesMsgTask)
}

/// Manage Logstash plugins
/// Manages Logstash plugins.
class LogstashPluginOptions {
    /// Install plugin with that name.
    name: String
    /// Specify logstash-plugin to use for plugin management.
    plugin_bin: String?
    /// Proxy host to use during plugin installation.
    proxy_host: String?
    /// Proxy port to use during plugin installation.
    proxy_port: String?
    /// Apply plugin state.
    state: ("present"|"absent")?
    /// Specify plugin Version of the plugin to install. If plugin exists with previous version, it will NOT be updated.
    version: String?
}

/// Task class for logstash_plugin
class LogstashPluginTask extends Playbook.Task {
    /// todo doc
    `community.general.logstash_plugin`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.logstash_plugin"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.logstash_plugin`
}

/// TaskBuilder class for logstash_plugin
class LogstashPlugin extends Playbook.TaskBuilder {
    /// Options for community.general.logstash_plugin
    options: LogstashPluginOptions?
    /// todo doc
    function Task(): LogstashPluginTask = this
        .toMap()
        .put("community.general.logstash_plugin", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(LogstashPluginTask)
}

/// Configure LVM volume groups
/// This module creates, removes or resizes volume groups.
class LvgOptions {
    /// If V(true), allows to remove volume group with logical volumes.
    force: Boolean?
    /// The size of the physical extent. O(pesize) must be a power of 2 of at least 1 sector (where the sector size is the largest sector size of the PVs currently used in the VG), or at least 128KiB.
    /// O(pesize) can be optionally suffixed by a UNIT (k/K/m/M/g/G), default unit is megabyte.
    pesize: String?
    /// Additional options to pass to C(pvcreate) when creating the volume group.
    pv_options: String?
    /// If V(true), resize the physical volume to the maximum available size.
    pvresize: Boolean?
    /// List of comma-separated devices to use as physical devices in this volume group.
    /// Required when creating or resizing volume group.
    /// The module will take care of running pvcreate if needed.
    pvs: Listing<String>?
    /// Whether the volume group's physical volumes' UUIDs are regenerated.
    /// This is B(not idempotent). Specifying this parameter always results in a change.
    reset_pv_uuid: Boolean?
    /// Whether the volume group's UUID is regenerated.
    /// This is B(not idempotent). Specifying this parameter always results in a change.
    reset_vg_uuid: Boolean?
    /// Control if the volume group exists and it's state.
    /// The states V(active) and V(inactive) implies V(present) state. Added in 7.1.0
    /// If V(active) or V(inactive), the module manages the VG's logical volumes current state. The module also handles the VG's autoactivation state if supported unless when creating a volume group and the autoactivation option specified in O(vg_options).
    state: ("absent"|"present"|"active"|"inactive")?
    /// The name of the volume group.
    vg: String
    /// Additional options to pass to C(vgcreate) when creating the volume group.
    vg_options: String?
}

/// Task class for lvg
class LvgTask extends Playbook.Task {
    /// todo doc
    `community.general.lvg`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.lvg"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.lvg`
}

/// TaskBuilder class for lvg
class Lvg extends Playbook.TaskBuilder {
    /// Options for community.general.lvg
    options: LvgOptions?
    /// todo doc
    function Task(): LvgTask = this
        .toMap()
        .put("community.general.lvg", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(LvgTask)
}

/// Renames LVM volume groups
/// This module renames volume groups using the C(vgchange) command.
class LvgRenameOptions {
    /// The name or UUID of the source VG.
    /// See V(vgrename(8\)) for valid values.
    vg: String
    /// The new name of the VG.
    /// See V(lvm(8\)) for valid names.
    vg_new: String
}

/// Task class for lvg_rename
class LvgRenameTask extends Playbook.Task {
    /// todo doc
    `community.general.lvg_rename`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.lvg_rename"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.lvg_rename`
}

/// TaskBuilder class for lvg_rename
class LvgRename extends Playbook.TaskBuilder {
    /// Options for community.general.lvg_rename
    options: LvgRenameOptions?
    /// todo doc
    function Task(): LvgRenameTask = this
        .toMap()
        .put("community.general.lvg_rename", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(LvgRenameTask)
}

/// Configure LVM logical volumes
/// This module creates, removes or resizes logical volumes.
class LvolOptions {
    /// Whether the volume is active and visible to the host.
    active: Boolean?
    /// Shrink or remove operations of volumes requires this switch. Ensures that that filesystems get never corrupted/destroyed by mistake.
    force: Boolean?
    /// The name of the logical volume.
    lv: String?
    /// Free-form options to be passed to the lvcreate command.
    opts: String?
    /// List of physical volumes (for example V(/dev/sda, /dev/sdb)).
    pvs: Listing<String>?
    /// Resize the underlying filesystem together with the logical volume.
    /// Supported for C(ext2), C(ext3), C(ext4), C(reiserfs) and C(XFS) filesystems. Attempts to resize other filesystem types will fail.
    resizefs: Boolean?
    /// Shrink if current size is higher than size requested.
    shrink: Boolean?
    /// The size of the logical volume, according to lvcreate(8) --size, by default in megabytes or optionally with one of [bBsSkKmMgGtTpPeE] units; or according to lvcreate(8) --extents as a percentage of [VG|PVS|FREE|ORIGIN]; Float values must begin with a digit.
    /// When resizing, apart from specifying an absolute size you may, according to lvextend(8)|lvreduce(8) C(--size), specify the amount to extend the logical volume with the prefix V(+) or the amount to reduce the logical volume by with prefix V(-).
    /// Resizing using V(+) or V(-) was not supported prior to community.general 3.0.0.
    /// Please note that when using V(+), V(-), or percentage of FREE, the module is B(not idempotent).
    size: String?
    /// The name of a snapshot volume to be configured. When creating a snapshot volume, the O(lv) parameter specifies the origin volume.
    snapshot: String?
    /// Control if the logical volume exists. If V(present) and the volume does not already exist then the O(size) option is required.
    state: ("absent"|"present")?
    /// The thin pool volume name. When you want to create a thin provisioned volume, specify a thin pool volume name.
    thinpool: String?
    /// The volume group this logical volume is part of.
    vg: String
}

/// Task class for lvol
class LvolTask extends Playbook.Task {
    /// todo doc
    `community.general.lvol`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.lvol"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.lvol`
}

/// TaskBuilder class for lvol
class Lvol extends Playbook.TaskBuilder {
    /// Options for community.general.lvol
    options: LvolOptions?
    /// todo doc
    function Task(): LvolTask = this
        .toMap()
        .put("community.general.lvol", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(LvolTask)
}

/// Manage LXC Containers
/// Management of LXC containers.
class LxcContainerOptions {
    /// Create an archive of a container.
    /// This will create a tarball of the running container.
    archive: Boolean?
    /// Type of compression to use when creating an archive of a running container.
    archive_compression: ("gzip"|"bzip2"|"none")?
    /// Path the save the archived container.
    /// If the path does not exist the archive method will attempt to create it.
    archive_path: String?
    /// Backend storage type for the container.
    backing_store: ("dir"|"lvm"|"loop"|"btrfs"|"overlayfs"|"zfs")?
    /// Name of the new cloned server.
    /// This is only used when state is clone.
    clone_name: String?
    /// Create a snapshot a container when cloning.
    /// This is not supported by all container storage backends.
    /// Enabling this may fail if the backing store does not support snapshots.
    clone_snapshot: Boolean?
    /// Path to the LXC configuration file.
    config: String?
    /// Run a command within a container.
    container_command: String?
    /// A list of C(key=value) options to use when configuring a container.
    container_config: Listing<String>?
    /// Enable a container log for host actions to the container.
    container_log: Boolean?
    /// Set the log level for a container where O(container_log) was set.
    container_log_level: ("Info"|"info"|"INFO"|"Error"|"error"|"ERROR"|"Debug"|"debug"|"DEBUG")?
    /// Place rootfs directory under DIR.
    directory: String?
    /// File system Size.
    fs_size: String?
    /// Create fstype TYPE.
    fs_type: String?
    /// Name of the logical volume, defaults to the container name.
    /// If not specified, it defaults to C($CONTAINER_NAME).
    lv_name: String?
    /// Place container under E(PATH).
    lxc_path: String?
    /// Name of a container.
    name: String
    /// Define the state of a container.
    /// If you clone a container using O(clone_name) the newly cloned container created in a stopped state.
    /// The running container will be stopped while the clone operation is happening and upon completion of the clone the original container state will be restored.
    state: ("started"|"stopped"|"restarted"|"absent"|"frozen"|"clone")?
    /// Name of the template to use within an LXC create.
    template: String?
    /// Template options when building the container.
    template_options: String?
    /// Use LVM thin pool called TP.
    thinpool: String?
    /// If backend store is lvm, specify the name of the volume group.
    vg_name: String?
    /// Create zfs under given zfsroot.
    zfs_root: String?
}

/// Task class for lxc_container
class LxcContainerTask extends Playbook.Task {
    /// todo doc
    `community.general.lxc_container`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.lxc_container"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.lxc_container`
}

/// TaskBuilder class for lxc_container
class LxcContainer extends Playbook.TaskBuilder {
    /// Options for community.general.lxc_container
    options: LxcContainerOptions?
    /// todo doc
    function Task(): LxcContainerTask = this
        .toMap()
        .put("community.general.lxc_container", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(LxcContainerTask)
}

/// Custom module for lxca cmms inventory utility
/// This module returns/displays a inventory details of cmms
class LxcaCmmsOptions {
    /// uuid of chassis, this is string with length greater than 16.
    chassis: String?
    /// options to filter nodes information
    command_options: ("cmms"|"cmms_by_uuid"|"cmms_by_chassis_uuid")?
    /// uuid of device, this is string with length greater than 16.
    uuid: String?
}

/// Task class for lxca_cmms
class LxcaCmmsTask extends Playbook.Task {
    /// todo doc
    `community.general.lxca_cmms`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.lxca_cmms"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.lxca_cmms`
}

/// TaskBuilder class for lxca_cmms
class LxcaCmms extends Playbook.TaskBuilder {
    /// Options for community.general.lxca_cmms
    options: LxcaCmmsOptions?
    /// todo doc
    function Task(): LxcaCmmsTask = this
        .toMap()
        .put("community.general.lxca_cmms", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(LxcaCmmsTask)
}

/// Custom module for lxca nodes inventory utility
/// This module returns/displays a inventory details of nodes
class LxcaNodesOptions {
    /// uuid of chassis, this is string with length greater than 16.
    chassis: String?
    /// options to filter nodes information
    command_options: ("nodes"|"nodes_by_uuid"|"nodes_by_chassis_uuid"|"nodes_status_managed"|"nodes_status_unmanaged")?
    /// uuid of device, this is string with length greater than 16.
    uuid: String?
}

/// Task class for lxca_nodes
class LxcaNodesTask extends Playbook.Task {
    /// todo doc
    `community.general.lxca_nodes`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.lxca_nodes"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.lxca_nodes`
}

/// TaskBuilder class for lxca_nodes
class LxcaNodes extends Playbook.TaskBuilder {
    /// Options for community.general.lxca_nodes
    options: LxcaNodesOptions?
    /// todo doc
    function Task(): LxcaNodesTask = this
        .toMap()
        .put("community.general.lxca_nodes", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(LxcaNodesTask)
}

/// Manage LXD instances
/// Management of LXD containers and virtual machines.
class LxdContainerOptions {
    /// The architecture for the instance (for example V(x86_64) or V(i686)). See U(https://documentation.ubuntu.com/lxd/en/latest/api/#/instances/instance_get).
    architecture: String?
    /// The client certificate file path.
    /// If not specified, it defaults to C(${HOME}/.config/lxc/client.crt).
    client_cert: String?
    /// The client certificate key file path.
    /// If not specified, it defaults to C(${HOME}/.config/lxc/client.key).
    client_key: String?
    /// The config for the instance (for example V({"limits.cpu": "2"})). See U(https://documentation.ubuntu.com/lxd/en/latest/api/#/instances/instance_get).
    /// If the instance already exists and its "config" values in metadata obtained from the LXD API U(https://documentation.ubuntu.com/lxd/en/latest/api/#/instances/instance_get) are different, then this module tries to apply the configurations U(https://documentation.ubuntu.com/lxd/en/latest/api/#/instances/instance_put).
    /// The keys starting with C(volatile.) are ignored for this comparison when O(ignore_volatile_options=true).
    config: Any?
    /// The devices for the instance (for example V({ "rootfs": { "path": "/dev/kvm", "type": "unix-char" }})). See U(https://documentation.ubuntu.com/lxd/en/latest/api/#/instances/instance_get).
    devices: Any?
    /// Whether or not the instance is ephemeral (for example V(true) or V(false)). See U(https://documentation.ubuntu.com/lxd/en/latest/api/#/instances/instance_get).
    ephemeral: Boolean?
    /// If this is V(true), the C(lxd_container) forces to stop the instance when it stops or restarts the instance.
    force_stop: Boolean?
    /// If set to V(true), options starting with C(volatile.) are ignored. As a result, they are reapplied for each execution.
    /// This default behavior can be changed by setting this option to V(false).
    /// The default value changed from V(true) to V(false) in community.general 6.0.0.
    ignore_volatile_options: Boolean?
    /// Name of an instance.
    name: String
    /// Profile to be used by the instance.
    profiles: Listing<String>?
    /// Project of an instance. See U(https://documentation.ubuntu.com/lxd/en/latest/projects/).
    project: String?
    /// The unix domain socket path when LXD is installed by snap package manager.
    snap_url: String?
    /// The source for the instance (for example V({ "type": "image", "mode": "pull", "server": "https://cloud-images.ubuntu.com/releases/", "protocol": "simplestreams", "alias": "22.04" })).
    /// See U(https://documentation.ubuntu.com/lxd/en/latest/api/) for complete API documentation.
    /// Note that C(protocol) accepts two choices: V(lxd) or V(simplestreams).
    source: Any?
    /// Define the state of an instance.
    state: ("started"|"stopped"|"restarted"|"absent"|"frozen")?
    /// For cluster deployments. Will attempt to create an instance on a target node. If the instance exists elsewhere in a cluster, then it will not be replaced or moved. The name should respond to same name of the node you see in C(lxc cluster list).
    target: String?
    /// A timeout for changing the state of the instance.
    /// This is also used as a timeout for waiting until IPv4 addresses are set to the all network interfaces in the instance after starting or restarting.
    timeout: Int?
    /// The client trusted password.
    /// You need to set this password on the LXD server before running this module using the following command: C(lxc config set core.trust_password <some random password>). See U(https://www.stgraber.org/2016/04/18/lxd-api-direct-interaction/).
    /// If trust_password is set, this module send a request for authentication before sending any requests.
    trust_password: String?
    /// Instance type can be either V(virtual-machine) or V(container).
    type: ("container"|"virtual-machine")?
    /// The unix domain socket path or the https URL for the LXD server.
    url: String?
    /// If set to V(true), the tasks will wait till the task reports a success status when performing container operations.
    wait_for_container: Boolean?
    /// If this is V(true), the C(lxd_container) waits until IPv4 addresses are set to the all network interfaces in the instance after starting or restarting.
    wait_for_ipv4_addresses: Boolean?
}

/// Task class for lxd_container
class LxdContainerTask extends Playbook.Task {
    /// todo doc
    `community.general.lxd_container`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.lxd_container"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.lxd_container`
}

/// TaskBuilder class for lxd_container
class LxdContainer extends Playbook.TaskBuilder {
    /// Options for community.general.lxd_container
    options: LxdContainerOptions?
    /// todo doc
    function Task(): LxdContainerTask = this
        .toMap()
        .put("community.general.lxd_container", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(LxdContainerTask)
}

/// Manage LXD profiles
/// Management of LXD profiles
class LxdProfileOptions {
    /// The client certificate file path.
    /// If not specified, it defaults to C($HOME/.config/lxc/client.crt).
    client_cert: String?
    /// The client certificate key file path.
    /// If not specified, it defaults to C($HOME/.config/lxc/client.key).
    client_key: String?
    /// The config for the instance (e.g. {"limits.memory": "4GB"}). See U(https://documentation.ubuntu.com/lxd/en/latest/api/#/profiles/profile_get).
    /// If the profile already exists and its "config" value in metadata obtained from GET /1.0/profiles/<name> U(https://documentation.ubuntu.com/lxd/en/latest/api/#/profiles/profile_get) are different, then this module tries to apply the configurations U(https://documentation.ubuntu.com/lxd/en/latest/api/#/profiles/profile_put).
    /// Not all config values are supported to apply the existing profile. Maybe you need to delete and recreate a profile.
    config: Any?
    /// Description of the profile.
    description: String?
    /// The devices for the profile (e.g. {"rootfs": {"path": "/dev/kvm", "type": "unix-char"}). See U(https://documentation.ubuntu.com/lxd/en/latest/api/#/profiles/profile_get).
    devices: Any?
    /// Merge the configuration of the present profile with the new desired configuration, instead of replacing it.
    merge_profile: Boolean?
    /// Name of a profile.
    name: String
    /// A new name of a profile.
    /// If this parameter is specified a profile will be renamed to this name. See U(https://documentation.ubuntu.com/lxd/en/latest/api/#/profiles/profile_post).
    new_name: String?
    /// Project of a profile. See U(https://documentation.ubuntu.com/lxd/en/latest/projects/).
    project: String?
    /// The unix domain socket path when LXD is installed by snap package manager.
    snap_url: String?
    /// Define the state of a profile.
    state: ("present"|"absent")?
    /// The client trusted password.
    /// You need to set this password on the LXD server before running this module using the following command. lxc config set core.trust_password <some random password> See U(https://www.stgraber.org/2016/04/18/lxd-api-direct-interaction/)
    /// If trust_password is set, this module send a request for authentication before sending any requests.
    trust_password: String?
    /// The unix domain socket path or the https URL for the LXD server.
    url: String?
}

/// Task class for lxd_profile
class LxdProfileTask extends Playbook.Task {
    /// todo doc
    `community.general.lxd_profile`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.lxd_profile"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.lxd_profile`
}

/// TaskBuilder class for lxd_profile
class LxdProfile extends Playbook.TaskBuilder {
    /// Options for community.general.lxd_profile
    options: LxdProfileOptions?
    /// todo doc
    function Task(): LxdProfileTask = this
        .toMap()
        .put("community.general.lxd_profile", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(LxdProfileTask)
}

/// Manage LXD projects
/// Management of LXD projects.
class LxdProjectOptions {
    /// The client certificate file path.
    /// If not specified, it defaults to C($HOME/.config/lxc/client.crt).
    client_cert: String?
    /// The client certificate key file path.
    /// If not specified, it defaults to C($HOME/.config/lxc/client.key).
    client_key: String?
    /// The config for the project (for example V({"features.profiles": "true"})). See U(https://documentation.ubuntu.com/lxd/en/latest/api/#/projects/project_get).
    /// If the project already exists and its "config" value in metadata obtained from C(GET /1.0/projects/<name>) U(https://documentation.ubuntu.com/lxd/en/latest/api/#/projects/project_get) are different, then this module tries to apply the configurations U(https://documentation.ubuntu.com/lxd/en/latest/api/#/projects/project_put).
    config: Any?
    /// Description of the project.
    description: String?
    /// Merge the configuration of the present project with the new desired configuration, instead of replacing it. If configuration is the same after merged, no change will be made.
    merge_project: Boolean?
    /// Name of the project.
    name: String
    /// A new name of a project.
    /// If this parameter is specified a project will be renamed to this name. See U(https://documentation.ubuntu.com/lxd/en/latest/api/#/projects/project_post).
    new_name: String?
    /// The Unix domain socket path when LXD is installed by snap package manager.
    snap_url: String?
    /// Define the state of a project.
    state: ("present"|"absent")?
    /// The client trusted password.
    /// You need to set this password on the LXD server before running this module using the following command: C(lxc config set core.trust_password <some random password>) See U(https://www.stgraber.org/2016/04/18/lxd-api-direct-interaction/).
    /// If O(trust_password) is set, this module send a request for authentication before sending any requests.
    trust_password: String?
    /// The Unix domain socket path or the https URL for the LXD server.
    url: String?
}

/// Task class for lxd_project
class LxdProjectTask extends Playbook.Task {
    /// todo doc
    `community.general.lxd_project`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.lxd_project"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.lxd_project`
}

/// TaskBuilder class for lxd_project
class LxdProject extends Playbook.TaskBuilder {
    /// Options for community.general.lxd_project
    options: LxdProjectOptions?
    /// todo doc
    function Task(): LxdProjectTask = this
        .toMap()
        .put("community.general.lxd_project", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(LxdProjectTask)
}

/// Package manager for MacPorts
/// Manages MacPorts packages (ports)
class MacportsOptions {
    /// A list of port names.
    name: Listing<String>?
    /// Update Macports and the ports tree, either prior to installing ports or as a separate step.
    /// Equivalent to running C(port selfupdate).
    selfupdate: Boolean?
    /// Indicates the desired state of the port.
    state: ("present"|"absent"|"active"|"inactive"|"installed"|"removed")?
    /// Upgrade all outdated ports, either prior to installing ports or as a separate step.
    /// Equivalent to running C(port upgrade outdated).
    upgrade: Boolean?
    /// A port variant specification.
    /// O(variant) is only supported with O(state=installed) and O(state=present).
    variant: String?
}

/// Task class for macports
class MacportsTask extends Playbook.Task {
    /// todo doc
    `community.general.macports`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.macports"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.macports`
}

/// TaskBuilder class for macports
class Macports extends Playbook.TaskBuilder {
    /// Options for community.general.macports
    options: MacportsOptions?
    /// todo doc
    function Task(): MacportsTask = this
        .toMap()
        .put("community.general.macports", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(MacportsTask)
}

/// Send an email
/// This module is useful for sending emails from playbooks.
/// One may wonder why automate sending emails?  In complex environments there are from time to time processes that cannot be automated, either because you lack the authority to make it so, or because not everyone agrees to a common approach.
/// If you cannot automate a specific step, but the step is non-blocking, sending out an email to the responsible party to make them perform their part of the bargain is an elegant way to put the responsibility in someone else's lap.
/// Of course sending out a mail can be equally useful as a way to notify one or more people in a team that a specific action has been (successfully) taken.
class MailOptions {
    /// A list of pathnames of files to attach to the message.
    /// Attached files will have their content-type set to C(application/octet-stream).
    attach: Listing<String>?
    /// The email-address(es) the mail is being 'blind' copied to.
    /// This is a list, which may contain address and phrase portions.
    bcc: Listing<String>?
    /// The body of the email being sent.
    body: String?
    /// The email-address(es) the mail is being copied to.
    /// This is a list, which may contain address and phrase portions.
    cc: Listing<String>?
    /// The character set of email being sent.
    charset: String?
    /// Allows for manual specification of host for EHLO.
    ehlohost: String?
    /// A list of headers which should be added to the message.
    /// Each individual header is specified as C(header=value) (see example below).
    headers: Listing<String>?
    /// The mail server.
    host: String?
    /// The domain name to use for the L(Message-ID header, https://en.wikipedia.org/wiki/Message-ID).
    /// Note that this is only available on Python 3+. On Python 2, this value will be ignored.
    message_id_domain: String?
    /// If SMTP requires password.
    password: String?
    /// The mail server port.
    /// This must be a valid integer between 1 and 65534
    port: Int?
    /// If V(always), the connection will only send email if the connection is Encrypted. If the server doesn't accept the encrypted connection it will fail.
    /// If V(try), the connection will attempt to setup a secure SSL/TLS session, before trying to send.
    /// If V(never), the connection will not attempt to setup a secure SSL/TLS session, before sending
    /// If V(starttls), the connection will try to upgrade to a secure SSL/TLS connection, before sending. If it is unable to do so it will fail.
    secure: ("always"|"never"|"starttls"|"try")?
    /// The email-address the mail is sent from. May contain address and phrase.
    sender: String?
    /// The subject of the email being sent.
    subject: String
    /// The minor mime type, can be either V(plain) or V(html).
    /// The major type is always V(text).
    subtype: ("html"|"plain")?
    /// Sets the timeout in seconds for connection attempts.
    timeout: Int?
    /// The email-address(es) the mail is being sent to.
    /// This is a list, which may contain address and phrase portions.
    to: Listing<String>?
    /// If SMTP requires username.
    username: String?
}

/// Task class for mail
class MailTask extends Playbook.Task {
    /// todo doc
    `community.general.mail`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.mail"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.mail`
}

/// TaskBuilder class for mail
class Mail extends Playbook.TaskBuilder {
    /// Options for community.general.mail
    options: MailOptions?
    /// todo doc
    function Task(): MailTask = this
        .toMap()
        .put("community.general.mail", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(MailTask)
}

/// Run targets in a Makefile
/// Run targets in a Makefile.
class MakeOptions {
    /// Change to this directory before running make.
    chdir: String
    /// Use a custom Makefile.
    file: String?
    /// Set the number of make jobs to run concurrently.
    /// Typically if set, this would be the number of processors and/or threads available to the machine.
    /// This is not supported by all make implementations.
    jobs: Int?
    /// Use a specific make binary.
    make: String?
    /// Any extra parameters to pass to make.
    /// If the value is empty, only the key will be used. For example, V(FOO:) will produce V(FOO), not V(FOO=).
    params: Any?
    /// The target to run.
    /// Typically this would be something like V(install), V(test), or V(all).
    /// O(target) and O(targets) are mutually exclusive.
    target: String?
    /// The list of targets to run.
    /// Typically this would be something like V(install), V(test), or V(all).
    /// O(target) and O(targets) are mutually exclusive.
    targets: Listing<String>?
}

/// Task class for make
class MakeTask extends Playbook.Task {
    /// todo doc
    `community.general.make`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.make"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.make`
}

/// TaskBuilder class for make
class Make extends Playbook.TaskBuilder {
    /// Options for community.general.make
    options: MakeOptions?
    /// todo doc
    function Task(): MakeTask = this
        .toMap()
        .put("community.general.make", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(MakeTask)
}

/// Configuration of alert profiles for ManageIQ
/// The manageiq_alert_profiles module supports adding, updating and deleting alert profiles in ManageIQ.
class ManageiqAlertProfilesOptions {
    /// List of alert descriptions to assign to this profile.
    /// Required if state is "present"
    alerts: Listing<String>?
    /// The unique alert profile name in ManageIQ.
    /// Required when state is "absent" or "present".
    name: String?
    /// Optional notes for this profile
    notes: String?
    /// The resource type for the alert profile in ManageIQ. Required when state is "present".
    resource_type: ("Vm"|"ContainerNode"|"MiqServer"|"Host"|"Storage"|"EmsCluster"|"ExtManagementSystem"|"MiddlewareServer")?
    /// absent - alert profile should not exist,
    /// present - alert profile should exist,
    state: ("absent"|"present")?
}

/// Task class for manageiq_alert_profiles
class ManageiqAlertProfilesTask extends Playbook.Task {
    /// todo doc
    `community.general.manageiq_alert_profiles`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.manageiq_alert_profiles"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.manageiq_alert_profiles`
}

/// TaskBuilder class for manageiq_alert_profiles
class ManageiqAlertProfiles extends Playbook.TaskBuilder {
    /// Options for community.general.manageiq_alert_profiles
    options: ManageiqAlertProfilesOptions?
    /// todo doc
    function Task(): ManageiqAlertProfilesTask = this
        .toMap()
        .put("community.general.manageiq_alert_profiles", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ManageiqAlertProfilesTask)
}

/// Configuration of alerts in ManageIQ
/// The manageiq_alerts module supports adding, updating and deleting alerts in ManageIQ.
class ManageiqAlertsOptions {
    /// The unique alert description in ManageIQ.
    /// Required when state is "absent" or "present".
    description: String?
    /// Enable or disable the alert. Required if state is "present".
    enabled: Boolean?
    /// The alert expression for ManageIQ.
    /// Can either be in the "Miq Expression" format or the "Hash Expression format".
    /// Required if state is "present".
    expression: Any?
    /// Expression type.
    expression_type: ("hash"|"miq")?
    /// Additional alert options, such as notification type and frequency
    options: Any?
    /// The entity type for the alert in ManageIQ. Required when state is "present".
    resource_type: ("Vm"|"ContainerNode"|"MiqServer"|"Host"|"Storage"|"EmsCluster"|"ExtManagementSystem"|"MiddlewareServer")?
    /// absent - alert should not exist,
    /// present - alert should exist,
    state: ("absent"|"present")?
}

/// Task class for manageiq_alerts
class ManageiqAlertsTask extends Playbook.Task {
    /// todo doc
    `community.general.manageiq_alerts`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.manageiq_alerts"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.manageiq_alerts`
}

/// TaskBuilder class for manageiq_alerts
class ManageiqAlerts extends Playbook.TaskBuilder {
    /// Options for community.general.manageiq_alerts
    options: ManageiqAlertsOptions?
    /// todo doc
    function Task(): ManageiqAlertsTask = this
        .toMap()
        .put("community.general.manageiq_alerts", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ManageiqAlertsTask)
}

/// Management of groups in ManageIQ
/// The manageiq_group module supports adding, updating and deleting groups in ManageIQ.
class ManageiqGroupOptions {
    /// A list of strings with a reference to the allowed host, cluster or folder
    belongsto_filters: Listing<String>?
    /// In merge mode existing settings are merged with the supplied O(belongsto_filters).
    /// In replace mode current values are replaced with the supplied O(belongsto_filters).
    belongsto_filters_merge_mode: ("merge"|"replace")?
    /// The group description.
    description: String
    /// The tag values per category
    managed_filters: Any?
    /// In merge mode existing categories are kept or updated, new categories are added.
    /// In replace mode all categories will be replaced with the supplied O(managed_filters).
    managed_filters_merge_mode: ("merge"|"replace")?
    /// The the group role name
    /// The O(role_id) has precedence over the O(role) when supplied.
    role: String?
    /// The the group role id
    role_id: Int?
    /// absent - group should not exist, present - group should be.
    state: ("absent"|"present")?
    /// The tenant for the group identified by the tenant name.
    /// The O(tenant_id) has precedence over the O(tenant) when supplied.
    /// Tenant names are case sensitive.
    tenant: String?
    /// The tenant for the group identified by the tenant id.
    tenant_id: Int?
}

/// Task class for manageiq_group
class ManageiqGroupTask extends Playbook.Task {
    /// todo doc
    `community.general.manageiq_group`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.manageiq_group"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.manageiq_group`
}

/// TaskBuilder class for manageiq_group
class ManageiqGroup extends Playbook.TaskBuilder {
    /// Options for community.general.manageiq_group
    options: ManageiqGroupOptions?
    /// todo doc
    function Task(): ManageiqGroupTask = this
        .toMap()
        .put("community.general.manageiq_group", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ManageiqGroupTask)
}

/// Management of resource policy_profiles in ManageIQ
/// The manageiq_policies module supports adding and deleting policy_profiles in ManageIQ.
class ManageiqPoliciesOptions {
    /// List of dictionaries, each includes the policy_profile V(name) key.
    /// Required if O(state) is V(present) or V(absent).
    policy_profiles: Listing<Any>?
    /// The ID of the resource to which the profile should be [un]assigned.
    /// Must be specified if O(resource_name) is not set. Both options are mutually exclusive.
    resource_id: Int?
    /// The name of the resource to which the profile should be [un]assigned.
    /// Must be specified if O(resource_id) is not set. Both options are mutually exclusive.
    resource_name: String?
    /// The type of the resource to which the profile should be [un]assigned.
    resource_type: ("provider"|"host"|"vm"|"blueprint"|"category"|"cluster"|"data store"|"group"|"resource pool"|"service"|"service template"|"template"|"tenant"|"user")
    /// V(absent) - policy_profiles should not exist,
    /// V(present) - policy_profiles should exist,
    state: ("absent"|"present")?
}

/// Task class for manageiq_policies
class ManageiqPoliciesTask extends Playbook.Task {
    /// todo doc
    `community.general.manageiq_policies`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.manageiq_policies"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.manageiq_policies`
}

/// TaskBuilder class for manageiq_policies
class ManageiqPolicies extends Playbook.TaskBuilder {
    /// Options for community.general.manageiq_policies
    options: ManageiqPoliciesOptions?
    /// todo doc
    function Task(): ManageiqPoliciesTask = this
        .toMap()
        .put("community.general.manageiq_policies", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ManageiqPoliciesTask)
}

/// Listing of resource policy_profiles in ManageIQ
/// The manageiq_policies module supports listing policy_profiles in ManageIQ.
class ManageiqPoliciesInfoOptions {
    /// The ID of the resource to obtain the profile for.
    /// Must be specified if O(resource_name) is not set. Both options are mutually exclusive.
    resource_id: Int?
    /// The name of the resource to obtain the profile for.
    /// Must be specified if O(resource_id) is not set. Both options are mutually exclusive.
    resource_name: String?
    /// The type of the resource to obtain the profile for.
    resource_type: ("provider"|"host"|"vm"|"blueprint"|"category"|"cluster"|"data store"|"group"|"resource pool"|"service"|"service template"|"template"|"tenant"|"user")
}

/// Task class for manageiq_policies_info
class ManageiqPoliciesInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.manageiq_policies_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.manageiq_policies_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.manageiq_policies_info`
}

/// TaskBuilder class for manageiq_policies_info
class ManageiqPoliciesInfo extends Playbook.TaskBuilder {
    /// Options for community.general.manageiq_policies_info
    options: ManageiqPoliciesInfoOptions?
    /// todo doc
    function Task(): ManageiqPoliciesInfoTask = this
        .toMap()
        .put("community.general.manageiq_policies_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ManageiqPoliciesInfoTask)
}

/// Management of provider in ManageIQ
/// The manageiq_provider module supports adding, updating, and deleting provider in ManageIQ.
class ManageiqProviderOptions {
    /// Alerts endpoint connection information.
    alerts: Any?
    /// The OpenStack Keystone API version. defaults to None.
    api_version: ("v2"|"v3")?
    /// Tenant ID. defaults to None.
    azure_tenant_id: String?
    /// The last port in the host VNC range. defaults to None.
    host_default_vnc_port_end: String?
    /// The first port in the host VNC range. defaults to None.
    host_default_vnc_port_start: String?
    /// Metrics endpoint connection information.
    metrics: Any?
    /// The provider's name.
    name: String
    /// Google Compute Engine Project ID. defaults to None.
    project: String?
    /// Default endpoint connection information, required if state is true.
    provider: Any?
    /// The provider region name to connect to (e.g. AWS region for Amazon).
    provider_region: String?
    /// SSH key pair used for SSH connections to all hosts in this provider.
    ssh_keypair: Any?
    /// absent - provider should not exist, present - provider should be present, refresh - provider will be refreshed
    state: ("absent"|"present"|"refresh")?
    /// Microsoft Azure subscription ID. defaults to None.
    subscription: String?
    /// Whether to enable mapping of existing tenants. defaults to False.
    tenant_mapping_enabled: Boolean?
    /// The provider's type.
    type: ("Openshift"|"Amazon"|"oVirt"|"VMware"|"Azure"|"Director"|"OpenStack"|"GCE")?
    /// The ManageIQ zone name that will manage the provider.
    zone: String?
}

/// Task class for manageiq_provider
class ManageiqProviderTask extends Playbook.Task {
    /// todo doc
    `community.general.manageiq_provider`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.manageiq_provider"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.manageiq_provider`
}

/// TaskBuilder class for manageiq_provider
class ManageiqProvider extends Playbook.TaskBuilder {
    /// Options for community.general.manageiq_provider
    options: ManageiqProviderOptions?
    /// todo doc
    function Task(): ManageiqProviderTask = this
        .toMap()
        .put("community.general.manageiq_provider", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ManageiqProviderTask)
}

/// Management of resource tags in ManageIQ
/// The manageiq_tags module supports adding, updating and deleting tags in ManageIQ.
class ManageiqTagsOptions {
    /// The ID of the resource at which tags will be controlled.
    /// Must be specified if O(resource_name) is not set. Both options are mutually exclusive.
    resource_id: Int?
    /// The name of the resource at which tags will be controlled.
    /// Must be specified if O(resource_id) is not set. Both options are mutually exclusive.
    resource_name: String?
    /// The relevant resource type in manageiq.
    resource_type: ("provider"|"host"|"vm"|"blueprint"|"category"|"cluster"|"data store"|"group"|"resource pool"|"service"|"service template"|"template"|"tenant"|"user")
    /// V(absent) - tags should not exist.
    /// V(present) - tags should exist.
    state: ("absent"|"present")?
    /// V(tags) - list of dictionaries, each includes C(name) and C(category) keys.
    /// Required if O(state) is V(present) or V(absent).
    tags: Listing<Any>?
}

/// Task class for manageiq_tags
class ManageiqTagsTask extends Playbook.Task {
    /// todo doc
    `community.general.manageiq_tags`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.manageiq_tags"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.manageiq_tags`
}

/// TaskBuilder class for manageiq_tags
class ManageiqTags extends Playbook.TaskBuilder {
    /// Options for community.general.manageiq_tags
    options: ManageiqTagsOptions?
    /// todo doc
    function Task(): ManageiqTagsTask = this
        .toMap()
        .put("community.general.manageiq_tags", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ManageiqTagsTask)
}

/// Retrieve resource tags in ManageIQ
/// This module supports retrieving resource tags from ManageIQ.
class ManageiqTagsInfoOptions {
    /// The ID of the resource at which tags will be controlled.
    /// Must be specified if O(resource_name) is not set. Both options are mutually exclusive.
    resource_id: Int?
    /// The name of the resource at which tags will be controlled.
    /// Must be specified if O(resource_id) is not set. Both options are mutually exclusive.
    resource_name: String?
    /// The relevant resource type in ManageIQ.
    resource_type: ("provider"|"host"|"vm"|"blueprint"|"category"|"cluster"|"data store"|"group"|"resource pool"|"service"|"service template"|"template"|"tenant"|"user")
}

/// Task class for manageiq_tags_info
class ManageiqTagsInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.manageiq_tags_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.manageiq_tags_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.manageiq_tags_info`
}

/// TaskBuilder class for manageiq_tags_info
class ManageiqTagsInfo extends Playbook.TaskBuilder {
    /// Options for community.general.manageiq_tags_info
    options: ManageiqTagsInfoOptions?
    /// todo doc
    function Task(): ManageiqTagsInfoTask = this
        .toMap()
        .put("community.general.manageiq_tags_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ManageiqTagsInfoTask)
}

/// Management of tenants in ManageIQ
/// The manageiq_tenant module supports adding, updating and deleting tenants in ManageIQ.
class ManageiqTenantOptions {
    /// The tenant description.
    description: String
    /// The tenant name.
    name: String
    /// The name of the parent tenant. If not supplied and no O(parent_id) is supplied the root tenant is used.
    parent: String?
    /// The id of the parent tenant. If not supplied the root tenant is used.
    /// The O(parent_id) takes president over O(parent) when supplied
    parent_id: Int?
    /// The tenant quotas.
    /// All parameters case sensitive.
    /// Valid attributes are:
    ///  - C(cpu_allocated) (int): use null to remove the quota.
    ///  - C(mem_allocated) (GB): use null to remove the quota.
    ///  - C(storage_allocated) (GB): use null to remove the quota.
    ///  - C(vms_allocated) (int): use null to remove the quota.
    ///  - C(templates_allocated) (int): use null to remove the quota.
    quotas: Any?
    /// absent - tenant should not exist, present - tenant should be.
    state: ("absent"|"present")?
}

/// Task class for manageiq_tenant
class ManageiqTenantTask extends Playbook.Task {
    /// todo doc
    `community.general.manageiq_tenant`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.manageiq_tenant"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.manageiq_tenant`
}

/// TaskBuilder class for manageiq_tenant
class ManageiqTenant extends Playbook.TaskBuilder {
    /// Options for community.general.manageiq_tenant
    options: ManageiqTenantOptions?
    /// todo doc
    function Task(): ManageiqTenantTask = this
        .toMap()
        .put("community.general.manageiq_tenant", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ManageiqTenantTask)
}

/// Management of users in ManageIQ
/// The manageiq_user module supports adding, updating and deleting users in ManageIQ.
class ManageiqUserOptions {
    /// The users' E-mail address.
    email: String?
    /// The name of the group to which the user belongs.
    group: String?
    /// The users' full name.
    name: String?
    /// The users' password.
    password: String?
    /// absent - user should not exist, present - user should be.
    state: ("absent"|"present")?
    /// V(always) will update passwords unconditionally.  V(on_create) will only set the password for a newly created user.
    update_password: ("always"|"on_create")?
    /// The unique userid in manageiq, often mentioned as username.
    userid: String
}

/// Task class for manageiq_user
class ManageiqUserTask extends Playbook.Task {
    /// todo doc
    `community.general.manageiq_user`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.manageiq_user"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.manageiq_user`
}

/// TaskBuilder class for manageiq_user
class ManageiqUser extends Playbook.TaskBuilder {
    /// Options for community.general.manageiq_user
    options: ManageiqUserOptions?
    /// todo doc
    function Task(): ManageiqUserTask = this
        .toMap()
        .put("community.general.manageiq_user", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ManageiqUserTask)
}

/// Manage Mac App Store applications with mas-cli
/// Installs, uninstalls and updates macOS applications from the Mac App Store using the C(mas-cli).
class MasOptions {
    /// The Mac App Store identifier of the app(s) you want to manage.
    /// This can be found by running C(mas search APP_NAME) on your machine.
    id: Listing<Int>?
    /// Desired state of the app installation.
    /// The V(absent) value requires root permissions, also see the examples.
    state: ("absent"|"latest"|"present")?
    /// Upgrade all installed Mac App Store apps.
    upgrade_all: Boolean?
}

/// Task class for mas
class MasTask extends Playbook.Task {
    /// todo doc
    `community.general.mas`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.mas"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.mas`
}

/// TaskBuilder class for mas
class Mas extends Playbook.TaskBuilder {
    /// Options for community.general.mas
    options: MasOptions?
    /// todo doc
    function Task(): MasTask = this
        .toMap()
        .put("community.general.mas", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(MasTask)
}

/// Send notifications to matrix
/// This module sends html formatted notifications to matrix rooms.
class MatrixOptions {
    /// URL of the homeserver, where the CS-API is reachable
    hs_url: String
    /// HTML form of the message to send to matrix
    msg_html: String
    /// Plain text form of the message to send to matrix, usually markdown
    msg_plain: String
    /// The password to log in with
    password: String?
    /// ID of the room to send the notification to
    room_id: String
    /// Authentication token for the API call. If provided, user_id and password are not required
    token: String?
    /// The user id of the user
    user_id: String?
}

/// Task class for matrix
class MatrixTask extends Playbook.Task {
    /// todo doc
    `community.general.matrix`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.matrix"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.matrix`
}

/// TaskBuilder class for matrix
class Matrix extends Playbook.TaskBuilder {
    /// Options for community.general.matrix
    options: MatrixOptions?
    /// todo doc
    function Task(): MatrixTask = this
        .toMap()
        .put("community.general.matrix", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(MatrixTask)
}

/// Send Mattermost notifications
/// Sends notifications to U(http://your.mattermost.url) via the Incoming WebHook integration.
class MattermostOptions {
    /// Mattermost webhook api key. Log into your mattermost site, go to Menu -> Integration -> Incoming Webhook -> Add Incoming Webhook. This will give you full URL. O(api_key) is the last part. http://mattermost.example.com/hooks/C(API_KEY)
    api_key: String
    /// Define a list of attachments.
    /// For more information, see U(https://developers.mattermost.com/integrate/admin-guide/admin-message-attachments/).
    /// Required when O(text) is not set.
    attachments: Listing<Any>?
    /// Channel to send the message to. If absent, the message goes to the channel selected for the O(api_key).
    channel: String?
    /// URL for the message sender's icon.
    icon_url: String?
    /// Text to send. Note that the module does not handle escaping characters.
    /// Required when O(attachments) is not set.
    text: String?
    /// Mattermost url (i.e. http://mattermost.yourcompany.com).
    url: String
    /// This is the sender of the message (Username Override need to be enabled by mattermost admin, see mattermost doc.
    username: String?
    /// If V(false), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
    validate_certs: Boolean?
}

/// Task class for mattermost
class MattermostTask extends Playbook.Task {
    /// todo doc
    `community.general.mattermost`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.mattermost"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.mattermost`
}

/// TaskBuilder class for mattermost
class Mattermost extends Playbook.TaskBuilder {
    /// Options for community.general.mattermost
    options: MattermostOptions?
    /// todo doc
    function Task(): MattermostTask = this
        .toMap()
        .put("community.general.mattermost", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(MattermostTask)
}

/// Downloads an Artifact from a Maven Repository
/// Downloads an artifact from a maven repository given the maven coordinates provided to the module.
/// Can retrieve snapshots or release versions of the artifact and will resolve the latest available version if one is not available.
class MavenArtifactOptions {
    /// The maven artifactId coordinate
    artifact_id: String
    /// If V(md5), checksums will use the MD5 algorithm. This is the default.
    /// If V(sha1), checksums will use the SHA1 algorithm. This can be used on systems configured to use FIPS-compliant algorithms, since MD5 will be blocked on such systems.
    checksum_alg: ("md5"|"sha1")?
    /// The maven classifier coordinate
    classifier: String?
    /// PEM formatted certificate chain file to be used for SSL client authentication.
    /// This file can also include the key as well, and if the key is included, O(client_key) is not required.
    client_cert: String?
    /// PEM formatted file that contains your private key to be used for SSL client authentication.
    /// If O(client_cert) contains both the certificate and key, this option is not required.
    client_key: String?
    /// The path where the artifact should be written to
    /// If file mode or ownerships are specified and destination path already exists, they affect the downloaded file
    dest: String
    /// Filesystem permission mode applied recursively to O(dest) when it is a directory.
    directory_mode: String?
    /// The maven type/extension coordinate
    extension: String?
    /// httplib2, the library used by the uri module only sends authentication information when a webservice responds to an initial request with a 401 status. Since some basic auth services do not properly send a 401, logins will fail. This option forces the sending of the Basic authentication header upon initial request.
    force_basic_auth: Boolean?
    /// The Maven groupId coordinate
    group_id: String
    /// Add custom HTTP headers to a request in hash/dict format.
    headers: Any?
    /// If V(true), the downloaded artifact's name is preserved, i.e the version number remains part of it.
    /// This option only has effect when O(dest) is a directory and O(version) is set to V(latest) or O(version_by_spec) is defined.
    keep_name: Boolean?
    /// The password to authenticate with to the Maven Repository. Use AWS secret access key of the repository is hosted on S3
    password: String?
    /// The URL of the Maven Repository to download from.
    /// Use s3://... if the repository is hosted on Amazon S3, added in version 2.2.
    /// Use file://... if the repository is local, added in version 2.6
    repository_url: String?
    /// The desired state of the artifact
    state: ("present"|"absent")?
    /// Specifies a timeout in seconds for the connection attempt
    timeout: Int?
    /// A list of headers that should not be included in the redirection. This headers are sent to the C(fetch_url) function.
    /// On ansible-core version 2.12 or later, the default of this option is V([Authorization, Cookie]).
    /// Useful if the redirection URL does not need to have sensitive headers in the request.
    /// Requires ansible-core version 2.12 or later.
    unredirected_headers: Listing<String>?
    /// The username to authenticate as to the Maven Repository. Use AWS secret key of the repository is hosted on S3
    username: String?
    /// If V(false), SSL certificates will not be validated. This should only be set to V(false) when no other option exists.
    validate_certs: Boolean?
    /// If V(never), the MD5/SHA1 checksum will never be downloaded and verified.
    /// If V(download), the MD5/SHA1 checksum will be downloaded and verified only after artifact download. This is the default.
    /// If V(change), the MD5/SHA1 checksum will be downloaded and verified if the destination already exist, to verify if they are identical. This was the behaviour before 2.6. Since it downloads the checksum before (maybe) downloading the artifact, and since some repository software, when acting as a proxy/cache, return a 404 error if the artifact has not been cached yet, it may fail unexpectedly. If you still need it, you should consider using V(always) instead - if you deal with a checksum, it is better to use it to verify integrity after download.
    /// V(always) combines V(download) and V(change).
    verify_checksum: ("never"|"download"|"change"|"always")?
    /// The maven version coordinate
    /// Mutually exclusive with O(version_by_spec).
    version: String?
    /// The maven dependency version ranges.
    /// See supported version ranges on U(https://cwiki.apache.org/confluence/display/MAVENOLD/Dependency+Mediation+and+Conflict+Resolution)
    /// The range type "(,1.0],[1.2,)" and "(,1.1),(1.1,)" is not supported.
    /// Mutually exclusive with O(version).
    version_by_spec: String?
}

/// Task class for maven_artifact
class MavenArtifactTask extends Playbook.Task {
    /// todo doc
    `community.general.maven_artifact`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.maven_artifact"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.maven_artifact`
}

/// TaskBuilder class for maven_artifact
class MavenArtifact extends Playbook.TaskBuilder {
    /// Options for community.general.maven_artifact
    options: MavenArtifactOptions?
    /// todo doc
    function Task(): MavenArtifactTask = this
        .toMap()
        .put("community.general.maven_artifact", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(MavenArtifactTask)
}

/// Request reload of Memset's DNS infrastructure,
/// Request a reload of Memset's DNS infrastructure, and optionally poll until it finishes.
class MemsetDnsReloadOptions {
    /// The API key obtained from the Memset control panel.
    api_key: String
    /// Boolean value, if set will poll the reload job's status and return when the job has completed (unless the 30 second timeout is reached first). If the timeout is reached then the task will not be marked as failed, but stderr will indicate that the polling failed.
    poll: Boolean?
}

/// Task class for memset_dns_reload
class MemsetDnsReloadTask extends Playbook.Task {
    /// todo doc
    `community.general.memset_dns_reload`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.memset_dns_reload"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.memset_dns_reload`
}

/// TaskBuilder class for memset_dns_reload
class MemsetDnsReload extends Playbook.TaskBuilder {
    /// Options for community.general.memset_dns_reload
    options: MemsetDnsReloadOptions?
    /// todo doc
    function Task(): MemsetDnsReloadTask = this
        .toMap()
        .put("community.general.memset_dns_reload", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(MemsetDnsReloadTask)
}

/// Retrieve Memstore product usage information
/// Retrieve Memstore product usage information.
class MemsetMemstoreInfoOptions {
    /// The API key obtained from the Memset control panel.
    api_key: String
    /// The Memstore product name (that is, C(mstestyaa1)).
    name: String
}

/// Task class for memset_memstore_info
class MemsetMemstoreInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.memset_memstore_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.memset_memstore_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.memset_memstore_info`
}

/// TaskBuilder class for memset_memstore_info
class MemsetMemstoreInfo extends Playbook.TaskBuilder {
    /// Options for community.general.memset_memstore_info
    options: MemsetMemstoreInfoOptions?
    /// todo doc
    function Task(): MemsetMemstoreInfoTask = this
        .toMap()
        .put("community.general.memset_memstore_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(MemsetMemstoreInfoTask)
}

/// Retrieve server information
/// Retrieve server information.
class MemsetServerInfoOptions {
    /// The API key obtained from the Memset control panel.
    api_key: String
    /// The server product name (that is, C(testyaa1)).
    name: String
}

/// Task class for memset_server_info
class MemsetServerInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.memset_server_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.memset_server_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.memset_server_info`
}

/// TaskBuilder class for memset_server_info
class MemsetServerInfo extends Playbook.TaskBuilder {
    /// Options for community.general.memset_server_info
    options: MemsetServerInfoOptions?
    /// todo doc
    function Task(): MemsetServerInfoTask = this
        .toMap()
        .put("community.general.memset_server_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(MemsetServerInfoTask)
}

/// Creates and deletes Memset DNS zones
/// Manage DNS zones in a Memset account.
class MemsetZoneOptions {
    /// The API key obtained from the Memset control panel.
    api_key: String
    /// Forces deletion of a zone and all zone domains/zone records it contains.
    force: Boolean?
    /// The zone nickname; usually the same as the main domain. Ensure this value has at most 250 characters.
    name: String
    /// Indicates desired state of resource.
    state: ("absent"|"present")
    /// The default TTL for all records created in the zone. This must be a valid int from U(https://www.memset.com/apidocs/methods_dns.html#dns.zone_create).
    ttl: Int?
}

/// Task class for memset_zone
class MemsetZoneTask extends Playbook.Task {
    /// todo doc
    `community.general.memset_zone`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.memset_zone"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.memset_zone`
}

/// TaskBuilder class for memset_zone
class MemsetZone extends Playbook.TaskBuilder {
    /// Options for community.general.memset_zone
    options: MemsetZoneOptions?
    /// todo doc
    function Task(): MemsetZoneTask = this
        .toMap()
        .put("community.general.memset_zone", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(MemsetZoneTask)
}

/// Create and delete domains in Memset DNS zones
/// Manage DNS zone domains in a Memset account.
class MemsetZoneDomainOptions {
    /// The API key obtained from the Memset control panel.
    api_key: String
    /// The zone domain name. Ensure this value has at most 250 characters.
    domain: String
    /// Indicates desired state of resource.
    state: ("absent"|"present")?
    /// The zone to add the domain to (this must already exist).
    zone: String
}

/// Task class for memset_zone_domain
class MemsetZoneDomainTask extends Playbook.Task {
    /// todo doc
    `community.general.memset_zone_domain`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.memset_zone_domain"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.memset_zone_domain`
}

/// TaskBuilder class for memset_zone_domain
class MemsetZoneDomain extends Playbook.TaskBuilder {
    /// Options for community.general.memset_zone_domain
    options: MemsetZoneDomainOptions?
    /// todo doc
    function Task(): MemsetZoneDomainTask = this
        .toMap()
        .put("community.general.memset_zone_domain", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(MemsetZoneDomainTask)
}

/// Create and delete records in Memset DNS zones
/// Manage DNS records in a Memset account.
class MemsetZoneRecordOptions {
    /// The address for this record (can be IP or text string depending on record type).
    address: String
    /// The API key obtained from the Memset control panel.
    api_key: String
    /// C(SRV) and C(TXT) record priority, in the range 0 > 999 (inclusive).
    priority: Int?
    /// The subdomain to create.
    `record`: String?
    /// If set then the current domain is added onto the address field for C(CNAME), C(MX), C(NS) and C(SRV)record types.
    relative: Boolean?
    /// Indicates desired state of resource.
    state: ("absent"|"present")?
    /// The record's TTL in seconds (will inherit zone's TTL if not explicitly set). This must be a valid int from U(https://www.memset.com/apidocs/methods_dns.html#dns.zone_record_create).
    ttl: Int?
    /// The type of DNS record to create.
    type: ("A"|"AAAA"|"CNAME"|"MX"|"NS"|"SRV"|"TXT")
    /// The name of the zone to which to add the record to.
    zone: String
}

/// Task class for memset_zone_record
class MemsetZoneRecordTask extends Playbook.Task {
    /// todo doc
    `community.general.memset_zone_record`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.memset_zone_record"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.memset_zone_record`
}

/// TaskBuilder class for memset_zone_record
class MemsetZoneRecord extends Playbook.TaskBuilder {
    /// Options for community.general.memset_zone_record
    options: MemsetZoneRecordOptions?
    /// todo doc
    function Task(): MemsetZoneRecordTask = this
        .toMap()
        .put("community.general.memset_zone_record", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(MemsetZoneRecordTask)
}

/// Generates AIX mksysb rootvg backups
/// This module manages a basic AIX mksysb (image) of rootvg.
class MksysbOptions {
    /// Backup encrypted files.
    backup_crypt_files: Boolean?
    /// Back up DMAPI filesystem files.
    backup_dmapi_fs: Boolean?
    /// Creates a new MAP files.
    create_map_files: Boolean?
    /// Excludes files using C(/etc/rootvg.exclude).
    exclude_files: Boolean?
    /// Excludes WPAR files.
    exclude_wpar_files: Boolean?
    /// Backup extended attributes.
    extended_attrs: Boolean?
    /// Backup name
    name: String
    /// Creates a new file data.
    new_image_data: Boolean?
    /// Exclude files from packing option listed in C(/etc/exclude_packing.rootvg).
    software_packing: Boolean?
    /// Storage path where the mksysb will stored.
    storage_path: String
    /// Creates backup using snapshots.
    use_snapshot: Boolean?
}

/// Task class for mksysb
class MksysbTask extends Playbook.Task {
    /// todo doc
    `community.general.mksysb`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.mksysb"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.mksysb`
}

/// TaskBuilder class for mksysb
class Mksysb extends Playbook.TaskBuilder {
    /// Options for community.general.mksysb
    options: MksysbOptions?
    /// todo doc
    function Task(): MksysbTask = this
        .toMap()
        .put("community.general.mksysb", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(MksysbTask)
}

/// Load or unload kernel modules
/// Load or unload kernel modules.
class ModprobeOptions {
    /// Name of kernel module to manage.
    name: String
    /// Modules parameters.
    params: String?
    /// Persistency between reboots for configured module.
    /// This option creates files in C(/etc/modules-load.d/) and C(/etc/modprobe.d/) that make your module configuration persistent during reboots.
    /// If V(present), adds module name to C(/etc/modules-load.d/) and params to C(/etc/modprobe.d/) so the module will be loaded on next reboot.
    /// If V(absent), will comment out module name from C(/etc/modules-load.d/) and comment out params from C(/etc/modprobe.d/) so the module will not be loaded on next reboot.
    /// If V(disabled), will not touch anything and leave C(/etc/modules-load.d/) and C(/etc/modprobe.d/) as it is.
    /// Note that it is usually a better idea to rely on the automatic module loading by PCI IDs, USB IDs, DMI IDs or similar triggers encoded in the kernel modules themselves instead of configuration like this.
    /// In fact, most modern kernel modules are prepared for automatic loading already.
    /// B(Note:) This option works only with distributions that use C(systemd) when set to values other than V(disabled).
    persistent: ("disabled"|"absent"|"present")?
    /// Whether the module should be present or absent.
    state: ("absent"|"present")?
}

/// Task class for modprobe
class ModprobeTask extends Playbook.Task {
    /// todo doc
    `community.general.modprobe`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.modprobe"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.modprobe`
}

/// TaskBuilder class for modprobe
class Modprobe extends Playbook.TaskBuilder {
    /// Options for community.general.modprobe
    options: ModprobeOptions?
    /// todo doc
    function Task(): ModprobeTask = this
        .toMap()
        .put("community.general.modprobe", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ModprobeTask)
}

/// Manage the state of a program monitored via Monit
/// Manage the state of a program monitored via Monit.
class MonitOptions {
    /// The name of the C(monit) program/process to manage.
    name: String
    /// The state of service.
    state: ("present"|"started"|"stopped"|"restarted"|"monitored"|"unmonitored"|"reloaded")
    /// If there are pending actions for the service monitored by monit, then Ansible will check for up to this many seconds to verify the requested action has been performed. Ansible will sleep for five seconds between each check.
    timeout: Int?
}

/// Task class for monit
class MonitTask extends Playbook.Task {
    /// todo doc
    `community.general.monit`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.monit"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.monit`
}

/// TaskBuilder class for monit
class Monit extends Playbook.TaskBuilder {
    /// Options for community.general.monit
    options: MonitOptions?
    /// todo doc
    function Task(): MonitTask = this
        .toMap()
        .put("community.general.monit", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(MonitTask)
}

/// Publish a message on an MQTT topic for the IoT
/// Publish a message on an MQTT topic.
class MqttOptions {
    /// The path to the Certificate Authority certificate files that are to be treated as trusted by this client. If this is the only option given then the client will operate in a similar manner to a web browser. That is to say it will require the broker to have a certificate signed by the Certificate Authorities in ca_certs and will communicate using TLS v1, but will not attempt any form of authentication. This provides basic network encryption but may not be sufficient depending on how the broker is configured.
    ca_cert: String?
    /// The path pointing to the PEM encoded client certificate. If this is not None it will be used as client information for TLS based authentication. Support for this feature is broker dependent.
    client_cert: String?
    /// MQTT client identifier
    /// If not specified, a value C(hostname + pid) will be used.
    client_id: String?
    /// The path pointing to the PEM encoded client private key. If this is not None it will be used as client information for TLS based authentication. Support for this feature is broker dependent.
    client_key: String?
    /// Password for O(username) to authenticate against the broker.
    password: String?
    /// Payload. The special string V("None") may be used to send a NULL (that is, empty) payload which is useful to simply notify with the O(topic) or to clear previously retained messages.
    payload: String
    /// MQTT broker port number
    port: Int?
    /// QoS (Quality of Service)
    qos: ("0"|"1"|"2")?
    /// Setting this flag causes the broker to retain (i.e. keep) the message so that applications that subsequently subscribe to the topic can received the last retained message immediately.
    retain: Boolean?
    /// MQTT broker address/name
    server: String?
    /// Specifies the version of the SSL/TLS protocol to be used.
    /// By default (if the python version supports it) the highest TLS version is detected. If unavailable, TLS v1 is used.
    tls_version: ("tlsv1.1"|"tlsv1.2")?
    /// MQTT topic name
    topic: String
    /// Username to authenticate against the broker.
    username: String?
}

/// Task class for mqtt
class MqttTask extends Playbook.Task {
    /// todo doc
    `community.general.mqtt`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.mqtt"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.mqtt`
}

/// TaskBuilder class for mqtt
class Mqtt extends Playbook.TaskBuilder {
    /// Options for community.general.mqtt
    options: MqttOptions?
    /// todo doc
    function Task(): MqttTask = this
        .toMap()
        .put("community.general.mqtt", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(MqttTask)
}

/// Add or remove MSSQL databases from a remote host
/// Add or remove MSSQL databases from a remote host.
class MssqlDbOptions {
    /// Automatically commit the change only if the import succeed. Sometimes it is necessary to use autocommit=true, since some content can't be changed within a transaction.
    autocommit: Boolean?
    /// Host running the database
    login_host: String
    /// The password used to authenticate with
    login_password: String?
    /// Port of the MSSQL server. Requires login_host be defined as other than localhost if login_port is used
    login_port: String?
    /// The username used to authenticate with
    login_user: String?
    /// name of the database to add or remove
    name: String
    /// The database state
    state: ("present"|"absent"|"import")?
    /// Location, on the remote host, of the dump file to read from or write to. Uncompressed SQL files (C(.sql)) files are supported.
    target: String?
}

/// Task class for mssql_db
class MssqlDbTask extends Playbook.Task {
    /// todo doc
    `community.general.mssql_db`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.mssql_db"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.mssql_db`
}

/// TaskBuilder class for mssql_db
class MssqlDb extends Playbook.TaskBuilder {
    /// Options for community.general.mssql_db
    options: MssqlDbOptions?
    /// todo doc
    function Task(): MssqlDbTask = this
        .toMap()
        .put("community.general.mssql_db", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(MssqlDbTask)
}

/// Execute SQL scripts on a MSSQL database
/// Execute SQL scripts on a MSSQL database.
class MssqlScriptOptions {
    /// Host running the database.
    login_host: String
    /// The password used to authenticate with.
    login_password: String?
    /// Port of the MSSQL server. Requires O(login_host) be defined as well.
    login_port: Int?
    /// The username used to authenticate with.
    login_user: String?
    /// Database to run script against.
    name: String?
    /// With V(default) each row will be returned as a list of values. See RV(query_results).
    /// Output format V(dict) will return dictionary with the column names as keys. See RV(query_results_dict).
    /// V(dict) requires named columns to be returned by each query otherwise an error is thrown.
    output: ("dict"|"default")?
    /// Parameters passed to the script as SQL parameters.(Query V('SELECT %(name\)s"') with V(example: '{"name": "John Doe"}).)'
    params: Any?
    /// The SQL script to be executed.
    /// Script can contain multiple SQL statements. Multiple Batches can be separated by V(GO) command.
    /// Each batch must return at least one result set.
    script: String
    /// If transactional mode is requested, start a transaction and commit the change only if the script succeed. Otherwise, rollback the transaction.
    /// If transactional mode is not requested (default), automatically commit the change.
    transaction: Boolean?
}

/// Task class for mssql_script
class MssqlScriptTask extends Playbook.Task {
    /// todo doc
    `community.general.mssql_script`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.mssql_script"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.mssql_script`
}

/// TaskBuilder class for mssql_script
class MssqlScript extends Playbook.TaskBuilder {
    /// Options for community.general.mssql_script
    options: MssqlScriptOptions?
    /// todo doc
    function Task(): MssqlScriptTask = this
        .toMap()
        .put("community.general.mssql_script", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(MssqlScriptTask)
}

/// Perform common tasks in Nagios related to downtime and notifications
/// The C(nagios) module has two basic functions: scheduling downtime and toggling alerts for services or hosts.
/// The C(nagios) module is not idempotent.
/// All actions require the O(host) parameter to be given explicitly. In playbooks you can use the C({{inventory_hostname}}) variable to refer to the host the playbook is currently running on.
/// You can specify multiple services at once by separating them with commas, .e.g. O(services=httpd,nfs,puppet).
/// When specifying what service to handle there is a special service value, O(host), which will handle alerts/downtime/acknowledge for the I(host itself), for example O(services=host). This keyword may not be given with other services at the same time. B(Setting alerts/downtime/acknowledge for a host does not affect alerts/downtime/acknowledge for any of the services running on it.) To schedule downtime for all services on particular host use keyword "all", for example O(services=all).
class NagiosOptions {
    /// Action to take.
    /// servicegroup options were added in 2.0.
    /// delete_downtime options were added in 2.2.
    /// The V(acknowledge) and V(forced_check) actions were added in community.general 1.2.0.
    action: ("downtime"|"delete_downtime"|"enable_alerts"|"disable_alerts"|"silence"|"unsilence"|"silence_nagios"|"unsilence_nagios"|"command"|"servicegroup_service_downtime"|"servicegroup_host_downtime"|"acknowledge"|"forced_check")
    /// Author to leave downtime comments as. Only used when O(action) is V(downtime) or V(acknowledge).
    author: String?
    /// Path to the nagios I(command file) (FIFO pipe). Only required if auto-detection fails.
    cmdfile: String?
    /// The raw command to send to nagios, which should not include the submitted time header or the line-feed.
    /// B(Required) option when using the V(command) O(action).
    command: String?
    /// Comment when O(action) is V(downtime) or V(acknowledge).
    comment: String?
    /// Host to operate on in Nagios.
    host: String?
    /// Minutes to schedule downtime for.
    /// Only usable with O(action=downtime).
    minutes: Int?
    /// The Servicegroup we want to set downtimes/alerts for.
    /// B(Required) option when using the V(servicegroup_service_downtime) and V(servicegroup_host_downtime) O(action).
    servicegroup: String?
    /// What to manage downtime/alerts for. Separate multiple services with commas.
    /// B(Required) option when O(action) is one of: V(downtime), V(acknowledge), V(forced_check), V(enable_alerts), V(disable_alerts).
    services: String?
    /// When downtime should start, in C(time_t) format (epoch seconds).
    start: String?
}

/// Task class for nagios
class NagiosTask extends Playbook.Task {
    /// todo doc
    `community.general.nagios`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.nagios"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.nagios`
}

/// TaskBuilder class for nagios
class Nagios extends Playbook.TaskBuilder {
    /// Options for community.general.nagios
    options: NagiosOptions?
    /// todo doc
    function Task(): NagiosTask = this
        .toMap()
        .put("community.general.nagios", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(NagiosTask)
}

/// Manage Netcup DNS records
/// Manages DNS records via the Netcup API, see the docs U(https://ccp.netcup.net/run/webservice/servers/endpoint.php).
class NetcupDnsOptions {
    /// API key for authentication, must be obtained via the netcup CCP (U(https://ccp.netcup.net)).
    api_key: String
    /// API password for authentication, must be obtained via the netcup CCP (U(https://ccp.netcup.net)).
    api_password: String
    /// Netcup customer id.
    customer_id: Int
    /// Domainname the records should be added / removed.
    domain: String
    /// Record priority. Required for O(type=MX).
    priority: Int?
    /// Record to add or delete, supports wildcard (V(*)). Default is V(@) (that is, the zone name).
    `record`: String?
    /// Whether the record should be the only one for that record type and record name. Only use with O(state=present).
    /// This will delete all other records with the same record name and type.
    solo: Boolean?
    /// Whether the record should exist or not.
    state: ("present"|"absent")?
    /// HTTP(S) connection timeout in seconds.
    timeout: Int?
    /// Record type.
    /// Support for V(OPENPGPKEY), V(SMIMEA) and V(SSHFP) was added in community.general 8.1.0.
    /// Record types V(OPENPGPKEY) and V(SMIMEA) require nc-dnsapi >= 0.1.5.
    /// Record type V(SSHFP) requires nc-dnsapi >= 0.1.6.
    type: ("A"|"AAAA"|"MX"|"CNAME"|"CAA"|"SRV"|"TXT"|"TLSA"|"NS"|"DS"|"OPENPGPKEY"|"SMIMEA"|"SSHFP")
    /// Record value.
    value: String
}

/// Task class for netcup_dns
class NetcupDnsTask extends Playbook.Task {
    /// todo doc
    `community.general.netcup_dns`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.netcup_dns"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.netcup_dns`
}

/// TaskBuilder class for netcup_dns
class NetcupDns extends Playbook.TaskBuilder {
    /// Options for community.general.netcup_dns
    options: NetcupDnsOptions?
    /// todo doc
    function Task(): NetcupDnsTask = this
        .toMap()
        .put("community.general.netcup_dns", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(NetcupDnsTask)
}

/// Notify New Relic about app deployments
/// Notify New Relic about app deployments (see https://docs.newrelic.com/docs/apm/new-relic-apm/maintenance/record-monitor-deployments/)
class NewrelicDeploymentOptions {
    /// The value of C(app_name) in the C(newrelic.yml) file used by the application.
    /// One of O(app_name) or O(application_id) is required.
    app_name: String?
    /// If this flag is set to V(true) then the application ID lookup by name would only work for an exact match. If set to V(false) it returns the first result.
    app_name_exact_match: Boolean?
    /// The application ID found in the metadata of the application in APM.
    /// One of O(app_name) or O(application_id) is required.
    application_id: String?
    /// A list of changes for this deployment
    changelog: String?
    /// Text annotation for the deployment - notes for you
    description: String?
    /// A revision number (e.g., git commit SHA)
    revision: String
    /// API token to place in the Api-Key header.
    token: String
    /// The name of the user/process that triggered this deployment
    user: String?
    /// If V(false), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
    validate_certs: Boolean?
}

/// Task class for newrelic_deployment
class NewrelicDeploymentTask extends Playbook.Task {
    /// todo doc
    `community.general.newrelic_deployment`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.newrelic_deployment"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.newrelic_deployment`
}

/// TaskBuilder class for newrelic_deployment
class NewrelicDeployment extends Playbook.TaskBuilder {
    /// Options for community.general.newrelic_deployment
    options: NewrelicDeploymentOptions?
    /// todo doc
    function Task(): NewrelicDeploymentTask = this
        .toMap()
        .put("community.general.newrelic_deployment", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(NewrelicDeploymentTask)
}

/// Send a SMS via nexmo
/// Send a SMS message via nexmo
class NexmoOptions {
    /// Nexmo API Key
    api_key: String
    /// Nexmo API Secret
    api_secret: String
    /// Phone number(s) to send SMS message to
    dest: Listing<Int>
    /// Message to text to send. Messages longer than 160 characters will be split into multiple messages
    msg: String
    /// Nexmo Number to send from
    src: Int
    /// If V(false), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
    validate_certs: Boolean?
}

/// Task class for nexmo
class NexmoTask extends Playbook.Task {
    /// todo doc
    `community.general.nexmo`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.nexmo"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.nexmo`
}

/// TaskBuilder class for nexmo
class Nexmo extends Playbook.TaskBuilder {
    /// Options for community.general.nexmo
    options: NexmoOptions?
    /// todo doc
    function Task(): NexmoTask = this
        .toMap()
        .put("community.general.nexmo", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(NexmoTask)
}

/// Retrieve information on nginx status
/// Gathers information from nginx from an URL having C(stub_status) enabled.
class NginxStatusInfoOptions {
    /// HTTP connection timeout in seconds.
    timeout: Int?
    /// URL of the nginx status.
    url: String
}

/// Task class for nginx_status_info
class NginxStatusInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.nginx_status_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.nginx_status_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.nginx_status_info`
}

/// TaskBuilder class for nginx_status_info
class NginxStatusInfo extends Playbook.TaskBuilder {
    /// Options for community.general.nginx_status_info
    options: NginxStatusInfoOptions?
    /// todo doc
    function Task(): NginxStatusInfoTask = this
        .toMap()
        .put("community.general.nginx_status_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(NginxStatusInfoTask)
}

/// Manage nic tags on SmartOS systems
/// Create or delete nic tags on SmartOS systems.
class NictagadmOptions {
    /// Specifies that the nic tag will be attached to a created O(etherstub).
    /// Parameter O(etherstub) is mutually exclusive with both O(mtu), and O(mac).
    etherstub: Boolean?
    /// When O(state=absent) this switch will use the C(-f) parameter and delete the nic tag regardless of existing VMs.
    force: Boolean?
    /// Specifies the O(mac) address to attach the nic tag to when not creating an O(etherstub).
    /// Parameters O(mac) and O(etherstub) are mutually exclusive.
    mac: String?
    /// Specifies the size of the O(mtu) of the desired nic tag.
    /// Parameters O(mtu) and O(etherstub) are mutually exclusive.
    mtu: Int?
    /// Name of the nic tag.
    name: String
    /// Create or delete a SmartOS nic tag.
    state: ("absent"|"present")?
}

/// Task class for nictagadm
class NictagadmTask extends Playbook.Task {
    /// todo doc
    `community.general.nictagadm`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.nictagadm"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.nictagadm`
}

/// TaskBuilder class for nictagadm
class Nictagadm extends Playbook.TaskBuilder {
    /// Options for community.general.nictagadm
    options: NictagadmOptions?
    /// todo doc
    function Task(): NictagadmTask = this
        .toMap()
        .put("community.general.nictagadm", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(NictagadmTask)
}

/// Manage Networking
/// Manage the network devices. Create, modify and manage various connection and device type e.g., ethernet, teams, bonds, vlans etc.
/// On CentOS 8 and Fedora >=29 like systems, the requirements can be met by installing the following packages: NetworkManager.
/// On CentOS 7 and Fedora <=28 like systems, the requirements can be met by installing the following packages: NetworkManager-tui.
/// On Ubuntu and Debian like systems, the requirements can be met by installing the following packages: network-manager
/// On openSUSE, the requirements can be met by installing the following packages: NetworkManager.
class NmcliOptions {
    /// Configure method for creating the address for use with IPv6 Stateless Address Autoconfiguration.
    /// V(default) and V(default-or-eui64) have been added in community.general 6.5.0.
    addr_gen_mode6: ("default"|"default-or-eui64"|"eui64"|"stable-privacy")?
    /// This is only used with bridge - [ageing-time <0-1000000>] the Ethernet MAC address aging time, in seconds.
    ageingtime: Int?
    /// This is only used with bond - ARP interval.
    arp_interval: Int?
    /// This is only used with bond - ARP IP target.
    arp_ip_target: String?
    /// Whether the connection should start on boot.
    /// Whether the connection profile can be automatically activated
    autoconnect: Boolean?
    /// The name used to call the connection. Pattern is <type>[-<ifname>][-<num>].
    conn_name: String
    /// DHCP Client Identifier sent to the DHCP server.
    dhcp_client_id: String?
    /// A list of up to 3 DNS servers.
    /// The entries must be IPv4 addresses, for example V(192.0.2.53).
    dns4: Listing<String>?
    /// Ignore automatically configured IPv4 name servers.
    dns4_ignore_auto: Boolean?
    /// A list of DNS options.
    dns4_options: Listing<String>?
    /// A list of DNS search domains.
    dns4_search: Listing<String>?
    /// A list of up to 3 DNS servers.
    /// The entries must be IPv6 addresses, for example V(2001:4860:4860::8888).
    dns6: Listing<String>?
    /// Ignore automatically configured IPv6 name servers.
    dns6_ignore_auto: Boolean?
    /// A list of DNS options.
    dns6_options: Listing<String>?
    /// A list of DNS search domains.
    dns6_search: Listing<String>?
    /// This is only used with bond - downdelay.
    downdelay: Int?
    /// This is only used with VLAN - VLAN egress priority mapping.
    egress: String?
    /// This is only used with VLAN - flags.
    flags: String?
    /// This is only used with bridge - [forward-delay <2-30>] STP forwarding delay, in seconds.
    forwarddelay: Int?
    /// The configuration of the GSM connection.
    /// Note the list of suboption attributes may vary depending on which version of NetworkManager/nmcli is installed on the host.
    /// An up-to-date list of supported attributes can be found here: U(https://networkmanager.dev/docs/api/latest/settings-gsm.html).
    /// For instance to use apn, pin, username and password: V({apn: provider.apn, pin: 1234, username: apn.username, password: apn.password}).
    gsm: Any?
    /// The IPv4 gateway for this interface.
    /// Use the format V(192.0.2.1).
    /// This parameter is mutually_exclusive with never_default4 parameter.
    gw4: String?
    /// Ignore automatically configured IPv4 routes.
    gw4_ignore_auto: Boolean?
    /// The IPv6 gateway for this interface.
    /// Use the format V(2001:db8::1).
    gw6: String?
    /// Ignore automatically configured IPv6 routes.
    gw6_ignore_auto: Boolean?
    /// This is only used with 'bridge-slave' - 'hairpin mode' for the slave, which allows frames to be sent back out through the slave the frame was received on.
    /// The default change to V(false) in community.general 7.0.0. It used to be V(true) before.
    hairpin: Boolean?
    /// This is only used with bridge - [hello-time <1-10>] STP hello time, in seconds.
    hellotime: Int?
    /// The interface to bind the connection to.
    /// The connection will only be applicable to this interface name.
    /// A special value of V('*') can be used for interface-independent connections.
    /// The ifname argument is mandatory for all connection types except bond, team, bridge, vlan and vpn.
    /// This parameter defaults to O(conn_name) when left unset for all connection types except vpn that removes it.
    ifname: String?
    /// Ignore suboptions which are invalid or unsupported by the version of NetworkManager/nmcli installed on the host.
    /// Only O(wifi) and O(wifi_sec) options are currently affected.
    ignore_unsupported_suboptions: Boolean?
    /// This is only used with VLAN - VLAN ingress priority mapping.
    ingress: String?
    /// List of IPv4 addresses to this interface.
    /// Use the format V(192.0.2.24/24) or V(192.0.2.24).
    /// If defined and O(method4) is not specified, automatically set C(ipv4.method) to V(manual).
    ip4: Listing<String>?
    /// List of IPv6 addresses to this interface.
    /// Use the format V(abbe::cafe/128) or V(abbe::cafe).
    /// If defined and O(method6) is not specified, automatically set C(ipv6.method) to V(manual).
    ip6: Listing<String>?
    /// If enabled, it makes the kernel generate a temporary IPv6 address in addition to the public one.
    ip_privacy6: ("disabled"|"prefer-public-addr"|"prefer-temp-addr"|"unknown")?
    /// This is used with GRE/IPIP/SIT - parent device this GRE/IPIP/SIT tunnel, can use ifname.
    ip_tunnel_dev: String?
    /// The key used for tunnel input packets.
    /// Only used when O(type=gre).
    ip_tunnel_input_key: String?
    /// This is used with GRE/IPIP/SIT - GRE/IPIP/SIT local IP address.
    ip_tunnel_local: String?
    /// The key used for tunnel output packets.
    /// Only used when O(type=gre).
    ip_tunnel_output_key: String?
    /// This is used with GRE/IPIP/SIT - GRE/IPIP/SIT destination IP address.
    ip_tunnel_remote: String?
    /// MAC address of the connection.
    /// Note this requires a recent kernel feature, originally introduced in 3.15 upstream kernel.
    mac: String?
    /// The configuration of the MAC VLAN connection.
    /// Note the list of suboption attributes may vary depending on which version of NetworkManager/nmcli is installed on the host.
    /// An up-to-date list of supported attributes can be found here: U(https://networkmanager.dev/docs/api/latest/settings-macvlan.html).
    macvlan: Any?
    /// Master <master (ifname, or connection UUID or conn_name) of bridge, team, bond, ovs-port master connection profile.
    /// Mandatory if O(slave_type) is defined.
    master: String?
    /// This is only used with bridge - [max-age <6-42>] STP maximum message age, in seconds.
    maxage: Int?
    /// If you need O(ip4) configured before C(network-online.target) is reached, set this option to V(false).
    /// This option applies when O(method4) is not V(disabled).
    may_fail4: Boolean?
    /// Configuration method to be used for IPv4.
    /// If O(ip4) is set, C(ipv4.method) is automatically set to V(manual) and this parameter is not needed.
    method4: ("auto"|"link-local"|"manual"|"shared"|"disabled")?
    /// Configuration method to be used for IPv6
    /// If O(ip6) is set, C(ipv6.method) is automatically set to V(manual) and this parameter is not needed.
    /// V(disabled) was added in community.general 3.3.0.
    method6: ("ignore"|"auto"|"dhcp"|"link-local"|"manual"|"shared"|"disabled")?
    /// This is only used with bond - miimon.
    /// This parameter defaults to V(100) when unset.
    miimon: Int?
    /// This is the type of device or network connection that you wish to create for a bond or bridge.
    mode: ("802.3ad"|"active-backup"|"balance-alb"|"balance-rr"|"balance-tlb"|"balance-xor"|"broadcast")?
    /// The connection MTU, e.g. 9000. This can't be applied when creating the interface and is done once the interface has been created.
    /// Can be used when modifying Team, VLAN, Ethernet (Future plans to implement wifi, gsm, pppoe, infiniband)
    /// This parameter defaults to V(1500) when unset.
    mtu: Int?
    /// Set as default route.
    /// This parameter is mutually_exclusive with gw4 parameter.
    never_default4: Boolean?
    /// This is only used with 'bridge-slave' - [<1-65535>] - STP port cost for destinations via this slave.
    path_cost: Int?
    /// This is only used with bond and is the primary interface name (for "active-backup" mode), this is the usually the 'ifname'.
    primary: String?
    /// This is only used with 'bridge' - sets STP priority.
    priority: Int?
    /// Set metric level of ipv4 routes configured on interface.
    route_metric4: Int?
    /// Set metric level of IPv6 routes configured on interface.
    route_metric6: Int?
    /// The list of IPv4 routes.
    /// Use the format V(192.0.3.0/24 192.0.2.1).
    /// To specify more complex routes, use the O(routes4_extended) option.
    routes4: Listing<String>?
    /// The list of IPv4 routes.
    routes4_extended: Listing<Any>?
    /// The list of IPv6 routes.
    /// Use the format V(fd12:3456:789a:1::/64 2001:dead:beef::1).
    /// To specify more complex routes, use the O(routes6_extended) option.
    routes6: Listing<String>?
    /// The list of IPv6 routes but with parameters.
    routes6_extended: Listing<Any>?
    /// Is the same as in an C(ip rule add) command, except always requires specifying a priority.
    routing_rules4: Listing<String>?
    /// This is the type of device or network connection that you wish to create for a team.
    runner: ("broadcast"|"roundrobin"|"activebackup"|"loadbalance"|"lacp")?
    /// Option specifies the rate at which our link partner is asked to transmit LACPDU packets. If this is V(true) then packets will be sent once per second. Otherwise they will be sent every 30 seconds.
    /// Only allowed for O(runner=lacp).
    runner_fast_rate: Boolean?
    /// This defines the policy of how hardware addresses of team device and port devices should be set during the team lifetime.
    runner_hwaddr_policy: ("same_all"|"by_active"|"only_active")?
    /// Type of the device of this slave's master connection (for example V(bond)).
    /// Type V(ovs-port) is added in community.general 8.6.0.
    slave_type: ("bond"|"bridge"|"team"|"ovs-port")?
    /// This is only used with 'bridge-slave' - [<0-63>] - STP priority of this slave.
    slavepriority: Int?
    /// Name of the Wireless router or the access point.
    ssid: String?
    /// Whether the device should exist or not, taking action if the state is different from what is stated.
    state: ("absent"|"present")
    /// This is only used with bridge and controls whether Spanning Tree Protocol (STP) is enabled for this bridge.
    stp: Boolean?
    /// This option sets the connection type of Infiniband IPoIB devices.
    transport_mode: ("datagram"|"connected")?
    /// This is the type of device or network connection that you wish to create or modify.
    /// Type V(dummy) is added in community.general 3.5.0.
    /// Type V(gsm) is added in community.general 3.7.0.
    /// Type V(infiniband) is added in community.general 2.0.0.
    /// Type V(loopback) is added in community.general 8.1.0.
    /// Type V(macvlan) is added in community.general 6.6.0.
    /// Type V(ovs-bridge) is added in community.general 8.6.0.
    /// Type V(ovs-interface) is added in community.general 8.6.0.
    /// Type V(ovs-port) is added in community.general 8.6.0.
    /// Type V(wireguard) is added in community.general 4.3.0.
    /// Type V(vpn) is added in community.general 5.1.0.
    /// Using V(bond-slave), V(bridge-slave), or V(team-slave) implies V(ethernet) connection type with corresponding O(slave_type) option.
    /// If you want to control non-ethernet connection attached to V(bond), V(bridge), or V(team) consider using O(slave_type) option.
    type: ("bond"|"bond-slave"|"bridge"|"bridge-slave"|"dummy"|"ethernet"|"generic"|"gre"|"infiniband"|"ipip"|"macvlan"|"sit"|"team"|"team-slave"|"vlan"|"vxlan"|"wifi"|"gsm"|"wireguard"|"ovs-bridge"|"ovs-port"|"ovs-interface"|"vpn"|"loopback")?
    /// This is only used with bond - updelay.
    updelay: Int?
    /// This is only used with VLAN - parent device this VLAN is on, can use ifname.
    vlandev: String?
    /// This is only used with VLAN - VLAN ID in range <0-4095>.
    vlanid: Int?
    /// Configuration of a VPN connection (PPTP and L2TP).
    /// In order to use L2TP you need to be sure that C(network-manager-l2tp) - and C(network-manager-l2tp-gnome) if host has UI - are installed on the host.
    vpn: Any?
    /// This is only used with VXLAN - VXLAN ID.
    vxlan_id: Int?
    /// This is only used with VXLAN - VXLAN local IP address.
    vxlan_local: String?
    /// This is only used with VXLAN - VXLAN destination IP address.
    vxlan_remote: String?
    /// The configuration of the WiFi connection.
    /// Note the list of suboption attributes may vary depending on which version of NetworkManager/nmcli is installed on the host.
    /// An up-to-date list of supported attributes can be found here: U(https://networkmanager.dev/docs/api/latest/settings-802-11-wireless.html).
    /// For instance to create a hidden AP mode WiFi connection: V({hidden: true, mode: ap}).
    wifi: Any?
    /// The security configuration of the WiFi connection.
    /// Note the list of suboption attributes may vary depending on which version of NetworkManager/nmcli is installed on the host.
    /// An up-to-date list of supported attributes can be found here: U(https://networkmanager.dev/docs/api/latest/settings-802-11-wireless-security.html).
    /// For instance to use common WPA-PSK auth with a password: V({key-mgmt: wpa-psk, psk: my_password}).
    wifi_sec: Any?
    /// The configuration of the Wireguard connection.
    /// Note the list of suboption attributes may vary depending on which version of NetworkManager/nmcli is installed on the host.
    /// An up-to-date list of supported attributes can be found here: U(https://networkmanager.dev/docs/api/latest/settings-wireguard.html).
    /// For instance to configure a listen port: V({listen-port: 12345}).
    wireguard: Any?
    /// This is only used with bond - xmit_hash_policy type.
    xmit_hash_policy: String?
    /// The trust level of the connection.
    /// When updating this property on a currently activated connection, the change takes effect immediately.
    zone: String?
}

/// Task class for nmcli
class NmcliTask extends Playbook.Task {
    /// todo doc
    `community.general.nmcli`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.nmcli"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.nmcli`
}

/// TaskBuilder class for nmcli
class Nmcli extends Playbook.TaskBuilder {
    /// Options for community.general.nmcli
    options: NmcliOptions?
    /// todo doc
    function Task(): NmcliTask = this
        .toMap()
        .put("community.general.nmcli", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(NmcliTask)
}

/// Launch a Nomad Job
/// Launch a Nomad job.
/// Stop a Nomad job.
/// Force start a Nomad job
class NomadJobOptions {
    /// Content of Nomad job.
    /// Either this or O(name) must be specified.
    content: String?
    /// Type of content of Nomad job.
    content_format: ("hcl"|"json")?
    /// Force job to started.
    force_start: Boolean?
    /// Name of job for delete, stop and start job without source.
    /// Name of job for delete, stop and start job without source.
    /// Either this or O(content) must be specified.
    name: String?
    /// Deploy or remove job.
    state: ("present"|"absent")
}

/// Task class for nomad_job
class NomadJobTask extends Playbook.Task {
    /// todo doc
    `community.general.nomad_job`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.nomad_job"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.nomad_job`
}

/// TaskBuilder class for nomad_job
class NomadJob extends Playbook.TaskBuilder {
    /// Options for community.general.nomad_job
    options: NomadJobOptions?
    /// todo doc
    function Task(): NomadJobTask = this
        .toMap()
        .put("community.general.nomad_job", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(NomadJobTask)
}

/// Get Nomad Jobs info
/// Get info for one Nomad job.
/// List Nomad jobs.
class NomadJobInfoOptions {
    /// Name of job for Get info.
    /// If not specified, lists all jobs.
    name: String?
}

/// Task class for nomad_job_info
class NomadJobInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.nomad_job_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.nomad_job_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.nomad_job_info`
}

/// TaskBuilder class for nomad_job_info
class NomadJobInfo extends Playbook.TaskBuilder {
    /// Options for community.general.nomad_job_info
    options: NomadJobInfoOptions?
    /// todo doc
    function Task(): NomadJobInfoTask = this
        .toMap()
        .put("community.general.nomad_job_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(NomadJobInfoTask)
}

/// Manage Nomad ACL tokens
/// This module allows to create Bootstrap tokens, create ACL tokens, update ACL tokens, and delete ACL tokens.
class NomadTokenOptions {
    /// Indicates whether or not the token was created with the C(--global).
    global_replicated: Boolean?
    /// Name of ACL token to create.
    name: String?
    /// A list of the policies assigned to the token.
    policies: Listing<String>?
    /// Create or remove ACL token.
    state: ("present"|"absent")
    /// The type of the token can be V(client), V(management), or V(bootstrap).
    token_type: ("client"|"management"|"bootstrap")?
}

/// Task class for nomad_token
class NomadTokenTask extends Playbook.Task {
    /// todo doc
    `community.general.nomad_token`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.nomad_token"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.nomad_token`
}

/// TaskBuilder class for nomad_token
class NomadToken extends Playbook.TaskBuilder {
    /// Options for community.general.nomad_token
    options: NomadTokenOptions?
    /// todo doc
    function Task(): NomadTokenTask = this
        .toMap()
        .put("community.general.nomad_token", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(NomadTokenTask)
}

/// Manage services with nosh
/// Control running and enabled state for system-wide or user services.
/// BSD and Linux systems are supported.
class NoshOptions {
    /// Enable or disable the service, independently of C(*.preset) file preference or running state. Mutually exclusive with O(preset). Will take effect prior to O(state=reset).
    enabled: Boolean?
    /// Name of the service to manage.
    name: String
    /// Enable or disable the service according to local preferences in C(*.preset) files. Mutually exclusive with O(enabled). Only has an effect if set to true. Will take effect prior to O(state=reset).
    preset: Boolean?
    /// V(started)/V(stopped) are idempotent actions that will not run commands unless necessary. V(restarted) will always bounce the service. V(reloaded) will send a SIGHUP or start the service. V(reset) will start or stop the service according to whether it is enabled or not.
    state: ("started"|"stopped"|"reset"|"restarted"|"reloaded")?
    /// Run system-control talking to the calling user's service manager, rather than the system-wide service manager.
    user: Boolean?
}

/// Task class for nosh
class NoshTask extends Playbook.Task {
    /// todo doc
    `community.general.nosh`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.nosh"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.nosh`
}

/// TaskBuilder class for nosh
class Nosh extends Playbook.TaskBuilder {
    /// Options for community.general.nosh
    options: NoshOptions?
    /// todo doc
    function Task(): NoshTask = this
        .toMap()
        .put("community.general.nosh", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(NoshTask)
}

/// Manage node.js packages with npm
/// Manage node.js packages with Node Package Manager (npm).
class NpmOptions {
    /// Install packages based on package-lock file, same as running C(npm ci).
    ci: Boolean?
    /// The executable location for npm.
    /// This is useful if you are using a version manager, such as nvm.
    executable: String?
    /// Install the node.js library globally.
    global: Boolean?
    /// Use the C(--ignore-scripts) flag when installing.
    ignore_scripts: Boolean?
    /// The name of a node.js library to install.
    name: String?
    /// Use the C(--no-bin-links) flag when installing.
    no_bin_links: Boolean?
    /// Use the C(--no-optional) flag when installing.
    no_optional: Boolean?
    /// The base path where to install the node.js libraries.
    path: String?
    /// Install dependencies in production mode, excluding devDependencies.
    production: Boolean?
    /// The registry to install modules from.
    registry: String?
    /// The state of the node.js library.
    state: ("present"|"absent"|"latest")?
    /// Use the C(--unsafe-perm) flag when installing.
    unsafe_perm: Boolean?
    /// The version to be installed.
    version: String?
}

/// Task class for npm
class NpmTask extends Playbook.Task {
    /// todo doc
    `community.general.npm`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.npm"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.npm`
}

/// TaskBuilder class for npm
class Npm extends Playbook.TaskBuilder {
    /// Options for community.general.npm
    options: NpmOptions?
    /// todo doc
    function Task(): NpmTask = this
        .toMap()
        .put("community.general.npm", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(NpmTask)
}

/// Manage DNS records
/// Create, update and remove DNS records using DDNS updates
class NsupdateOptions {
    /// Specify key algorithm used by O(key_secret).
    key_algorithm: ("HMAC-MD5.SIG-ALG.REG.INT"|"hmac-md5"|"hmac-sha1"|"hmac-sha224"|"hmac-sha256"|"hmac-sha384"|"hmac-sha512")?
    /// Use TSIG key name to authenticate against DNS O(server)
    key_name: String?
    /// Use TSIG key secret, associated with O(key_name), to authenticate against O(server)
    key_secret: String?
    /// Use this TCP port when connecting to O(server).
    port: Int?
    /// Sets the transport protocol (TCP or UDP). TCP is the recommended and a more robust option.
    protocol: ("tcp"|"udp")?
    /// Sets the DNS record to modify. When zone is omitted this has to be absolute (ending with a dot).
    `record`: String
    /// Apply DNS modification on this server, specified by IPv4 or IPv6 address.
    server: String
    /// Manage DNS record.
    state: ("present"|"absent")?
    /// Sets the record TTL.
    ttl: Int?
    /// Sets the record type.
    type: String?
    /// Sets the record value.
    value: Listing<String>?
    /// DNS record will be modified on this O(zone).
    /// When omitted DNS will be queried to attempt finding the correct zone.
    zone: String?
}

/// Task class for nsupdate
class NsupdateTask extends Playbook.Task {
    /// todo doc
    `community.general.nsupdate`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.nsupdate"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.nsupdate`
}

/// TaskBuilder class for nsupdate
class Nsupdate extends Playbook.TaskBuilder {
    /// Options for community.general.nsupdate
    options: NsupdateOptions?
    /// todo doc
    function Task(): NsupdateTask = this
        .toMap()
        .put("community.general.nsupdate", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(NsupdateTask)
}

/// Manages Out-Of-Band controllers using Open Composable API (OCAPI)
/// Builds OCAPI URIs locally and sends them to remote OOB controllers to perform an action.
/// Manages OOB controller such as Indicator LED, Reboot, Power Mode, Firmware Update.
class OcapiCommandOptions {
    /// Base URI of OOB controller.
    baseuri: String
    /// Category to execute on OOB controller.
    category: String
    /// Command to execute on OOB controller.
    command: String
    /// For O(command=DeleteJob) command, the name of the job to delete.
    job_name: String?
    /// Password for authenticating to OOB controller.
    password: String
    /// For proxied inband requests, the slot number of the IOM.  Only applies if O(baseuri) is a proxy server.
    proxy_slot_number: Int?
    /// Timeout in seconds for URL requests to OOB controller.
    timeout: Int?
    /// For O(command=FWUpload), the path on the local filesystem of the firmware update image.
    update_image_path: String?
    /// Username for authenticating to OOB controller.
    username: String
}

/// Task class for ocapi_command
class OcapiCommandTask extends Playbook.Task {
    /// todo doc
    `community.general.ocapi_command`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ocapi_command"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ocapi_command`
}

/// TaskBuilder class for ocapi_command
class OcapiCommand extends Playbook.TaskBuilder {
    /// Options for community.general.ocapi_command
    options: OcapiCommandOptions?
    /// todo doc
    function Task(): OcapiCommandTask = this
        .toMap()
        .put("community.general.ocapi_command", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OcapiCommandTask)
}

/// Manages Out-Of-Band controllers using Open Composable API (OCAPI)
/// Builds OCAPI URIs locally and sends them to remote OOB controllers to get information back.
class OcapiInfoOptions {
    /// Base URI of OOB controller.
    baseuri: String
    /// Category to execute on OOB controller.
    category: String
    /// Command to execute on OOB controller.
    command: String
    /// Name of job for fetching status.
    job_name: String?
    /// Password for authenticating to OOB controller.
    password: String
    /// For proxied inband requests, the slot number of the IOM.  Only applies if O(baseuri) is a proxy server.
    proxy_slot_number: Int?
    /// Timeout in seconds for URL requests to OOB controller.
    timeout: Int?
    /// Username for authenticating to OOB controller.
    username: String
}

/// Task class for ocapi_info
class OcapiInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.ocapi_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ocapi_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ocapi_info`
}

/// TaskBuilder class for ocapi_info
class OcapiInfo extends Playbook.TaskBuilder {
    /// Options for community.general.ocapi_info
    options: OcapiInfoOptions?
    /// todo doc
    function Task(): OcapiInfoTask = this
        .toMap()
        .put("community.general.ocapi_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OcapiInfoTask)
}

/// Manage Virtual Cloud Networks(VCN) in OCI
/// This module allows the user to create, delete and update virtual cloud networks(VCNs) in OCI. The complete Oracle Cloud Infrastructure Ansible Modules can be downloaded from U(https://github.com/oracle/oci-ansible-modules/releases).
class OciVcnOptions {
    /// The CIDR IP address block of the VCN. Required when creating a VCN with O(state=present).
    cidr_block: String?
    /// The OCID of the compartment to contain the VCN. Required when creating a VCN with O(state=present). This option is mutually exclusive with O(vcn_id).
    compartment_id: String?
    /// A user-friendly name. Does not have to be unique, and it's changeable.
    display_name: String?
    /// A DNS label for the VCN, used in conjunction with the VNIC's hostname and subnet's DNS label to form a fully qualified domain name (FQDN) for each VNIC within this subnet (for example, bminstance-1.subnet123.vcn1.oraclevcn.com). Not required to be unique, but it's a best practice to set unique DNS labels for VCNs in your tenancy. Must be an alphanumeric string that begins with a letter. The value cannot be changed.
    dns_label: String?
    /// Create or update a VCN with O(state=present). Use O(state=absent) to delete a VCN.
    state: ("present"|"absent")?
    /// The OCID of the VCN. Required when deleting a VCN with O(state=absent) or updating a VCN with O(state=present). This option is mutually exclusive with O(compartment_id).
    vcn_id: String?
}

/// Task class for oci_vcn
class OciVcnTask extends Playbook.Task {
    /// todo doc
    `community.general.oci_vcn`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.oci_vcn"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.oci_vcn`
}

/// TaskBuilder class for oci_vcn
class OciVcn extends Playbook.TaskBuilder {
    /// Options for community.general.oci_vcn
    options: OciVcnOptions?
    /// todo doc
    function Task(): OciVcnTask = this
        .toMap()
        .put("community.general.oci_vcn", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OciVcnTask)
}

/// Execute SQL via ODBC
/// Read/Write info via ODBC drivers.
class OdbcOptions {
    /// Perform a commit after the execution of the SQL query.
    /// Some databases allow a commit after a select whereas others raise an exception.
    /// Default is V(true) to support legacy module behavior.
    commit: Boolean?
    /// The connection string passed into ODBC.
    dsn: String
    /// Parameters to pass to the SQL query.
    params: Listing<String>?
    /// The SQL query to perform.
    query: String
}

/// Task class for odbc
class OdbcTask extends Playbook.Task {
    /// todo doc
    `community.general.odbc`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.odbc"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.odbc`
}

/// TaskBuilder class for odbc
class Odbc extends Playbook.TaskBuilder {
    /// Options for community.general.odbc
    options: OdbcOptions?
    /// todo doc
    function Task(): OdbcTask = this
        .toMap()
        .put("community.general.odbc", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OdbcTask)
}

/// Use webhooks to create Connector Card messages within an Office 365 group
/// Creates Connector Card messages through Office 365 Connectors U(https://learn.microsoft.com/en-us/microsoftteams/platform/task-modules-and-cards/cards/cards-reference#connector-card-for-microsoft-365-groups).
class Office365ConnectorCardOptions {
    /// This array of objects will power the action links
    /// found at the bottom of the card.
    actions: Listing<Any>?
    /// Accent color used for branding or indicating status in the card.
    color: String?
    /// Contains a list of sections to display in the card.
    /// For more information see U(https://learn.microsoft.com/en-us/outlook/actionable-messages/message-card-reference#section-fields).
    sections: Listing<Any>?
    /// A string used for summarizing card content.
    /// This will be shown as the message subject.
    /// This is required if the text parameter isn't populated.
    summary: String?
    /// The main text of the card.
    /// This will be rendered below the sender information and optional title,
    /// and above any sections or actions present.
    text: String?
    /// A title for the Connector message. Shown at the top of the message.
    title: String?
    /// The webhook URL is given to you when you create a new Connector.
    webhook: String
}

/// Task class for office_365_connector_card
class Office365ConnectorCardTask extends Playbook.Task {
    /// todo doc
    `community.general.office_365_connector_card`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.office_365_connector_card"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.office_365_connector_card`
}

/// TaskBuilder class for office_365_connector_card
class Office365ConnectorCard extends Playbook.TaskBuilder {
    /// Options for community.general.office_365_connector_card
    options: Office365ConnectorCardOptions?
    /// todo doc
    function Task(): Office365ConnectorCardTask = this
        .toMap()
        .put("community.general.office_365_connector_card", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(Office365ConnectorCardTask)
}

/// Returns inventory data from I(Ohai)
/// Similar to the M(community.general.facter) module, this runs the I(Ohai) discovery program (U(https://docs.chef.io/ohai.html)) on the remote host and returns JSON inventory data. I(Ohai) data is a bit more verbose and nested than I(facter).
class OhaiOptions {
}

/// Task class for ohai
class OhaiTask extends Playbook.Task {
    /// todo doc
    `community.general.ohai`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ohai"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ohai`
}

/// TaskBuilder class for ohai
class Ohai extends Playbook.TaskBuilder {
    /// Options for community.general.ohai
    options: OhaiOptions?
    /// todo doc
    function Task(): OhaiTask = this
        .toMap()
        .put("community.general.ohai", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OhaiTask)
}

/// Setup OMAPI hosts
/// Manage OMAPI hosts into compatible DHCPd servers
class OmapiHostOptions {
    /// Enable dynamic DNS updates for this host.
    ddns: Boolean?
    /// Sets OMAPI server host to interact with.
    host: String?
    /// Sets the host lease hostname (mandatory if state=present).
    hostname: String?
    /// Sets the lease host IP address.
    ip: String?
    /// Sets the TSIG key content for authenticating against OMAPI server.
    key: String
    /// Sets the TSIG key name for authenticating against OMAPI server.
    key_name: String
    /// Sets the lease host MAC address.
    macaddr: String
    /// Sets the OMAPI server port to interact with.
    port: Int?
    /// Create or remove OMAPI host.
    state: ("absent"|"present")
    /// Attach a list of OMAPI DHCP statements with host lease (without ending semicolon).
    statements: Listing<String>?
}

/// Task class for omapi_host
class OmapiHostTask extends Playbook.Task {
    /// todo doc
    `community.general.omapi_host`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.omapi_host"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.omapi_host`
}

/// TaskBuilder class for omapi_host
class OmapiHost extends Playbook.TaskBuilder {
    /// Options for community.general.omapi_host
    options: OmapiHostOptions?
    /// todo doc
    function Task(): OmapiHostTask = this
        .toMap()
        .put("community.general.omapi_host", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OmapiHostTask)
}

/// Manages OpenNebula Hosts
/// Manages OpenNebula Hosts
class OneHostOptions {
    /// The cluster ID.
    cluster_id: Int?
    /// The cluster specified by name.
    cluster_name: String?
    /// The name of the information manager, this values are taken from the oned.conf with the tag name IM_MAD (name)
    im_mad_name: String?
    /// The labels for this host.
    labels: Listing<String>?
    /// Hostname of the machine to manage.
    name: String
    /// Takes the host to the desired lifecycle state.
    /// If V(absent) the host will be deleted from the cluster.
    /// If V(present) the host will be created in the cluster (includes V(enabled), V(disabled) and V(offline) states).
    /// If V(enabled) the host is fully operational.
    /// V(disabled), e.g. to perform maintenance operations.
    /// V(offline), host is totally offline.
    state: ("absent"|"present"|"enabled"|"disabled"|"offline")?
    /// The template or attribute changes to merge into the host template.
    template: Any?
    /// The name of the virtual machine manager mad name, this values are taken from the oned.conf with the tag name VM_MAD (name)
    vmm_mad_name: String?
}

/// Task class for one_host
class OneHostTask extends Playbook.Task {
    /// todo doc
    `community.general.one_host`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.one_host"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.one_host`
}

/// TaskBuilder class for one_host
class OneHost extends Playbook.TaskBuilder {
    /// Options for community.general.one_host
    options: OneHostOptions?
    /// todo doc
    function Task(): OneHostTask = this
        .toMap()
        .put("community.general.one_host", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OneHostTask)
}

/// Manages OpenNebula images
/// Manages OpenNebula images
class OneImageOptions {
    /// Password of the user to login into OpenNebula RPC server. If not set
    /// then the value of the E(ONE_PASSWORD) environment variable is used.
    api_password: String?
    /// URL of the OpenNebula RPC server.
    /// It is recommended to use HTTPS so that the username/password are not
    /// transferred over the network unencrypted.
    /// If not set then the value of the E(ONE_URL) environment variable is used.
    api_url: String?
    /// Name of the user to login into the OpenNebula RPC server. If not set
    /// then the value of the E(ONE_USERNAME) environment variable is used.
    api_username: String?
    /// Whether the image should be enabled or disabled.
    enabled: Boolean?
    /// A O(id) of the image you would like to manage.
    id: Int?
    /// A O(name) of the image you would like to manage.
    name: String?
    /// A name that will be assigned to the existing or new image.
    /// In the case of cloning, by default O(new_name) will take the name of the origin image with the prefix 'Copy of'.
    new_name: String?
    /// V(present) - state that is used to manage the image
    /// V(absent) - delete the image
    /// V(cloned) - clone the image
    /// V(renamed) - rename the image to the O(new_name)
    state: ("present"|"absent"|"cloned"|"renamed")?
}

/// Task class for one_image
class OneImageTask extends Playbook.Task {
    /// todo doc
    `community.general.one_image`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.one_image"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.one_image`
}

/// TaskBuilder class for one_image
class OneImage extends Playbook.TaskBuilder {
    /// Options for community.general.one_image
    options: OneImageOptions?
    /// todo doc
    function Task(): OneImageTask = this
        .toMap()
        .put("community.general.one_image", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OneImageTask)
}

/// Gather information on OpenNebula images
/// Gather information on OpenNebula images.
class OneImageInfoOptions {
    /// Password of the user to login into OpenNebula RPC server. If not set
    /// then the value of the E(ONE_PASSWORD) environment variable is used.
    api_password: String?
    /// URL of the OpenNebula RPC server.
    /// It is recommended to use HTTPS so that the username/password are not
    /// transferred over the network unencrypted.
    /// If not set then the value of the E(ONE_URL) environment variable is used.
    api_url: String?
    /// Name of the user to login into the OpenNebula RPC server. If not set
    /// then the value of the E(ONE_USERNAME) environment variable is used.
    api_username: String?
    /// A list of images ids whose facts you want to gather.
    ids: Listing<String>?
    /// A O(name) of the image whose facts will be gathered.
    /// If the O(name) begins with V(~) the O(name) will be used as regex pattern
    /// which restricts the list of images (whose facts will be returned) whose names match specified regex.
    /// Also, if the O(name) begins with V(~*) case-insensitive matching will be performed.
    /// See examples for more details.
    name: String?
}

/// Task class for one_image_info
class OneImageInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.one_image_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.one_image_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.one_image_info`
}

/// TaskBuilder class for one_image_info
class OneImageInfo extends Playbook.TaskBuilder {
    /// Options for community.general.one_image_info
    options: OneImageInfoOptions?
    /// todo doc
    function Task(): OneImageInfoTask = this
        .toMap()
        .put("community.general.one_image_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OneImageInfoTask)
}

/// Deploy and manage OpenNebula services
/// Manage OpenNebula services
class OneServiceOptions {
    /// Password of the user to login into OpenNebula OneFlow API server. If not set then the value of the E(ONEFLOW_PASSWORD) environment variable is used.
    api_password: String?
    /// URL of the OpenNebula OneFlow API server.
    /// It is recommended to use HTTPS so that the username/password are not transferred over the network unencrypted.
    /// If not set then the value of the E(ONEFLOW_URL) environment variable is used.
    api_url: String?
    /// Name of the user to login into the OpenNebula OneFlow API server. If not set then the value of the E(ONEFLOW_USERNAME) environment variable is used.
    api_username: String?
    /// Number of VMs for the specified role.
    cardinality: Int?
    /// Dictionary of key/value custom attributes which will be used when instantiating a new service.
    custom_attrs: Any?
    /// Force the new cardinality even if it is outside the limits.
    force: Boolean?
    /// ID of the group which will be set as the group of the service.
    group_id: Int?
    /// Set permission mode of a service instance in octet format, for example V(0600) to give owner C(use) and C(manage) and nothing to group and others.
    mode: String?
    /// ID of the user which will be set as the owner of the service.
    owner_id: Int?
    /// Name of the role whose cardinality should be changed.
    role: String?
    /// ID of a service instance that you would like to manage.
    service_id: Int?
    /// Name of a service instance that you would like to manage.
    service_name: String?
    /// V(present) - instantiate a service from a template specified with O(template_id) or O(template_name).
    /// V(absent) - terminate an instance of a service specified with O(template_id) or O(template_name).
    state: ("present"|"absent")?
    /// ID of a service template to use to create a new instance of a service.
    template_id: Int?
    /// Name of service template to use to create a new instance of a service.
    template_name: String?
    /// Setting O(unique=true) will make sure that there is only one service instance running with a name set with O(service_name) when instantiating a service from a template specified with O(template_id) or O(template_name). Check examples below.
    unique: Boolean?
    /// Wait for the instance to reach RUNNING state after DEPLOYING or COOLDOWN state after SCALING.
    wait: Boolean?
    /// How long before wait gives up, in seconds.
    wait_timeout: Int?
}

/// Task class for one_service
class OneServiceTask extends Playbook.Task {
    /// todo doc
    `community.general.one_service`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.one_service"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.one_service`
}

/// TaskBuilder class for one_service
class OneService extends Playbook.TaskBuilder {
    /// Options for community.general.one_service
    options: OneServiceOptions?
    /// todo doc
    function Task(): OneServiceTask = this
        .toMap()
        .put("community.general.one_service", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OneServiceTask)
}

/// Manages OpenNebula templates
/// Manages OpenNebula templates.
class OneTemplateOptions {
    /// A O(id) of the template you would like to manage.  If not set then a
    /// new template will be created with the given O(name).
    id: Int?
    /// A O(name) of the template you would like to manage.  If a template with
    /// the given name does not exist it will be created, otherwise it will be
    /// managed by this module.
    name: String?
    /// V(present) - state that is used to manage the template.
    /// V(absent) - delete the template.
    state: ("present"|"absent")?
    /// A string containing the template contents.
    template: String?
}

/// Task class for one_template
class OneTemplateTask extends Playbook.Task {
    /// todo doc
    `community.general.one_template`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.one_template"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.one_template`
}

/// TaskBuilder class for one_template
class OneTemplate extends Playbook.TaskBuilder {
    /// Options for community.general.one_template
    options: OneTemplateOptions?
    /// todo doc
    function Task(): OneTemplateTask = this
        .toMap()
        .put("community.general.one_template", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OneTemplateTask)
}

/// Creates or terminates OpenNebula instances
/// Manages OpenNebula instances
class OneVmOptions {
    /// Password of the user to login into OpenNebula RPC server. If not set then the value of the E(ONE_PASSWORD) environment variable is used. if both O(api_username) or O(api_password) are not set, then it will try authenticate with ONE auth file. Default path is "~/.one/one_auth".
    /// Set environment variable E(ONE_AUTH) to override this path.
    api_password: String?
    /// URL of the OpenNebula RPC server.
    /// It is recommended to use HTTPS so that the username/password are not transferred over the network unencrypted.
    /// If not set then the value of the E(ONE_URL) environment variable is used.
    api_url: String?
    /// Name of the user to login into the OpenNebula RPC server. If not set then the value of the E(ONE_USERNAME) environment variable is used.
    api_username: String?
    /// A dictionary of key/value attributes to add to new instances, or for setting C(state) of instances with these attributes.
    /// Keys are case insensitive and OpenNebula automatically converts them to upper case.
    /// Be aware C(NAME) is a special attribute which sets the name of the VM when it's deployed.
    /// C(#) character(s) can be appended to the C(NAME) and the module will automatically add indexes to the names of VMs.
    /// For example':' C(NAME':' foo-###) would create VMs with names C(foo-000), C(foo-001),...
    /// When used with O(count_attributes) and O(exact_count) the module will match the base name without the index part.
    attributes: Any?
    /// Number of instances to launch
    count: Int?
    /// A dictionary of key/value attributes that can only be used with O(exact_count) to determine how many nodes based on a specific attributes criteria should be deployed. This can be expressed in multiple ways and is shown in the EXAMPLES section.
    count_attributes: Any?
    /// A list of labels that can only be used with O(exact_count) to determine how many nodes based on a specific labels criteria should be deployed. This can be expressed in multiple ways and is shown in the EXAMPLES section.
    count_labels: Listing<String>?
    /// Percentage of CPU divided by 100 required for the new instance. Half a processor is written 0.5.
    cpu: Any?
    /// Name of Datastore to use to create a new instance
    datastore_id: Int?
    /// Name of Datastore to use to create a new instance
    datastore_name: String?
    /// Creates an image from a VM disk.
    /// It is a dictionary where you have to specify C(name) of the new image.
    /// Optionally you can specify C(disk_id) of the disk you want to save. By default C(disk_id) is 0.
    /// B(NOTE:) This operation will only be performed on the first VM (if more than one VM ID is passed) and the VM has to be in the C(poweredoff) state.
    /// Also this operation will fail if an image with specified C(name) already exists.
    disk_saveas: Any?
    /// The size of the disk created for new instances (in MB, GB, TB,...).
    /// B(NOTE:) If The Template hats Multiple Disks the Order of the Sizes is matched against the order specified in O(template_id)/O(template_name).
    disk_size: Listing<String>?
    /// Indicates how many instances that match O(count_attributes) and O(count_labels) parameters should be deployed. Instances are either created or terminated based on this value.
    /// B(NOTE:) Instances with the least IDs will be terminated first.
    exact_count: Int?
    /// ID of the group which will be set as the group of the instance
    group_id: Int?
    /// Reboot, power-off or terminate instances C(hard).
    hard: Boolean?
    /// A list of instance ids used for states: V(absent), V(running), V(rebooted), V(poweredoff).
    instance_ids: Listing<Int>?
    /// A list of labels to associate with new instances, or for setting C(state) of instances with these labels.
    labels: Listing<String>?
    /// The size of the memory for new instances (in MB, GB, ...)
    memory: String?
    /// Set permission mode of the instance in octet format, for example V(0600) to give owner C(use) and C(manage) and nothing to group and others.
    mode: String?
    /// A list of dictionaries with network parameters. See examples for more details.
    networks: Listing<Any>?
    /// ID of the user which will be set as the owner of the instance
    owner_id: Int?
    /// Create a private persistent copy of the template plus any image defined in DISK, and instantiate that copy.
    persistent: Boolean?
    /// V(present) - create instances from a template specified with C(template_id)/C(template_name).
    /// V(running) - run instances
    /// V(poweredoff) - power-off instances
    /// V(rebooted) - reboot instances
    /// V(absent) - terminate instances
    state: ("present"|"absent"|"running"|"rebooted"|"poweredoff")?
    /// ID of a VM template to use to create a new instance
    template_id: Int?
    /// Name of VM template to use to create a new instance
    template_name: String?
    /// When O(instance_ids) is provided, updates running VMs with the C(updateconf) API call.
    /// When new VMs are being created, emulates the C(updateconf) API call via direct template merge.
    /// Allows for complete modifications of the C(CONTEXT) attribute.
    updateconf: Any?
    /// Number of CPUs (cores) new VM will have.
    vcpu: Int?
    /// Set to true to put vm on hold while creating
    vm_start_on_hold: Boolean?
    /// Wait for the instance to reach its desired state before returning. Keep in mind if you are waiting for instance to be in running state it doesn't mean that you will be able to SSH on that machine only that boot process have started on that instance, see 'wait_for' example for details.
    wait: Boolean?
    /// How long before wait gives up, in seconds
    wait_timeout: Int?
}

/// Task class for one_vm
class OneVmTask extends Playbook.Task {
    /// todo doc
    `community.general.one_vm`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.one_vm"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.one_vm`
}

/// TaskBuilder class for one_vm
class OneVm extends Playbook.TaskBuilder {
    /// Options for community.general.one_vm
    options: OneVmOptions?
    /// todo doc
    function Task(): OneVmTask = this
        .toMap()
        .put("community.general.one_vm", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OneVmTask)
}

/// Configure 1&1 firewall policy
/// Create, remove, reconfigure, update firewall policies. This module has a dependency on 1and1 >= 1.0.
class OneandoneFirewallPolicyOptions {
    /// A list of rules that will be added to an existing firewall policy. It is syntax is the same as the one used for rules parameter. Used in combination with update state.
    add_rules: Listing<Any>?
    /// A list of server identifiers (id or name) to be assigned to a firewall policy. Used in combination with update state.
    add_server_ips: Listing<String>?
    /// Custom API URL. Overrides the ONEANDONE_API_URL environment variable.
    api_url: String?
    /// Authenticating API token provided by 1&1.
    auth_token: String?
    /// Firewall policy description. maxLength=256
    description: String?
    /// The identifier (id or name) of the firewall policy used with update state.
    firewall_policy: String?
    /// Firewall policy name used with present state. Used as identifier (id or name) when used with absent state. maxLength=128
    name: String?
    /// A list of rule ids that will be removed from an existing firewall policy. Used in combination with update state.
    remove_rules: Listing<String>?
    /// A list of server IP ids to be unassigned from a firewall policy. Used in combination with update state.
    remove_server_ips: Listing<String>?
    /// A list of rules that will be set for the firewall policy. Each rule must contain protocol parameter, in addition to three optional parameters (port_from, port_to, and source)
    rules: Listing<Any>?
    /// Define a firewall policy state to create, remove, or update.
    state: ("present"|"absent"|"update")?
    /// wait for the instance to be in state 'running' before returning
    wait: Boolean?
    /// Defines the number of seconds to wait when using the _wait_for methods
    wait_interval: Int?
    /// how long before wait gives up, in seconds
    wait_timeout: Int?
}

/// Task class for oneandone_firewall_policy
class OneandoneFirewallPolicyTask extends Playbook.Task {
    /// todo doc
    `community.general.oneandone_firewall_policy`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.oneandone_firewall_policy"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.oneandone_firewall_policy`
}

/// TaskBuilder class for oneandone_firewall_policy
class OneandoneFirewallPolicy extends Playbook.TaskBuilder {
    /// Options for community.general.oneandone_firewall_policy
    options: OneandoneFirewallPolicyOptions?
    /// todo doc
    function Task(): OneandoneFirewallPolicyTask = this
        .toMap()
        .put("community.general.oneandone_firewall_policy", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OneandoneFirewallPolicyTask)
}

/// Configure 1&1 load balancer
/// Create, remove, update load balancers. This module has a dependency on 1and1 >= 1.0.
class OneandoneLoadBalancerOptions {
    /// A list of rules that will be added to an existing load balancer. It is syntax is the same as the one used for rules parameter. Used in combination with update state.
    add_rules: Listing<Any>?
    /// A list of server identifiers (id or name) to be assigned to a load balancer. Used in combination with update state.
    add_server_ips: Listing<String>?
    /// Custom API URL. Overrides the E(ONEANDONE_API_URL) environment variable.
    api_url: String?
    /// Authenticating API token provided by 1&1.
    auth_token: String?
    /// ID or country code of the datacenter where the load balancer will be created.
    /// If not specified, it defaults to V(US).
    datacenter: ("US"|"ES"|"DE"|"GB")?
    /// Description of the load balancer. maxLength=256
    description: String?
    /// Health check period in seconds. minimum=5, maximum=300, multipleOf=1
    health_check_interval: String?
    /// Regular expression to check. Required for HTTP health check. maxLength=64
    health_check_parse: String?
    /// Url to call for checking. Required for HTTP health check. maxLength=1000
    health_check_path: String?
    /// Type of the health check. At the moment, HTTP is not allowed.
    health_check_test: ("NONE"|"TCP"|"HTTP"|"ICMP")?
    /// The identifier (id or name) of the load balancer used with update state.
    load_balancer: String?
    /// Balancing procedure.
    method: ("ROUND_ROBIN"|"LEAST_CONNECTIONS")?
    /// Load balancer name used with present state. Used as identifier (id or name) when used with absent state. maxLength=128
    name: String?
    /// Persistence.
    persistence: Boolean?
    /// Persistence time in seconds. Required if persistence is enabled. minimum=30, maximum=1200, multipleOf=1
    persistence_time: String?
    /// A list of rule ids that will be removed from an existing load balancer. Used in combination with update state.
    remove_rules: Listing<String>?
    /// A list of server IP ids to be unassigned from a load balancer. Used in combination with update state.
    remove_server_ips: Listing<String>?
    /// A list of rule objects that will be set for the load balancer. Each rule must contain protocol, port_balancer, and port_server parameters, in addition to source parameter, which is optional.
    rules: Listing<Any>?
    /// Define a load balancer state to create, remove, or update.
    state: ("present"|"absent"|"update")?
    /// wait for the instance to be in state 'running' before returning
    wait: Boolean?
    /// Defines the number of seconds to wait when using the _wait_for methods
    wait_interval: Int?
    /// how long before wait gives up, in seconds
    wait_timeout: Int?
}

/// Task class for oneandone_load_balancer
class OneandoneLoadBalancerTask extends Playbook.Task {
    /// todo doc
    `community.general.oneandone_load_balancer`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.oneandone_load_balancer"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.oneandone_load_balancer`
}

/// TaskBuilder class for oneandone_load_balancer
class OneandoneLoadBalancer extends Playbook.TaskBuilder {
    /// Options for community.general.oneandone_load_balancer
    options: OneandoneLoadBalancerOptions?
    /// todo doc
    function Task(): OneandoneLoadBalancerTask = this
        .toMap()
        .put("community.general.oneandone_load_balancer", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OneandoneLoadBalancerTask)
}

/// Configure 1&1 monitoring policy
/// Create, remove, update monitoring policies (and add/remove ports, processes, and servers). This module has a dependency on 1and1 >= 1.0.
class OneandoneMonitoringPolicyOptions {
    /// Ports to add to the monitoring policy.
    add_ports: Listing<Any>?
    /// Processes to add to the monitoring policy.
    add_processes: Listing<Any>?
    /// Servers to add to the monitoring policy.
    add_servers: Listing<String>?
    /// Set true for using agent.
    agent: String?
    /// Custom API URL. Overrides the ONEANDONE_API_URL environment variable.
    api_url: String?
    /// Authenticating API token provided by 1&1.
    auth_token: String?
    /// Monitoring policy description. maxLength=256
    description: String?
    /// User's email. maxLength=128
    email: String?
    /// The identifier (id or name) of the monitoring policy used with update state.
    monitoring_policy: String?
    /// Monitoring policy name used with present state. Used as identifier (id or name) when used with absent state. maxLength=128
    name: String?
    /// Array of ports that will be monitoring.
    ports: Listing<Any>?
    /// Array of processes that will be monitoring.
    processes: Listing<Any>?
    /// Ports to remove from the monitoring policy.
    remove_ports: Listing<String>?
    /// Processes to remove from the monitoring policy.
    remove_processes: Listing<String>?
    /// Servers to remove from the monitoring policy.
    remove_servers: Listing<String>?
    /// Define a monitoring policy's state to create, remove, update.
    state: ("present"|"absent"|"update")?
    /// Monitoring policy thresholds. Each of the suboptions have warning and critical, which both have alert and value suboptions. Warning is used to set limits for warning alerts, critical is used to set critical alerts. alert enables alert, and value is used to advise when the value is exceeded.
    thresholds: Listing<Any>?
    /// Ports to be updated on the monitoring policy.
    update_ports: Listing<Any>?
    /// Processes to be updated on the monitoring policy.
    update_processes: Listing<Any>?
    /// wait for the instance to be in state 'running' before returning
    wait: Boolean?
    /// Defines the number of seconds to wait when using the _wait_for methods
    wait_interval: Int?
    /// how long before wait gives up, in seconds
    wait_timeout: Int?
}

/// Task class for oneandone_monitoring_policy
class OneandoneMonitoringPolicyTask extends Playbook.Task {
    /// todo doc
    `community.general.oneandone_monitoring_policy`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.oneandone_monitoring_policy"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.oneandone_monitoring_policy`
}

/// TaskBuilder class for oneandone_monitoring_policy
class OneandoneMonitoringPolicy extends Playbook.TaskBuilder {
    /// Options for community.general.oneandone_monitoring_policy
    options: OneandoneMonitoringPolicyOptions?
    /// todo doc
    function Task(): OneandoneMonitoringPolicyTask = this
        .toMap()
        .put("community.general.oneandone_monitoring_policy", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OneandoneMonitoringPolicyTask)
}

/// Configure 1&1 private networking
/// Create, remove, reconfigure, update a private network. This module has a dependency on 1and1 >= 1.0.
class OneandonePrivateNetworkOptions {
    /// List of server identifiers (name or id) to be added to the private network.
    add_members: Listing<String>?
    /// Custom API URL. Overrides the ONEANDONE_API_URL environment variable.
    api_url: String?
    /// Authenticating API token provided by 1&1.
    auth_token: String?
    /// The identifier of the datacenter where the private network will be created
    datacenter: ("US"|"ES"|"DE"|"GB")?
    /// Set a description for the network.
    description: String?
    /// Private network name used with present state. Used as identifier (id or name) when used with absent state.
    name: String?
    /// Set a private network space, i.e. 192.168.1.0
    network_address: String?
    /// The identifier (id or name) of the network used with update state.
    private_network: String?
    /// List of server identifiers (name or id) to be removed from the private network.
    remove_members: Listing<String>?
    /// Define a network's state to create, remove, or update.
    state: ("present"|"absent"|"update")?
    /// Set the netmask for the private network, i.e. 255.255.255.0
    subnet_mask: String?
    /// wait for the instance to be in state 'running' before returning
    wait: Boolean?
    /// Defines the number of seconds to wait when using the _wait_for methods
    wait_interval: Int?
    /// how long before wait gives up, in seconds
    wait_timeout: Int?
}

/// Task class for oneandone_private_network
class OneandonePrivateNetworkTask extends Playbook.Task {
    /// todo doc
    `community.general.oneandone_private_network`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.oneandone_private_network"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.oneandone_private_network`
}

/// TaskBuilder class for oneandone_private_network
class OneandonePrivateNetwork extends Playbook.TaskBuilder {
    /// Options for community.general.oneandone_private_network
    options: OneandonePrivateNetworkOptions?
    /// todo doc
    function Task(): OneandonePrivateNetworkTask = this
        .toMap()
        .put("community.general.oneandone_private_network", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OneandonePrivateNetworkTask)
}

/// Configure 1&1 public IPs
/// Create, update, and remove public IPs. This module has a dependency on 1and1 >= 1.0.
class OneandonePublicIpOptions {
    /// Custom API URL. Overrides the ONEANDONE_API_URL environment variable.
    api_url: String?
    /// Authenticating API token provided by 1&1.
    auth_token: String?
    /// ID of the datacenter where the IP will be created (only for unassigned IPs).
    datacenter: ("US"|"ES"|"DE"|"GB")?
    /// The ID of the public IP used with update and delete states.
    public_ip_id: String?
    /// Reverse DNS name. maxLength=256
    reverse_dns: String?
    /// Define a public ip state to create, remove, or update.
    state: ("present"|"absent"|"update")?
    /// Type of IP. Currently, only IPV4 is available.
    type: ("IPV4"|"IPV6")?
    /// wait for the instance to be in state 'running' before returning
    wait: Boolean?
    /// Defines the number of seconds to wait when using the _wait_for methods
    wait_interval: Int?
    /// how long before wait gives up, in seconds
    wait_timeout: Int?
}

/// Task class for oneandone_public_ip
class OneandonePublicIpTask extends Playbook.Task {
    /// todo doc
    `community.general.oneandone_public_ip`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.oneandone_public_ip"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.oneandone_public_ip`
}

/// TaskBuilder class for oneandone_public_ip
class OneandonePublicIp extends Playbook.TaskBuilder {
    /// Options for community.general.oneandone_public_ip
    options: OneandonePublicIpOptions?
    /// todo doc
    function Task(): OneandonePublicIpTask = this
        .toMap()
        .put("community.general.oneandone_public_ip", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OneandonePublicIpTask)
}

/// Create, destroy, start, stop, and reboot a 1&1 Host server
/// Create, destroy, update, start, stop, and reboot a 1&1 Host server. When the server is created it can optionally wait for it to be 'running' before returning.
class OneandoneServerOptions {
    /// Custom API URL. Overrides the ONEANDONE_API_URL environment variable.
    api_url: String?
    /// The operating system name or ID for the server. It is required only for 'present' state.
    appliance: String?
    /// Authenticating API token provided by 1&1. Overrides the ONEANDONE_AUTH_TOKEN environment variable.
    auth_token: String?
    /// When creating multiple servers at once, whether to differentiate hostnames by appending a count after them or substituting the count where there is a %02d or %03d in the hostname string.
    auto_increment: Boolean?
    /// The number of cores per processor. It must be provided with vcore, ram, and hdds parameters.
    cores_per_processor: Int?
    /// The number of servers to create.
    count: Int?
    /// The datacenter location.
    datacenter: ("US"|"ES"|"DE"|"GB")?
    /// The description of the server.
    description: String?
    /// The firewall policy name or ID.
    firewall_policy: String?
    /// The instance size name or ID of the server. It is required only for 'present' state, and it is mutually exclusive with vcore, cores_per_processor, ram, and hdds parameters.
    /// The available choices are: V(S), V(M), V(L), V(XL), V(XXL), V(3XL), V(4XL), V(5XL)
    fixed_instance_size: String?
    /// A list of hard disks with nested "size" and "is_main" properties. It must be provided with vcore, cores_per_processor, and ram parameters.
    hdds: Listing<Any>?
    /// The hostname or ID of the server. Only used when state is 'present'.
    hostname: String?
    /// The load balancer name or ID.
    load_balancer: String?
    /// The monitoring policy name or ID.
    monitoring_policy: String?
    /// The private network name or ID.
    private_network: String?
    /// The amount of RAM memory. It must be provided with with vcore, cores_per_processor, and hdds parameters.
    ram: Any?
    /// Server identifier (ID or hostname). It is required for all states except 'running' and 'present'.
    server: String?
    /// The type of server to be built.
    server_type: ("cloud"|"baremetal"|"k8s_node")?
    /// User's public SSH key (contents, not path).
    ssh_key: String?
    /// Define a server's state to create, remove, start or stop it.
    state: ("present"|"absent"|"running"|"stopped")?
    /// The total number of processors. It must be provided with cores_per_processor, ram, and hdds parameters.
    vcore: Int?
    /// Wait for the server to be in state 'running' before returning. Also used for delete operation (set to 'false' if you don't want to wait for each individual server to be deleted before moving on with other tasks.)
    wait: Boolean?
    /// Defines the number of seconds to wait when using the wait_for methods
    wait_interval: Int?
    /// how long before wait gives up, in seconds
    wait_timeout: Int?
}

/// Task class for oneandone_server
class OneandoneServerTask extends Playbook.Task {
    /// todo doc
    `community.general.oneandone_server`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.oneandone_server"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.oneandone_server`
}

/// TaskBuilder class for oneandone_server
class OneandoneServer extends Playbook.TaskBuilder {
    /// Options for community.general.oneandone_server
    options: OneandoneServerOptions?
    /// todo doc
    function Task(): OneandoneServerTask = this
        .toMap()
        .put("community.general.oneandone_server", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OneandoneServerTask)
}

/// Gather items from 1Password
/// M(community.general.onepassword_info) wraps the C(op) command line utility to fetch data about one or more 1Password items.
/// A fatal error occurs if any of the items being searched for can not be found.
/// Recommend using with the C(no_log) option to avoid logging the values of the secrets being retrieved.
class OnepasswordInfoOptions {
    /// A dictionary containing authentication details. If this is set, M(community.general.onepassword_info) will attempt to sign in to 1Password automatically.
    /// Without this option, you must have already logged in via the 1Password CLI before running Ansible.
    /// It is B(highly) recommended to store 1Password credentials in an Ansible Vault. Ensure that the key used to encrypt the Ansible Vault is equal to or greater in strength than the 1Password master password.
    auto_login: Any?
    /// Used to specify the exact path to the C(op) command line interface
    cli_path: String?
    /// A list of one or more search terms.
    /// Each search term can either be a simple string or it can be a dictionary for more control.
    /// When passing a simple string, O(search_terms[].field) is assumed to be V(password).
    /// When passing a dictionary, the following fields are available.
    search_terms: Listing<Any>
}

/// Task class for onepassword_info
class OnepasswordInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.onepassword_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.onepassword_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.onepassword_info`
}

/// TaskBuilder class for onepassword_info
class OnepasswordInfo extends Playbook.TaskBuilder {
    /// Options for community.general.onepassword_info
    options: OnepasswordInfoOptions?
    /// todo doc
    function Task(): OnepasswordInfoTask = this
        .toMap()
        .put("community.general.onepassword_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OnepasswordInfoTask)
}

/// Retrieve information about the OneView Data Centers
/// Retrieve information about the OneView Data Centers.
class OneviewDatacenterInfoOptions {
    /// Data Center name.
    name: String?
    /// Retrieve additional information. Options available: 'visualContent'.
    options: Listing<String>?
}

/// Task class for oneview_datacenter_info
class OneviewDatacenterInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.oneview_datacenter_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.oneview_datacenter_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.oneview_datacenter_info`
}

/// TaskBuilder class for oneview_datacenter_info
class OneviewDatacenterInfo extends Playbook.TaskBuilder {
    /// Options for community.general.oneview_datacenter_info
    options: OneviewDatacenterInfoOptions?
    /// todo doc
    function Task(): OneviewDatacenterInfoTask = this
        .toMap()
        .put("community.general.oneview_datacenter_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OneviewDatacenterInfoTask)
}

/// Retrieve information about one or more Enclosures
/// Retrieve information about one or more of the Enclosures from OneView.
class OneviewEnclosureInfoOptions {
    /// Enclosure name.
    name: String?
    /// List with options to gather additional information about an Enclosure and related resources. Options allowed: V(script), V(environmentalConfiguration), and V(utilization). For the option V(utilization), you can provide specific parameters.
    options: Listing<String>?
}

/// Task class for oneview_enclosure_info
class OneviewEnclosureInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.oneview_enclosure_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.oneview_enclosure_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.oneview_enclosure_info`
}

/// TaskBuilder class for oneview_enclosure_info
class OneviewEnclosureInfo extends Playbook.TaskBuilder {
    /// Options for community.general.oneview_enclosure_info
    options: OneviewEnclosureInfoOptions?
    /// todo doc
    function Task(): OneviewEnclosureInfoTask = this
        .toMap()
        .put("community.general.oneview_enclosure_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OneviewEnclosureInfoTask)
}

/// Manage OneView Ethernet Network resources
/// Provides an interface to manage Ethernet Network resources. Can create, update, or delete.
class OneviewEthernetNetworkOptions {
    /// List with Ethernet Network properties.
    data: Any
    /// Indicates the desired state for the Ethernet Network resource. - V(present) will ensure data properties are compliant with OneView. - V(absent) will remove the resource from OneView, if it exists. - V(default_bandwidth_reset) will reset the network connection template to the default.
    state: ("present"|"absent"|"default_bandwidth_reset")?
}

/// Task class for oneview_ethernet_network
class OneviewEthernetNetworkTask extends Playbook.Task {
    /// todo doc
    `community.general.oneview_ethernet_network`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.oneview_ethernet_network"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.oneview_ethernet_network`
}

/// TaskBuilder class for oneview_ethernet_network
class OneviewEthernetNetwork extends Playbook.TaskBuilder {
    /// Options for community.general.oneview_ethernet_network
    options: OneviewEthernetNetworkOptions?
    /// todo doc
    function Task(): OneviewEthernetNetworkTask = this
        .toMap()
        .put("community.general.oneview_ethernet_network", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OneviewEthernetNetworkTask)
}

/// Retrieve the information about one or more of the OneView Ethernet Networks
/// Retrieve the information about one or more of the Ethernet Networks from OneView.
class OneviewEthernetNetworkInfoOptions {
    /// Ethernet Network name.
    name: String?
    /// List with options to gather additional information about an Ethernet Network and related resources. Options allowed: V(associatedProfiles) and V(associatedUplinkGroups).
    options: Listing<String>?
}

/// Task class for oneview_ethernet_network_info
class OneviewEthernetNetworkInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.oneview_ethernet_network_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.oneview_ethernet_network_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.oneview_ethernet_network_info`
}

/// TaskBuilder class for oneview_ethernet_network_info
class OneviewEthernetNetworkInfo extends Playbook.TaskBuilder {
    /// Options for community.general.oneview_ethernet_network_info
    options: OneviewEthernetNetworkInfoOptions?
    /// todo doc
    function Task(): OneviewEthernetNetworkInfoTask = this
        .toMap()
        .put("community.general.oneview_ethernet_network_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OneviewEthernetNetworkInfoTask)
}

/// Manage OneView Fibre Channel Network resources
/// Provides an interface to manage Fibre Channel Network resources. Can create, update, and delete.
class OneviewFcNetworkOptions {
    /// List with the Fibre Channel Network properties.
    data: Any
    /// Indicates the desired state for the Fibre Channel Network resource. V(present) will ensure data properties are compliant with OneView. V(absent) will remove the resource from OneView, if it exists.
    state: ("present"|"absent")
}

/// Task class for oneview_fc_network
class OneviewFcNetworkTask extends Playbook.Task {
    /// todo doc
    `community.general.oneview_fc_network`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.oneview_fc_network"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.oneview_fc_network`
}

/// TaskBuilder class for oneview_fc_network
class OneviewFcNetwork extends Playbook.TaskBuilder {
    /// Options for community.general.oneview_fc_network
    options: OneviewFcNetworkOptions?
    /// todo doc
    function Task(): OneviewFcNetworkTask = this
        .toMap()
        .put("community.general.oneview_fc_network", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OneviewFcNetworkTask)
}

/// Retrieve the information about one or more of the OneView Fibre Channel Networks
/// Retrieve the information about one or more of the Fibre Channel Networks from OneView.
class OneviewFcNetworkInfoOptions {
    /// Fibre Channel Network name.
    name: String?
}

/// Task class for oneview_fc_network_info
class OneviewFcNetworkInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.oneview_fc_network_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.oneview_fc_network_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.oneview_fc_network_info`
}

/// TaskBuilder class for oneview_fc_network_info
class OneviewFcNetworkInfo extends Playbook.TaskBuilder {
    /// Options for community.general.oneview_fc_network_info
    options: OneviewFcNetworkInfoOptions?
    /// todo doc
    function Task(): OneviewFcNetworkInfoTask = this
        .toMap()
        .put("community.general.oneview_fc_network_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OneviewFcNetworkInfoTask)
}

/// Manage OneView FCoE Network resources
/// Provides an interface to manage FCoE Network resources. Can create, update, or delete.
class OneviewFcoeNetworkOptions {
    /// List with FCoE Network properties.
    data: Any
    /// Indicates the desired state for the FCoE Network resource. V(present) will ensure data properties are compliant with OneView. V(absent) will remove the resource from OneView, if it exists.
    state: ("present"|"absent")?
}

/// Task class for oneview_fcoe_network
class OneviewFcoeNetworkTask extends Playbook.Task {
    /// todo doc
    `community.general.oneview_fcoe_network`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.oneview_fcoe_network"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.oneview_fcoe_network`
}

/// TaskBuilder class for oneview_fcoe_network
class OneviewFcoeNetwork extends Playbook.TaskBuilder {
    /// Options for community.general.oneview_fcoe_network
    options: OneviewFcoeNetworkOptions?
    /// todo doc
    function Task(): OneviewFcoeNetworkTask = this
        .toMap()
        .put("community.general.oneview_fcoe_network", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OneviewFcoeNetworkTask)
}

/// Retrieve the information about one or more of the OneView FCoE Networks
/// Retrieve the information about one or more of the FCoE Networks from OneView.
class OneviewFcoeNetworkInfoOptions {
    /// FCoE Network name.
    name: String?
}

/// Task class for oneview_fcoe_network_info
class OneviewFcoeNetworkInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.oneview_fcoe_network_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.oneview_fcoe_network_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.oneview_fcoe_network_info`
}

/// TaskBuilder class for oneview_fcoe_network_info
class OneviewFcoeNetworkInfo extends Playbook.TaskBuilder {
    /// Options for community.general.oneview_fcoe_network_info
    options: OneviewFcoeNetworkInfoOptions?
    /// todo doc
    function Task(): OneviewFcoeNetworkInfoTask = this
        .toMap()
        .put("community.general.oneview_fcoe_network_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OneviewFcoeNetworkInfoTask)
}

/// Manage OneView Logical Interconnect Group resources
/// Provides an interface to manage Logical Interconnect Group resources. Can create, update, or delete.
class OneviewLogicalInterconnectGroupOptions {
    /// List with the Logical Interconnect Group properties.
    data: Any
    /// Indicates the desired state for the Logical Interconnect Group resource. V(absent) will remove the resource from OneView, if it exists. V(present) will ensure data properties are compliant with OneView.
    state: ("absent"|"present")?
}

/// Task class for oneview_logical_interconnect_group
class OneviewLogicalInterconnectGroupTask extends Playbook.Task {
    /// todo doc
    `community.general.oneview_logical_interconnect_group`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.oneview_logical_interconnect_group"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.oneview_logical_interconnect_group`
}

/// TaskBuilder class for oneview_logical_interconnect_group
class OneviewLogicalInterconnectGroup extends Playbook.TaskBuilder {
    /// Options for community.general.oneview_logical_interconnect_group
    options: OneviewLogicalInterconnectGroupOptions?
    /// todo doc
    function Task(): OneviewLogicalInterconnectGroupTask = this
        .toMap()
        .put("community.general.oneview_logical_interconnect_group", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OneviewLogicalInterconnectGroupTask)
}

/// Retrieve information about one or more of the OneView Logical Interconnect Groups
/// Retrieve information about one or more of the Logical Interconnect Groups from OneView
class OneviewLogicalInterconnectGroupInfoOptions {
    /// Logical Interconnect Group name.
    name: String?
}

/// Task class for oneview_logical_interconnect_group_info
class OneviewLogicalInterconnectGroupInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.oneview_logical_interconnect_group_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.oneview_logical_interconnect_group_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.oneview_logical_interconnect_group_info`
}

/// TaskBuilder class for oneview_logical_interconnect_group_info
class OneviewLogicalInterconnectGroupInfo extends Playbook.TaskBuilder {
    /// Options for community.general.oneview_logical_interconnect_group_info
    options: OneviewLogicalInterconnectGroupInfoOptions?
    /// todo doc
    function Task(): OneviewLogicalInterconnectGroupInfoTask = this
        .toMap()
        .put("community.general.oneview_logical_interconnect_group_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OneviewLogicalInterconnectGroupInfoTask)
}

/// Manage HPE OneView Network Set resources
/// Provides an interface to manage Network Set resources. Can create, update, or delete.
class OneviewNetworkSetOptions {
    /// List with the Network Set properties.
    data: Any
    /// Indicates the desired state for the Network Set resource. - V(present) will ensure data properties are compliant with OneView. - V(absent) will remove the resource from OneView, if it exists.
    state: ("present"|"absent")?
}

/// Task class for oneview_network_set
class OneviewNetworkSetTask extends Playbook.Task {
    /// todo doc
    `community.general.oneview_network_set`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.oneview_network_set"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.oneview_network_set`
}

/// TaskBuilder class for oneview_network_set
class OneviewNetworkSet extends Playbook.TaskBuilder {
    /// Options for community.general.oneview_network_set
    options: OneviewNetworkSetOptions?
    /// todo doc
    function Task(): OneviewNetworkSetTask = this
        .toMap()
        .put("community.general.oneview_network_set", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OneviewNetworkSetTask)
}

/// Retrieve information about the OneView Network Sets
/// Retrieve information about the Network Sets from OneView.
class OneviewNetworkSetInfoOptions {
    /// Network Set name.
    name: String?
    /// List with options to gather information about Network Set. Option allowed: V(withoutEthernet). The option V(withoutEthernet) retrieves the list of network_sets excluding Ethernet networks.
    options: Listing<String>?
}

/// Task class for oneview_network_set_info
class OneviewNetworkSetInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.oneview_network_set_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.oneview_network_set_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.oneview_network_set_info`
}

/// TaskBuilder class for oneview_network_set_info
class OneviewNetworkSetInfo extends Playbook.TaskBuilder {
    /// Options for community.general.oneview_network_set_info
    options: OneviewNetworkSetInfoOptions?
    /// todo doc
    function Task(): OneviewNetworkSetInfoTask = this
        .toMap()
        .put("community.general.oneview_network_set_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OneviewNetworkSetInfoTask)
}

/// Manage OneView SAN Manager resources
/// Provides an interface to manage SAN Manager resources. Can create, update, or delete.
class OneviewSanManagerOptions {
    /// List with SAN Manager properties.
    data: Any
    /// Indicates the desired state for the Uplink Set resource. - V(present) ensures data properties are compliant with OneView. - V(absent) removes the resource from OneView, if it exists. - V(connection_information_set) updates the connection information for the SAN Manager. This operation is non-idempotent.
    state: ("present"|"absent"|"connection_information_set")?
}

/// Task class for oneview_san_manager
class OneviewSanManagerTask extends Playbook.Task {
    /// todo doc
    `community.general.oneview_san_manager`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.oneview_san_manager"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.oneview_san_manager`
}

/// TaskBuilder class for oneview_san_manager
class OneviewSanManager extends Playbook.TaskBuilder {
    /// Options for community.general.oneview_san_manager
    options: OneviewSanManagerOptions?
    /// todo doc
    function Task(): OneviewSanManagerTask = this
        .toMap()
        .put("community.general.oneview_san_manager", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OneviewSanManagerTask)
}

/// Retrieve information about one or more of the OneView SAN Managers
/// Retrieve information about one or more of the SAN Managers from OneView
class OneviewSanManagerInfoOptions {
    /// List of params to delimit, filter and sort the list of resources.
    /// params allowed: - V(start): The first item to return, using 0-based indexing. - V(count): The number of resources to return. - V(query): A general query string to narrow the list of resources returned. - V(sort): The sort order of the returned data set.
    params: Any?
    /// Provider Display Name.
    provider_display_name: String?
}

/// Task class for oneview_san_manager_info
class OneviewSanManagerInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.oneview_san_manager_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.oneview_san_manager_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.oneview_san_manager_info`
}

/// TaskBuilder class for oneview_san_manager_info
class OneviewSanManagerInfo extends Playbook.TaskBuilder {
    /// Options for community.general.oneview_san_manager_info
    options: OneviewSanManagerInfoOptions?
    /// todo doc
    function Task(): OneviewSanManagerInfoTask = this
        .toMap()
        .put("community.general.oneview_san_manager_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OneviewSanManagerInfoTask)
}

/// Gather information about Online servers
/// Gather information about the servers.
/// U(https://www.online.net/en/dedicated-server)
class OnlineServerInfoOptions {
}

/// Task class for online_server_info
class OnlineServerInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.online_server_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.online_server_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.online_server_info`
}

/// TaskBuilder class for online_server_info
class OnlineServerInfo extends Playbook.TaskBuilder {
    /// Options for community.general.online_server_info
    options: OnlineServerInfoOptions?
    /// todo doc
    function Task(): OnlineServerInfoTask = this
        .toMap()
        .put("community.general.online_server_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OnlineServerInfoTask)
}

/// Gather information about Online user
/// Gather information about the user.
class OnlineUserInfoOptions {
}

/// Task class for online_user_info
class OnlineUserInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.online_user_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.online_user_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.online_user_info`
}

/// TaskBuilder class for online_user_info
class OnlineUserInfo extends Playbook.TaskBuilder {
    /// Options for community.general.online_user_info
    options: OnlineUserInfoOptions?
    /// todo doc
    function Task(): OnlineUserInfoTask = this
        .toMap()
        .put("community.general.online_user_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OnlineUserInfoTask)
}

/// Manage iSCSI targets with Open-iSCSI
/// Discover targets on given portal, (dis)connect targets, mark targets to manually or auto start, return device nodes of connected targets.
class OpenIscsiOptions {
    /// Whether the target node should be automatically connected at startup.
    auto_node_startup: Boolean?
    /// Whether the target node portal should be automatically connected at startup.
    auto_portal_startup: Boolean?
    /// Whether the list of target nodes on the portal should be (re)discovered and added to the persistent iSCSI database.
    /// Keep in mind that C(iscsiadm) discovery resets configuration, like C(node.startup) to manual, hence combined with O(auto_node_startup=true) will always return a changed state.
    discover: Boolean?
    /// Whether the target node should be connected.
    login: Boolean?
    /// The value for C(node.session.auth.authmethod).
    node_auth: String?
    /// The value for C(node.session.auth.password).
    node_pass: String?
    /// The value for C(node.session.auth.password_in).
    node_pass_in: String?
    /// The value for C(node.session.auth.username).
    node_user: String?
    /// The value for C(node.session.auth.username_in).
    node_user_in: String?
    /// The port on which the iSCSI target process listens.
    port: String?
    /// The domain name or IP address of the iSCSI target.
    portal: String?
    /// Rescan an established session for discovering new targets.
    /// When O(target) is omitted, will rescan all sessions.
    rescan: Boolean?
    /// Whether the list of nodes in the persistent iSCSI database should be returned by the module.
    show_nodes: Boolean?
    /// The iSCSI target name.
    target: String?
}

/// Task class for open_iscsi
class OpenIscsiTask extends Playbook.Task {
    /// todo doc
    `community.general.open_iscsi`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.open_iscsi"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.open_iscsi`
}

/// TaskBuilder class for open_iscsi
class OpenIscsi extends Playbook.TaskBuilder {
    /// Options for community.general.open_iscsi
    options: OpenIscsiOptions?
    /// todo doc
    function Task(): OpenIscsiTask = this
        .toMap()
        .put("community.general.open_iscsi", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OpenIscsiTask)
}

/// Manage packages on OpenBSD
/// Manage packages on OpenBSD using the pkg tools.
class OpenbsdPkgOptions {
    /// Build the package from source instead of downloading and installing a binary. Requires that the port source tree is already installed. Automatically builds and installs the 'sqlports' package, if it is not already installed.
    /// Mutually exclusive with O(snapshot).
    build: Boolean?
    /// When updating or removing packages, delete the extra configuration file(s) in the old packages which are annotated with @extra in the packaging-list.
    clean: Boolean?
    /// A name or a list of names of the packages.
    name: Listing<String>
    /// When used in combination with the O(build) option, allows overriding the default ports source directory.
    ports_dir: String?
    /// Replace or delete packages quickly; do not bother with checksums before removing normal files.
    quick: Boolean?
    /// Force C(%c) and C(%m) to expand to C(snapshots), even on a release kernel.
    /// Mutually exclusive with O(build).
    snapshot: Boolean?
    /// V(present) will make sure the package is installed.
    /// V(latest) will make sure the latest version of the package is installed.
    /// V(absent) will make sure the specified package is not installed.
    state: ("absent"|"latest"|"present"|"installed"|"removed")?
}

/// Task class for openbsd_pkg
class OpenbsdPkgTask extends Playbook.Task {
    /// todo doc
    `community.general.openbsd_pkg`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.openbsd_pkg"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.openbsd_pkg`
}

/// TaskBuilder class for openbsd_pkg
class OpenbsdPkg extends Playbook.TaskBuilder {
    /// Options for community.general.openbsd_pkg
    options: OpenbsdPkgOptions?
    /// todo doc
    function Task(): OpenbsdPkgTask = this
        .toMap()
        .put("community.general.openbsd_pkg", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OpenbsdPkgTask)
}

/// Will update the backend configuration of OpenDJ via the dsconfig set-backend-prop command
/// This module will update settings for OpenDJ with the command set-backend-prop.
/// It will check first via de get-backend-prop if configuration needs to be applied.
class OpendjBackendpropOptions {
    /// The name of the backend on which the property needs to be updated.
    backend: String
    /// The hostname of the OpenDJ server.
    hostname: String
    /// The configuration setting to update.
    name: String
    /// The path to the bin directory of OpenDJ.
    opendj_bindir: String?
    /// The password for the cn=Directory Manager user.
    /// Either password or passwordfile is needed.
    password: String?
    /// Location to the password file which holds the password for the cn=Directory Manager user.
    /// Either password or passwordfile is needed.
    passwordfile: String?
    /// The Admin port on which the OpenDJ instance is available.
    port: String
    /// If configuration needs to be added/updated
    state: String?
    /// The username to connect to.
    username: String?
    /// The value for the configuration item.
    value: String
}

/// Task class for opendj_backendprop
class OpendjBackendpropTask extends Playbook.Task {
    /// todo doc
    `community.general.opendj_backendprop`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.opendj_backendprop"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.opendj_backendprop`
}

/// TaskBuilder class for opendj_backendprop
class OpendjBackendprop extends Playbook.TaskBuilder {
    /// Options for community.general.opendj_backendprop
    options: OpendjBackendpropOptions?
    /// todo doc
    function Task(): OpendjBackendpropTask = this
        .toMap()
        .put("community.general.opendj_backendprop", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OpendjBackendpropTask)
}

/// Manage services on OpenWrt
/// Controls OpenWrt services on remote hosts.
class OpenwrtInitOptions {
    /// Whether the service should start on boot. B(At least one of state and enabled are required.)
    enabled: Boolean?
    /// Name of the service.
    name: String
    /// If the service does not respond to the 'running' command, name a substring to look for as would be found in the output of the C(ps) command as a stand-in for a 'running' result.  If the string is found, the service will be assumed to be running.
    pattern: String?
    /// V(started)/V(stopped) are idempotent actions that will not run commands unless necessary.
    /// V(restarted) will always bounce the service.
    /// V(reloaded) will always reload.
    state: ("started"|"stopped"|"restarted"|"reloaded")?
}

/// Task class for openwrt_init
class OpenwrtInitTask extends Playbook.Task {
    /// todo doc
    `community.general.openwrt_init`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.openwrt_init"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.openwrt_init`
}

/// TaskBuilder class for openwrt_init
class OpenwrtInit extends Playbook.TaskBuilder {
    /// Options for community.general.openwrt_init
    options: OpenwrtInitOptions?
    /// todo doc
    function Task(): OpenwrtInitTask = this
        .toMap()
        .put("community.general.openwrt_init", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OpenwrtInitTask)
}

/// Package manager for OpenWrt and Openembedded/Yocto based Linux distributions
/// Manages ipk packages for OpenWrt and Openembedded/Yocto based Linux distributions
class OpkgOptions {
    /// The executable location for C(opkg).
    executable: String?
    /// The C(opkg --force) parameter used.
    /// Passing V("") as value and not passing any value at all have both the same effect of B(not) using any C(--force-) parameter.
    force: (""|"depends"|"maintainer"|"reinstall"|"overwrite"|"downgrade"|"space"|"postinstall"|"remove"|"checksum"|"removal-of-dependent-packages")?
    /// Name of package(s) to install/remove.
    /// C(NAME=VERSION) syntax is also supported to install a package in a certain version. See the examples. This only works on Yocto based Linux distributions (opkg>=0.3.2) and not for OpenWrt. This is supported since community.general 6.2.0.
    name: Listing<String>
    /// State of the package.
    state: ("present"|"absent"|"installed"|"removed")?
    /// Update the package DB first.
    update_cache: Boolean?
}

/// Task class for opkg
class OpkgTask extends Playbook.Task {
    /// todo doc
    `community.general.opkg`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.opkg"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.opkg`
}

/// TaskBuilder class for opkg
class Opkg extends Playbook.TaskBuilder {
    /// Options for community.general.opkg
    options: OpkgOptions?
    /// todo doc
    function Task(): OpkgTask = this
        .toMap()
        .put("community.general.opkg", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OpkgTask)
}

/// Manage macOS user defaults
/// osx_defaults allows users to read, write, and delete macOS user defaults from Ansible scripts.
/// macOS applications and other programs use the defaults system to record user preferences and other information that must be maintained when the applications are not running (such as default font for new documents, or the position of an Info panel).
class OsxDefaultsOptions {
    /// Add new elements to the array for a key which has an array as its value.
    array_add: Boolean?
    /// Checks if the type of the provided O(value) matches the type of an existing default.
    /// If the types do not match, raises an error.
    check_type: Boolean?
    /// The domain is a domain name of the form C(com.companyname.appname).
    domain: String?
    /// The host on which the preference should apply.
    /// The special value V(currentHost) corresponds to the C(-currentHost) switch of the defaults commandline tool.
    host: String?
    /// The key of the user preference.
    key: String?
    /// The path in which to search for C(defaults).
    path: String?
    /// The state of the user defaults.
    /// If set to V(list) will query the given parameter specified by O(key). Returns V(null) is nothing found or mis-spelled.
    state: ("absent"|"list"|"present")?
    /// The type of value to write.
    type: ("array"|"bool"|"boolean"|"date"|"float"|"int"|"integer"|"string")?
    /// The value to write.
    /// Only required when O(state=present).
    value: String?
}

/// Task class for osx_defaults
class OsxDefaultsTask extends Playbook.Task {
    /// todo doc
    `community.general.osx_defaults`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.osx_defaults"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.osx_defaults`
}

/// TaskBuilder class for osx_defaults
class OsxDefaults extends Playbook.TaskBuilder {
    /// Options for community.general.osx_defaults
    options: OsxDefaultsOptions?
    /// todo doc
    function Task(): OsxDefaultsTask = this
        .toMap()
        .put("community.general.osx_defaults", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OsxDefaultsTask)
}

/// Manage OVH IP failover address
/// Manage OVH (French European hosting provider) IP Failover Address. For now, this module can only be used to move an ip failover (or failover block) between services
class OvhIpFailoverOptions {
    /// The applicationKey to use
    application_key: String
    /// The application secret to use
    application_secret: String
    /// The consumer key to use
    consumer_key: String
    /// The endpoint to use ( for instance ovh-eu)
    endpoint: String
    /// The IP address to manage (can be a single IP like 1.1.1.1 or a block like 1.1.1.1/28 )
    name: String
    /// The name of the OVH service this IP address should be routed
    service: String
    /// The timeout in seconds used to wait for a task to be completed. Default is 120 seconds.
    timeout: Int?
    /// If true, the module will wait for the IP address to be moved. If false, exit without waiting. The taskId will be returned in module output
    wait_completion: Boolean?
    /// If not 0, the module will wait for this task id to be completed. Use wait_task_completion if you want to wait for completion of a previously executed task with wait_completion=false. You can execute this module repeatedly on a list of failover IPs using wait_completion=false (see examples)
    wait_task_completion: Int?
}

/// Task class for ovh_ip_failover
class OvhIpFailoverTask extends Playbook.Task {
    /// todo doc
    `community.general.ovh_ip_failover`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ovh_ip_failover"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ovh_ip_failover`
}

/// TaskBuilder class for ovh_ip_failover
class OvhIpFailover extends Playbook.TaskBuilder {
    /// Options for community.general.ovh_ip_failover
    options: OvhIpFailoverOptions?
    /// todo doc
    function Task(): OvhIpFailoverTask = this
        .toMap()
        .put("community.general.ovh_ip_failover", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OvhIpFailoverTask)
}

/// Manage OVH IP LoadBalancing backends
/// Manage OVH (French European hosting provider) LoadBalancing IP backends
class OvhIpLoadbalancingBackendOptions {
    /// The applicationKey to use
    application_key: String
    /// The application secret to use
    application_secret: String
    /// The IP address of the backend to update / modify / delete
    backend: String
    /// The consumer key to use
    consumer_key: String
    /// The endpoint to use ( for instance ovh-eu)
    endpoint: String
    /// Name of the LoadBalancing internal name (ip-X.X.X.X)
    name: String
    /// Determines the type of probe to use for this backend
    probe: ("none"|"http"|"icmp"|"oco")?
    /// Determines whether the backend is to be created/modified or deleted
    state: ("present"|"absent")?
    /// The timeout in seconds used to wait for a task to be completed.
    timeout: Int?
    /// Determines the weight for this backend
    weight: Int?
}

/// Task class for ovh_ip_loadbalancing_backend
class OvhIpLoadbalancingBackendTask extends Playbook.Task {
    /// todo doc
    `community.general.ovh_ip_loadbalancing_backend`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ovh_ip_loadbalancing_backend"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ovh_ip_loadbalancing_backend`
}

/// TaskBuilder class for ovh_ip_loadbalancing_backend
class OvhIpLoadbalancingBackend extends Playbook.TaskBuilder {
    /// Options for community.general.ovh_ip_loadbalancing_backend
    options: OvhIpLoadbalancingBackendOptions?
    /// todo doc
    function Task(): OvhIpLoadbalancingBackendTask = this
        .toMap()
        .put("community.general.ovh_ip_loadbalancing_backend", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OvhIpLoadbalancingBackendTask)
}

/// Manage OVH monthly billing
/// Enable monthly billing on OVH cloud instances (be aware OVH does not allow to disable it).
class OvhMonthlyBillingOptions {
    /// The applicationKey to use
    application_key: String?
    /// The application secret to use
    application_secret: String?
    /// The consumer key to use
    consumer_key: String?
    /// The endpoint to use (for instance ovh-eu)
    endpoint: String?
    /// ID of the instance, get it with U(https://api.ovh.com/console/#/cloud/project/%7BserviceName%7D/instance#GET)
    instance_id: String
    /// ID of the project, get it with U(https://api.ovh.com/console/#/cloud/project#GET)
    project_id: String
}

/// Task class for ovh_monthly_billing
class OvhMonthlyBillingTask extends Playbook.Task {
    /// todo doc
    `community.general.ovh_monthly_billing`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ovh_monthly_billing"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ovh_monthly_billing`
}

/// TaskBuilder class for ovh_monthly_billing
class OvhMonthlyBilling extends Playbook.TaskBuilder {
    /// Options for community.general.ovh_monthly_billing
    options: OvhMonthlyBillingOptions?
    /// todo doc
    function Task(): OvhMonthlyBillingTask = this
        .toMap()
        .put("community.general.ovh_monthly_billing", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(OvhMonthlyBillingTask)
}

/// Manage pacemaker clusters
/// This module can manage a pacemaker cluster and nodes from Ansible using the pacemaker cli.
class PacemakerClusterOptions {
    /// Force the change of the cluster state
    force: Boolean?
    /// Specify which node of the cluster you want to manage. None == the cluster status itself, 'all' == check the status of all nodes.
    node: String?
    /// Indicate desired state of the cluster
    state: ("cleanup"|"offline"|"online"|"restart")?
    /// Timeout when the module should considered that the action has failed
    timeout: Int?
}

/// Task class for pacemaker_cluster
class PacemakerClusterTask extends Playbook.Task {
    /// todo doc
    `community.general.pacemaker_cluster`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.pacemaker_cluster"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.pacemaker_cluster`
}

/// TaskBuilder class for pacemaker_cluster
class PacemakerCluster extends Playbook.TaskBuilder {
    /// Options for community.general.pacemaker_cluster
    options: PacemakerClusterOptions?
    /// todo doc
    function Task(): PacemakerClusterTask = this
        .toMap()
        .put("community.general.pacemaker_cluster", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PacemakerClusterTask)
}

/// Manage a bare metal server in the Packet Host
/// Manage a bare metal server in the Packet Host (a "device" in the API terms).
/// When the machine is created it can optionally wait for public IP address, or for active state.
/// This module has a dependency on packet >= 1.0.
/// API is documented at U(https://www.packet.net/developers/api/devices).
class PacketDeviceOptions {
    /// Persist PXE as the first boot option.
    /// Normally, the PXE process happens only on the first boot. Set this arg to have your device continuously boot to iPXE.
    always_pxe: Boolean?
    /// Packet API token. You can also supply it in environment variable E(PACKET_API_TOKEN).
    auth_token: String?
    /// The number of devices to create. Count number can be included in hostname via the %d string formatter.
    count: Int?
    /// From which number to start the count.
    count_offset: Int?
    /// List of device IDs on which to operate.
    device_ids: Listing<String>?
    /// Facility slug for device creation. See Packet API for current list - U(https://www.packet.net/developers/api/facilities/).
    facility: String?
    /// Dict with "features" for device creation. See Packet API docs for details.
    features: Any?
    /// A hostname of a device, or a list of hostnames.
    /// If given string or one-item list, you can use the C("%d") Python string format to expand numbers from O(count).
    /// If only one hostname, it might be expanded to list if O(count)>1.
    hostnames: Listing<String>?
    /// URL of custom iPXE script for provisioning.
    /// More about custom iPXE for Packet devices at U(https://help.packet.net/technical/infrastructure/custom-ipxe).
    ipxe_script_url: String?
    /// Whether to lock a created device.
    locked: Boolean?
    /// OS slug for device creation. See Packet API for current list - U(https://www.packet.net/developers/api/operatingsystems/).
    operating_system: String?
    /// Plan slug for device creation. See Packet API for current list - U(https://www.packet.net/developers/api/plans/).
    plan: String?
    /// ID of project of the device.
    project_id: String
    /// Desired state of the device.
    /// If set to V(present) (the default), the module call will return immediately after the device-creating HTTP request successfully returns.
    /// If set to V(active), the module call will block until all the specified devices are in state active due to the Packet API, or until O(wait_timeout).
    state: ("present"|"absent"|"active"|"inactive"|"rebooted")?
    /// List of device tags.
    /// Currently implemented only for device creation.
    tags: Listing<String>?
    /// Userdata blob made available to the machine
    user_data: String?
    /// Whether to wait for the instance to be assigned a public IPv4/IPv6 address.
    /// If set to 4, it will wait until IPv4 is assigned to the instance.
    /// If set to 6, wait until public IPv6 is assigned to the instance.
    wait_for_public_IPv: Int?
    /// How long (seconds) to wait either for automatic IP address assignment, or for the device to reach the V(active) state.
    /// If O(wait_for_public_IPv) is set and O(state=active), the module will wait for both events consequently, applying the timeout twice.
    wait_timeout: Int?
}

/// Task class for packet_device
class PacketDeviceTask extends Playbook.Task {
    /// todo doc
    `community.general.packet_device`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.packet_device"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.packet_device`
}

/// TaskBuilder class for packet_device
class PacketDevice extends Playbook.TaskBuilder {
    /// Options for community.general.packet_device
    options: PacketDeviceOptions?
    /// todo doc
    function Task(): PacketDeviceTask = this
        .toMap()
        .put("community.general.packet_device", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PacketDeviceTask)
}

/// Assign IP subnet to a bare metal server
/// Assign or unassign IPv4 or IPv6 subnets to or from a device in the Packet host.
/// IPv4 subnets must come from already reserved block.
/// IPv6 subnets must come from publicly routable /56 block from your project.
/// See U(https://support.packet.com/kb/articles/elastic-ips) for more info on IP block reservation.
class PacketIpSubnetOptions {
    /// Packet API token. You can also supply it in environment variable E(PACKET_API_TOKEN).
    auth_token: String?
    /// IPv4 or IPv6 subnet which you want to manage. It must come from a reserved block for your project in the Packet Host.
    cidr: String
    /// The number of devices to retrieve from the project. The max allowed value is 1000.
    /// See U(https://www.packet.com/developers/api/#retrieve-all-devices-of-a-project) for more info.
    device_count: Int?
    /// UUID of a device to/from which to assign/remove a subnet.
    device_id: String?
    /// A hostname of a device to/from which to assign/remove a subnet.
    hostname: String?
    /// UUID of a project of the device to/from which to assign/remove a subnet.
    project_id: String?
    /// Desired state of the IP subnet on the specified device.
    /// With O(state=present), you must specify either O(hostname) or O(device_id). Subnet with given CIDR will then be assigned to the specified device.
    /// With O(state=absent), you can specify either O(hostname) or O(device_id). The subnet will be removed from specified devices.
    /// If you leave both O(hostname) and O(device_id) empty, the subnet will be removed from any device it's assigned to.
    state: ("present"|"absent")?
}

/// Task class for packet_ip_subnet
class PacketIpSubnetTask extends Playbook.Task {
    /// todo doc
    `community.general.packet_ip_subnet`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.packet_ip_subnet"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.packet_ip_subnet`
}

/// TaskBuilder class for packet_ip_subnet
class PacketIpSubnet extends Playbook.TaskBuilder {
    /// Options for community.general.packet_ip_subnet
    options: PacketIpSubnetOptions?
    /// todo doc
    function Task(): PacketIpSubnetTask = this
        .toMap()
        .put("community.general.packet_ip_subnet", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PacketIpSubnetTask)
}

/// Create/delete a project in Packet host
/// Create/delete a project in Packet host.
/// API is documented at U(https://www.packet.com/developers/api/#projects).
class PacketProjectOptions {
    /// Packet api token. You can also supply it in environment variable E(PACKET_API_TOKEN).
    auth_token: String?
    /// Custom data about the project to create.
    custom_data: String?
    /// UUID of the project which you want to remove.
    id: String?
    /// Name for/of the project.
    name: String?
    /// UUID of the organization to create a project for.
    /// When blank, the API assumes the default organization.
    org_id: String?
    /// Payment method is name of one of the payment methods available to your user.
    /// When blank, the API assumes the default payment method.
    payment_method: String?
    /// Indicate desired state of the target.
    state: ("present"|"absent")?
}

/// Task class for packet_project
class PacketProjectTask extends Playbook.Task {
    /// todo doc
    `community.general.packet_project`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.packet_project"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.packet_project`
}

/// TaskBuilder class for packet_project
class PacketProject extends Playbook.TaskBuilder {
    /// Options for community.general.packet_project
    options: PacketProjectOptions?
    /// todo doc
    function Task(): PacketProjectTask = this
        .toMap()
        .put("community.general.packet_project", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PacketProjectTask)
}

/// Create/delete an SSH key in Packet host
/// Create/delete an SSH key in Packet host.
/// API is documented at U(https://www.packet.net/help/api/#page:ssh-keys,header:ssh-keys-ssh-keys-post).
class PacketSshkeyOptions {
    /// Packet API token. You can also supply it in environment variable E(PACKET_API_TOKEN).
    auth_token: String?
    /// Fingerprint of the key which you want to remove.
    fingerprint: String?
    /// UUID of the key which you want to remove.
    id: String?
    /// Public Key string ({type} {base64 encoded key} {description}).
    key: String?
    /// File with the public key.
    key_file: String?
    /// Label for the key. If you keep it empty, it will be read from key string.
    label: String?
    /// Indicate desired state of the target.
    state: ("present"|"absent")?
}

/// Task class for packet_sshkey
class PacketSshkeyTask extends Playbook.Task {
    /// todo doc
    `community.general.packet_sshkey`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.packet_sshkey"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.packet_sshkey`
}

/// TaskBuilder class for packet_sshkey
class PacketSshkey extends Playbook.TaskBuilder {
    /// Options for community.general.packet_sshkey
    options: PacketSshkeyOptions?
    /// todo doc
    function Task(): PacketSshkeyTask = this
        .toMap()
        .put("community.general.packet_sshkey", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PacketSshkeyTask)
}

/// Create/delete a volume in Packet host
/// Create/delete a volume in Packet host.
/// API is documented at U(https://www.packet.com/developers/api/#volumes).
class PacketVolumeOptions {
    /// Packet API token. You can also supply it in environment variable E(PACKET_API_TOKEN).
    auth_token: String?
    /// Billing cycle for new volume.
    billing_cycle: ("hourly"|"monthly")?
    /// User-defined description attribute for Packet volume.
    /// It is used used as idempotent identifier - if volume with given description exists, new one is not created.
    description: String?
    /// Location of the volume.
    /// Volumes can only be attached to device in the same location.
    facility: String?
    /// UUID of a volume.
    id: String?
    /// Create new volume locked.
    locked: Boolean?
    /// Selector for API-generated name of the volume
    name: String?
    /// storage_1 for standard tier, storage_2 for premium (performance) tier.
    /// Tiers are described at U(https://www.packet.com/cloud/storage/).
    plan: ("storage_1"|"storage_2")?
    /// ID of project of the device.
    project_id: String
    /// Size of the volume in gigabytes.
    size: Int?
    /// Snapshot policy for new volume.
    snapshot_policy: Any?
    /// Desired state of the volume.
    state: ("present"|"absent")?
}

/// Task class for packet_volume
class PacketVolumeTask extends Playbook.Task {
    /// todo doc
    `community.general.packet_volume`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.packet_volume"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.packet_volume`
}

/// TaskBuilder class for packet_volume
class PacketVolume extends Playbook.TaskBuilder {
    /// Options for community.general.packet_volume
    options: PacketVolumeOptions?
    /// todo doc
    function Task(): PacketVolumeTask = this
        .toMap()
        .put("community.general.packet_volume", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PacketVolumeTask)
}

/// Attach/detach a volume to a device in the Packet host
/// Attach/detach a volume to a device in the Packet host.
/// API is documented at U(https://www.packet.com/developers/api/volumes/).
/// This module creates the attachment route in the Packet API. In order to discover the block devices on the server, you have to run the Attach Scripts, as documented at U(https://help.packet.net/technical/storage/packet-block-storage-linux).
class PacketVolumeAttachmentOptions {
    /// Packet API token. You can also supply it in environment variable E(PACKET_API_TOKEN).
    auth_token: String?
    /// Selector for the device.
    /// It can be a UUID of the device, or a hostname.
    /// Example values: 98a14f7a-3d27-4478-b7cf-35b5670523f3, "my device"
    device: String?
    /// UUID of the project to which the device and volume belong.
    project_id: String
    /// Indicate desired state of the attachment.
    state: ("present"|"absent")?
    /// Selector for the volume.
    /// It can be a UUID, an API-generated volume name, or user-defined description string.
    /// Example values: 4a347482-b546-4f67-8300-fb5018ef0c5, volume-4a347482, "my volume"
    volume: String
}

/// Task class for packet_volume_attachment
class PacketVolumeAttachmentTask extends Playbook.Task {
    /// todo doc
    `community.general.packet_volume_attachment`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.packet_volume_attachment"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.packet_volume_attachment`
}

/// TaskBuilder class for packet_volume_attachment
class PacketVolumeAttachment extends Playbook.TaskBuilder {
    /// Options for community.general.packet_volume_attachment
    options: PacketVolumeAttachmentOptions?
    /// todo doc
    function Task(): PacketVolumeAttachmentTask = this
        .toMap()
        .put("community.general.packet_volume_attachment", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PacketVolumeAttachmentTask)
}

/// Manage packages with I(pacman)
/// Manage packages with the I(pacman) package manager, which is used by Arch Linux and its variants.
class PacmanOptions {
    /// Path of the binary to use. This can either be C(pacman) or a pacman compatible AUR helper.
    /// Pacman compatibility is unfortunately ill defined, in particular, this modules makes extensive use of the C(--print-format) directive which is known not to be implemented by some AUR helpers (notably, C(yay)).
    /// Beware that AUR helpers might behave unexpectedly and are therefore not recommended.
    executable: String?
    /// Additional option to pass to pacman when enforcing O(state).
    extra_args: String?
    /// When removing packages, forcefully remove them, without any checks. Same as O(extra_args="--nodeps --nodeps").
    /// When combined with O(update_cache), force a refresh of all package databases. Same as O(update_cache_extra_args="--refresh --refresh").
    force: Boolean?
    /// Name or list of names of the package(s) or file(s) to install, upgrade, or remove. Cannot be used in combination with O(upgrade).
    name: Listing<String>?
    /// The install reason to set for the packages.
    reason: ("dependency"|"explicit")?
    /// Set the install reason for V(all) packages or only for V(new) packages.
    /// In case of O(state=latest) already installed packages which will be updated to a newer version are not counted as V(new).
    reason_for: ("all"|"new")?
    /// When removing packages, do not save modified configuration files as C(.pacsave) files. (passes C(--nosave) to pacman)
    remove_nosave: Boolean?
    /// Whether to install (V(present) or V(installed), V(latest)), or remove (V(absent) or V(removed)) a package.
    /// V(present) and V(installed) will simply ensure that a desired package is installed.
    /// V(latest) will update the specified package if it is not of the latest available version.
    /// V(absent) and V(removed) will remove the specified package.
    state: ("absent"|"installed"|"latest"|"present"|"removed")?
    /// Whether or not to refresh the master package lists.
    /// This can be run as part of a package installation or as a separate step.
    /// If not specified, it defaults to V(false).
    /// Please note that this option only had an influence on the module's C(changed) state if O(name) and O(upgrade) are not specified before community.general 5.0.0. See the examples for how to keep the old behavior.
    update_cache: Boolean?
    /// Additional option to pass to pacman when enforcing O(update_cache).
    update_cache_extra_args: String?
    /// Whether or not to upgrade the whole system. Cannot be used in combination with O(name).
    /// If not specified, it defaults to V(false).
    upgrade: Boolean?
    /// Additional option to pass to pacman when enforcing O(upgrade).
    upgrade_extra_args: String?
}

/// Task class for pacman
class PacmanTask extends Playbook.Task {
    /// todo doc
    `community.general.pacman`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.pacman"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.pacman`
}

/// TaskBuilder class for pacman
class Pacman extends Playbook.TaskBuilder {
    /// Options for community.general.pacman
    options: PacmanOptions?
    /// todo doc
    function Task(): PacmanTask = this
        .toMap()
        .put("community.general.pacman", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PacmanTask)
}

/// Manage pacman's list of trusted keys
/// Add or remove gpg keys from the pacman keyring.
class PacmanKeyOptions {
    /// The keyfile contents to add to the keyring.
    /// Must be of C(PGP PUBLIC KEY BLOCK) type.
    data: String?
    /// The path to a keyfile on the remote server to add to the keyring.
    /// Remote file must be of C(PGP PUBLIC KEY BLOCK) type.
    file: String?
    /// This forces the key to be updated if it already exists in the keyring.
    force_update: Boolean?
    /// The 40 character identifier of the key.
    /// Including this allows check mode to correctly report the changed state.
    /// Do not specify a subkey ID, instead specify the primary key ID.
    id: String
    /// The full path to the keyring folder on the remote server.
    /// If not specified, module will use pacman's default (V(/etc/pacman.d/gnupg)).
    /// Useful if the remote system requires an alternative gnupg directory.
    keyring: String?
    /// The keyserver used to retrieve key from.
    keyserver: String?
    /// Ensures that the key is present (added) or absent (revoked).
    state: ("absent"|"present")?
    /// The URL to retrieve keyfile from.
    /// Remote file must be of C(PGP PUBLIC KEY BLOCK) type.
    url: String?
    /// Whether or not to verify the keyfile's key ID against specified key ID.
    verify: Boolean?
}

/// Task class for pacman_key
class PacmanKeyTask extends Playbook.Task {
    /// todo doc
    `community.general.pacman_key`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.pacman_key"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.pacman_key`
}

/// TaskBuilder class for pacman_key
class PacmanKey extends Playbook.TaskBuilder {
    /// Options for community.general.pacman_key
    options: PacmanKeyOptions?
    /// todo doc
    function Task(): PacmanKeyTask = this
        .toMap()
        .put("community.general.pacman_key", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PacmanKeyTask)
}

/// Create PagerDuty maintenance windows
/// This module will let you create PagerDuty maintenance windows
class PagerdutyOptions {
    /// Short description of maintenance window.
    desc: String?
    /// Length of maintenance window in hours.
    hours: String?
    /// Maintenance window in minutes (this is added to the hours).
    minutes: String?
    /// PagerDuty unique subdomain. Obsolete. It is not used with PagerDuty REST v2 API.
    name: String?
    /// ID of user making the request. Only needed when creating a maintenance_window.
    requester_id: String?
    /// A comma separated list of PagerDuty service IDs.
    service: Listing<String>?
    /// Create a maintenance window or get a list of ongoing windows.
    state: ("running"|"started"|"ongoing"|"absent")
    /// A pagerduty token, generated on the pagerduty site. It is used for authorization.
    token: String
    /// PagerDuty user ID. Obsolete. Please, use O(token) for authorization.
    user: String?
    /// If V(false), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
    validate_certs: Boolean?
    /// ID of maintenance window. Only needed when absent a maintenance_window.
    window_id: String?
}

/// Task class for pagerduty
class PagerdutyTask extends Playbook.Task {
    /// todo doc
    `community.general.pagerduty`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.pagerduty"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.pagerduty`
}

/// TaskBuilder class for pagerduty
class Pagerduty extends Playbook.TaskBuilder {
    /// Options for community.general.pagerduty
    options: PagerdutyOptions?
    /// todo doc
    function Task(): PagerdutyTask = this
        .toMap()
        .put("community.general.pagerduty", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PagerdutyTask)
}

/// Trigger, acknowledge or resolve PagerDuty incidents
/// This module will let you trigger, acknowledge or resolve a PagerDuty incident by sending events
class PagerdutyAlertOptions {
    /// The pagerduty API key (readonly access), generated on the pagerduty site.
    /// Required if O(api_version=v1).
    api_key: String?
    /// The API version we want to use to run the module.
    /// V1 is more limited with option we can provide to trigger incident.
    /// V2 has more variables for example, O(severity), O(source), O(custom_details), etc.
    api_version: ("v1"|"v2")?
    /// The name of the monitoring client that is triggering this event.
    client: String?
    /// The URL of the monitoring client that is triggering this event.
    client_url: String?
    /// Component of the source machine that is responsible for the event, for example C(mysql) or C(eth0).
    component: String?
    /// Additional details about the event and affected system.
    /// A dictionary with custom keys and values.
    custom_details: Any?
    /// For O(state=triggered) - Required. Short description of the problem that led to this trigger. This field (or a truncated version) will be used when generating phone calls, SMS messages and alert emails. It will also appear on the incidents tables in the PagerDuty UI. The maximum length is 1024 characters.
    /// For O(state=acknowledged) or O(state=resolved) - Text that will appear in the incident's log associated with this event.
    desc: String?
    /// The class/type of the event, for example C(ping failure) or C(cpu load).
    incident_class: String?
    /// Identifies the incident to which this O(state) should be applied.
    /// For O(state=triggered) - If there's no open (i.e. unresolved) incident with this key, a new one will be created. If there's already an open incident with a matching key, this event will be appended to that incident's log. The event key provides an easy way to 'de-dup' problem reports. If no O(incident_key) is provided, then it will be generated by PagerDuty.
    /// For O(state=acknowledged) or O(state=resolved) - This should be the incident_key you received back when the incident was first opened by a trigger event. Acknowledge events referencing resolved or nonexistent incidents will be discarded.
    incident_key: String?
    /// The GUID of one of your 'Generic API' services.
    /// This is the 'integration key' listed on a 'Integrations' tab of PagerDuty service.
    integration_key: String?
    /// A short description of the link_url.
    link_text: String?
    /// Relevant link url to the alert. For example, the website or the job link.
    link_url: String?
    /// PagerDuty unique subdomain. Obsolete. It is not used with PagerDuty REST v2 API.
    name: String?
    /// ID of PagerDuty service when incidents will be triggered, acknowledged or resolved.
    /// Required if O(api_version=v1).
    service_id: String?
    /// The GUID of one of your 'Generic API' services. Obsolete. Please use O(integration_key).
    service_key: String?
    /// The perceived severity of the status the event is describing with respect to the affected system.
    /// Required in case of O(state=trigger) and O(api_version=v2).
    severity: ("critical"|"warning"|"error"|"info")?
    /// The unique location of the affected system, preferably a hostname or FQDN.
    /// Required in case of O(state=trigger) and O(api_version=v2).
    source: String?
    /// Type of event to be sent.
    state: ("triggered"|"acknowledged"|"resolved")
}

/// Task class for pagerduty_alert
class PagerdutyAlertTask extends Playbook.Task {
    /// todo doc
    `community.general.pagerduty_alert`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.pagerduty_alert"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.pagerduty_alert`
}

/// TaskBuilder class for pagerduty_alert
class PagerdutyAlert extends Playbook.TaskBuilder {
    /// Options for community.general.pagerduty_alert
    options: PagerdutyAlertOptions?
    /// todo doc
    function Task(): PagerdutyAlertTask = this
        .toMap()
        .put("community.general.pagerduty_alert", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PagerdutyAlertTask)
}

/// Track a code or infrastructure change as a PagerDuty change event
/// This module will let you create a PagerDuty change event each time the module is run.
/// This is not an idempotent action and a new change event will be created each time it is run.
class PagerdutyChangeOptions {
    /// The environment name, typically V(production), V(staging), and so on.
    environment: String?
    /// The integration key that identifies the service the change was made to. This can be found by adding an integration to a service in PagerDuty.
    integration_key: String
    /// Descriptive text for a URL where more information about the deployment can be obtained.
    link_text: String?
    /// A URL where more information about the deployment can be obtained.
    link_url: String?
    /// The URL of the project repository.
    repo: String?
    /// An identifier of the revision being deployed, typically a number or SHA from a version control system.
    revision: String?
    /// The source of the change event.
    source: String?
    /// A short description of the change that occurred.
    summary: String
    /// URL to submit the change event to.
    url: String?
    /// The name of the user or process that triggered this deployment.
    user: String?
    /// If V(false), SSL certificates for the target URL will not be validated. This should only be used on personally controlled sites using self-signed certificates.
    validate_certs: Boolean?
}

/// Task class for pagerduty_change
class PagerdutyChangeTask extends Playbook.Task {
    /// todo doc
    `community.general.pagerduty_change`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.pagerduty_change"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.pagerduty_change`
}

/// TaskBuilder class for pagerduty_change
class PagerdutyChange extends Playbook.TaskBuilder {
    /// Options for community.general.pagerduty_change
    options: PagerdutyChangeOptions?
    /// todo doc
    function Task(): PagerdutyChangeTask = this
        .toMap()
        .put("community.general.pagerduty_change", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PagerdutyChangeTask)
}

/// Manage a user account on PagerDuty
/// This module manages the creation/removal of a user account on PagerDuty.
class PagerdutyUserOptions {
    /// An API access token to authenticate with the PagerDuty REST API.
    access_token: String
    /// The user's email address.
    /// O(pd_email) is the unique identifier used and cannot be updated using this module.
    pd_email: String
    /// The user's role.
    pd_role: ("global_admin"|"manager"|"responder"|"observer"|"stakeholder"|"limited_stakeholder"|"restricted_access")?
    /// The teams to which the user belongs.
    /// Required if O(state=present).
    pd_teams: Listing<String>?
    /// Name of the user in PagerDuty.
    pd_user: String
    /// State of the user.
    /// On V(present), it creates a user if the user doesn't exist.
    /// On V(absent), it removes a user if the account exists.
    state: ("present"|"absent")?
}

/// Task class for pagerduty_user
class PagerdutyUserTask extends Playbook.Task {
    /// todo doc
    `community.general.pagerduty_user`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.pagerduty_user"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.pagerduty_user`
}

/// TaskBuilder class for pagerduty_user
class PagerdutyUser extends Playbook.TaskBuilder {
    /// Options for community.general.pagerduty_user
    options: PagerdutyUserOptions?
    /// todo doc
    function Task(): PagerdutyUserTask = this
        .toMap()
        .put("community.general.pagerduty_user", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PagerdutyUserTask)
}

/// Modify Linux PAM limits
/// The M(community.general.pam_limits) module modifies PAM limits.
/// The default file is V(/etc/security/limits.conf).
/// For the full documentation, see C(man 5 limits.conf).
class PamLimitsOptions {
    /// Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.
    backup: Boolean?
    /// Comment associated with the limit.
    comment: String?
    /// Modify the limits.conf path.
    dest: String?
    /// A username, @groupname, wildcard, UID/GID range.
    domain: String
    /// The limit to be set.
    limit_item: ("core"|"data"|"fsize"|"memlock"|"nofile"|"rss"|"stack"|"cpu"|"nproc"|"as"|"maxlogins"|"maxsyslogins"|"priority"|"locks"|"sigpending"|"msgqueue"|"nice"|"rtprio"|"chroot")
    /// Limit type, see C(man 5 limits.conf) for an explanation.
    limit_type: ("hard"|"soft"|"-")
    /// If set to V(true), the maximal value will be used or conserved.
    /// If the specified value is superior to the value in the file, file content is replaced with the new value, else content is not modified.
    use_max: Boolean?
    /// If set to V(true), the minimal value will be used or conserved.
    /// If the specified value is inferior to the value in the file, file content is replaced with the new value, else content is not modified.
    use_min: Boolean?
    /// The value of the limit.
    /// Value must either be V(unlimited), V(infinity) or V(-1), all of which indicate no limit, or a limit of 0 or larger.
    /// Value must be a number in the range -20 to 19 inclusive, if O(limit_item) is set to V(nice) or V(priority).
    /// Refer to the C(man 5 limits.conf) manual pages for more details.
    value: String
}

/// Task class for pam_limits
class PamLimitsTask extends Playbook.Task {
    /// todo doc
    `community.general.pam_limits`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.pam_limits"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.pam_limits`
}

/// TaskBuilder class for pam_limits
class PamLimits extends Playbook.TaskBuilder {
    /// Options for community.general.pam_limits
    options: PamLimitsOptions?
    /// todo doc
    function Task(): PamLimitsTask = this
        .toMap()
        .put("community.general.pam_limits", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PamLimitsTask)
}

/// Manage PAM Modules
/// Edit PAM service's type, control, module path and module arguments.
/// In order for a PAM rule to be modified, the type, control and module_path must match an existing rule. See man(5) pam.d for details.
class PamdOptions {
    /// Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.
    backup: Boolean?
    /// The control of the PAM rule being modified.
    /// This may be a complicated control with brackets. If this is the case, be sure to put "[bracketed controls]" in quotes.
    /// The O(type), O(control), and O(module_path) options all must match a rule to be modified.
    control: String
    /// When O(state=updated), the O(module_arguments) will replace existing module_arguments.
    /// When O(state=args_absent) args matching those listed in O(module_arguments) will be removed.
    /// When O(state=args_present) any args listed in O(module_arguments) are added if missing from the existing rule.
    /// Furthermore, if the module argument takes a value denoted by C(=), the value will be changed to that specified in module_arguments.
    module_arguments: Listing<String>?
    /// The module path of the PAM rule being modified.
    /// The O(type), O(control), and O(module_path) options all must match a rule to be modified.
    module_path: String
    /// The name generally refers to the PAM service file to change, for example system-auth.
    name: String
    /// The new control to assign to the new rule.
    new_control: String?
    /// The new module path to be assigned to the new rule.
    new_module_path: String?
    /// The new type to assign to the new rule.
    new_type: ("account"|"-account"|"auth"|"-auth"|"password"|"-password"|"session"|"-session")?
    /// This is the path to the PAM service files.
    path: String?
    /// The default of V(updated) will modify an existing rule if type, control and module_path all match an existing rule.
    /// With V(before), the new rule will be inserted before a rule matching type, control and module_path.
    /// Similarly, with V(after), the new rule will be inserted after an existing rulematching type, control and module_path.
    /// With either V(before) or V(after) O(new_type), O(new_control), and O(new_module_path) must all be specified.
    /// If state is V(args_absent) or V(args_present), O(new_type), O(new_control), and O(new_module_path) will be ignored.
    /// State V(absent) will remove the rule.
    state: ("absent"|"before"|"after"|"args_absent"|"args_present"|"updated")?
    /// The type of the PAM rule being modified.
    /// The O(type), O(control), and O(module_path) options all must match a rule to be modified.
    type: ("account"|"-account"|"auth"|"-auth"|"password"|"-password"|"session"|"-session")
}

/// Task class for pamd
class PamdTask extends Playbook.Task {
    /// todo doc
    `community.general.pamd`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.pamd"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.pamd`
}

/// TaskBuilder class for pamd
class Pamd extends Playbook.TaskBuilder {
    /// Options for community.general.pamd
    options: PamdOptions?
    /// todo doc
    function Task(): PamdTask = this
        .toMap()
        .put("community.general.pamd", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PamdTask)
}

/// Configure block device partitions
/// This module allows configuring block device partition using the C(parted) command line tool. For a full description of the fields and the options check the GNU parted manual.
class PartedOptions {
    /// Set alignment for newly created partitions. Use V(undefined) for parted default alignment.
    align: ("cylinder"|"minimal"|"none"|"optimal"|"undefined")?
    /// The block device (disk) where to operate.
    /// Regular files can also be partitioned, but it is recommended to create a loopback device using C(losetup) to easily access its partitions.
    device: String
    /// A list of the flags that has to be set on the partition.
    flags: Listing<String>?
    /// If specified and the partition does not exist, will set filesystem type to given partition.
    /// Parameter optional, but see notes below about negative O(part_start) values.
    fs_type: String?
    /// Disk label type or partition table to use.
    /// If O(device) already contains a different label, it will be changed to O(label) and any previous partitions will be lost.
    /// A O(name) must be specified for a V(gpt) partition table.
    label: ("aix"|"amiga"|"bsd"|"dvh"|"gpt"|"loop"|"mac"|"msdos"|"pc98"|"sun")?
    /// Sets the name for the partition number (GPT, Mac, MIPS and PC98 only).
    name: String?
    /// The partition number being affected.
    /// Required when performing any action on the disk, except fetching information.
    number: Int?
    /// Where the partition will end as offset from the beginning of the disk, that is, the "distance" from the start of the disk. Negative numbers specify distance from the end of the disk.
    /// The distance can be specified with all the units supported by parted (except compat) and it is case sensitive, for example V(10GiB), V(15%).
    part_end: String?
    /// Where the partition will start as offset from the beginning of the disk, that is, the "distance" from the start of the disk. Negative numbers specify distance from the end of the disk.
    /// The distance can be specified with all the units supported by parted (except compat) and it is case sensitive, for example V(10GiB), V(15%).
    /// Using negative values may require setting of O(fs_type) (see notes).
    part_start: String?
    /// May be specified only with O(label=msdos) or O(label=dvh).
    /// Neither O(part_type) nor O(name) may be used with O(label=sun).
    part_type: ("extended"|"logical"|"primary")?
    /// Call C(resizepart) on existing partitions to match the size specified by O(part_end).
    resize: Boolean?
    /// Whether to create or delete a partition.
    /// If set to V(info) the module will only return the device information.
    state: ("absent"|"present"|"info")?
    /// Selects the current default unit that Parted will use to display locations and capacities on the disk and to interpret those given by the user if they are not suffixed by an unit.
    /// When fetching information about a disk, it is recommended to always specify a unit.
    unit: ("s"|"B"|"KB"|"KiB"|"MB"|"MiB"|"GB"|"GiB"|"TB"|"TiB"|"%"|"cyl"|"chs"|"compact")?
}

/// Task class for parted
class PartedTask extends Playbook.Task {
    /// todo doc
    `community.general.parted`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.parted"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.parted`
}

/// TaskBuilder class for parted
class Parted extends Playbook.TaskBuilder {
    /// Options for community.general.parted
    options: PartedOptions?
    /// todo doc
    function Task(): PartedTask = this
        .toMap()
        .put("community.general.parted", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PartedTask)
}

/// Manage pear/pecl packages
/// Manage PHP packages with the pear package manager.
class PearOptions {
    /// Path to the pear executable.
    executable: String?
    /// Name of the package to install, upgrade, or remove.
    name: String
    /// List of regular expressions that can be used to detect prompts during pear package installation to answer the expected question.
    /// Prompts will be processed in the same order as the packages list.
    /// You can optionally specify an answer to any question in the list.
    /// If no answer is provided, the list item will only contain the regular expression.
    /// To specify an answer, the item will be a dict with the regular expression as key and the answer as value C(my_regular_expression: 'an_answer').
    /// You can provide a list containing items with or without answer.
    /// A prompt list can be shorter or longer than the packages list but will issue a warning.
    /// If you want to specify that a package will not need prompts in the middle of a list,  V(null).
    prompts: Listing<String>?
    /// Desired state of the package.
    state: ("present"|"installed"|"latest"|"absent"|"removed")?
}

/// Task class for pear
class PearTask extends Playbook.Task {
    /// todo doc
    `community.general.pear`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.pear"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.pear`
}

/// TaskBuilder class for pear
class Pear extends Playbook.TaskBuilder {
    /// Options for community.general.pear
    options: PearOptions?
    /// todo doc
    function Task(): PearTask = this
        .toMap()
        .put("community.general.pear", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PearTask)
}

/// Retrieves process IDs list if the process is running otherwise return empty list
/// Retrieves a list of PIDs of given process name in Ansible controller/controlled machines.Returns an empty list if no process in that name exists.
class PidsOptions {
    /// Ignore case in pattern if using the O(pattern) option.
    ignore_case: Boolean?
    /// The name of the process(es) you want to get PID(s) for.
    name: String?
    /// The pattern (regular expression) to match the process(es) you want to get PID(s) for.
    pattern: String?
}

/// Task class for pids
class PidsTask extends Playbook.Task {
    /// todo doc
    `community.general.pids`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.pids"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.pids`
}

/// TaskBuilder class for pids
class Pids extends Playbook.TaskBuilder {
    /// Options for community.general.pids
    options: PidsOptions?
    /// todo doc
    function Task(): PidsTask = this
        .toMap()
        .put("community.general.pids", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PidsTask)
}

/// Pause/unpause Pingdom alerts
/// This module will let you pause/unpause Pingdom alerts
class PingdomOptions {
    /// Pingdom ID of the check.
    checkid: String
    /// Pingdom API key.
    key: String
    /// Pingdom user password.
    passwd: String
    /// Define whether or not the check should be running or paused.
    state: ("running"|"paused"|"started"|"stopped")
    /// Pingdom user ID.
    uid: String
}

/// Task class for pingdom
class PingdomTask extends Playbook.Task {
    /// todo doc
    `community.general.pingdom`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.pingdom"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.pingdom`
}

/// TaskBuilder class for pingdom
class Pingdom extends Playbook.TaskBuilder {
    /// Options for community.general.pingdom
    options: PingdomOptions?
    /// todo doc
    function Task(): PingdomTask = this
        .toMap()
        .put("community.general.pingdom", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PingdomTask)
}

/// Pip package information
/// Return information about installed pip packages
class PipPackageInfoOptions {
    /// A list of the pip executables that will be used to get the packages. They can be supplied with the full path or just the executable name, for example V(pip3.7).
    clients: Listing<String>?
}

/// Task class for pip_package_info
class PipPackageInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.pip_package_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.pip_package_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.pip_package_info`
}

/// TaskBuilder class for pip_package_info
class PipPackageInfo extends Playbook.TaskBuilder {
    /// Options for community.general.pip_package_info
    options: PipPackageInfoOptions?
    /// todo doc
    function Task(): PipPackageInfoTask = this
        .toMap()
        .put("community.general.pip_package_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PipPackageInfoTask)
}

/// Manages applications installed with pipx
/// Manage Python applications installed in isolated virtualenvs using pipx.
class PipxOptions {
    /// Install the project in editable mode.
    editable: Boolean?
    /// Path to the C(pipx) installed in the system.
    /// If not specified, the module will use C(python -m pipx) to run the tool, using the same Python interpreter as ansible itself.
    executable: String?
    /// Force modification of the application's virtual environment. See C(pipx) for details.
    /// Only used when O(state=install), O(state=upgrade), O(state=upgrade_all), O(state=latest), or O(state=inject).
    force: Boolean?
    /// Upgrade the injected packages along with the application.
    /// Only used when O(state=upgrade), O(state=upgrade_all), or O(state=latest).
    /// This is used with O(state=upgrade) and O(state=latest) since community.general 6.6.0.
    include_injected: Boolean?
    /// Base URL of Python Package Index.
    /// Only used when O(state=install), O(state=upgrade), O(state=latest), or O(state=inject).
    index_url: String?
    /// Packages to be injected into an existing virtual environment.
    /// Only used when O(state=inject).
    inject_packages: Listing<String>?
    /// Add apps from the injected packages.
    /// Only used when O(state=inject).
    install_apps: Boolean?
    /// Include applications of dependent packages.
    /// Only used when O(state=install), O(state=latest), or O(state=inject).
    install_deps: Boolean?
    /// The name of the application to be installed. It must to be a simple package name. For passing package specifications or installing from URLs or directories, please use the O(source) option.
    name: String?
    /// Arbitrary arguments to pass directly to C(pip).
    pip_args: String?
    /// Python version to be used when creating the application virtual environment. Must be 3.6+.
    /// Only used when O(state=install), O(state=latest), O(state=reinstall), or O(state=reinstall_all).
    python: String?
    /// If the application source, such as a package with version specifier, or an URL, directory or any other accepted specification. See C(pipx) documentation for more details.
    /// When specified, the C(pipx) command will use O(source) instead of O(name).
    source: String?
    /// Desired state for the application.
    /// The states V(present) and V(absent) are aliases to V(install) and V(uninstall), respectively.
    /// The state V(latest) is equivalent to executing the task twice, with state V(install) and then V(upgrade). It was added in community.general 5.5.0.
    state: ("present"|"absent"|"install"|"uninstall"|"uninstall_all"|"inject"|"upgrade"|"upgrade_all"|"reinstall"|"reinstall_all"|"latest")?
    /// Give application virtual environment access to the system site-packages directory.
    /// Only used when O(state=install) or O(state=latest).
    system_site_packages: Boolean?
}

/// Task class for pipx
class PipxTask extends Playbook.Task {
    /// todo doc
    `community.general.pipx`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.pipx"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.pipx`
}

/// TaskBuilder class for pipx
class Pipx extends Playbook.TaskBuilder {
    /// Options for community.general.pipx
    options: PipxOptions?
    /// todo doc
    function Task(): PipxTask = this
        .toMap()
        .put("community.general.pipx", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PipxTask)
}

/// Rretrieves information about applications installed with pipx
/// Retrieve details about Python applications installed in isolated virtualenvs using pipx.
class PipxInfoOptions {
    /// Path to the C(pipx) installed in the system.
    /// If not specified, the module will use C(python -m pipx) to run the tool, using the same Python interpreter as ansible itself.
    executable: String?
    /// Include dependent packages in the output.
    include_deps: Boolean?
    /// Include injected packages in the output.
    include_injected: Boolean?
    /// Returns the raw output of C(pipx list --json).
    /// The raw output is not affected by O(include_deps) or O(include_injected).
    include_raw: Boolean?
    /// Name of an application installed with C(pipx).
    name: String?
}

/// Task class for pipx_info
class PipxInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.pipx_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.pipx_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.pipx_info`
}

/// TaskBuilder class for pipx_info
class PipxInfo extends Playbook.TaskBuilder {
    /// Options for community.general.pipx_info
    options: PipxInfoOptions?
    /// todo doc
    function Task(): PipxInfoTask = this
        .toMap()
        .put("community.general.pipx_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PipxInfoTask)
}

/// Manages packages with the Solaris 11 Image Packaging System
/// IPS packages are the native packages in Solaris 11 and higher.
class Pkg5Options {
    /// Accept any licences.
    accept_licenses: Boolean?
    /// Creates a new boot environment with the given name.
    be_name: String?
    /// An FRMI of the package(s) to be installed/removed/updated.
    /// Multiple packages may be specified, separated by V(,).
    name: Listing<String>
    /// Refresh publishers before execution.
    refresh: Boolean?
    /// Whether to install (V(present), V(latest)), or remove (V(absent)) a package.
    state: ("absent"|"latest"|"present"|"installed"|"removed"|"uninstalled")?
}

/// Task class for pkg5
class Pkg5Task extends Playbook.Task {
    /// todo doc
    `community.general.pkg5`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.pkg5"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.pkg5`
}

/// TaskBuilder class for pkg5
class Pkg5 extends Playbook.TaskBuilder {
    /// Options for community.general.pkg5
    options: Pkg5Options?
    /// todo doc
    function Task(): Pkg5Task = this
        .toMap()
        .put("community.general.pkg5", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(Pkg5Task)
}

/// Manages Solaris 11 Image Packaging System publishers
/// IPS packages are the native packages in Solaris 11 and higher.
/// This modules will configure which publishers a client will download IPS packages from.
class Pkg5PublisherOptions {
    /// Is the repository enabled or disabled?
    enabled: Boolean?
    /// A path or URL to the repository mirror.
    /// Multiple values may be provided.
    mirror: Listing<String>?
    /// The publisher's name.
    name: String
    /// A path or URL to the repository.
    /// Multiple values may be provided.
    origin: Listing<String>?
    /// Whether to ensure that a publisher is present or absent.
    state: ("present"|"absent")?
    /// Packages installed from a sticky repository can only receive updates from that repository.
    sticky: Boolean?
}

/// Task class for pkg5_publisher
class Pkg5PublisherTask extends Playbook.Task {
    /// todo doc
    `community.general.pkg5_publisher`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.pkg5_publisher"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.pkg5_publisher`
}

/// TaskBuilder class for pkg5_publisher
class Pkg5Publisher extends Playbook.TaskBuilder {
    /// Options for community.general.pkg5_publisher
    options: Pkg5PublisherOptions?
    /// todo doc
    function Task(): Pkg5PublisherTask = this
        .toMap()
        .put("community.general.pkg5_publisher", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(Pkg5PublisherTask)
}

/// Package manager for SmartOS, NetBSD, et al
/// The standard package manager for SmartOS, but also usable on NetBSD or any OS that uses C(pkgsrc).  (Home: U(http://pkgin.net/))
class PkginOptions {
    /// Clean packages cache
    clean: Boolean?
    /// Force package reinstall
    force: Boolean?
    /// Upgrade all packages to their newer versions
    full_upgrade: Boolean?
    /// Name of package to install/remove;
    /// multiple names may be given, separated by commas
    name: Listing<String>?
    /// Intended state of the package
    state: ("present"|"absent")?
    /// Update repository database. Can be run with other steps or on it's own.
    update_cache: Boolean?
    /// Upgrade main packages to their newer versions
    upgrade: Boolean?
}

/// Task class for pkgin
class PkginTask extends Playbook.Task {
    /// todo doc
    `community.general.pkgin`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.pkgin"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.pkgin`
}

/// TaskBuilder class for pkgin
class Pkgin extends Playbook.TaskBuilder {
    /// Options for community.general.pkgin
    options: PkginOptions?
    /// todo doc
    function Task(): PkginTask = this
        .toMap()
        .put("community.general.pkgin", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PkginTask)
}

/// Package manager for FreeBSD >= 9.0
/// Manage binary packages for FreeBSD using 'pkgng' which is available in versions after 9.0.
class PkgngOptions {
    /// A list of keyvalue-pairs of the form C(<+/-/:><key>[=<value>]). A V(+) denotes adding an annotation, a V(-) denotes removing an annotation, and V(:) denotes modifying an annotation. If setting or modifying annotations, a value must be provided.
    annotation: Listing<String>?
    /// Remove automatically installed packages which are no longer needed.
    autoremove: Boolean?
    /// Use local package base instead of fetching an updated one.
    cached: Boolean?
    /// Pkg will chroot in the specified environment.
    /// Can not be used together with O(rootdir) or O(jail) options.
    chroot: String?
    /// Ignore FreeBSD OS version check, useful on -STABLE and -CURRENT branches.
    /// Defines the E(IGNORE_OSVERSION) environment variable.
    ignore_osver: Boolean?
    /// Pkg will execute in the given jail name or id.
    /// Can not be used together with O(chroot) or O(rootdir) options.
    jail: String?
    /// Name or list of names of packages to install/remove.
    /// With O(name=*), O(state=latest) will operate, but O(state=present) and O(state=absent) will be noops.
    name: Listing<String>
    /// For pkgng versions before 1.1.4, specify packagesite to use for downloading packages. If not specified, use settings from C(/usr/local/etc/pkg.conf).
    /// For newer pkgng versions, specify a the name of a repository configured in C(/usr/local/etc/pkg/repos).
    pkgsite: String?
    /// For pkgng versions 1.5 and later, pkg will install all packages within the specified root directory.
    /// Can not be used together with O(chroot) or O(jail) options.
    rootdir: String?
    /// State of the package.
    state: ("present"|"latest"|"absent")?
}

/// Task class for pkgng
class PkgngTask extends Playbook.Task {
    /// todo doc
    `community.general.pkgng`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.pkgng"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.pkgng`
}

/// TaskBuilder class for pkgng
class Pkgng extends Playbook.TaskBuilder {
    /// Options for community.general.pkgng
    options: PkgngOptions?
    /// todo doc
    function Task(): PkgngTask = this
        .toMap()
        .put("community.general.pkgng", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PkgngTask)
}

/// OpenCSW package management on Solaris
/// This module installs, updates and removes packages from the OpenCSW project for Solaris.
/// Unlike the M(community.general.svr4pkg) module, it will resolve and download dependencies.
/// See U(https://www.opencsw.org/) for more information about the project.
class PkgutilOptions {
    /// To allow the update process to downgrade packages to match what is present in the repository, set this to V(true).
    /// This is useful for rolling back to stable from testing, or similar operations.
    force: Boolean?
    /// The name of the package.
    /// When using O(state=latest), this can be V('*'), which updates all installed packages managed by pkgutil.
    name: Listing<String>
    /// The repository path to install the package from.
    /// Its global definition is in C(/etc/opt/csw/pkgutil.conf).
    site: String?
    /// Whether to install (V(present)/V(installed)), or remove (V(absent)/V(removed)) packages.
    /// The upgrade (V(latest)) operation will update/install the packages to the latest version available.
    state: ("absent"|"installed"|"latest"|"present"|"removed")
    /// If you always want to refresh your catalog from the mirror, even when it's not stale, set this to V(true).
    update_catalog: Boolean?
}

/// Task class for pkgutil
class PkgutilTask extends Playbook.Task {
    /// todo doc
    `community.general.pkgutil`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.pkgutil"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.pkgutil`
}

/// TaskBuilder class for pkgutil
class Pkgutil extends Playbook.TaskBuilder {
    /// Options for community.general.pkgutil
    options: PkgutilOptions?
    /// todo doc
    function Task(): PkgutilTask = this
        .toMap()
        .put("community.general.pkgutil", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PkgutilTask)
}

/// Configure Intel Optane Persistent Memory modules
/// This module allows Configuring Intel Optane Persistent Memory modules (PMem) using ipmctl and ndctl command line tools.
class PmemOptions {
    /// Percentage of the total capacity to use in AppDirect Mode (V(0)-V(100)).
    /// Create AppDirect capacity utilizing hardware interleaving across the requested PMem modules if applicable given the specified target.
    /// Total of O(appdirect), O(memorymode) and O(reserved) must be V(100)
    appdirect: Int?
    /// Create AppDirect capacity that is interleaved any other PMem modules.
    appdirect_interleaved: Boolean?
    /// Percentage of the total capacity to use in Memory Mode (V(0)-V(100)).
    memorymode: Int?
    /// This enables to set the configuration for the namespace of the PMem.
    namespace: Listing<Any>?
    /// Enable to append the new namespaces to the system.
    /// The default is V(false) so the all existing namespaces not listed in O(namespace) are removed.
    namespace_append: Boolean?
    /// Percentage of the capacity to reserve (V(0)-V(100)). O(reserved) will not be mapped into the system physical address space and will be presented as reserved capacity with Show Device and Show Memory Resources Commands.
    /// O(reserved) will be set automatically if this is not configured.
    reserved: Int?
    /// This enables to set the configuration for each socket by using the socket ID.
    /// Total of O(appdirect), O(memorymode) and O(reserved) must be V(100) within one socket.
    socket: Listing<Any>?
}

/// Task class for pmem
class PmemTask extends Playbook.Task {
    /// todo doc
    `community.general.pmem`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.pmem"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.pmem`
}

/// TaskBuilder class for pmem
class Pmem extends Playbook.TaskBuilder {
    /// Options for community.general.pmem
    options: PmemOptions?
    /// todo doc
    function Task(): PmemTask = this
        .toMap()
        .put("community.general.pmem", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PmemTask)
}

/// Manage node.js packages with pnpm
/// Manage node.js packages with the L(pnpm package manager, https://pnpm.io/).
class PnpmOptions {
    /// Alias of the node.js library.
    alias: String?
    /// Install dependencies in development mode.
    /// Pnpm will ignore any regular dependencies in C(package.json).
    dev: Boolean?
    /// The executable location for pnpm.
    /// The default location it searches for is E(PATH), fails if not set.
    executable: String?
    /// Install the node.js library globally.
    global: Boolean?
    /// Use the C(--ignore-scripts) flag when installing.
    ignore_scripts: Boolean?
    /// The name of a node.js library to install.
    /// All packages in package.json are installed if not provided.
    name: String?
    /// Do not install optional packages, equivalent to C(--no-optional).
    no_optional: Boolean?
    /// Install dependencies in optional mode.
    optional: Boolean?
    /// The base path to install the node.js libraries.
    path: String?
    /// Install dependencies in production mode.
    /// Pnpm will ignore any dependencies under C(devDependencies) in package.json.
    production: Boolean?
    /// Installation state of the named node.js library.
    /// If V(absent) is selected, a name option must be provided.
    state: ("present"|"absent"|"latest")?
    /// The version of the library to be installed, in semver format.
    version: String?
}

/// Task class for pnpm
class PnpmTask extends Playbook.Task {
    /// todo doc
    `community.general.pnpm`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.pnpm"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.pnpm`
}

/// TaskBuilder class for pnpm
class Pnpm extends Playbook.TaskBuilder {
    /// Options for community.general.pnpm
    options: PnpmOptions?
    /// todo doc
    function Task(): PnpmTask = this
        .toMap()
        .put("community.general.pnpm", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PnpmTask)
}

/// Package manager for Gentoo
/// Manages Gentoo packages
class PortageOptions {
    /// Set backtrack value (C(--backtrack)).
    backtrack: Int?
    /// Include installed packages where USE flags have changed, except when
    /// flags that the user has not enabled are added or removed
    /// (--changed-use)
    changed_use: Boolean?
    /// Consider the entire dependency tree of packages (--deep)
    deep: Boolean?
    /// Remove packages not needed by explicitly merged packages (--depclean)
    /// If no package is specified, clean up the world's dependencies
    /// Otherwise, --depclean serves as a dependency aware version of --unmerge
    depclean: Boolean?
    /// Prefer packages specified at C(PORTAGE_BINHOST) in C(make.conf).
    getbinpkg: Boolean?
    /// Merge only packages specified at C(PORTAGE_BINHOST) in C(make.conf).
    getbinpkgonly: Boolean?
    /// Specifies the number of packages to build simultaneously.
    /// Since version 2.6: Value of 0 or False resets any previously added
    /// --jobs setting values
    jobs: Int?
    /// Continue as much as possible after an error.
    keepgoing: Boolean?
    /// Specifies that no new builds should be started if there are
    /// other builds running and the load average is at least LOAD
    /// Since version 2.6: Value of 0 or False resets any previously added
    /// --load-average setting values
    loadavg: Any?
    /// Include installed packages where USE flags have changed (--newuse)
    newuse: Boolean?
    /// Only merge packages but not their dependencies (--nodeps)
    nodeps: Boolean?
    /// Do not re-emerge installed packages (--noreplace)
    noreplace: Boolean?
    /// Do not add the packages to the world file (--oneshot)
    oneshot: Boolean?
    /// Only merge packages' dependencies but not the packages (--onlydeps)
    onlydeps: Boolean?
    /// Package atom or set, for example V(sys-apps/foo) or V(>foo-2.13) or V(@world)
    package: Listing<String>?
    /// Run emerge in quiet mode (--quiet)
    quiet: Boolean?
    /// Redirect all build output to logs alone, and do not display it
    /// on stdout (--quiet-build)
    quietbuild: Boolean?
    /// Suppresses display of the build log on stdout (--quiet-fail)
    /// Only the die message and the path of the build log will be
    /// displayed on stdout.
    quietfail: Boolean?
    /// If set to V(true), explicitely add the package to the world file.
    /// Please note that this option is not used for idempotency, it is only used when actually installing a package.
    select: Boolean?
    /// State of the package atom
    state: ("present"|"installed"|"emerged"|"absent"|"removed"|"unmerged"|"latest")?
    /// Sync package repositories first
    /// If V(yes), perform "emerge --sync"
    /// If V(web), perform "emerge-webrsync"
    sync: ("web"|"yes"|"no")?
    /// Update packages to the best version available (--update)
    update: Boolean?
    /// Tries to use the binary package(s) in the locally available packages directory.
    usepkg: Boolean?
    /// Merge only binaries (no compiling).
    usepkgonly: Boolean?
    /// Run emerge in verbose mode (--verbose)
    verbose: Boolean?
    /// Specifies that build time dependencies should be installed.
    withbdeps: Boolean?
}

/// Task class for portage
class PortageTask extends Playbook.Task {
    /// todo doc
    `community.general.portage`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.portage"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.portage`
}

/// TaskBuilder class for portage
class Portage extends Playbook.TaskBuilder {
    /// Options for community.general.portage
    options: PortageOptions?
    /// todo doc
    function Task(): PortageTask = this
        .toMap()
        .put("community.general.portage", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PortageTask)
}

/// Installing packages from FreeBSD's ports system
/// Manage packages for FreeBSD using 'portinstall'.
class PortinstallOptions {
    /// name of package to install/remove
    name: String
    /// state of the package
    state: ("present"|"absent")?
    /// use packages instead of ports whenever available
    use_packages: Boolean?
}

/// Task class for portinstall
class PortinstallTask extends Playbook.Task {
    /// todo doc
    `community.general.portinstall`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.portinstall"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.portinstall`
}

/// TaskBuilder class for portinstall
class Portinstall extends Playbook.TaskBuilder {
    /// Options for community.general.portinstall
    options: PortinstallOptions?
    /// todo doc
    function Task(): PortinstallTask = this
        .toMap()
        .put("community.general.portinstall", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PortinstallTask)
}

/// Manages Pritunl Organizations using the Pritunl API
/// A module to manage Pritunl organizations using the Pritunl API.
class PritunlOrgOptions {
    /// If O(force) is V(true) and O(state) is V(absent), the module will delete the organization, no matter if it contains users or not. By default O(force) is V(false), which will cause the module to fail the deletion of the organization when it contains users.
    force: Boolean?
    /// The name of the organization to manage in Pritunl.
    name: String
    /// If V(present), the module adds organization O(name) to Pritunl. If V(absent), attempt to delete the organization from Pritunl (please read about O(force) usage).
    state: ("present"|"absent")?
}

/// Task class for pritunl_org
class PritunlOrgTask extends Playbook.Task {
    /// todo doc
    `community.general.pritunl_org`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.pritunl_org"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.pritunl_org`
}

/// TaskBuilder class for pritunl_org
class PritunlOrg extends Playbook.TaskBuilder {
    /// Options for community.general.pritunl_org
    options: PritunlOrgOptions?
    /// todo doc
    function Task(): PritunlOrgTask = this
        .toMap()
        .put("community.general.pritunl_org", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PritunlOrgTask)
}

/// List Pritunl Organizations using the Pritunl API
/// A module to list Pritunl organizations using the Pritunl API.
class PritunlOrgInfoOptions {
    /// Name of the Pritunl organization to search for. If none provided, the module will return all Pritunl organizations.
    organization: String?
}

/// Task class for pritunl_org_info
class PritunlOrgInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.pritunl_org_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.pritunl_org_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.pritunl_org_info`
}

/// TaskBuilder class for pritunl_org_info
class PritunlOrgInfo extends Playbook.TaskBuilder {
    /// Options for community.general.pritunl_org_info
    options: PritunlOrgInfoOptions?
    /// todo doc
    function Task(): PritunlOrgInfoTask = this
        .toMap()
        .put("community.general.pritunl_org_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PritunlOrgInfoTask)
}

/// Manage Pritunl Users using the Pritunl API
/// A module to manage Pritunl users using the Pritunl API.
class PritunlUserOptions {
    /// The name of the organization the user is part of.
    organization: String
    /// If V(present), the module adds user O(user_name) to the Pritunl O(organization). If V(absent), removes the user O(user_name) from the Pritunl O(organization).
    state: ("present"|"absent")?
    /// Enable/Disable the user O(user_name).
    user_disabled: Boolean?
    /// Email address associated with the user O(user_name).
    user_email: String?
    /// Enable/Disable Gravatar usage for the user O(user_name).
    user_gravatar: Boolean?
    /// List of groups associated with the user O(user_name).
    user_groups: Listing<String>?
    /// Allowed MAC addresses for the user O(user_name).
    user_mac_addresses: Listing<String>?
    /// Name of the user to create or delete from Pritunl.
    user_name: String
    /// Type of the user O(user_name).
    user_type: ("client"|"server")?
}

/// Task class for pritunl_user
class PritunlUserTask extends Playbook.Task {
    /// todo doc
    `community.general.pritunl_user`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.pritunl_user"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.pritunl_user`
}

/// TaskBuilder class for pritunl_user
class PritunlUser extends Playbook.TaskBuilder {
    /// Options for community.general.pritunl_user
    options: PritunlUserOptions?
    /// todo doc
    function Task(): PritunlUserTask = this
        .toMap()
        .put("community.general.pritunl_user", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PritunlUserTask)
}

/// List Pritunl Users using the Pritunl API
/// A module to list Pritunl users using the Pritunl API.
class PritunlUserInfoOptions {
    /// The name of the organization the user is part of.
    organization: String
    /// Name of the user to filter on Pritunl.
    user_name: String?
    /// Type of the user O(user_name).
    user_type: ("client"|"server")?
}

/// Task class for pritunl_user_info
class PritunlUserInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.pritunl_user_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.pritunl_user_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.pritunl_user_info`
}

/// TaskBuilder class for pritunl_user_info
class PritunlUserInfo extends Playbook.TaskBuilder {
    /// Options for community.general.pritunl_user_info
    options: PritunlUserInfoOptions?
    /// todo doc
    function Task(): PritunlUserInfoTask = this
        .toMap()
        .put("community.general.pritunl_user_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PritunlUserInfoTask)
}

/// Create, destroy, start, stop, and reboot a ProfitBricks virtual machine
/// Create, destroy, update, start, stop, and reboot a ProfitBricks virtual machine. When the virtual machine is created it can optionally wait for it to be 'running' before returning. This module has a dependency on profitbricks >= 1.0.0
class ProfitbricksOptions {
    /// This will assign the machine to the public LAN. If no LAN exists with public Internet access it is created.
    assign_public_ip: Boolean?
    /// Whether or not to increment a single number in the name for created virtual machines.
    auto_increment: Boolean?
    /// The bus type for the volume.
    bus: ("IDE"|"VIRTIO")?
    /// The number of CPU cores to allocate to the virtual machine.
    cores: Int?
    /// The number of virtual machines to create.
    count: Int?
    /// The CPU family type to allocate to the virtual machine.
    cpu_family: ("AMD_OPTERON"|"INTEL_XEON")?
    /// The datacenter to provision this virtual machine.
    datacenter: String?
    /// the type of disk to be allocated.
    disk_type: ("SSD"|"HDD")?
    /// The system image ID for creating the virtual machine, e.g. a3eae284-a2fe-11e4-b187-5f1f641608c8.
    image: String?
    /// Password set for the administrative user.
    image_password: String?
    /// list of instance ids, currently only used when state='absent' to remove instances.
    instance_ids: Listing<String>?
    /// The ID of the LAN you wish to add the servers to.
    lan: Int?
    /// The datacenter location. Use only if you want to create the Datacenter or else this value is ignored.
    location: ("us/las"|"de/fra"|"de/fkb")?
    /// The name of the virtual machine.
    name: String?
    /// The amount of memory to allocate to the virtual machine.
    ram: Int?
    /// remove the bootVolume of the virtual machine you're destroying.
    remove_boot_volume: Boolean?
    /// Public SSH keys allowing access to the virtual machine.
    ssh_keys: Listing<String>?
    /// create or terminate instances
    /// The choices available are: V(running), V(stopped), V(absent), V(present).
    state: String?
    /// THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.
    subscription_password: String?
    /// The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.
    subscription_user: String?
    /// The size in GB of the boot volume.
    volume_size: Int?
    /// wait for the instance to be in state 'running' before returning
    wait: Boolean?
    /// how long before wait gives up, in seconds
    wait_timeout: Int?
}

/// Task class for profitbricks
class ProfitbricksTask extends Playbook.Task {
    /// todo doc
    `community.general.profitbricks`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.profitbricks"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.profitbricks`
}

/// TaskBuilder class for profitbricks
class Profitbricks extends Playbook.TaskBuilder {
    /// Options for community.general.profitbricks
    options: ProfitbricksOptions?
    /// todo doc
    function Task(): ProfitbricksTask = this
        .toMap()
        .put("community.general.profitbricks", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ProfitbricksTask)
}

/// Create or destroy a ProfitBricks Virtual Datacenter
/// This is a simple module that supports creating or removing vDCs. A vDC is required before you can create servers. This module has a dependency on profitbricks >= 1.0.0
class ProfitbricksDatacenterOptions {
    /// The description of the virtual datacenter.
    description: String?
    /// The datacenter location.
    location: ("us/las"|"de/fra"|"de/fkb")?
    /// The name of the virtual datacenter.
    name: String?
    /// Create or terminate datacenters.
    /// The available choices are: V(present), V(absent).
    state: String?
    /// THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.
    subscription_password: String?
    /// The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.
    subscription_user: String?
    /// wait for the datacenter to be created before returning
    wait: Boolean?
    /// how long before wait gives up, in seconds
    wait_timeout: Int?
}

/// Task class for profitbricks_datacenter
class ProfitbricksDatacenterTask extends Playbook.Task {
    /// todo doc
    `community.general.profitbricks_datacenter`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.profitbricks_datacenter"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.profitbricks_datacenter`
}

/// TaskBuilder class for profitbricks_datacenter
class ProfitbricksDatacenter extends Playbook.TaskBuilder {
    /// Options for community.general.profitbricks_datacenter
    options: ProfitbricksDatacenterOptions?
    /// todo doc
    function Task(): ProfitbricksDatacenterTask = this
        .toMap()
        .put("community.general.profitbricks_datacenter", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ProfitbricksDatacenterTask)
}

/// Create or Remove a NIC
/// This module allows you to create or restore a volume snapshot. This module has a dependency on profitbricks >= 1.0.0
class ProfitbricksNicOptions {
    /// The datacenter in which to operate.
    datacenter: String
    /// The LAN to place the NIC on. You can pass a LAN that doesn't exist and it will be created. Required on create.
    lan: String?
    /// The name or ID of the NIC. This is only required on deletes, but not on create.
    /// If not specified, it defaults to a value based on UUID4.
    name: String?
    /// The server name or ID.
    server: String
    /// Indicate desired state of the resource
    /// The available choices are: V(present), V(absent).
    state: String?
    /// THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.
    subscription_password: String
    /// The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.
    subscription_user: String
    /// wait for the operation to complete before returning
    wait: Boolean?
    /// how long before wait gives up, in seconds
    wait_timeout: Int?
}

/// Task class for profitbricks_nic
class ProfitbricksNicTask extends Playbook.Task {
    /// todo doc
    `community.general.profitbricks_nic`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.profitbricks_nic"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.profitbricks_nic`
}

/// TaskBuilder class for profitbricks_nic
class ProfitbricksNic extends Playbook.TaskBuilder {
    /// Options for community.general.profitbricks_nic
    options: ProfitbricksNicOptions?
    /// todo doc
    function Task(): ProfitbricksNicTask = this
        .toMap()
        .put("community.general.profitbricks_nic", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ProfitbricksNicTask)
}

/// Create or destroy a volume
/// Allows you to create or remove a volume from a ProfitBricks datacenter. This module has a dependency on profitbricks >= 1.0.0
class ProfitbricksVolumeOptions {
    /// Whether or not to increment a single number in the name for created virtual machines.
    auto_increment: Boolean?
    /// The bus type.
    bus: ("IDE"|"VIRTIO")?
    /// The number of volumes you wish to create.
    count: Int?
    /// The datacenter in which to create the volumes.
    datacenter: String?
    /// The disk type of the volume.
    disk_type: ("HDD"|"SSD")?
    /// The system image ID for the volume, e.g. a3eae284-a2fe-11e4-b187-5f1f641608c8. This can also be a snapshot image ID.
    image: String?
    /// Password set for the administrative user.
    image_password: String?
    /// list of instance ids, currently only used when state='absent' to remove instances.
    instance_ids: Listing<String>?
    /// The licence type for the volume. This is used when the image is non-standard.
    /// The available choices are: V(LINUX), V(WINDOWS), V(UNKNOWN), V(OTHER).
    licence_type: String?
    /// The name of the volumes. You can enumerate the names using auto_increment.
    name: String?
    /// Server name to attach the volume to.
    server: String?
    /// The size of the volume.
    size: Int?
    /// Public SSH keys allowing access to the virtual machine.
    ssh_keys: Listing<String>?
    /// create or terminate datacenters
    /// The available choices are: V(present), V(absent).
    state: String?
    /// THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.
    subscription_password: String?
    /// The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.
    subscription_user: String?
    /// wait for the datacenter to be created before returning
    wait: Boolean?
    /// how long before wait gives up, in seconds
    wait_timeout: Int?
}

/// Task class for profitbricks_volume
class ProfitbricksVolumeTask extends Playbook.Task {
    /// todo doc
    `community.general.profitbricks_volume`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.profitbricks_volume"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.profitbricks_volume`
}

/// TaskBuilder class for profitbricks_volume
class ProfitbricksVolume extends Playbook.TaskBuilder {
    /// Options for community.general.profitbricks_volume
    options: ProfitbricksVolumeOptions?
    /// todo doc
    function Task(): ProfitbricksVolumeTask = this
        .toMap()
        .put("community.general.profitbricks_volume", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ProfitbricksVolumeTask)
}

/// Attach or detach a volume
/// Allows you to attach or detach a volume from a ProfitBricks server. This module has a dependency on profitbricks >= 1.0.0
class ProfitbricksVolumeAttachmentsOptions {
    /// The datacenter in which to operate.
    datacenter: String?
    /// The name of the server you wish to detach or attach the volume.
    server: String?
    /// Indicate desired state of the resource
    /// The available choices are: V(present), V(absent).
    state: String?
    /// THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.
    subscription_password: String?
    /// The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.
    subscription_user: String?
    /// The volume name or ID.
    volume: String?
    /// wait for the operation to complete before returning
    wait: Boolean?
    /// how long before wait gives up, in seconds
    wait_timeout: Int?
}

/// Task class for profitbricks_volume_attachments
class ProfitbricksVolumeAttachmentsTask extends Playbook.Task {
    /// todo doc
    `community.general.profitbricks_volume_attachments`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.profitbricks_volume_attachments"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.profitbricks_volume_attachments`
}

/// TaskBuilder class for profitbricks_volume_attachments
class ProfitbricksVolumeAttachments extends Playbook.TaskBuilder {
    /// Options for community.general.profitbricks_volume_attachments
    options: ProfitbricksVolumeAttachmentsOptions?
    /// todo doc
    function Task(): ProfitbricksVolumeAttachmentsTask = this
        .toMap()
        .put("community.general.profitbricks_volume_attachments", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ProfitbricksVolumeAttachmentsTask)
}

/// Management of instances in Proxmox VE cluster
/// Allows you to create/delete/stop instances in Proxmox VE cluster.
/// The module automatically detects containerization type (lxc for PVE 4, openvz for older).
/// Since community.general 4.0.0 on, there are no more default values, see O(proxmox_default_behavior).
class ProxmoxOptions {
    /// ID of the container to be cloned.
    /// O(description), O(hostname), and O(pool) will be copied from the cloned container if not specified.
    /// The type of clone created is defined by the O(clone_type) parameter.
    /// This operator is only supported for Proxmox clusters that use LXC containerization (PVE version >= 4).
    clone: Int?
    /// Type of the clone created.
    /// V(full) creates a full clone, and O(storage) must be specified.
    /// V(linked) creates a linked clone, and the cloned container must be a template container.
    /// V(opportunistic) creates a linked clone if the cloned container is a template container, and a full clone if not. O(storage) may be specified, if not it will fall back to the default.
    clone_type: ("full"|"linked"|"opportunistic")?
    /// Specify number of cores per socket.
    /// This option has no default unless O(proxmox_default_behavior) is set to V(compatibility); then the default is V(1).
    cores: Int?
    /// numbers of allocated cpus for instance
    /// This option has no default unless O(proxmox_default_behavior) is set to V(compatibility); then the default is V(1).
    cpus: Int?
    /// CPU weight for a VM
    /// This option has no default unless O(proxmox_default_behavior) is set to V(compatibility); then the default is V(1000).
    cpuunits: Int?
    /// Specify the description for the container. Only used on the configuration web interface.
    /// This is saved as a comment inside the configuration file.
    description: String?
    /// This option was previously described as "hard disk size in GB for instance" however several formats describing a lxc mount are permitted.
    /// Older versions of Proxmox will accept a numeric value for size using the O(storage) parameter to automatically choose which storage to allocate from, however new versions enforce the C(<STORAGE>:<SIZE>) syntax.
    /// Additional options are available by using some combination of the following key-value pairs as a comma-delimited list C([volume=]<volume> [,acl=<1|0>] [,mountoptions=<opt[;opt...]>] [,quota=<1|0>] [,replicate=<1|0>] [,ro=<1|0>] [,shared=<1|0>] [,size=<DiskSize>]).
    /// See U(https://pve.proxmox.com/wiki/Linux_Container) for a full description.
    /// This option has no default unless O(proxmox_default_behavior) is set to V(compatibility); then the default is V(3).
    /// Should not be used in conjunction with O(storage).
    disk: String?
    /// Specifies a list of features to be enabled. For valid options, see U(https://pve.proxmox.com/wiki/Linux_Container#pct_options).
    /// Some features require the use of a privileged container.
    features: Listing<String>?
    /// Forcing operations.
    /// Can be used only with states V(present), V(stopped), V(restarted).
    /// with O(state=present) force option allow to overwrite existing container.
    /// with states V(stopped), V(restarted) allow to force stop instance.
    force: Boolean?
    /// Script that will be executed during various steps in the containers lifetime.
    hookscript: String?
    /// the instance hostname
    /// required only for O(state=present)
    /// must be unique if vmid is not passed
    hostname: String?
    /// specifies the address the container will be assigned
    ip_address: String?
    /// memory size in MB for instance
    /// This option has no default unless O(proxmox_default_behavior) is set to V(compatibility); then the default is V(512).
    memory: Int?
    /// specifies additional mounts (separate disks) for the container. As a hash/dictionary defining mount points
    mounts: Any?
    /// sets DNS server IP address for a container
    nameserver: String?
    /// specifies network interfaces for the container. As a hash/dictionary defining interfaces.
    netif: Any?
    /// specifies whether a VM will be started during system bootup
    /// This option has no default unless O(proxmox_default_behavior) is set to V(compatibility); then the default is V(false).
    onboot: Boolean?
    /// the template for VM creating
    /// required only for O(state=present)
    ostemplate: String?
    /// Specifies the C(ostype) of the LXC container.
    /// If set to V(auto), no C(ostype) will be provided on instance creation.
    ostype: ("auto"|"debian"|"devuan"|"ubuntu"|"centos"|"fedora"|"opensuse"|"archlinux"|"alpine"|"gentoo"|"nixos"|"unmanaged")?
    /// the instance root password
    password: String?
    /// As of community.general 4.0.0, various options no longer have default values. These default values caused problems when users expected different behavior from Proxmox by default or filled options which caused problems when set.
    /// The value V(compatibility) (default before community.general 4.0.0) will ensure that the default values are used when the values are not explicitly specified by the user. The new default is V(no_defaults), which makes sure these options have no defaults.
    /// This affects the O(disk), O(cores), O(cpus), O(memory), O(onboot), O(swap), and O(cpuunits) options.
    /// This parameter is now B(deprecated) and it will be removed in community.general 10.0.0. By then, the module's behavior should be to not set default values, equivalent to V(no_defaults). If a consistent set of defaults is needed, the playbook or role should be responsible for setting it.
    proxmox_default_behavior: ("compatibility"|"no_defaults")?
    /// Public key to add to /root/.ssh/authorized_keys. This was added on Proxmox 4.2, it is ignored for earlier versions
    pubkey: String?
    /// Remove container from all related configurations.
    /// For example backup jobs, replication jobs, or HA.
    /// Related ACLs and Firewall entries will always be removed.
    /// Used with O(state=absent).
    purge: Boolean?
    /// sets DNS search domain for a container
    searchdomain: String?
    /// Specifies the startup order of the container.
    /// Use C(order=#) where C(#) is a non-negative number to define the general startup order. Shutdown in done with reverse ordering.
    /// Use C(up=#) where C(#) is in seconds, to specify a delay to wait before the next VM is started.
    /// Use C(down=#) where C(#) is in seconds, to specify a delay to wait before the next VM is stopped.
    startup: Listing<String>?
    /// Indicate desired state of the instance
    /// V(template) was added in community.general 8.1.0.
    state: ("present"|"started"|"absent"|"stopped"|"restarted"|"template")?
    /// target storage
    /// Should not be used in conjunction with O(disk).
    storage: String?
    /// swap memory size in MB for instance
    /// This option has no default unless O(proxmox_default_behavior) is set to V(compatibility); then the default is V(0).
    swap: Int?
    /// List of tags to apply to the container.
    /// Tags must start with V([a-z0-9_]) followed by zero or more of the following characters V([a-z0-9_-+.]).
    /// Tags are only available in Proxmox 7+.
    tags: Listing<String>?
    /// timeout for operations
    timeout: Int?
    /// Timezone used by the container, accepts values like V(Europe/Paris).
    /// The special value V(host) configures the same timezone used by Proxmox host.
    timezone: String?
    /// Indicate if the container should be unprivileged.
    /// The default change to V(true) in community.general 7.0.0. It used to be V(false) before.
    unprivileged: Boolean?
    /// If V(true), the container will be updated with new values.
    update: Boolean?
}

/// Task class for proxmox
class ProxmoxTask extends Playbook.Task {
    /// todo doc
    `community.general.proxmox`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.proxmox"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.proxmox`
}

/// TaskBuilder class for proxmox
class Proxmox extends Playbook.TaskBuilder {
    /// Options for community.general.proxmox
    options: ProxmoxOptions?
    /// todo doc
    function Task(): ProxmoxTask = this
        .toMap()
        .put("community.general.proxmox", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ProxmoxTask)
}

/// Management of a disk of a Qemu(KVM) VM in a Proxmox VE cluster
/// Allows you to perform some supported operations on a disk in Qemu(KVM) Virtual Machines in a Proxmox VE cluster.
class ProxmoxDiskOptions {
    /// AIO type to use.
    aio: ("native"|"threads"|"io_uring")?
    /// Whether the drive should be included when making backups.
    backup: Boolean?
    /// Maximum length of total r/w I/O bursts in seconds.
    bps_max_length: Int?
    /// Maximum length of read I/O bursts in seconds.
    bps_rd_max_length: Int?
    /// Maximum length of write I/O bursts in seconds.
    bps_wr_max_length: Int?
    /// Override I/O bandwidth limit (in KB/s).
    /// Used only when O(state=moved).
    bwlimit: Int?
    /// The drive's cache mode.
    cache: ("none"|"writethrough"|"writeback"|"unsafe"|"directsync")?
    /// With O(create) flag you can control behavior of O(state=present).
    /// When O(create=disabled) it will not create new disk (if not exists) but will update options in existing disk.
    /// When O(create=regular) it will either create new disk (if not exists) or update options in existing disk.
    /// When O(create=forced) it will always create new disk (if disk exists it will be detached and left unused).
    create: ("disabled"|"regular"|"forced")?
    /// Force the drive's physical geometry to have a specific cylinder count.
    cyls: Int?
    /// Delete the original disk after successful copy.
    /// By default the original disk is kept as unused disk.
    /// Used only when O(state=moved).
    delete_moved: Boolean?
    /// Control whether to detect and try to optimize writes of zeroes.
    detect_zeroes: Boolean?
    /// Control whether to pass discard/trim requests to the underlying storage.
    discard: ("ignore"|"on")?
    /// The disk key (V(unused[n]), V(ide[n]), V(sata[n]), V(scsi[n]) or V(virtio[n])) you want to operate on.
    /// Disk buses (IDE, SATA and so on) have fixed ranges of V(n) that accepted by Proxmox API.
    /// For IDE: 0-3; for SCSI: 0-30; for SATA: 0-5; for VirtIO: 0-15; for Unused: 0-255.
    disk: String
    /// The drive's backing file's data format.
    format: ("raw"|"cow"|"qcow"|"qed"|"qcow2"|"vmdk"|"cloop")?
    /// Force the drive's physical geometry to have a specific head count.
    heads: Int?
    /// Import volume from this existing one.
    /// Volume string format
    /// C(<STORAGE>:<VMID>/<FULL_NAME>) or C(<ABSOLUTE_PATH>/<FULL_NAME>)
    /// Attention! Only root can use absolute paths.
    /// This parameter is mutually exclusive with O(size).
    /// Increase O(timeout) parameter when importing large disk images or using slow storage.
    import_from: String?
    /// Maximum total r/w I/O in operations per second.
    /// You can specify either total limit or per operation (mutually exclusive with O(iops_rd) and O(iops_wr)).
    iops: Int?
    /// Maximum unthrottled total r/w I/O pool in operations per second.
    iops_max: Int?
    /// Maximum length of total r/w I/O bursts in seconds.
    iops_max_length: Int?
    /// Maximum read I/O in operations per second.
    /// You can specify either read or total limit (mutually exclusive with O(iops)).
    iops_rd: Int?
    /// Maximum unthrottled read I/O pool in operations per second.
    iops_rd_max: Int?
    /// Maximum length of read I/O bursts in seconds.
    iops_rd_max_length: Int?
    /// Maximum write I/O in operations per second.
    /// You can specify either write or total limit (mutually exclusive with O(iops)).
    iops_wr: Int?
    /// Maximum unthrottled write I/O pool in operations per second.
    iops_wr_max: Int?
    /// Maximum length of write I/O bursts in seconds.
    iops_wr_max_length: Int?
    /// Whether to use iothreads for this drive (only for SCSI and VirtIO)
    iothread: Boolean?
    /// The ISO image to be mounted on the specified in O(disk) CD-ROM.
    /// O(media=cdrom) needs to be specified for this option to work.
    /// Image string format:
    /// V(<STORAGE>:iso/<ISO_NAME>) to mount ISO.
    /// V(cdrom) to use physical CD/DVD drive.
    /// V(none) to unmount image from existent CD-ROM or create empty CD-ROM drive.
    iso_image: String?
    /// Maximum total r/w speed in megabytes per second.
    /// Can be fractional but use with caution - fractionals less than 1 are not supported officially.
    /// You can specify either total limit or per operation (mutually exclusive with O(mbps_rd) and O(mbps_wr)).
    mbps: Any?
    /// Maximum unthrottled total r/w pool in megabytes per second.
    mbps_max: Any?
    /// Maximum read speed in megabytes per second.
    /// You can specify either read or total limit (mutually exclusive with O(mbps)).
    mbps_rd: Any?
    /// Maximum unthrottled read pool in megabytes per second.
    mbps_rd_max: Any?
    /// Maximum write speed in megabytes per second.
    /// You can specify either write or total limit (mutually exclusive with O(mbps)).
    mbps_wr: Any?
    /// Maximum unthrottled write pool in megabytes per second.
    mbps_wr_max: Any?
    /// The drive's media type.
    media: ("cdrom"|"disk")?
    /// The unique name of the VM.
    /// You can specify either O(name) or O(vmid) or both of them.
    name: String?
    /// Number of queues (SCSI only).
    queues: Int?
    /// Whether the drive should considered for replication jobs.
    replicate: Boolean?
    /// Read error action.
    rerror: ("ignore"|"report"|"stop")?
    /// Whether the drive is read-only.
    ro: Boolean?
    /// Whether to use scsi-block for full passthrough of host block device.
    /// Can lead to I/O errors in combination with low memory or high memory fragmentation on host.
    scsiblock: Boolean?
    /// Force the drive's physical geometry to have a specific sector count.
    secs: Int?
    /// The drive's reported serial number, url-encoded, up to 20 bytes long.
    serial: String?
    /// Mark this locally-managed volume as available on all nodes.
    /// This option does not share the volume automatically, it assumes it is shared already!
    shared: Boolean?
    /// Desired volume size in GB to allocate when O(state=present) (specify O(size) without suffix).
    /// New (or additional) size of volume when O(state=resized). With the V(+) sign the value is added to the actual size of the volume and without it, the value is taken as an absolute one.
    size: String?
    /// Control qemu's snapshot mode feature.
    /// If activated, changes made to the disk are temporary and will be discarded when the VM is shutdown.
    snapshot: Boolean?
    /// Whether to expose this drive as an SSD, rather than a rotational hard disk.
    ssd: Boolean?
    /// Indicates desired state of the disk.
    /// O(state=present) can be used to create, replace disk or update options in existing disk. It will create missing disk or update options in existing one by default. See the O(create) parameter description to control behavior of this option.
    /// Some updates on options (like O(cache)) are not being applied instantly and require VM restart.
    /// Use O(state=detached) to detach existing disk from VM but do not remove it entirely. When O(state=detached) and disk is V(unused[n]) it will be left in same state (not removed).
    /// O(state=moved) may be used to change backing storage for the disk in bounds of the same VM or to send the disk to another VM (using the same backing storage).
    /// O(state=resized) intended to change the disk size. As of Proxmox 7.2 you can only increase the disk size because shrinking disks is not supported by the PVE API and has to be done manually.
    /// To entirely remove the disk from backing storage use O(state=absent).
    state: ("present"|"resized"|"detached"|"moved"|"absent")?
    /// The drive's backing storage.
    /// Used only when O(state) is V(present).
    storage: String?
    /// The config key the disk will be moved to on the target VM (for example, V(ide0) or V(scsi1)).
    /// Default is the source disk key.
    /// Used only when O(state=moved).
    target_disk: String?
    /// Move the disk to this storage when O(state=moved).
    /// You can move between storages only in scope of one VM.
    /// Mutually exclusive with O(target_vmid).
    /// Consider increasing O(timeout) in case of large disk images or slow storage backend.
    target_storage: String?
    /// The (unique) ID of the VM where disk will be placed when O(state=moved).
    /// You can move disk between VMs only when the same storage is used.
    /// Mutually exclusive with O(target_vmid).
    target_vmid: Int?
    /// Timeout in seconds to wait for slow operations such as importing disk or moving disk between storages.
    /// Used only when O(state) is V(present) or V(moved).
    timeout: Int?
    /// Force disk geometry bios translation mode.
    trans: ("auto"|"lba"|"none")?
    /// The unique ID of the VM.
    /// You can specify either O(vmid) or O(name) or both of them.
    vmid: Int?
    /// Write error action.
    werror: ("enospc"|"ignore"|"report"|"stop")?
    /// The drive's worldwide name, encoded as 16 bytes hex string, prefixed by V(0x).
    wwn: String?
}

/// Task class for proxmox_disk
class ProxmoxDiskTask extends Playbook.Task {
    /// todo doc
    `community.general.proxmox_disk`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.proxmox_disk"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.proxmox_disk`
}

/// TaskBuilder class for proxmox_disk
class ProxmoxDisk extends Playbook.TaskBuilder {
    /// Options for community.general.proxmox_disk
    options: ProxmoxDiskOptions?
    /// todo doc
    function Task(): ProxmoxDiskTask = this
        .toMap()
        .put("community.general.proxmox_disk", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ProxmoxDiskTask)
}

/// Retrieve information about one or more Proxmox VE domains
/// Retrieve information about one or more Proxmox VE domains.
class ProxmoxDomainInfoOptions {
    /// Restrict results to a specific authentication realm.
    domain: String?
}

/// Task class for proxmox_domain_info
class ProxmoxDomainInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.proxmox_domain_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.proxmox_domain_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.proxmox_domain_info`
}

/// TaskBuilder class for proxmox_domain_info
class ProxmoxDomainInfo extends Playbook.TaskBuilder {
    /// Options for community.general.proxmox_domain_info
    options: ProxmoxDomainInfoOptions?
    /// todo doc
    function Task(): ProxmoxDomainInfoTask = this
        .toMap()
        .put("community.general.proxmox_domain_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ProxmoxDomainInfoTask)
}

/// Retrieve information about one or more Proxmox VE groups
/// Retrieve information about one or more Proxmox VE groups
class ProxmoxGroupInfoOptions {
    /// Restrict results to a specific group.
    group: String?
}

/// Task class for proxmox_group_info
class ProxmoxGroupInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.proxmox_group_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.proxmox_group_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.proxmox_group_info`
}

/// TaskBuilder class for proxmox_group_info
class ProxmoxGroupInfo extends Playbook.TaskBuilder {
    /// Options for community.general.proxmox_group_info
    options: ProxmoxGroupInfoOptions?
    /// todo doc
    function Task(): ProxmoxGroupInfoTask = this
        .toMap()
        .put("community.general.proxmox_group_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ProxmoxGroupInfoTask)
}

/// Management of Qemu(KVM) Virtual Machines in Proxmox VE cluster
/// Allows you to create/delete/stop Qemu(KVM) Virtual Machines in Proxmox VE cluster.
/// Since community.general 4.0.0 on, there are no more default values, see O(proxmox_default_behavior).
class ProxmoxKvmOptions {
    /// Specify if ACPI should be enabled/disabled.
    /// This option has no default unless O(proxmox_default_behavior) is set to V(compatibility); then the default is V(true).
    acpi: Boolean?
    /// Specify if the QEMU Guest Agent should be enabled/disabled.
    /// Since community.general 5.5.0, this can also be a string instead of a boolean. This allows to specify values such as V(enabled=1,fstrim_cloned_disks=1).
    agent: String?
    /// Specify a path to an archive to restore (instead of creating or cloning a VM).
    archive: String?
    /// Pass arbitrary arguments to kvm.
    /// This option is for experts only!
    /// If O(proxmox_default_behavior) is set to V(compatibility), this option has a default of V(-serial unix:/var/run/qemu-server/<vmid>.serial,server,nowait).
    args: String?
    /// Specify if the VM should be automatically restarted after crash (currently ignored in PVE API).
    /// This option has no default unless O(proxmox_default_behavior) is set to V(compatibility); then the default is V(false).
    autostart: Boolean?
    /// Specify the amount of RAM for the VM in MB.
    /// Using zero disables the balloon driver.
    /// This option has no default unless O(proxmox_default_behavior) is set to V(compatibility); then the default is V(0).
    balloon: Int?
    /// Specify the BIOS implementation.
    bios: ("seabios"|"ovmf")?
    /// Specify the boot order -> boot on floppy V(a), hard disk V(c), CD-ROM V(d), or network V(n).
    /// For newer versions of Proxmox VE, use a boot order like V(order=scsi0;net0;hostpci0).
    /// You can combine to set order.
    /// This option has no default unless O(proxmox_default_behavior) is set to V(compatibility); then the default is V(cnd).
    boot: String?
    /// Enable booting from specified disk. Format V((ide|sata|scsi|virtio\)\\d+).
    bootdisk: String?
    /// cloud-init: Specify custom files to replace the automatically generated ones at start.
    cicustom: String?
    /// cloud-init: password of default user to create.
    cipassword: String?
    /// cloud-init: Specifies the cloud-init configuration format.
    /// The default depends on the configured operating system type (V(ostype)).
    /// We use the V(nocloud) format for Linux, and V(configdrive2) for Windows.
    citype: ("nocloud"|"configdrive2")?
    /// cloud-init: username of default user to create.
    ciuser: String?
    /// Name of VM to be cloned. If O(vmid) is set, O(clone) can take an arbitrary value but is required for initiating the clone.
    clone: String?
    /// Specify number of cores per socket.
    /// This option has no default unless O(proxmox_default_behavior) is set to V(compatibility); then the default is V(1).
    cores: Int?
    /// Specify emulated CPU type.
    /// This option has no default unless O(proxmox_default_behavior) is set to V(compatibility); then the default is V(kvm64).
    cpu: String?
    /// Specify if CPU usage will be limited. Value 0 indicates no CPU limit.
    /// If the computer has 2 CPUs, it has total of '2' CPU time
    cpulimit: Int?
    /// Specify CPU weight for a VM.
    /// You can disable fair-scheduler configuration by setting this to 0
    /// This option has no default unless O(proxmox_default_behavior) is set to V(compatibility); then the default is V(1000).
    cpuunits: Int?
    /// Specify a list of settings you want to delete.
    `delete`: String?
    /// Specify the description for the VM. Only used on the configuration web interface.
    /// This is saved as comment inside the configuration file.
    description: String?
    /// Specify if to prevent changes if current configuration file has different SHA1 digest.
    /// This can be used to prevent concurrent modifications.
    digest: String?
    /// Specify a hash/dictionary of EFI disk options.
    /// Requires O(bios=ovmf) to be set to be able to use it.
    efidisk0: Any?
    /// Allow to force stop VM.
    /// Can be used with states V(stopped), V(restarted), and V(absent).
    /// This option has no default unless O(proxmox_default_behavior) is set to V(compatibility); then the default is V(false).
    force: Boolean?
    /// Target drive's backing file's data format.
    /// Used only with clone
    /// Use O(format=unspecified) and O(full=false) for a linked clone.
    /// Please refer to the Proxmox VE Administrator Guide, section Proxmox VE Storage (see U(https://pve.proxmox.com/pve-docs/chapter-pvesm.html) for the latest version, tables 3 to 14) to find out format supported by the provided storage backend.
    /// This option has no default unless O(proxmox_default_behavior) is set to V(compatibility); then the default is V(qcow2). If O(proxmox_default_behavior) is set to V(no_defaults), not specifying this option is equivalent to setting it to V(unspecified).
    format: ("cloop"|"cow"|"qcow"|"qcow2"|"qed"|"raw"|"vmdk"|"unspecified")?
    /// Specify if PVE should freeze CPU at startup (use 'c' monitor command to start execution).
    freeze: Boolean?
    /// Create a full copy of all disk. This is always done when you clone a normal VM.
    /// For VM templates, we try to create a linked clone by default.
    /// Used only with clone
    full: Boolean?
    /// Script that will be executed during various steps in the containers lifetime.
    hookscript: String?
    /// Specify a hash/dictionary of map host pci devices into guest. O(hostpci='{"key":"value", "key":"value"}').
    /// Keys allowed are - C(hostpci[n]) where 0 ≤ n ≤ N.
    /// Values allowed are -  C("host="HOSTPCIID[;HOSTPCIID2...]",pcie="1|0",rombar="1|0",x-vga="1|0"").
    /// The C(host) parameter is Host PCI device pass through. HOSTPCIID syntax is C(bus:dev.func) (hexadecimal numbers).
    /// C(pcie=boolean) C(default=0) Choose the PCI-express bus (needs the q35 machine model).
    /// C(rombar=boolean) C(default=1) Specify whether or not the device's ROM will be visible in the guest's memory map.
    /// C(x-vga=boolean) C(default=0) Enable vfio-vga device support.
    /// /!\ This option allows direct access to host hardware. So it is no longer possible to migrate such machines - use with special care.
    hostpci: Any?
    /// Selectively enable hotplug features.
    /// This is a comma separated list of hotplug features V(network), V(disk), V(cpu), V(memory), and V(usb).
    /// Value 0 disables hotplug completely and value 1 is an alias for the default V(network,disk,usb).
    hotplug: String?
    /// Enable/disable hugepages memory.
    hugepages: ("any"|"2"|"1024")?
    /// A hash/dictionary of volume used as IDE hard disk or CD-ROM. O(ide='{"key":"value", "key":"value"}').
    /// Keys allowed are - C(ide[n]) where 0 ≤ n ≤ 3.
    /// Values allowed are - C("storage:size,format=value").
    /// C(storage) is the storage identifier where to create the disk.
    /// C(size) is the size of the disk in GB.
    /// C(format) is the drive's backing file's data format. C(qcow2|raw|subvol). Please refer to the Proxmox VE Administrator Guide, section Proxmox VE Storage (see U(https://pve.proxmox.com/pve-docs/chapter-pvesm.html) for the latest version, tables 3 to 14) to find out format supported by the provided storage backend.
    ide: Any?
    /// cloud-init: Set the IP configuration.
    /// A hash/dictionary of network ip configurations. O(ipconfig='{"key":"value", "key":"value"}').
    /// Keys allowed are - C(ipconfig[n]) where 0 ≤ n ≤ network interfaces.
    /// Values allowed are -  C("[gw=<GatewayIPv4>] [,gw6=<GatewayIPv6>] [,ip=<IPv4Format/CIDR>] [,ip6=<IPv6Format/CIDR>]").
    /// cloud-init: Specify IP addresses and gateways for the corresponding interface.
    /// IP addresses use CIDR notation, gateways are optional but they should be in the same subnet of specified IP address.
    /// The special string 'dhcp' can be used for IP addresses to use DHCP, in which case no explicit gateway should be provided.
    /// For IPv6 the special string 'auto' can be used to use stateless autoconfiguration.
    /// If cloud-init is enabled and neither an IPv4 nor an IPv6 address is specified, it defaults to using dhcp on IPv4.
    ipconfig: Any?
    /// Sets the keyboard layout for VNC server.
    keyboard: String?
    /// Enable/disable KVM hardware virtualization.
    /// This option has no default unless O(proxmox_default_behavior) is set to V(compatibility); then the default is V(true).
    kvm: Boolean?
    /// Sets the real time clock to local time.
    /// This is enabled by default if ostype indicates a Microsoft OS.
    localtime: Boolean?
    /// Lock/unlock the VM.
    lock: ("migrate"|"backup"|"snapshot"|"rollback")?
    /// Specifies the Qemu machine type.
    /// Type => V((pc|pc(-i440fx\)?-\\d+\\.\\d+(\\.pxe\)?|q35|pc-q35-\\d+\\.\\d+(\\.pxe\)?\)).
    machine: String?
    /// Memory size in MB for instance.
    /// This option has no default unless O(proxmox_default_behavior) is set to V(compatibility); then the default is V(512).
    memory: Int?
    /// Migrate the VM to O(node) if it is on another node.
    migrate: Boolean?
    /// Sets maximum tolerated downtime (in seconds) for migrations.
    migrate_downtime: Int?
    /// Sets maximum speed (in MB/s) for migrations.
    /// A value of 0 is no limit.
    migrate_speed: Int?
    /// Specifies the VM name. Name could be non-unique across the cluster.
    /// Required only for O(state=present).
    /// With O(state=present) if O(vmid) not provided and VM with name exists in the cluster then no changes will be made.
    name: String?
    /// cloud-init: DNS server IP address(es).
    /// If unset, PVE host settings are used.
    nameservers: Listing<String>?
    /// A hash/dictionary of network interfaces for the VM. O(net='{"key":"value", "key":"value"}').
    /// Keys allowed are - C(net[n]) where 0 ≤ n ≤ N.
    /// Values allowed are - C("model="XX:XX:XX:XX:XX:XX",bridge="value",rate="value",tag="value",firewall="1|0",trunks="vlanid"").
    /// Model is one of C(e1000 e1000-82540em e1000-82544gc e1000-82545em i82551 i82557b i82559er ne2k_isa ne2k_pci pcnet rtl8139 virtio vmxnet3).
    /// C(XX:XX:XX:XX:XX:XX) should be an unique MAC address. This is automatically generated if not specified.
    /// The C(bridge) parameter can be used to automatically add the interface to a bridge device. The Proxmox VE standard bridge is called 'vmbr0'.
    /// Option C(rate) is used to limit traffic bandwidth from and to this interface. It is specified as floating point number, unit is 'Megabytes per second'.
    /// If you specify no bridge, we create a kvm 'user' (NATed) network device, which provides DHCP and DNS services.
    net: Any?
    /// VMID for the clone. Used only with clone.
    /// If newid is not set, the next available VM ID will be fetched from ProxmoxAPI.
    newid: Int?
    /// A hash/dictionaries of NUMA topology. O(numa='{"key":"value", "key":"value"}').
    /// Keys allowed are - C(numa[n]) where 0 ≤ n ≤ N.
    /// Values allowed are - C("cpu="<id[-id];...>",hostnodes="<id[-id];...>",memory="number",policy="(bind|interleave|preferred)"").
    /// C(cpus) CPUs accessing this NUMA node.
    /// C(hostnodes) Host NUMA nodes to use.
    /// C(memory) Amount of memory this NUMA node provides.
    /// C(policy) NUMA allocation policy.
    numa: Any?
    /// Enables NUMA.
    numa_enabled: Boolean?
    /// Specifies whether a VM will be started during system bootup.
    /// This option has no default unless O(proxmox_default_behavior) is set to V(compatibility); then the default is V(true).
    onboot: Boolean?
    /// Specifies guest operating system. This is used to enable special optimization/features for specific operating systems.
    /// The l26 is Linux 2.6/3.X Kernel.
    /// This option has no default unless O(proxmox_default_behavior) is set to V(compatibility); then the default is V(l26).
    ostype: ("other"|"wxp"|"w2k"|"w2k3"|"w2k8"|"wvista"|"win7"|"win8"|"win10"|"win11"|"l24"|"l26"|"solaris")?
    /// A hash/dictionary of map host parallel devices. O(parallel='{"key":"value", "key":"value"}').
    /// Keys allowed are - (parallel[n]) where 0 ≤ n ≤ 2.
    /// Values allowed are - C("/dev/parport\d+|/dev/usb/lp\d+").
    parallel: Any?
    /// Enable/disable the protection flag of the VM. This will enable/disable the remove VM and remove disk operations.
    protection: Boolean?
    /// As of community.general 4.0.0, various options no longer have default values. These default values caused problems when users expected different behavior from Proxmox by default or filled options which caused problems when set. - The value V(compatibility) (default before community.general 4.0.0) will ensure that the default values are used when the values are not explicitly specified by the user. The new default is V(no_defaults), which makes sure these options have no defaults. - This affects the O(acpi), O(autostart), O(balloon), O(boot), O(cores), O(cpu), O(cpuunits), O(force), O(format), O(kvm), O(memory), O(onboot), O(ostype), O(sockets), O(tablet), O(template), and O(vga) options. - This option is deprecated and will be removed in community.general 10.0.0.
    proxmox_default_behavior: ("compatibility"|"no_defaults")?
    /// Allow reboot. If set to V(true), the VM exit on reboot.
    reboot: Boolean?
    /// Revert a pending change.
    revert: String?
    /// A hash/dictionary of volume used as sata hard disk or CD-ROM. O(sata='{"key":"value", "key":"value"}').
    /// Keys allowed are - C(sata[n]) where 0 ≤ n ≤ 5.
    /// Values allowed are -  C("storage:size,format=value").
    /// C(storage) is the storage identifier where to create the disk.
    /// C(size) is the size of the disk in GB.
    /// C(format) is the drive's backing file's data format. C(qcow2|raw|subvol). Please refer to the Proxmox VE Administrator Guide, section Proxmox VE Storage (see U(https://pve.proxmox.com/pve-docs/chapter-pvesm.html) for the latest version, tables 3 to 14) to find out format supported by the provided storage backend.
    sata: Any?
    /// A hash/dictionary of volume used as SCSI hard disk or CD-ROM. O(scsi='{"key":"value", "key":"value"}').
    /// Keys allowed are - C(scsi[n]) where 0 ≤ n ≤ 13.
    /// Values allowed are -  C("storage:size,format=value").
    /// C(storage) is the storage identifier where to create the disk.
    /// C(size) is the size of the disk in GB.
    /// C(format) is the drive's backing file's data format. C(qcow2|raw|subvol). Please refer to the Proxmox VE Administrator Guide, section Proxmox VE Storage (see U(https://pve.proxmox.com/pve-docs/chapter-pvesm.html) for the latest version, tables 3 to 14) to find out format supported by the provided storage backend.
    scsi: Any?
    /// Specifies the SCSI controller model.
    scsihw: ("lsi"|"lsi53c810"|"virtio-scsi-pci"|"virtio-scsi-single"|"megasas"|"pvscsi")?
    /// cloud-init: Sets DNS search domain(s).
    /// If unset, PVE host settings are used.
    searchdomains: Listing<String>?
    /// A hash/dictionary of serial device to create inside the VM. V('{"key":"value", "key":"value"}').
    /// Keys allowed are - serial[n](str; required) where 0 ≤ n ≤ 3.
    /// Values allowed are - V((/dev/.+|socket\)).
    /// /!\ If you pass through a host serial device, it is no longer possible to migrate such machines - use with special care.
    serial: Any?
    /// Rets amount of memory shares for auto-ballooning. (0 - 50000).
    /// The larger the number is, the more memory this VM gets.
    /// The number is relative to weights of all other running VMs.
    /// Using 0 disables auto-ballooning, this means no limit.
    shares: Int?
    /// Ignore locks
    /// Only root is allowed to use this option.
    skiplock: Boolean?
    /// Specifies SMBIOS type 1 fields.
    /// Comma separated, Base64 encoded (optional) SMBIOS properties:
    /// V([base64=<1|0>] [,family=<Base64 encoded string>])
    /// V([,manufacturer=<Base64 encoded string>])
    /// V([,product=<Base64 encoded string>])
    /// V([,serial=<Base64 encoded string>])
    /// V([,sku=<Base64 encoded string>])
    /// V([,uuid=<UUID>])
    /// V([,version=<Base64 encoded string>])
    smbios: String?
    /// The name of the snapshot. Used only with clone.
    snapname: String?
    /// Sets the number of CPU sockets. (1 - N).
    /// This option has no default unless O(proxmox_default_behavior) is set to V(compatibility); then the default is V(1).
    sockets: Int?
    /// cloud-init: SSH key to assign to the default user. NOT TESTED with multiple keys but a multi-line value should work.
    sshkeys: String?
    /// Sets the initial date of the real time clock.
    /// Valid format for date are V('now') or V('2016-09-25T16:01:21') or V('2016-09-25').
    startdate: String?
    /// Startup and shutdown behavior. V([[order=]\\d+] [,up=\\d+] [,down=\\d+]).
    /// Order is a non-negative number defining the general startup order.
    /// Shutdown in done with reverse ordering.
    startup: String?
    /// Indicates desired state of the instance.
    /// If V(current), the current state of the VM will be fetched. You can access it with C(results.status)
    /// V(template) was added in community.general 8.1.0.
    state: ("present"|"started"|"absent"|"stopped"|"restarted"|"current"|"template")?
    /// Target storage for full clone.
    storage: String?
    /// Enables/disables the USB tablet device.
    /// This option has no default unless O(proxmox_default_behavior) is set to V(compatibility); then the default is V(false).
    tablet: Boolean?
    /// List of tags to apply to the VM instance.
    /// Tags must start with V([a-z0-9_]) followed by zero or more of the following characters V([a-z0-9_-+.]).
    /// Tags are only available in Proxmox 6+.
    tags: Listing<String>?
    /// Target node. Only allowed if the original VM is on shared storage.
    /// Used only with clone
    target: String?
    /// Enables/disables time drift fix.
    tdf: Boolean?
    /// Enables/disables the template.
    /// This option has no default unless O(proxmox_default_behavior) is set to V(compatibility); then the default is V(false).
    template: Boolean?
    /// Timeout for operations.
    /// When used with O(state=stopped) the option sets a graceful timeout for VM stop after which a VM will be forcefully stopped.
    timeout: Int?
    /// A hash/dictionary of options for the Trusted Platform Module disk.
    /// A TPM state disk is required for Windows 11 installations.
    tpmstate0: Any?
    /// If V(true), the VM will be updated with new value.
    /// Because of the operations of the API and security reasons, I have disabled the update of the following parameters O(net), O(virtio), O(ide), O(sata), O(scsi). Per example updating O(net) update the MAC address and C(virtio) create always new disk... This security feature can be disabled by setting the O(update_unsafe) to V(true).
    /// Update of O(pool) is disabled. It needs an additional API endpoint not covered by this module.
    update: Boolean?
    /// If V(true), do not enforce limitations on parameters O(net), O(virtio), O(ide), O(sata), O(scsi), O(efidisk0), and O(tpmstate0). Use this option with caution because an improper configuration might result in a permanent loss of data (e.g. disk recreated).
    update_unsafe: Boolean?
    /// Sets number of hotplugged vcpus.
    vcpus: Int?
    /// Select VGA type. If you want to use high resolution modes (>= 1280x1024x16) then you should use option 'std' or 'vmware'.
    /// This option has no default unless O(proxmox_default_behavior) is set to V(compatibility); then the default is V(std).
    vga: ("std"|"cirrus"|"vmware"|"qxl"|"serial0"|"serial1"|"serial2"|"serial3"|"qxl2"|"qxl3"|"qxl4")?
    /// A hash/dictionary of volume used as VIRTIO hard disk. O(virtio='{"key":"value", "key":"value"}').
    /// Keys allowed are - C(virtio[n]) where 0 ≤ n ≤ 15.
    /// Values allowed are -  C("storage:size,format=value").
    /// C(storage) is the storage identifier where to create the disk.
    /// C(size) is the size of the disk in GB.
    /// C(format) is the drive's backing file's data format. C(qcow2|raw|subvol). Please refer to the Proxmox VE Administrator Guide, section Proxmox VE Storage (see U(https://pve.proxmox.com/pve-docs/chapter-pvesm.html) for the latest version, tables 3 to 14) to find out format supported by the provided storage backend.
    virtio: Any?
    /// Creates a virtual hardware watchdog device.
    watchdog: String?
}

/// Task class for proxmox_kvm
class ProxmoxKvmTask extends Playbook.Task {
    /// todo doc
    `community.general.proxmox_kvm`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.proxmox_kvm"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.proxmox_kvm`
}

/// TaskBuilder class for proxmox_kvm
class ProxmoxKvm extends Playbook.TaskBuilder {
    /// Options for community.general.proxmox_kvm
    options: ProxmoxKvmOptions?
    /// todo doc
    function Task(): ProxmoxKvmTask = this
        .toMap()
        .put("community.general.proxmox_kvm", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ProxmoxKvmTask)
}

/// Management of a NIC of a Qemu(KVM) VM in a Proxmox VE cluster
/// Allows you to create/update/delete a NIC on Qemu(KVM) Virtual Machines in a Proxmox VE cluster.
class ProxmoxNicOptions {
    /// Add this interface to the specified bridge device. The Proxmox VE default bridge is called V(vmbr0).
    bridge: String?
    /// Whether this interface should be protected by the firewall.
    firewall: Boolean?
    /// Name of the interface, should be V(net[n]) where C(1 ≤ n ≤ 31).
    interface: String
    /// Whether this interface should be disconnected (like pulling the plug).
    link_down: Boolean?
    /// V(XX:XX:XX:XX:XX:XX) should be a unique MAC address. This is automatically generated if not specified.
    /// When not specified this module will keep the MAC address the same when changing an existing interface.
    mac: String?
    /// The NIC emulator model.
    model: ("e1000"|"e1000-82540em"|"e1000-82544gc"|"e1000-82545em"|"i82551"|"i82557b"|"i82559er"|"ne2k_isa"|"ne2k_pci"|"pcnet"|"rtl8139"|"virtio"|"vmxnet3")?
    /// Force MTU, for C(virtio) model only, setting will be ignored otherwise.
    /// Set to V(1) to use the bridge MTU.
    /// Value should be C(1 ≤ n ≤ 65520).
    mtu: Int?
    /// Specifies the VM name. Only used on the configuration web interface.
    /// Required only for O(state=present).
    name: String?
    /// Number of packet queues to be used on the device.
    /// Value should be C(0 ≤ n ≤ 16).
    queues: Int?
    /// Rate limit in MBps (MegaBytes per second) as floating point number.
    rate: Any?
    /// Indicates desired state of the NIC.
    state: ("present"|"absent")?
    /// VLAN tag to apply to packets on this interface.
    /// Value should be C(1 ≤ n ≤ 4094).
    tag: Int?
    /// List of VLAN trunks to pass through this interface.
    trunks: Listing<Int>?
    /// Specifies the instance ID.
    vmid: Int?
}

/// Task class for proxmox_nic
class ProxmoxNicTask extends Playbook.Task {
    /// todo doc
    `community.general.proxmox_nic`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.proxmox_nic"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.proxmox_nic`
}

/// TaskBuilder class for proxmox_nic
class ProxmoxNic extends Playbook.TaskBuilder {
    /// Options for community.general.proxmox_nic
    options: ProxmoxNicOptions?
    /// todo doc
    function Task(): ProxmoxNicTask = this
        .toMap()
        .put("community.general.proxmox_nic", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ProxmoxNicTask)
}

/// Retrieve information about one or more Proxmox VE nodes
/// Retrieve information about one or more Proxmox VE nodes.
class ProxmoxNodeInfoOptions {
}

/// Task class for proxmox_node_info
class ProxmoxNodeInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.proxmox_node_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.proxmox_node_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.proxmox_node_info`
}

/// TaskBuilder class for proxmox_node_info
class ProxmoxNodeInfo extends Playbook.TaskBuilder {
    /// Options for community.general.proxmox_node_info
    options: ProxmoxNodeInfoOptions?
    /// todo doc
    function Task(): ProxmoxNodeInfoTask = this
        .toMap()
        .put("community.general.proxmox_node_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ProxmoxNodeInfoTask)
}

/// Pool management for Proxmox VE cluster
/// Create or delete a pool for Proxmox VE clusters.
/// For pool members management please consult M(community.general.proxmox_pool_member) module.
class ProxmoxPoolOptions {
    /// Specify the description for the pool.
    /// Parameter is ignored when pool already exists or O(state=absent).
    comment: String?
    /// The pool ID.
    poolid: String
    /// Indicate desired state of the pool.
    /// The pool must be empty prior deleting it with O(state=absent).
    state: ("present"|"absent")?
}

/// Task class for proxmox_pool
class ProxmoxPoolTask extends Playbook.Task {
    /// todo doc
    `community.general.proxmox_pool`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.proxmox_pool"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.proxmox_pool`
}

/// TaskBuilder class for proxmox_pool
class ProxmoxPool extends Playbook.TaskBuilder {
    /// Options for community.general.proxmox_pool
    options: ProxmoxPoolOptions?
    /// todo doc
    function Task(): ProxmoxPoolTask = this
        .toMap()
        .put("community.general.proxmox_pool", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ProxmoxPoolTask)
}

/// Add or delete members from Proxmox VE cluster pools
/// Create or delete a pool member in Proxmox VE clusters.
class ProxmoxPoolMemberOptions {
    /// Specify the member name.
    /// For O(type=storage) it is a storage name.
    /// For O(type=vm) either vmid or vm name could be used.
    member: String
    /// The pool ID.
    poolid: String
    /// Indicate desired state of the pool member.
    state: ("present"|"absent")?
    /// Member type to add/remove from the pool.
    type: ("vm"|"storage")?
}

/// Task class for proxmox_pool_member
class ProxmoxPoolMemberTask extends Playbook.Task {
    /// todo doc
    `community.general.proxmox_pool_member`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.proxmox_pool_member"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.proxmox_pool_member`
}

/// TaskBuilder class for proxmox_pool_member
class ProxmoxPoolMember extends Playbook.TaskBuilder {
    /// Options for community.general.proxmox_pool_member
    options: ProxmoxPoolMemberOptions?
    /// todo doc
    function Task(): ProxmoxPoolMemberTask = this
        .toMap()
        .put("community.general.proxmox_pool_member", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ProxmoxPoolMemberTask)
}

/// Snapshot management of instances in Proxmox VE cluster
/// Allows you to create/delete/restore snapshots from instances in Proxmox VE cluster.
/// Supports both KVM and LXC, OpenVZ has not been tested, as it is no longer supported on Proxmox VE.
class ProxmoxSnapOptions {
    /// Specify the description for the snapshot. Only used on the configuration web interface.
    /// This is saved as a comment inside the configuration file.
    description: String?
    /// For removal from config file, even if removing disk snapshot fails.
    force: Boolean?
    /// The instance name.
    hostname: String?
    /// Remove old snapshots if there are more than O(retention) snapshots.
    /// If O(retention) is set to V(0), all snapshots will be kept.
    /// This is only used when O(state=present) and when an actual snapshot is created. If no snapshot is created, all existing snapshots will be kept.
    retention: Int?
    /// Name of the snapshot that has to be created/deleted/restored.
    snapname: String?
    /// Indicate desired state of the instance snapshot.
    /// The V(rollback) value was added in community.general 4.8.0.
    state: ("present"|"absent"|"rollback")?
    /// Timeout for operations.
    timeout: Int?
    /// This option only applies to LXC containers.
    /// Allows to snapshot a container even if it has configured mountpoints.
    /// Temporarily disables all configured mountpoints, takes snapshot, and finally restores original configuration.
    /// If running, the container will be stopped and restarted to apply config changes.
    /// Due to restrictions in the Proxmox API this option can only be used authenticating as V(root@pam) with O(api_password), API tokens do not work either.
    /// See U(https://pve.proxmox.com/pve-docs/api-viewer/#/nodes/{node}/lxc/{vmid}/config) (PUT tab) for more details.
    unbind: Boolean?
    /// The instance id.
    /// If not set, will be fetched from PromoxAPI based on the hostname.
    vmid: String?
    /// Snapshot includes RAM.
    vmstate: Boolean?
}

/// Task class for proxmox_snap
class ProxmoxSnapTask extends Playbook.Task {
    /// todo doc
    `community.general.proxmox_snap`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.proxmox_snap"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.proxmox_snap`
}

/// TaskBuilder class for proxmox_snap
class ProxmoxSnap extends Playbook.TaskBuilder {
    /// Options for community.general.proxmox_snap
    options: ProxmoxSnapOptions?
    /// todo doc
    function Task(): ProxmoxSnapTask = this
        .toMap()
        .put("community.general.proxmox_snap", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ProxmoxSnapTask)
}

/// List content from a Proxmox VE storage
/// Retrieves information about stored objects on a specific storage attached to a node.
class ProxmoxStorageContentsInfoOptions {
    /// Filter on a specific content type.
    content: ("all"|"backup"|"rootdir"|"images"|"iso")?
    /// Proxmox node to which the storage is attached.
    node: String
    /// Only return content stored on that specific storage.
    storage: String
    /// Filter on a specific VMID.
    vmid: Int?
}

/// Task class for proxmox_storage_contents_info
class ProxmoxStorageContentsInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.proxmox_storage_contents_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.proxmox_storage_contents_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.proxmox_storage_contents_info`
}

/// TaskBuilder class for proxmox_storage_contents_info
class ProxmoxStorageContentsInfo extends Playbook.TaskBuilder {
    /// Options for community.general.proxmox_storage_contents_info
    options: ProxmoxStorageContentsInfoOptions?
    /// todo doc
    function Task(): ProxmoxStorageContentsInfoTask = this
        .toMap()
        .put("community.general.proxmox_storage_contents_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ProxmoxStorageContentsInfoTask)
}

/// Retrieve information about one or more Proxmox VE storages
/// Retrieve information about one or more Proxmox VE storages.
class ProxmoxStorageInfoOptions {
    /// Only return information on a specific storage.
    storage: String?
    /// Filter on a specific storage type.
    type: String?
}

/// Task class for proxmox_storage_info
class ProxmoxStorageInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.proxmox_storage_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.proxmox_storage_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.proxmox_storage_info`
}

/// TaskBuilder class for proxmox_storage_info
class ProxmoxStorageInfo extends Playbook.TaskBuilder {
    /// Options for community.general.proxmox_storage_info
    options: ProxmoxStorageInfoOptions?
    /// todo doc
    function Task(): ProxmoxStorageInfoTask = this
        .toMap()
        .put("community.general.proxmox_storage_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ProxmoxStorageInfoTask)
}

/// Retrieve information about one or more Proxmox VE tasks
/// Retrieve information about one or more Proxmox VE tasks.
class ProxmoxTasksInfoOptions {
    /// Node where to get tasks.
    node: String
    /// Return specific task.
    task: String?
}

/// Task class for proxmox_tasks_info
class ProxmoxTasksInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.proxmox_tasks_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.proxmox_tasks_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.proxmox_tasks_info`
}

/// TaskBuilder class for proxmox_tasks_info
class ProxmoxTasksInfo extends Playbook.TaskBuilder {
    /// Options for community.general.proxmox_tasks_info
    options: ProxmoxTasksInfoOptions?
    /// todo doc
    function Task(): ProxmoxTasksInfoTask = this
        .toMap()
        .put("community.general.proxmox_tasks_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ProxmoxTasksInfoTask)
}

/// Management of OS templates in Proxmox VE cluster
/// allows you to upload/delete templates in Proxmox VE cluster
class ProxmoxTemplateOptions {
    /// Content type.
    /// Required only for O(state=present).
    content_type: ("vztmpl"|"iso")?
    /// It can only be used with O(state=present), existing template will be overwritten.
    force: Boolean?
    /// Proxmox VE node on which to operate.
    node: String?
    /// Path to uploaded file.
    /// Required only for O(state=present).
    src: String?
    /// Indicate desired state of the template.
    state: ("present"|"absent")?
    /// Target storage.
    storage: String?
    /// The template name.
    /// Required for O(state=absent) to delete a template.
    /// Required for O(state=present) to download an appliance container template (pveam).
    template: String?
    /// Timeout for operations.
    timeout: Int?
}

/// Task class for proxmox_template
class ProxmoxTemplateTask extends Playbook.Task {
    /// todo doc
    `community.general.proxmox_template`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.proxmox_template"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.proxmox_template`
}

/// TaskBuilder class for proxmox_template
class ProxmoxTemplate extends Playbook.TaskBuilder {
    /// Options for community.general.proxmox_template
    options: ProxmoxTemplateOptions?
    /// todo doc
    function Task(): ProxmoxTemplateTask = this
        .toMap()
        .put("community.general.proxmox_template", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ProxmoxTemplateTask)
}

/// Retrieve information about one or more Proxmox VE users
/// Retrieve information about one or more Proxmox VE users
class ProxmoxUserInfoOptions {
    /// Restrict results to a specific authentication realm.
    domain: String?
    /// Restrict results to a specific user.
    user: String?
    /// Restrict results to a specific user ID, which is a concatenation of a user and domain parts.
    userid: String?
}

/// Task class for proxmox_user_info
class ProxmoxUserInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.proxmox_user_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.proxmox_user_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.proxmox_user_info`
}

/// TaskBuilder class for proxmox_user_info
class ProxmoxUserInfo extends Playbook.TaskBuilder {
    /// Options for community.general.proxmox_user_info
    options: ProxmoxUserInfoOptions?
    /// todo doc
    function Task(): ProxmoxUserInfoTask = this
        .toMap()
        .put("community.general.proxmox_user_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ProxmoxUserInfoTask)
}

/// Retrieve information about one or more Proxmox VE virtual machines
/// Retrieve information about one or more Proxmox VE virtual machines.
class ProxmoxVmInfoOptions {
    /// Whether to retrieve the VM configuration along with VM status.
    /// If set to V(none) (default), no configuration will be returned.
    /// If set to V(current), the current running configuration will be returned.
    /// If set to V(pending), the configuration with pending changes applied will be returned.
    config: ("none"|"current"|"pending")?
    /// Restrict results to a specific virtual machine(s) by using their name.
    /// If VM(s) with the specified name do not exist in a cluster then the resulting list will be empty.
    name: String?
    /// Restrict results to a specific Proxmox VE node.
    node: String?
    /// Restrict results to a specific virtual machine(s) type.
    type: ("all"|"qemu"|"lxc")?
    /// Restrict results to a specific virtual machine by using its ID.
    /// If VM with the specified vmid does not exist in a cluster then resulting list will be empty.
    vmid: Int?
}

/// Task class for proxmox_vm_info
class ProxmoxVmInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.proxmox_vm_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.proxmox_vm_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.proxmox_vm_info`
}

/// TaskBuilder class for proxmox_vm_info
class ProxmoxVmInfo extends Playbook.TaskBuilder {
    /// Options for community.general.proxmox_vm_info
    options: ProxmoxVmInfoOptions?
    /// todo doc
    function Task(): ProxmoxVmInfoTask = this
        .toMap()
        .put("community.general.proxmox_vm_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ProxmoxVmInfoTask)
}

/// PubNub blocks management module
/// This module allows Ansible to interface with the PubNub BLOCKS infrastructure by providing the following operations: create / remove, start / stop and rename for blocks and create / modify / remove for event handlers.
class PubnubBlocksOptions {
    /// Name of PubNub account for from which O(application) will be used to manage blocks.
    /// User's account will be used if value not set or empty.
    account: String?
    /// Name of target PubNub application for which blocks configuration on specific O(keyset) will be done.
    application: String
    /// In case if single play use blocks management module few times it is preferred to enabled 'caching' by making previous module to share gathered artifacts and pass them to this parameter.
    cache: Any?
    /// List of fields which should be changed by block itself (doesn't affect any event handlers).
    /// Possible options for change is: O(name).
    changes: Any?
    /// Short block description which will be later visible on admin.pubnub.com. Used only if block doesn't exists and won't change description for existing block.
    description: String?
    /// Email from account for which new session should be started.
    /// Not required if O(cache) contains result of previous module call (in same play).
    email: String?
    /// List of event handlers which should be updated for specified block O(name).
    /// Each entry for new event handler should contain: C(name), C(src), C(channels), C(event). C(name) used as event handler name which can be used later to make changes to it.
    /// C(src) is full path to file with event handler code.
    /// C(channels) is name of channel from which event handler is waiting for events.
    /// C(event) is type of event which is able to trigger event handler: C(js-before-publish), C(js-after-publish), C(js-after-presence).
    /// Each entry for existing handlers should contain C(name) (so target handler can be identified). Rest parameters (C(src), C(channels) and C(event)) can be added if changes required for them.
    /// It is possible to rename event handler by adding C(changes) key to event handler payload and pass dictionary, which will contain single key C(name), where new name should be passed.
    /// To remove particular event handler it is possible to set C(state) for it to C(absent) and it will be removed.
    event_handlers: Listing<Any>?
    /// Name of application's keys set which is bound to managed blocks.
    keyset: String
    /// Name of managed block which will be later visible on admin.pubnub.com.
    name: String
    /// Password which match to account to which specified O(email) belong.
    /// Not required if O(cache) contains result of previous module call (in same play).
    password: String?
    /// Intended block state after event handlers creation / update process will be completed.
    state: ("started"|"stopped"|"present"|"absent")?
    /// This key allow to try skip certificates check when performing REST API calls. Sometimes host may have issues with certificates on it and this will cause problems to call PubNub REST API.
    /// If check should be ignored V(false) should be passed to this parameter.
    validate_certs: Boolean?
}

/// Task class for pubnub_blocks
class PubnubBlocksTask extends Playbook.Task {
    /// todo doc
    `community.general.pubnub_blocks`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.pubnub_blocks"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.pubnub_blocks`
}

/// TaskBuilder class for pubnub_blocks
class PubnubBlocks extends Playbook.TaskBuilder {
    /// Options for community.general.pubnub_blocks
    options: PubnubBlocksOptions?
    /// todo doc
    function Task(): PubnubBlocksTask = this
        .toMap()
        .put("community.general.pubnub_blocks", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PubnubBlocksTask)
}

/// Add or remove Pulp repos from a remote host
/// Add or remove Pulp repos from a remote host.
/// Note, this is for Pulp 2 only.
class PulpRepoOptions {
    /// Whether or not to add the export distributor to new C(rpm) repositories.
    add_export_distributor: Boolean?
    /// Upstream feed URL to receive updates from.
    feed: String?
    /// CA certificate string used to validate the feed source SSL certificate. This can be the file content or the path to the file.
    feed_ca_cert: String?
    /// Certificate used as the client certificate when synchronizing the repository. This is used to communicate authentication information to the feed source. The value to this option must be the full path to the certificate. The specified file may be the certificate itself or a single file containing both the certificate and private key. This can be the file content or the path to the file.
    feed_client_cert: String?
    /// Private key to the certificate specified in O(feed_client_cert), assuming it is not included in the certificate file itself. This can be the file content or the path to the file.
    feed_client_key: String?
    /// httplib2, the library used by the M(ansible.builtin.uri) module only sends authentication information when a webservice responds to an initial request with a 401 status. Since some basic auth services do not properly send a 401, logins will fail. This option forces the sending of the Basic authentication header upon initial request.
    force_basic_auth: Boolean?
    /// Boolean flag to indicate whether sqlite files should be generated during a repository publish.
    generate_sqlite: Boolean?
    /// Name of the repo to add or remove. This correlates to repo-id in Pulp.
    name: String
    /// Proxy url setting for the pulp repository importer. This is in the format scheme://host.
    proxy_host: String?
    /// Proxy password for the pulp repository importer.
    proxy_password: String?
    /// Proxy port setting for the pulp repository importer.
    proxy_port: String?
    /// Proxy username for the pulp repository importer.
    proxy_username: String?
    /// Distributor to use when O(state=publish). The default is to publish all distributors.
    publish_distributor: String?
    /// URL of the pulp server to connect to.
    pulp_host: String?
    /// Relative URL for the local repository. It's required when state=present.
    relative_url: String?
    /// Repo plugin type to use (that is, V(rpm), V(docker)).
    repo_type: String?
    /// Whether to generate repoview files for a published repository. Setting this to V(true) automatically activates O(generate_sqlite).
    repoview: Boolean?
    /// Make the repo available over HTTP.
    serve_http: Boolean?
    /// Make the repo available over HTTPS.
    serve_https: Boolean?
    /// The repo state. A state of V(sync) will queue a sync of the repo. This is asynchronous but not delayed like a scheduled sync. A state of V(publish) will use the repository's distributor to publish the content.
    state: ("present"|"absent"|"sync"|"publish")?
    /// The password for use in HTTP basic authentication to the pulp API. If the O(url_username) parameter is not specified, the O(url_password) parameter will not be used.
    url_password: Any?
    /// The username for use in HTTP basic authentication to the pulp API.
    url_username: Any?
    /// If V(false), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
    validate_certs: Boolean?
    /// Wait for asynchronous tasks to complete before returning.
    wait_for_completion: Boolean?
}

/// Task class for pulp_repo
class PulpRepoTask extends Playbook.Task {
    /// todo doc
    `community.general.pulp_repo`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.pulp_repo"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.pulp_repo`
}

/// TaskBuilder class for pulp_repo
class PulpRepo extends Playbook.TaskBuilder {
    /// Options for community.general.pulp_repo
    options: PulpRepoOptions?
    /// todo doc
    function Task(): PulpRepoTask = this
        .toMap()
        .put("community.general.pulp_repo", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PulpRepoTask)
}

/// Runs puppet
/// Runs C(puppet) agent or apply in a reliable manner.
class PuppetOptions {
    /// The name to use when handling certificates.
    certname: String?
    /// Path to the directory containing the puppet.conf file.
    confdir: String?
    /// Enable full debugging.
    debug: Boolean?
    /// Puppet environment to be used.
    environment: String?
    /// The lang environment to use when running the puppet agent.
    /// The default value, V(C), is supported on every system, but can lead to encoding errors if UTF-8 is used in the output
    /// Use V(C.UTF-8) or V(en_US.UTF-8) or similar UTF-8 supporting locales in case of problems. You need to make sure the selected locale is supported on the system the puppet agent runs on.
    environment_lang: String?
    /// Execute a specific piece of Puppet code.
    /// It has no effect with a puppetmaster.
    execute: String?
    /// Basename of the facter output file.
    facter_basename: String?
    /// A dict of values to pass in as persistent external facter facts.
    facts: Any?
    /// Where the puppet logs should go, if puppet apply is being used.
    /// V(all) will go to both C(console) and C(syslog).
    /// V(stdout) will be deprecated and replaced by C(console).
    logdest: ("all"|"stdout"|"syslog")?
    /// Path to the manifest file to run puppet apply on.
    manifest: String?
    /// Path to an alternate location for puppet modules.
    modulepath: String?
    /// Override puppet.conf noop mode.
    /// When V(true), run Puppet agent with C(--noop) switch set.
    /// When V(false), run Puppet agent with C(--no-noop) switch set.
    /// When unset (default), use default or puppet.conf value if defined.
    noop: Boolean?
    /// The hostname of the puppetmaster to contact.
    puppetmaster: String?
    /// Whether to print file changes details
    show_diff: Boolean?
    /// A list of puppet tags to be excluded.
    skip_tags: Listing<String>?
    /// Whether to print a transaction summary.
    summarize: Boolean?
    /// A list of puppet tags to be used.
    tags: Listing<String>?
    /// How long to wait for C(puppet) to finish.
    timeout: String?
    /// Toggles use_srv_records flag
    use_srv_records: Boolean?
    /// Print extra information.
    verbose: Boolean?
}

/// Task class for puppet
class PuppetTask extends Playbook.Task {
    /// todo doc
    `community.general.puppet`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.puppet"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.puppet`
}

/// TaskBuilder class for puppet
class Puppet extends Playbook.TaskBuilder {
    /// Options for community.general.puppet
    options: PuppetOptions?
    /// todo doc
    function Task(): PuppetTask = this
        .toMap()
        .put("community.general.puppet", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PuppetTask)
}

/// Sends notifications to Pushbullet
/// This module sends push notifications via Pushbullet to channels or devices.
class PushbulletOptions {
    /// Push bullet API token
    api_key: String
    /// Body of the notification, e.g. Details of the fault you're alerting.
    body: String?
    /// The channel TAG you wish to broadcast a push notification, as seen on the "My Channels" > "Edit your channel" at Pushbullet page.
    channel: String?
    /// The device NAME you wish to send a push notification, as seen on the Pushbullet main page.
    device: String?
    /// Thing you wish to push.
    push_type: ("note"|"link")?
    /// Title of the notification.
    title: String
    /// URL field, used when O(push_type=link).
    url: String?
}

/// Task class for pushbullet
class PushbulletTask extends Playbook.Task {
    /// todo doc
    `community.general.pushbullet`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.pushbullet"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.pushbullet`
}

/// TaskBuilder class for pushbullet
class Pushbullet extends Playbook.TaskBuilder {
    /// Options for community.general.pushbullet
    options: PushbulletOptions?
    /// todo doc
    function Task(): PushbulletTask = this
        .toMap()
        .put("community.general.pushbullet", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PushbulletTask)
}

/// Send notifications via U(https://pushover.net)
/// Send notifications via pushover, to subscriber list of devices, and email addresses. Requires pushover app on devices.
class PushoverOptions {
    /// Pushover issued token identifying your pushover app.
    app_token: String
    /// A device the message should be sent to. Multiple devices can be specified, separated by a comma.
    device: String?
    /// What message you wish to send.
    msg: String
    /// Message priority (see U(https://pushover.net) for details).
    pri: ("-2"|"-1"|"0"|"1"|"2")?
    /// Message title.
    title: String?
    /// Pushover issued authentication key for your user.
    user_key: String
}

/// Task class for pushover
class PushoverTask extends Playbook.Task {
    /// todo doc
    `community.general.pushover`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.pushover"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.pushover`
}

/// TaskBuilder class for pushover
class Pushover extends Playbook.TaskBuilder {
    /// Options for community.general.pushover
    options: PushoverOptions?
    /// todo doc
    function Task(): PushoverTask = this
        .toMap()
        .put("community.general.pushover", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PushoverTask)
}

/// Show python path and assert dependency versions
/// Get info about available Python requirements on the target host, including listing required libraries and gathering versions.
class PythonRequirementsInfoOptions {
    /// A list of version-likes or module names to check for installation. Supported operators: <, >, <=, >=, or ==. The bare module name like V(ansible), the module with a specific version like V(boto3==1.6.1), or a partial version like V(requests>2) are all valid specifications.
    dependencies: Listing<String>?
}

/// Task class for python_requirements_info
class PythonRequirementsInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.python_requirements_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.python_requirements_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.python_requirements_info`
}

/// TaskBuilder class for python_requirements_info
class PythonRequirementsInfo extends Playbook.TaskBuilder {
    /// Options for community.general.python_requirements_info
    options: PythonRequirementsInfoOptions?
    /// todo doc
    function Task(): PythonRequirementsInfoTask = this
        .toMap()
        .put("community.general.python_requirements_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(PythonRequirementsInfoTask)
}

/// Create / delete an instance in Rackspace Public Cloud
/// creates / deletes a Rackspace Public Cloud instance and optionally waits for it to be 'running'.
class RaxOptions {
    /// Whether or not to increment a single number with the name of the created servers. Only applicable when used with the O(group) attribute or meta key.
    auto_increment: Boolean?
    /// Whether or not to boot the instance from a Cloud Block Storage volume. If V(true) and O(image) is specified a new volume will be created at boot time. O(boot_volume_size) is required with O(image) to create a new volume at boot time.
    boot_from_volume: Boolean?
    /// Cloud Block Storage ID or Name to use as the boot volume of the instance
    boot_volume: String?
    /// Size of the volume to create in Gigabytes. This is only required with O(image) and O(boot_from_volume).
    boot_volume_size: Int?
    /// Whether the O(boot_volume) or newly created volume from O(image) will be terminated when the server is terminated
    boot_volume_terminate: Boolean?
    /// Attach read-only configuration drive to server as label config-2
    config_drive: Boolean?
    /// number of instances to launch
    count: Int?
    /// number count to start at
    count_offset: Int?
    /// Disk partitioning strategy
    /// If not specified it will assume the value V(auto).
    disk_config: ("auto"|"manual")?
    /// Explicitly ensure an exact count of instances, used with state=active/present. If specified as V(true) and O(count) is less than the servers matched, servers will be deleted to match the count. If the number of matched servers is fewer than specified in O(count) additional servers will be added.
    exact_count: Boolean?
    /// A hash of key/value pairs to be used when creating the cloudservers client. This is considered an advanced option, use it wisely and with caution.
    extra_client_args: Any?
    /// A hash of key/value pairs to be used when creating a new server. This is considered an advanced option, use it wisely and with caution.
    extra_create_args: Any?
    /// Files to insert into the instance. remotefilename:localcontent
    files: Any?
    /// flavor to use for the instance
    flavor: String?
    /// host group to assign to server, is also used for idempotent operations to ensure a specific number of instances
    group: String?
    /// image to use for the instance. Can be an C(id), C(human_id) or C(name). With O(boot_from_volume), a Cloud Block Storage volume will be created with this image
    image: String?
    /// list of instance ids, currently only used when state='absent' to remove instances
    instance_ids: Listing<String>?
    /// key pair to use on the instance
    key_name: String?
    /// A hash of metadata to associate with the instance
    meta: Any?
    /// Name to give the instance
    name: String?
    /// The network to attach to the instances. If specified, you must include ALL networks including the public and private interfaces. Can be C(id) or C(label).
    networks: Listing<String>?
    /// Indicate desired state of the resource
    state: ("present"|"absent")?
    /// Data to be uploaded to the servers config drive. This option implies O(config_drive). Can be a file path or a string
    user_data: String?
    /// wait for the instance to be in state 'running' before returning
    wait: Boolean?
    /// how long before wait gives up, in seconds
    wait_timeout: Int?
}

/// Task class for rax
class RaxTask extends Playbook.Task {
    /// todo doc
    `community.general.rax`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rax"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rax`
}

/// TaskBuilder class for rax
class Rax extends Playbook.TaskBuilder {
    /// Options for community.general.rax
    options: RaxOptions?
    /// todo doc
    function Task(): RaxTask = this
        .toMap()
        .put("community.general.rax", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RaxTask)
}

/// Manipulate Rackspace Cloud Block Storage Volumes
/// Manipulate Rackspace Cloud Block Storage Volumes
class RaxCbsOptions {
    /// Description to give the volume being created.
    description: String?
    /// Image to use for bootable volumes. Can be an C(id), C(human_id) or C(name). This option requires C(pyrax>=1.9.3).
    image: String?
    /// A hash of metadata to associate with the volume.
    meta: Any?
    /// Name to give the volume being created.
    name: String
    /// Size of the volume to create in Gigabytes.
    size: Int?
    /// The id of the snapshot to create the volume from.
    snapshot_id: String?
    /// Indicate desired state of the resource.
    state: ("present"|"absent")?
    /// Type of the volume being created.
    volume_type: ("SATA"|"SSD")?
    /// Wait for the volume to be in state C(available) before returning.
    wait: Boolean?
    /// how long before wait gives up, in seconds.
    wait_timeout: Int?
}

/// Task class for rax_cbs
class RaxCbsTask extends Playbook.Task {
    /// todo doc
    `community.general.rax_cbs`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rax_cbs"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rax_cbs`
}

/// TaskBuilder class for rax_cbs
class RaxCbs extends Playbook.TaskBuilder {
    /// Options for community.general.rax_cbs
    options: RaxCbsOptions?
    /// todo doc
    function Task(): RaxCbsTask = this
        .toMap()
        .put("community.general.rax_cbs", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RaxCbsTask)
}

/// Manipulate Rackspace Cloud Block Storage Volume Attachments
/// Manipulate Rackspace Cloud Block Storage Volume Attachments
class RaxCbsAttachmentsOptions {
    /// The device path to attach the volume to, e.g. /dev/xvde.
    /// Before 2.4 this was a required field. Now it can be left to null to auto assign the device name.
    device: String?
    /// Name or id of the server to attach/detach
    server: String
    /// Indicate desired state of the resource
    state: ("present"|"absent")?
    /// Name or id of the volume to attach/detach
    volume: String
    /// wait for the volume to be in 'in-use'/'available' state before returning
    wait: Boolean?
    /// how long before wait gives up, in seconds
    wait_timeout: Int?
}

/// Task class for rax_cbs_attachments
class RaxCbsAttachmentsTask extends Playbook.Task {
    /// todo doc
    `community.general.rax_cbs_attachments`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rax_cbs_attachments"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rax_cbs_attachments`
}

/// TaskBuilder class for rax_cbs_attachments
class RaxCbsAttachments extends Playbook.TaskBuilder {
    /// Options for community.general.rax_cbs_attachments
    options: RaxCbsAttachmentsOptions?
    /// todo doc
    function Task(): RaxCbsAttachmentsTask = this
        .toMap()
        .put("community.general.rax_cbs_attachments", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RaxCbsAttachmentsTask)
}

/// Create/delete or resize a Rackspace Cloud Databases instance
/// creates / deletes or resize a Rackspace Cloud Databases instance and optionally waits for it to be 'running'. The name option needs to be unique since it's used to identify the instance.
class RaxCdbOptions {
    /// type of instance (i.e. MySQL, MariaDB, Percona)
    cdb_type: String?
    /// version of database (MySQL supports 5.1 and 5.6, MariaDB supports 10, Percona supports 5.6)
    /// The available choices are: V(5.1), V(5.6) and  V(10).
    cdb_version: String?
    /// flavor to use for the instance 1 to 6 (i.e. 512MB to 16GB)
    flavor: Int?
    /// Name of the databases server instance
    name: String
    /// Indicate desired state of the resource
    state: ("present"|"absent")?
    /// Volume size of the database 1-150GB
    volume: Int?
    /// wait for the instance to be in state 'running' before returning
    wait: Boolean?
    /// how long before wait gives up, in seconds
    wait_timeout: Int?
}

/// Task class for rax_cdb
class RaxCdbTask extends Playbook.Task {
    /// todo doc
    `community.general.rax_cdb`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rax_cdb"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rax_cdb`
}

/// TaskBuilder class for rax_cdb
class RaxCdb extends Playbook.TaskBuilder {
    /// Options for community.general.rax_cdb
    options: RaxCdbOptions?
    /// todo doc
    function Task(): RaxCdbTask = this
        .toMap()
        .put("community.general.rax_cdb", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RaxCdbTask)
}

/// Create / delete a database in the Cloud Databases
/// create / delete a database in the Cloud Databases.
class RaxCdbDatabaseOptions {
    /// The databases server UUID
    cdb_id: String
    /// Set of symbols and encodings
    character_set: String?
    /// Set of rules for comparing characters in a character set
    collate: String?
    /// Name to give to the database
    name: String
    /// Indicate desired state of the resource
    state: ("present"|"absent")?
}

/// Task class for rax_cdb_database
class RaxCdbDatabaseTask extends Playbook.Task {
    /// todo doc
    `community.general.rax_cdb_database`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rax_cdb_database"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rax_cdb_database`
}

/// TaskBuilder class for rax_cdb_database
class RaxCdbDatabase extends Playbook.TaskBuilder {
    /// Options for community.general.rax_cdb_database
    options: RaxCdbDatabaseOptions?
    /// todo doc
    function Task(): RaxCdbDatabaseTask = this
        .toMap()
        .put("community.general.rax_cdb_database", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RaxCdbDatabaseTask)
}

/// Create / delete a Rackspace Cloud Database
/// create / delete a database in the Cloud Databases.
class RaxCdbUserOptions {
    /// The databases server UUID
    cdb_id: String
    /// Name of the databases that the user can access
    databases: Listing<String>?
    /// Database user password
    db_password: String
    /// Name of the database user
    db_username: String
    /// Specifies the host from which a user is allowed to connect to the database. Possible values are a string containing an IPv4 address or "%" to allow connecting from any host
    host: String?
    /// Indicate desired state of the resource
    state: ("present"|"absent")?
}

/// Task class for rax_cdb_user
class RaxCdbUserTask extends Playbook.Task {
    /// todo doc
    `community.general.rax_cdb_user`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rax_cdb_user"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rax_cdb_user`
}

/// TaskBuilder class for rax_cdb_user
class RaxCdbUser extends Playbook.TaskBuilder {
    /// Options for community.general.rax_cdb_user
    options: RaxCdbUserOptions?
    /// todo doc
    function Task(): RaxCdbUserTask = this
        .toMap()
        .put("community.general.rax_cdb_user", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RaxCdbUserTask)
}

/// Create / delete a load balancer in Rackspace Public Cloud
/// creates / deletes a Rackspace Public Cloud load balancer.
class RaxClbOptions {
    /// algorithm for the balancer being created
    algorithm: ("RANDOM"|"LEAST_CONNECTIONS"|"ROUND_ROBIN"|"WEIGHTED_LEAST_CONNECTIONS"|"WEIGHTED_ROUND_ROBIN")?
    /// A hash of metadata to associate with the instance
    meta: Any?
    /// Name to give the load balancer
    name: String
    /// Port for the balancer being created
    port: Int?
    /// Protocol for the balancer being created
    protocol: ("DNS_TCP"|"DNS_UDP"|"FTP"|"HTTP"|"HTTPS"|"IMAPS"|"IMAPv4"|"LDAP"|"LDAPS"|"MYSQL"|"POP3"|"POP3S"|"SMTP"|"TCP"|"TCP_CLIENT_FIRST"|"UDP"|"UDP_STREAM"|"SFTP")?
    /// Indicate desired state of the resource
    state: ("present"|"absent")?
    /// timeout for communication between the balancer and the node
    timeout: Int?
    /// type of interface for the balancer being created
    type: ("PUBLIC"|"SERVICENET")?
    /// Virtual IP ID to use when creating the load balancer for purposes of sharing an IP with another load balancer of another protocol
    vip_id: String?
    /// wait for the balancer to be in state 'running' before returning
    wait: Boolean?
    /// how long before wait gives up, in seconds
    wait_timeout: Int?
}

/// Task class for rax_clb
class RaxClbTask extends Playbook.Task {
    /// todo doc
    `community.general.rax_clb`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rax_clb"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rax_clb`
}

/// TaskBuilder class for rax_clb
class RaxClb extends Playbook.TaskBuilder {
    /// Options for community.general.rax_clb
    options: RaxClbOptions?
    /// todo doc
    function Task(): RaxClbTask = this
        .toMap()
        .put("community.general.rax_clb", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RaxClbTask)
}

/// Add, modify and remove nodes from a Rackspace Cloud Load Balancer
/// Adds, modifies and removes nodes from a Rackspace Cloud Load Balancer
class RaxClbNodesOptions {
    /// IP address or domain name of the node
    address: String?
    /// Condition for the node, which determines its role within the load balancer
    condition: ("enabled"|"disabled"|"draining")?
    /// Load balancer id
    load_balancer_id: Int
    /// Node id
    node_id: Int?
    /// Port number of the load balanced service on the node
    port: Int?
    /// Indicate desired state of the node
    state: ("present"|"absent")?
    /// Type of node
    type: ("primary"|"secondary")?
    /// Virtualenv to execute this module in
    virtualenv: String?
    /// Wait for the load balancer to become active before returning
    wait: Boolean?
    /// How long to wait before giving up and returning an error
    wait_timeout: Int?
    /// Weight of node
    weight: Int?
}

/// Task class for rax_clb_nodes
class RaxClbNodesTask extends Playbook.Task {
    /// todo doc
    `community.general.rax_clb_nodes`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rax_clb_nodes"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rax_clb_nodes`
}

/// TaskBuilder class for rax_clb_nodes
class RaxClbNodes extends Playbook.TaskBuilder {
    /// Options for community.general.rax_clb_nodes
    options: RaxClbNodesOptions?
    /// todo doc
    function Task(): RaxClbNodesTask = this
        .toMap()
        .put("community.general.rax_clb_nodes", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RaxClbNodesTask)
}

/// Manage SSL termination for a Rackspace Cloud Load Balancer
/// Set up, reconfigure, or remove SSL termination for an existing load balancer.
class RaxClbSslOptions {
    /// The public SSL certificates as a string in PEM format.
    certificate: String?
    /// If set to "false", temporarily disable SSL termination without discarding
    /// existing credentials.
    enabled: Boolean?
    /// If "true", the load balancer will redirect HTTP traffic to HTTPS.
    /// Requires "secure_traffic_only" to be true. Incurs an implicit wait if SSL
    /// termination is also applied or removed.
    https_redirect: Boolean?
    /// One or more intermediate certificate authorities as a string in PEM
    /// format, concatenated into a single string.
    intermediate_certificate: String?
    /// Name or ID of the load balancer on which to manage SSL termination.
    loadbalancer: String
    /// The private SSL key as a string in PEM format.
    private_key: String?
    /// The port to listen for secure traffic.
    secure_port: Int?
    /// If "true", the load balancer will *only* accept secure traffic.
    secure_traffic_only: Boolean?
    /// If set to "present", SSL termination will be added to this load balancer.
    /// If "absent", SSL termination will be removed instead.
    state: ("present"|"absent")?
    /// Wait for the balancer to be in state "running" before turning.
    wait: Boolean?
    /// How long before "wait" gives up, in seconds.
    wait_timeout: Int?
}

/// Task class for rax_clb_ssl
class RaxClbSslTask extends Playbook.Task {
    /// todo doc
    `community.general.rax_clb_ssl`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rax_clb_ssl"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rax_clb_ssl`
}

/// TaskBuilder class for rax_clb_ssl
class RaxClbSsl extends Playbook.TaskBuilder {
    /// Options for community.general.rax_clb_ssl
    options: RaxClbSslOptions?
    /// todo doc
    function Task(): RaxClbSslTask = this
        .toMap()
        .put("community.general.rax_clb_ssl", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RaxClbSslTask)
}

/// Manage domains on Rackspace Cloud DNS
/// Manage domains on Rackspace Cloud DNS
class RaxDnsOptions {
    /// Brief description of the domain. Maximum length of 160 characters
    comment: String?
    /// Email address of the domain administrator
    email: String?
    /// Domain name to create
    name: String?
    /// Indicate desired state of the resource
    state: ("present"|"absent")?
    /// Time to live of domain in seconds
    ttl: Int?
}

/// Task class for rax_dns
class RaxDnsTask extends Playbook.Task {
    /// todo doc
    `community.general.rax_dns`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rax_dns"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rax_dns`
}

/// TaskBuilder class for rax_dns
class RaxDns extends Playbook.TaskBuilder {
    /// Options for community.general.rax_dns
    options: RaxDnsOptions?
    /// todo doc
    function Task(): RaxDnsTask = this
        .toMap()
        .put("community.general.rax_dns", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RaxDnsTask)
}

/// Manage DNS records on Rackspace Cloud DNS
/// Manage DNS records on Rackspace Cloud DNS
class RaxDnsRecordOptions {
    /// Brief description of the domain. Maximum length of 160 characters
    comment: String?
    /// IP address for A/AAAA record, FQDN for CNAME/MX/NS, or text data for SRV/TXT
    data: String
    /// Domain name to create the record in. This is an invalid option when type=PTR
    domain: String?
    /// Load Balancer ID to create a PTR record for. Only used with type=PTR
    loadbalancer: String?
    /// FQDN record name to create
    name: String
    /// Add new records if data doesn't match, instead of updating existing record with matching name. If there are already multiple records with matching name and overwrite=true, this module will fail.
    overwrite: Boolean?
    /// Required for MX and SRV records, but forbidden for other record types. If specified, must be an integer from 0 to 65535.
    priority: Int?
    /// Server ID to create a PTR record for. Only used with type=PTR
    server: String?
    /// Indicate desired state of the resource
    state: ("present"|"absent")?
    /// Time to live of record in seconds
    ttl: Int?
    /// DNS record type
    type: ("A"|"AAAA"|"CNAME"|"MX"|"NS"|"SRV"|"TXT"|"PTR")
}

/// Task class for rax_dns_record
class RaxDnsRecordTask extends Playbook.Task {
    /// todo doc
    `community.general.rax_dns_record`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rax_dns_record"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rax_dns_record`
}

/// TaskBuilder class for rax_dns_record
class RaxDnsRecord extends Playbook.TaskBuilder {
    /// Options for community.general.rax_dns_record
    options: RaxDnsRecordOptions?
    /// todo doc
    function Task(): RaxDnsRecordTask = this
        .toMap()
        .put("community.general.rax_dns_record", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RaxDnsRecordTask)
}

/// Gather facts for Rackspace Cloud Servers
/// Gather facts for Rackspace Cloud Servers.
class RaxFactsOptions {
    /// Server IP address to retrieve facts for, will match any IP assigned to the server
    address: String?
    /// Server ID to retrieve facts for
    id: String?
    /// Server name to retrieve facts for
    name: String?
}

/// Task class for rax_facts
class RaxFactsTask extends Playbook.Task {
    /// todo doc
    `community.general.rax_facts`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rax_facts"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rax_facts`
}

/// TaskBuilder class for rax_facts
class RaxFacts extends Playbook.TaskBuilder {
    /// Options for community.general.rax_facts
    options: RaxFactsOptions?
    /// todo doc
    function Task(): RaxFactsTask = this
        .toMap()
        .put("community.general.rax_facts", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RaxFactsTask)
}

/// Manipulate Rackspace Cloud Files Containers
/// Manipulate Rackspace Cloud Files Containers
class RaxFilesOptions {
    /// Optionally clear existing metadata when applying metadata to existing containers. Selecting this option is only appropriate when setting type=meta
    clear_meta: Boolean?
    /// The container to use for container or metadata operations.
    container: String?
    /// A hash of items to set as metadata values on a container
    meta: Any?
    /// Used to set a container as private, removing it from the CDN.  B(Warning!) Private containers, if previously made public, can have live objects available until the TTL on cached objects expires
    private: Boolean?
    /// Used to set a container as public, available via the Cloud Files CDN
    public: Boolean?
    /// Region to create an instance in
    region: String?
    /// Indicate desired state of the resource
    state: ("present"|"absent"|"list")?
    /// In seconds, set a container-wide TTL for all objects cached on CDN edge nodes. Setting a TTL is only appropriate for containers that are public
    ttl: Int?
    /// Type of object to do work on, i.e. metadata object or a container object
    type: ("container"|"meta")?
    /// Sets an object to be presented as the HTTP error page when accessed by the CDN URL
    web_error: String?
    /// Sets an object to be presented as the HTTP index page when accessed by the CDN URL
    web_index: String?
}

/// Task class for rax_files
class RaxFilesTask extends Playbook.Task {
    /// todo doc
    `community.general.rax_files`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rax_files"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rax_files`
}

/// TaskBuilder class for rax_files
class RaxFiles extends Playbook.TaskBuilder {
    /// Options for community.general.rax_files
    options: RaxFilesOptions?
    /// todo doc
    function Task(): RaxFilesTask = this
        .toMap()
        .put("community.general.rax_files", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RaxFilesTask)
}

/// Upload, download, and delete objects in Rackspace Cloud Files
/// Upload, download, and delete objects in Rackspace Cloud Files.
class RaxFilesObjectsOptions {
    /// Optionally clear existing metadata when applying metadata to existing objects. Selecting this option is only appropriate when setting O(type=meta).
    clear_meta: Boolean?
    /// The container to use for file object operations.
    container: String
    /// The destination of a C(get) operation; i.e. a local directory, C(/home/user/myfolder). Used to specify the destination of an operation on a remote object; i.e. a file name, V(file1), or a comma-separated list of remote objects, V(file1,file2,file17).
    dest: String?
    /// Used to set an expiration in seconds on an uploaded file or folder.
    expires: Int?
    /// Items to set as metadata values on an uploaded file or folder.
    meta: Any?
    /// The method of operation to be performed: V(put) to upload files, V(get) to download files or V(delete) to remove remote objects in Cloud Files.
    method: ("get"|"put"|"delete")?
    /// Source from which to upload files.  Used to specify a remote object as a source for an operation, i.e. a file name, V(file1), or a comma-separated list of remote objects, V(file1,file2,file17). Parameters O(src) and O(dest) are mutually exclusive on remote-only object operations
    src: String?
    /// Used to specify whether to maintain nested directory structure when downloading objects from Cloud Files.  Setting to false downloads the contents of a container to a single, flat directory
    structure: Boolean?
    /// Type of object to do work on
    /// Metadata object or a file object
    type: ("file"|"meta")?
}

/// Task class for rax_files_objects
class RaxFilesObjectsTask extends Playbook.Task {
    /// todo doc
    `community.general.rax_files_objects`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rax_files_objects"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rax_files_objects`
}

/// TaskBuilder class for rax_files_objects
class RaxFilesObjects extends Playbook.TaskBuilder {
    /// Options for community.general.rax_files_objects
    options: RaxFilesObjectsOptions?
    /// todo doc
    function Task(): RaxFilesObjectsTask = this
        .toMap()
        .put("community.general.rax_files_objects", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RaxFilesObjectsTask)
}

/// Load Rackspace Cloud Identity
/// Verifies Rackspace Cloud credentials and returns identity information
class RaxIdentityOptions {
    /// Indicate desired state of the resource
    state: ("present")?
}

/// Task class for rax_identity
class RaxIdentityTask extends Playbook.Task {
    /// todo doc
    `community.general.rax_identity`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rax_identity"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rax_identity`
}

/// TaskBuilder class for rax_identity
class RaxIdentity extends Playbook.TaskBuilder {
    /// Options for community.general.rax_identity
    options: RaxIdentityOptions?
    /// todo doc
    function Task(): RaxIdentityTask = this
        .toMap()
        .put("community.general.rax_identity", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RaxIdentityTask)
}

/// Create a keypair for use with Rackspace Cloud Servers
/// Create a keypair for use with Rackspace Cloud Servers
class RaxKeypairOptions {
    /// Name of keypair
    name: String
    /// Public Key string to upload. Can be a file path or string
    public_key: String?
    /// Indicate desired state of the resource
    state: ("present"|"absent")?
}

/// Task class for rax_keypair
class RaxKeypairTask extends Playbook.Task {
    /// todo doc
    `community.general.rax_keypair`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rax_keypair"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rax_keypair`
}

/// TaskBuilder class for rax_keypair
class RaxKeypair extends Playbook.TaskBuilder {
    /// Options for community.general.rax_keypair
    options: RaxKeypairOptions?
    /// todo doc
    function Task(): RaxKeypairTask = this
        .toMap()
        .put("community.general.rax_keypair", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RaxKeypairTask)
}

/// Manipulate metadata for Rackspace Cloud Servers
/// Manipulate metadata for Rackspace Cloud Servers
class RaxMetaOptions {
    /// Server IP address to modify metadata for, will match any IP assigned to the server
    address: String?
    /// Server ID to modify metadata for
    id: String?
    /// A hash of metadata to associate with the instance
    meta: Any?
    /// Server name to modify metadata for
    name: String?
}

/// Task class for rax_meta
class RaxMetaTask extends Playbook.Task {
    /// todo doc
    `community.general.rax_meta`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rax_meta"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rax_meta`
}

/// TaskBuilder class for rax_meta
class RaxMeta extends Playbook.TaskBuilder {
    /// Options for community.general.rax_meta
    options: RaxMetaOptions?
    /// todo doc
    function Task(): RaxMetaTask = this
        .toMap()
        .put("community.general.rax_meta", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RaxMetaTask)
}

/// Create or delete a Rackspace Cloud Monitoring alarm
/// Create or delete a Rackspace Cloud Monitoring alarm that associates an existing rax_mon_entity, rax_mon_check, and rax_mon_notification_plan with criteria that specify what conditions will trigger which levels of notifications. Rackspace monitoring module flow | rax_mon_entity -> rax_mon_check -> rax_mon_notification -> rax_mon_notification_plan -> *rax_mon_alarm*
class RaxMonAlarmOptions {
    /// ID of the check that should be alerted on. May be acquired by registering the value of a rax_mon_check task.
    check_id: String
    /// Alarm DSL that describes alerting conditions and their output states. Must be between 1 and 16384 characters long. See http://docs.rackspace.com/cm/api/v1.0/cm-devguide/content/alerts-language.html for a reference on the alerting language.
    criteria: String?
    /// If yes, create this alarm, but leave it in an inactive state. Defaults to no.
    disabled: Boolean?
    /// ID of the entity this alarm is attached to. May be acquired by registering the value of a rax_mon_entity task.
    entity_id: String
    /// Friendly name for this alarm, used to achieve idempotence. Must be a String between 1 and 255 characters long.
    label: String
    /// Arbitrary key/value pairs to accompany the alarm. Must be a hash of String keys and values between 1 and 255 characters long.
    metadata: Any?
    /// ID of the notification plan to trigger if this alarm fires. May be acquired by registering the value of a rax_mon_notification_plan task.
    notification_plan_id: String
    /// Ensure that the alarm with this O(label) exists or does not exist.
    state: ("present"|"absent")?
}

/// Task class for rax_mon_alarm
class RaxMonAlarmTask extends Playbook.Task {
    /// todo doc
    `community.general.rax_mon_alarm`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rax_mon_alarm"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rax_mon_alarm`
}

/// TaskBuilder class for rax_mon_alarm
class RaxMonAlarm extends Playbook.TaskBuilder {
    /// Options for community.general.rax_mon_alarm
    options: RaxMonAlarmOptions?
    /// todo doc
    function Task(): RaxMonAlarmTask = this
        .toMap()
        .put("community.general.rax_mon_alarm", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RaxMonAlarmTask)
}

/// Create or delete a Rackspace Cloud Monitoring check for an existing entity.
/// Create or delete a Rackspace Cloud Monitoring check associated with an existing rax_mon_entity. A check is a specific test or measurement that is performed, possibly from different monitoring zones, on the systems you monitor. Rackspace monitoring module flow | rax_mon_entity -> *rax_mon_check* -> rax_mon_notification -> rax_mon_notification_plan -> rax_mon_alarm
class RaxMonCheckOptions {
    /// The type of check to create. C(remote.) checks may be created on any rax_mon_entity. C(agent.) checks may only be created on rax_mon_entities that have a non-null C(agent_id).
    /// Choices for this option are:- V(remote.dns)- V(remote.ftp-banner)- V(remote.http)- V(remote.imap-banner)- V(remote.mssql-banner)- V(remote.mysql-banner)- V(remote.ping)- V(remote.pop3-banner)- V(remote.postgresql-banner)- V(remote.smtp-banner)- V(remote.smtp)- V(remote.ssh)- V(remote.tcp)- V(remote.telnet-banner)- V(agent.filesystem)- V(agent.memory)- V(agent.load_average)- V(agent.cpu)- V(agent.disk)- V(agent.network)- V(agent.plugin)
    check_type: String
    /// Additional details specific to the check type. Must be a hash of strings between 1 and 255 characters long, or an array or object containing 0 to 256 items.
    details: Any?
    /// If V(true), ensure the check is created, but don't actually use it yet.
    disabled: Boolean?
    /// ID of the rax_mon_entity to target with this check.
    entity_id: String
    /// Defines a label for this check, between 1 and 64 characters long.
    label: String
    /// Hash of arbitrary key-value pairs to accompany this check if it fires. Keys and values must be strings between 1 and 255 characters long.
    metadata: Any?
    /// Comma-separated list of the names of the monitoring zones the check should run from. Available monitoring zones include mzdfw, mzhkg, mziad, mzlon, mzord and mzsyd. Required for remote.* checks; prohibited for agent.* checks.
    monitoring_zones_poll: String?
    /// The number of seconds between each time the check is performed. Must be greater than the minimum period set on your account.
    period: Int?
    /// Ensure that a check with this O(label) exists or does not exist.
    state: ("present"|"absent")?
    /// One of O(target_alias) and O(target_hostname) is required for remote.* checks, but prohibited for agent.* checks. Use the corresponding key in the entity's C(ip_addresses) hash to resolve an IP address to target.
    target_alias: String?
    /// One of O(target_hostname) and O(target_alias) is required for remote.* checks, but prohibited for agent.* checks. The hostname this check should target. Must be a valid IPv4, IPv6, or FQDN.
    target_hostname: String?
    /// The number of seconds this check will wait when attempting to collect results. Must be less than the period.
    timeout: Int?
}

/// Task class for rax_mon_check
class RaxMonCheckTask extends Playbook.Task {
    /// todo doc
    `community.general.rax_mon_check`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rax_mon_check"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rax_mon_check`
}

/// TaskBuilder class for rax_mon_check
class RaxMonCheck extends Playbook.TaskBuilder {
    /// Options for community.general.rax_mon_check
    options: RaxMonCheckOptions?
    /// todo doc
    function Task(): RaxMonCheckTask = this
        .toMap()
        .put("community.general.rax_mon_check", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RaxMonCheckTask)
}

/// Create or delete a Rackspace Cloud Monitoring entity
/// Create or delete a Rackspace Cloud Monitoring entity, which represents a device to monitor. Entities associate checks and alarms with a target system and provide a convenient, centralized place to store IP addresses. Rackspace monitoring module flow | *rax_mon_entity* -> rax_mon_check -> rax_mon_notification -> rax_mon_notification_plan -> rax_mon_alarm
class RaxMonEntityOptions {
    /// Rackspace monitoring agent on the target device to which this entity is bound. Necessary to collect C(agent.) rax_mon_checks against this entity.
    agent_id: String?
    /// Defines a name for this entity. Must be a non-empty string between 1 and 255 characters long.
    label: String
    /// Hash of arbitrary C(name), C(value) pairs that are passed to associated rax_mon_alarms. Names and values must all be between 1 and 255 characters long.
    metadata: Any?
    /// Hash of IP addresses that may be referenced by name by rax_mon_checks added to this entity. Must be a dictionary of with keys that are names between 1 and 64 characters long, and values that are valid IPv4 or IPv6 addresses.
    named_ip_addresses: Any?
    /// Ensure that an entity with this C(name) exists or does not exist.
    state: ("present"|"absent")?
}

/// Task class for rax_mon_entity
class RaxMonEntityTask extends Playbook.Task {
    /// todo doc
    `community.general.rax_mon_entity`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rax_mon_entity"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rax_mon_entity`
}

/// TaskBuilder class for rax_mon_entity
class RaxMonEntity extends Playbook.TaskBuilder {
    /// Options for community.general.rax_mon_entity
    options: RaxMonEntityOptions?
    /// todo doc
    function Task(): RaxMonEntityTask = this
        .toMap()
        .put("community.general.rax_mon_entity", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RaxMonEntityTask)
}

/// Create or delete a Rackspace Cloud Monitoring notification
/// Create or delete a Rackspace Cloud Monitoring notification that specifies a channel that can be used to communicate alarms, such as email, webhooks, or PagerDuty. Rackspace monitoring module flow | rax_mon_entity -> rax_mon_check -> *rax_mon_notification* -> rax_mon_notification_plan -> rax_mon_alarm
class RaxMonNotificationOptions {
    /// Dictionary of key-value pairs used to initialize the notification. Required keys and meanings vary with notification type. See http://docs.rackspace.com/cm/api/v1.0/cm-devguide/content/ service-notification-types-crud.html for details.
    details: Any
    /// Defines a friendly name for this notification. String between 1 and 255 characters long.
    label: String
    /// A supported notification type.
    notification_type: ("webhook"|"email"|"pagerduty")
    /// Ensure that the notification with this O(label) exists or does not exist.
    state: ("present"|"absent")?
}

/// Task class for rax_mon_notification
class RaxMonNotificationTask extends Playbook.Task {
    /// todo doc
    `community.general.rax_mon_notification`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rax_mon_notification"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rax_mon_notification`
}

/// TaskBuilder class for rax_mon_notification
class RaxMonNotification extends Playbook.TaskBuilder {
    /// Options for community.general.rax_mon_notification
    options: RaxMonNotificationOptions?
    /// todo doc
    function Task(): RaxMonNotificationTask = this
        .toMap()
        .put("community.general.rax_mon_notification", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RaxMonNotificationTask)
}

/// Create or delete a Rackspace Cloud Monitoring notification plan.
/// Create or delete a Rackspace Cloud Monitoring notification plan by associating existing rax_mon_notifications with severity levels. Rackspace monitoring module flow | rax_mon_entity -> rax_mon_check -> rax_mon_notification -> *rax_mon_notification_plan* -> rax_mon_alarm
class RaxMonNotificationPlanOptions {
    /// Notification list to use when the alarm state is CRITICAL. Must be an array of valid rax_mon_notification ids.
    critical_state: Listing<String>?
    /// Defines a friendly name for this notification plan. String between 1 and 255 characters long.
    label: String
    /// Notification list to use when the alarm state is OK. Must be an array of valid rax_mon_notification ids.
    ok_state: Listing<String>?
    /// Ensure that the notification plan with this O(label) exists or does not exist.
    state: ("present"|"absent")?
    /// Notification list to use when the alarm state is WARNING. Must be an array of valid rax_mon_notification ids.
    warning_state: Listing<String>?
}

/// Task class for rax_mon_notification_plan
class RaxMonNotificationPlanTask extends Playbook.Task {
    /// todo doc
    `community.general.rax_mon_notification_plan`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rax_mon_notification_plan"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rax_mon_notification_plan`
}

/// TaskBuilder class for rax_mon_notification_plan
class RaxMonNotificationPlan extends Playbook.TaskBuilder {
    /// Options for community.general.rax_mon_notification_plan
    options: RaxMonNotificationPlanOptions?
    /// todo doc
    function Task(): RaxMonNotificationPlanTask = this
        .toMap()
        .put("community.general.rax_mon_notification_plan", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RaxMonNotificationPlanTask)
}

/// Create / delete an isolated network in Rackspace Public Cloud
/// creates / deletes a Rackspace Public Cloud isolated network.
class RaxNetworkOptions {
    /// cidr of the network being created
    cidr: String?
    /// Label (name) to give the network
    label: String
    /// Indicate desired state of the resource
    state: ("present"|"absent")?
}

/// Task class for rax_network
class RaxNetworkTask extends Playbook.Task {
    /// todo doc
    `community.general.rax_network`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rax_network"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rax_network`
}

/// TaskBuilder class for rax_network
class RaxNetwork extends Playbook.TaskBuilder {
    /// Options for community.general.rax_network
    options: RaxNetworkOptions?
    /// todo doc
    function Task(): RaxNetworkTask = this
        .toMap()
        .put("community.general.rax_network", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RaxNetworkTask)
}

/// Create / delete a queue in Rackspace Public Cloud
/// creates / deletes a Rackspace Public Cloud queue.
class RaxQueueOptions {
    /// Name to give the queue
    name: String?
    /// Indicate desired state of the resource
    state: ("present"|"absent")?
}

/// Task class for rax_queue
class RaxQueueTask extends Playbook.Task {
    /// todo doc
    `community.general.rax_queue`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rax_queue"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rax_queue`
}

/// TaskBuilder class for rax_queue
class RaxQueue extends Playbook.TaskBuilder {
    /// Options for community.general.rax_queue
    options: RaxQueueOptions?
    /// todo doc
    function Task(): RaxQueueTask = this
        .toMap()
        .put("community.general.rax_queue", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RaxQueueTask)
}

/// Manipulate Rackspace Cloud Autoscale Groups
/// Manipulate Rackspace Cloud Autoscale Groups
class RaxScalingGroupOptions {
    /// Attach read-only configuration drive to server as label config-2
    config_drive: Boolean?
    /// The period of time, in seconds, that must pass before any scaling can occur after the previous scaling. Must be an integer between 0 and 86400 (24 hrs).
    cooldown: Int?
    /// Disk partitioning strategy
    /// If not specified, it will fallback to V(auto).
    disk_config: ("auto"|"manual")?
    /// Files to insert into the instance. Hash of C(remotepath: localpath)
    files: Any?
    /// flavor to use for the instance
    flavor: String
    /// image to use for the instance. Can be an C(id), C(human_id) or C(name).
    image: String
    /// key pair to use on the instance
    key_name: String?
    /// List of load balancer C(id) and C(port) hashes
    loadbalancers: Listing<Any>?
    /// The maximum number of entities that are allowed in the scaling group. Must be an integer between 0 and 1000.
    max_entities: Int
    /// A hash of metadata to associate with the instance
    meta: Any?
    /// The minimum number of entities that are allowed in the scaling group. Must be an integer between 0 and 1000.
    min_entities: Int
    /// Name to give the scaling group
    name: String
    /// The network to attach to the instances. If specified, you must include ALL networks including the public and private interfaces. Can be C(id) or C(label).
    networks: Listing<String>?
    /// The base name for servers created by Autoscale
    server_name: String
    /// Indicate desired state of the resource
    state: ("present"|"absent")?
    /// Data to be uploaded to the servers config drive. This option implies O(config_drive). Can be a file path or a string
    user_data: String?
    /// wait for the scaling group to finish provisioning the minimum amount of servers
    wait: Boolean?
    /// how long before wait gives up, in seconds
    wait_timeout: Int?
}

/// Task class for rax_scaling_group
class RaxScalingGroupTask extends Playbook.Task {
    /// todo doc
    `community.general.rax_scaling_group`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rax_scaling_group"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rax_scaling_group`
}

/// TaskBuilder class for rax_scaling_group
class RaxScalingGroup extends Playbook.TaskBuilder {
    /// Options for community.general.rax_scaling_group
    options: RaxScalingGroupOptions?
    /// todo doc
    function Task(): RaxScalingGroupTask = this
        .toMap()
        .put("community.general.rax_scaling_group", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RaxScalingGroupTask)
}

/// Manipulate Rackspace Cloud Autoscale Scaling Policy
/// Manipulate Rackspace Cloud Autoscale Scaling Policy
class RaxScalingPolicyOptions {
    /// The UTC time when this policy will be executed. The time must be formatted according to C(yyyy-MM-dd'T'HH:mm:ss.SSS) such as V(2013-05-19T08:07:08Z)
    at: String?
    /// The change, either as a number of servers or as a percentage, to make in the scaling group. If this is a percentage, you must set O(is_percent) to V(true) also.
    change: Int?
    /// The period of time, in seconds, that must pass before any scaling can occur after the previous scaling. Must be an integer between 0 and 86400 (24 hrs).
    cooldown: Int?
    /// The time when the policy will be executed, as a cron entry. For example, if this is parameter is set to V(1 0 * * *).
    cron: String?
    /// The desired server capacity of the scaling the group; that is, how many servers should be in the scaling group.
    desired_capacity: Int?
    /// Whether the value in O(change) is a percent value
    is_percent: Boolean?
    /// Name to give the policy
    name: String
    /// The type of policy that will be executed for the current release.
    policy_type: ("webhook"|"schedule")
    /// Name of the scaling group that this policy will be added to
    scaling_group: String
    /// Indicate desired state of the resource
    state: ("present"|"absent")?
}

/// Task class for rax_scaling_policy
class RaxScalingPolicyTask extends Playbook.Task {
    /// todo doc
    `community.general.rax_scaling_policy`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rax_scaling_policy"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rax_scaling_policy`
}

/// TaskBuilder class for rax_scaling_policy
class RaxScalingPolicy extends Playbook.TaskBuilder {
    /// Options for community.general.rax_scaling_policy
    options: RaxScalingPolicyOptions?
    /// todo doc
    function Task(): RaxScalingPolicyTask = this
        .toMap()
        .put("community.general.rax_scaling_policy", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RaxScalingPolicyTask)
}

/// Read a CSV file
/// Read a CSV file and return a list or a dictionary, containing one dictionary per row.
class ReadCsvOptions {
    /// A one-character string used to separate fields.
    /// When using this parameter, you change the default value used by O(dialect).
    /// The default value depends on the dialect used.
    delimiter: String?
    /// The CSV dialect to use when parsing the CSV file.
    /// Possible values include V(excel), V(excel-tab) or V(unix).
    dialect: String?
    /// A list of field names for every column.
    /// This is needed if the CSV does not have a header.
    fieldnames: Listing<String>?
    /// The column name used as a key for the resulting dictionary.
    /// If O(key) is unset, the module returns a list of dictionaries, where each dictionary is a row in the CSV file.
    key: String?
    /// The CSV filename to read data from.
    path: String
    /// Whether to ignore any whitespaces immediately following the delimiter.
    /// When using this parameter, you change the default value used by O(dialect).
    /// The default value depends on the dialect used.
    skipinitialspace: Boolean?
    /// Whether to raise an exception on bad CSV input.
    /// When using this parameter, you change the default value used by O(dialect).
    /// The default value depends on the dialect used.
    strict: Boolean?
    /// Whether the O(key) used is expected to be unique.
    unique: Boolean?
}

/// Task class for read_csv
class ReadCsvTask extends Playbook.Task {
    /// todo doc
    `community.general.read_csv`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.read_csv"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.read_csv`
}

/// TaskBuilder class for read_csv
class ReadCsv extends Playbook.TaskBuilder {
    /// Options for community.general.read_csv
    options: ReadCsvOptions?
    /// todo doc
    function Task(): ReadCsvTask = this
        .toMap()
        .put("community.general.read_csv", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ReadCsvTask)
}

/// Manages Out-Of-Band controllers using Redfish APIs
/// Builds Redfish URIs locally and sends them to remote OOB controllers to perform an action.
/// Manages OOB controller ex. reboot, log management.
/// Manages OOB controller users ex. add, remove, update.
/// Manages system power ex. on, off, graceful and forced reboot.
class RedfishCommandOptions {
    /// Properties of account service to update.
    account_properties: Any?
    /// Array of account types to apply to a user account.
    account_types: Listing<String>?
    /// Security token for authenticating to OOB controller.
    auth_token: String?
    /// Base URI of OOB controller.
    baseuri: String
    /// BIOS attributes that needs to be verified in the given server.
    bios_attributes: Any?
    /// BootNext target when bootdevice is "UefiBootNext".
    boot_next: String?
    /// Boot mode when using an override.
    boot_override_mode: ("Legacy"|"UEFI")?
    /// Boot device when setting boot configuration.
    bootdevice: String?
    /// Category to execute on OOB controller.
    category: String
    /// List of commands to execute on OOB controller.
    command: Listing<String>
    /// ID of account to delete/modify.
    /// Can also be used in account creation to work around vendor issues where the ID of the new user is required in the POST request.
    id: String?
    /// New password of account to add/modify.
    new_password: String?
    /// Username of account to add/delete/modify.
    new_username: String?
    /// Array of OEM account types to apply to a user account.
    oem_account_types: Listing<String>?
    /// Password for authenticating to OOB controller.
    password: String?
    /// Mode to apply when reseting to default.
    reset_to_defaults_mode: ("ResetAll"|"PreserveNetworkAndUsers"|"PreserveNetwork")?
    /// ID of the System, Manager or Chassis to modify.
    resource_id: String?
    /// Role of account to add/modify.
    roleid: String?
    /// URI of the session resource.
    session_uri: String?
    /// Removes surrounding quotes of etag used in C(If-Match) header of C(PATCH) requests.
    /// Only use this option to resolve bad vendor implementation where C(If-Match) only matches the unquoted etag string.
    strip_etag_quotes: Boolean?
    /// Timeout in seconds for HTTP requests to OOB controller.
    /// The default value for this param is C(10) but that is being deprecated and it will be replaced with C(60) in community.general 9.0.0.
    timeout: Int?
    /// UEFI boot target when bootdevice is "UefiTarget".
    uefi_target: String?
    /// Time when to apply the update.
    update_apply_time: ("Immediate"|"OnReset"|"AtMaintenanceWindowStart"|"InMaintenanceWindowOnReset"|"OnStartUpdateRequest")?
    /// Credentials for retrieving the update image.
    update_creds: Any?
    /// Handle to check the status of an update in progress.
    update_handle: String?
    /// Filename, with optional path, of the image for the update.
    update_image_file: String?
    /// URI of the image for the update.
    update_image_uri: String?
    /// Properties for HTTP Multipart Push Updates.
    update_oem_params: Any?
    /// Protocol for the update.
    update_protocol: String?
    /// List of target resource URIs to apply the update to.
    update_targets: Listing<String>?
    /// New user name for updating account_username.
    update_username: String?
    /// Username for authenticating to OOB controller.
    username: String?
    /// Options for VirtualMedia commands.
    virtual_media: Any?
}

/// Task class for redfish_command
class RedfishCommandTask extends Playbook.Task {
    /// todo doc
    `community.general.redfish_command`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.redfish_command"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.redfish_command`
}

/// TaskBuilder class for redfish_command
class RedfishCommand extends Playbook.TaskBuilder {
    /// Options for community.general.redfish_command
    options: RedfishCommandOptions?
    /// todo doc
    function Task(): RedfishCommandTask = this
        .toMap()
        .put("community.general.redfish_command", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RedfishCommandTask)
}

/// Manages Out-Of-Band controllers using Redfish APIs
/// Builds Redfish URIs locally and sends them to remote OOB controllers to set or update a configuration attribute.
/// Manages BIOS configuration settings.
/// Manages OOB controller configuration settings.
class RedfishConfigOptions {
    /// Security token for authenticating to OOB controller.
    auth_token: String?
    /// Base URI of OOB controller.
    baseuri: String
    /// Dictionary of BIOS attributes to update.
    bios_attributes: Any?
    /// List of BootOptionReference strings specifying the BootOrder.
    boot_order: Listing<String>?
    /// Category to execute on OOB controller.
    category: String
    /// List of commands to execute on OOB controller.
    command: Listing<String>
    /// Setting dict of HostInterface on OOB controller.
    hostinterface_config: Any?
    /// Redfish HostInterface instance ID if multiple HostInterfaces are present.
    hostinterface_id: String?
    /// Setting dict of manager services to update.
    network_protocols: Any?
    /// EthernetInterface Address string on OOB controller.
    nic_addr: String?
    /// Setting dict of EthernetInterface on OOB controller.
    nic_config: Any?
    /// Password for authenticating to OOB controller.
    password: String?
    /// ID of the System, Manager or Chassis to modify.
    resource_id: String?
    /// Setting parameter to enable or disable SecureBoot.
    secure_boot_enable: Boolean?
    /// ID of the manager to update.
    service_id: String?
    /// Setting dict of Sessions.
    sessions_config: Any?
    /// Id of the Storage Subsystem on which the volume is to be created.
    storage_subsystem_id: String?
    /// Removes surrounding quotes of etag used in C(If-Match) header of C(PATCH) requests.
    /// Only use this option to resolve bad vendor implementation where C(If-Match) only matches the unquoted etag string.
    strip_etag_quotes: Boolean?
    /// Timeout in seconds for HTTP requests to OOB controller.
    /// The default value for this param is C(10) but that is being deprecated and it will be replaced with C(60) in community.general 9.0.0.
    timeout: Int?
    /// Username for authenticating to OOB controller.
    username: String?
    /// Setting dict of volume to be created.
    volume_details: Any?
    /// List of IDs of volumes to be deleted.
    volume_ids: Listing<String>?
}

/// Task class for redfish_config
class RedfishConfigTask extends Playbook.Task {
    /// todo doc
    `community.general.redfish_config`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.redfish_config"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.redfish_config`
}

/// TaskBuilder class for redfish_config
class RedfishConfig extends Playbook.TaskBuilder {
    /// Options for community.general.redfish_config
    options: RedfishConfigOptions?
    /// todo doc
    function Task(): RedfishConfigTask = this
        .toMap()
        .put("community.general.redfish_config", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RedfishConfigTask)
}

/// Manages Out-Of-Band controllers using Redfish APIs
/// Builds Redfish URIs locally and sends them to remote OOB controllers to get information back.
/// Information retrieved is placed in a location specified by the user.
class RedfishInfoOptions {
    /// Security token for authenticating to OOB controller.
    auth_token: String?
    /// Base URI of OOB controller.
    baseuri: String
    /// List of categories to execute on OOB controller.
    category: Listing<String>?
    /// List of commands to execute on OOB controller.
    command: Listing<String>?
    /// Name of manager on OOB controller to target.
    manager: String?
    /// Password for authenticating to OOB controller.
    password: String?
    /// Timeout in seconds for HTTP requests to OOB controller.
    /// The default value for this param is C(10) but that is being deprecated and it will be replaced with C(60) in community.general 9.0.0.
    timeout: Int?
    /// Handle to check the status of an update in progress.
    update_handle: String?
    /// Username for authenticating to OOB controller.
    username: String?
}

/// Task class for redfish_info
class RedfishInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.redfish_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.redfish_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.redfish_info`
}

/// TaskBuilder class for redfish_info
class RedfishInfo extends Playbook.TaskBuilder {
    /// Options for community.general.redfish_info
    options: RedfishInfoOptions?
    /// todo doc
    function Task(): RedfishInfoTask = this
        .toMap()
        .put("community.general.redfish_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RedfishInfoTask)
}

/// Manage registration and subscriptions to RHSM using C(subscription-manager)
/// Manage registration and subscription to the Red Hat Subscription Management entitlement platform using the C(subscription-manager) command, registering using D-Bus if possible.
class RedhatSubscriptionOptions {
    /// supply an activation key for use with registration
    activationkey: String?
    /// Upon successful registration, auto-consume available subscriptions
    /// Please note that the alias O(autosubscribe) will be removed incommunity.general 9.0.0.
    auto_attach: Boolean?
    /// References an existing consumer ID to resume using a previous registrationfor this system. If the  system's identity certificate is lost or corrupted,this option allows it to resume using its previous identity and subscriptions.The default is to not specify a consumer ID so a new ID is created.
    consumer_id: String?
    /// Name of the system to register, defaults to the hostname
    consumer_name: String?
    /// The type of unit to register, defaults to system
    consumer_type: String?
    /// Register with a specific environment in the destination org. Used with Red Hat Satellite or Katello
    environment: String?
    /// Register the system even if it is already registered
    force_register: Boolean?
    /// Organization ID to use in conjunction with activationkey
    org_id: String?
    /// access.redhat.com or Red Hat Satellite or Katello password
    password: String?
    /// Specify a subscription pool name to consume.  Regular expressions accepted.Mutually exclusive with O(pool_ids).
    /// Please use O(pool_ids) instead: specifying pool IDs is much faster,and it avoids to match new pools that become available for thesystem and are not explicitly wanted.  Also, this option does notsupport quantities.
    /// This option is deprecated for the reasons mentioned above,and it will be removed in community.general 10.0.0.
    pool: String?
    /// Specify subscription pool IDs to consume. Prefer over O(pool) when possible as it is much faster.A pool ID may be specified as a C(string) - just the pool ID (for example V(0123456789abcdef0123456789abcdef)),or as a C(dict) with the pool ID as the key, and a quantity as the value (for exampleV(0123456789abcdef0123456789abcdef: 2). If the quantity is provided, it is used to consume multipleentitlements from a pool (the pool must support this). Mutually exclusive with O(pool).
    pool_ids: Listing<String>?
    /// Set a release version
    release: String?
    /// Specify CDN baseurl
    rhsm_baseurl: String?
    /// Specify an alternative location for a CA certificate for CDN
    rhsm_repo_ca_cert: String?
    /// Specify an alternative Red Hat Subscription Management or Red Hat Satellite or Katello server.
    server_hostname: String?
    /// Enable or disable https server certificate verification when connecting to O(server_hostname).
    server_insecure: String?
    /// Specify the port when registering to the Red Hat Subscription Management or Red Hat Satellite or Katello server.
    server_port: String?
    /// Specify the prefix when registering to the Red Hat Subscription Management or Red Hat Satellite or Katello server.
    server_prefix: String?
    /// Specify an HTTP proxy hostname.
    server_proxy_hostname: String?
    /// Specify a password for HTTP proxy with basic authentication
    server_proxy_password: String?
    /// Specify an HTTP proxy port.
    server_proxy_port: String?
    /// Specify an HTTP proxy scheme, for example V(http) or V(https).
    server_proxy_scheme: String?
    /// Specify a user for HTTP proxy with basic authentication
    server_proxy_user: String?
    /// whether to register and subscribe (V(present)), or unregister (V(absent)) a system
    state: ("present"|"absent")?
    /// Set syspurpose attributes in file C(/etc/rhsm/syspurpose/syspurpose.json) and synchronize these attributes with RHSM server. Syspurpose attributes help attach the most appropriate subscriptions to the system automatically. When C(syspurpose.json) file already contains some attributes, then new attributes overwrite existing attributes. When some attribute is not listed in the new list of attributes, the existing attribute will be removed from C(syspurpose.json) file. Unknown attributes are ignored.
    syspurpose: Any?
    /// sso.redhat.com API access token.
    token: String?
    /// access.redhat.com or Red Hat Satellite or Katello username
    username: String?
}

/// Task class for redhat_subscription
class RedhatSubscriptionTask extends Playbook.Task {
    /// todo doc
    `community.general.redhat_subscription`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.redhat_subscription"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.redhat_subscription`
}

/// TaskBuilder class for redhat_subscription
class RedhatSubscription extends Playbook.TaskBuilder {
    /// Options for community.general.redhat_subscription
    options: RedhatSubscriptionOptions?
    /// todo doc
    function Task(): RedhatSubscriptionTask = this
        .toMap()
        .put("community.general.redhat_subscription", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RedhatSubscriptionTask)
}

/// Various redis commands, replica and flush
/// Unified utility to interact with redis instances.
class RedisOptions {
    ca_certs: Any?
    /// The selected redis command
    /// V(config) ensures a configuration setting on an instance.
    /// V(flush) flushes all the instance or a specified db.
    /// V(replica) sets a redis instance in replica or master mode. (V(slave) is an alias for V(replica).)
    command: ("config"|"flush"|"replica"|"slave")?
    /// The database to flush (used in db mode) [flush command]
    db: Int?
    /// Type of flush (all the dbs in a redis instance or a specific one) [flush command]
    flush_mode: ("all"|"db")?
    login_user: Any?
    /// The host of the master instance [replica command]
    master_host: String?
    /// The port of the master instance [replica command]
    master_port: Int?
    /// A redis config key.
    name: String?
    /// The mode of the redis instance [replica command]
    /// V(slave) is an alias for V(replica).
    replica_mode: ("master"|"replica"|"slave")?
    tls: Any?
    validate_certs: Any?
    /// A redis config value. When memory size is needed, it is possible to specify it in the usual form of 1KB, 2M, 400MB where the base is 1024. Units are case insensitive i.e. 1m = 1mb = 1M = 1MB.
    value: String?
}

/// Task class for redis
class RedisTask extends Playbook.Task {
    /// todo doc
    `community.general.redis`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.redis"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.redis`
}

/// TaskBuilder class for redis
class Redis extends Playbook.TaskBuilder {
    /// Options for community.general.redis
    options: RedisOptions?
    /// todo doc
    function Task(): RedisTask = this
        .toMap()
        .put("community.general.redis", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RedisTask)
}

/// Set key value pairs in Redis
/// Set key value pairs in Redis database.
class RedisDataOptions {
    /// Only set key if it already exists.
    existing: Boolean?
    /// Expiration time in milliseconds. Setting this flag will always result in a change in the database.
    expiration: Int?
    /// Retain the time to live associated with the key.
    keep_ttl: Boolean?
    /// Database key.
    key: String
    /// Only set key if it does not already exist.
    non_existing: Boolean?
    /// State of the key.
    state: ("present"|"absent")?
    /// Value that key should be set to.
    value: String?
}

/// Task class for redis_data
class RedisDataTask extends Playbook.Task {
    /// todo doc
    `community.general.redis_data`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.redis_data"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.redis_data`
}

/// TaskBuilder class for redis_data
class RedisData extends Playbook.TaskBuilder {
    /// Options for community.general.redis_data
    options: RedisDataOptions?
    /// todo doc
    function Task(): RedisDataTask = this
        .toMap()
        .put("community.general.redis_data", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RedisDataTask)
}

/// Increment keys in Redis
/// Increment integers or float keys in Redis database and get new value.
/// Default increment for all keys is 1. For specific increments use the O(increment_int) and O(increment_float) options.
class RedisDataIncrOptions {
    /// Float amount to increment the key by.
    /// This only works with keys that contain float values in their string representation.
    increment_float: Any?
    /// Integer amount to increment the key by.
    increment_int: Int?
    /// Database key.
    key: String
}

/// Task class for redis_data_incr
class RedisDataIncrTask extends Playbook.Task {
    /// todo doc
    `community.general.redis_data_incr`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.redis_data_incr"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.redis_data_incr`
}

/// TaskBuilder class for redis_data_incr
class RedisDataIncr extends Playbook.TaskBuilder {
    /// Options for community.general.redis_data_incr
    options: RedisDataIncrOptions?
    /// todo doc
    function Task(): RedisDataIncrTask = this
        .toMap()
        .put("community.general.redis_data_incr", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RedisDataIncrTask)
}

/// Get value of key in Redis database
/// Get value of keys in Redis database.
class RedisDataInfoOptions {
    /// Database key.
    key: String
}

/// Task class for redis_data_info
class RedisDataInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.redis_data_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.redis_data_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.redis_data_info`
}

/// TaskBuilder class for redis_data_info
class RedisDataInfo extends Playbook.TaskBuilder {
    /// Options for community.general.redis_data_info
    options: RedisDataInfoOptions?
    /// todo doc
    function Task(): RedisDataInfoTask = this
        .toMap()
        .put("community.general.redis_data_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RedisDataInfoTask)
}

/// Gather information about Redis servers
/// Gathers information and statistics about Redis servers.
class RedisInfoOptions {
    ca_certs: Any?
    login_user: Any?
    tls: Any?
    validate_certs: Any?
}

/// Task class for redis_info
class RedisInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.redis_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.redis_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.redis_info`
}

/// TaskBuilder class for redis_info
class RedisInfo extends Playbook.TaskBuilder {
    /// Options for community.general.redis_info
    options: RedisInfoOptions?
    /// todo doc
    function Task(): RedisInfoTask = this
        .toMap()
        .put("community.general.redis_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RedisInfoTask)
}

/// RHEV/oVirt automation
/// This module only supports oVirt/RHEV version 3.
/// A newer module M(ovirt.ovirt.ovirt_vm) supports oVirt/RHV version 4.
/// Allows you to create/remove/update or powermanage virtual machines on a RHEV/oVirt platform.
class RhevmOptions {
    /// This option uses complex arguments and is a list of items that specify the bootorder.
    boot_order: Listing<String>?
    /// The CD you wish to have mounted on the VM when O(state=cd).
    cd_drive: String?
    /// The RHEV/oVirt cluster in which you want you VM to start.
    cluster: String?
    /// This parameter is used to configure the CPU share.
    cpu_share: Int?
    /// The RHEV/oVirt datacenter in which you want you VM to start.
    datacenter: String?
    /// This option sets the delete protection checkbox.
    del_prot: Boolean?
    /// This option uses complex arguments and is a list of disks with the options name, size and domain.
    disks: Listing<String>?
    /// This option uses complex arguments and is a list of interfaces with the options name and vlan.
    ifaces: Listing<String>?
    /// The template to use for the VM.
    image: String?
    /// A boolean switch to make a secure or insecure connection to the server.
    insecure_api: Boolean?
    /// The minimum amount of memory you wish to reserve for this system.
    mempol: Int?
    /// The name of the VM.
    name: String?
    /// The operating system option in RHEV/oVirt.
    osver: String?
    /// The password for user authentication.
    password: String
    /// The port on which the API is reachable.
    port: Int?
    /// The name/IP of your RHEV-m/oVirt instance.
    server: String?
    /// This serves to create/remove/update or powermanage your VM.
    state: ("absent"|"cd"|"down"|"info"|"ping"|"present"|"restarted"|"up")?
    /// The timeout you wish to define for power actions.
    /// When O(state=up).
    /// When O(state=down).
    /// When O(state=restarted).
    timeout: Int?
    /// To define if the VM is a server or desktop.
    type: ("desktop"|"host"|"server")?
    /// The user to authenticate with.
    user: String?
    /// To make your VM High Available.
    vm_ha: Boolean?
    /// The number of CPUs you want in your VM.
    vmcpu: Int?
    /// The host you wish your VM to run on.
    vmhost: String?
    /// The amount of memory you want your VM to use (in GB).
    vmmem: Int?
}

/// Task class for rhevm
class RhevmTask extends Playbook.Task {
    /// todo doc
    `community.general.rhevm`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rhevm"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rhevm`
}

/// TaskBuilder class for rhevm
class Rhevm extends Playbook.TaskBuilder {
    /// Options for community.general.rhevm
    options: RhevmOptions?
    /// todo doc
    function Task(): RhevmTask = this
        .toMap()
        .put("community.general.rhevm", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RhevmTask)
}

/// Adds or removes Red Hat software channels
/// Adds or removes Red Hat software channels.
class RhnChannelOptions {
    /// Name of the software channel.
    name: String
    /// RHN/Satellite password.
    password: String
    /// Whether the channel should be present or not, taking action if the state is different from what is stated.
    state: ("present"|"absent")?
    /// Name of the system as it is known in RHN/Satellite.
    sysname: String
    /// The full URL to the RHN/Satellite API.
    url: String
    /// RHN/Satellite login.
    user: String
    /// If V(false), SSL certificates will not be validated.
    /// This should only set to V(false) when used on self controlled sites using self-signed certificates, and you are absolutely sure that nobody can modify traffic between the module and the site.
    validate_certs: Boolean?
}

/// Task class for rhn_channel
class RhnChannelTask extends Playbook.Task {
    /// todo doc
    `community.general.rhn_channel`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rhn_channel"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rhn_channel`
}

/// TaskBuilder class for rhn_channel
class RhnChannel extends Playbook.TaskBuilder {
    /// Options for community.general.rhn_channel
    options: RhnChannelOptions?
    /// todo doc
    function Task(): RhnChannelTask = this
        .toMap()
        .put("community.general.rhn_channel", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RhnChannelTask)
}

/// Manage Red Hat Network registration using the C(rhnreg_ks) command
/// Manage registration to the Red Hat Network.
class RhnRegisterOptions {
    /// Supply an activation key for use with registration.
    activationkey: String?
    /// Supply a custom ssl CA certificate file for use with registration.
    ca_cert: String?
    /// Optionally specify a list of channels to subscribe to upon successful registration.
    channels: Listing<String>?
    /// If V(false), extended update support will be requested.
    enable_eus: Boolean?
    /// Force registration, even if system is already registered.
    force: Boolean?
    /// If V(true), the registered node will not upload its installed packages information to Satellite server.
    nopackages: Boolean?
    /// Red Hat Network password.
    password: String?
    /// Supply an profilename for use with registration.
    profilename: String?
    /// Specify an alternative Red Hat Network server URL.
    /// The default is the current value of C(serverURL) from C(/etc/sysconfig/rhn/up2date).
    server_url: String?
    /// Whether to register (V(present)), or unregister (V(absent)) a system.
    state: ("absent"|"present")?
    /// Supply an organizational id for use with registration.
    systemorgid: String?
    /// Red Hat Network username.
    username: String?
}

/// Task class for rhn_register
class RhnRegisterTask extends Playbook.Task {
    /// todo doc
    `community.general.rhn_register`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rhn_register"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rhn_register`
}

/// TaskBuilder class for rhn_register
class RhnRegister extends Playbook.TaskBuilder {
    /// Options for community.general.rhn_register
    options: RhnRegisterOptions?
    /// todo doc
    function Task(): RhnRegisterTask = this
        .toMap()
        .put("community.general.rhn_register", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RhnRegisterTask)
}

/// Set or Unset RHSM Release version
/// Sets or unsets the release version used by RHSM repositories.
class RhsmReleaseOptions {
    /// RHSM release version to use.
    /// To unset either pass V(null) for this option, or omit this option.
    release: String?
}

/// Task class for rhsm_release
class RhsmReleaseTask extends Playbook.Task {
    /// todo doc
    `community.general.rhsm_release`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rhsm_release"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rhsm_release`
}

/// TaskBuilder class for rhsm_release
class RhsmRelease extends Playbook.TaskBuilder {
    /// Options for community.general.rhsm_release
    options: RhsmReleaseOptions?
    /// todo doc
    function Task(): RhsmReleaseTask = this
        .toMap()
        .put("community.general.rhsm_release", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RhsmReleaseTask)
}

/// Manage RHSM repositories using the subscription-manager command
/// Manage (Enable/Disable) RHSM repositories to the Red Hat Subscription Management entitlement platform using the C(subscription-manager) command.
class RhsmRepositoryOptions {
    /// The ID of repositories to enable.
    /// To operate on several repositories this can accept a comma separated list or a YAML list.
    name: Listing<String>
    /// Disable all currently enabled repositories that are not not specified in O(name). Only set this to V(true) if passing in a list of repositories to the O(name) field. Using this with C(loop) will most likely not have the desired result.
    purge: Boolean?
    /// If state is equal to present or disabled, indicates the desired repository state.
    /// Please note that V(present) and V(absent) are deprecated, and will beremoved in community.general 10.0.0; please use V(enabled) andV(disabled) instead.
    state: ("present"|"enabled"|"absent"|"disabled")?
}

/// Task class for rhsm_repository
class RhsmRepositoryTask extends Playbook.Task {
    /// todo doc
    `community.general.rhsm_repository`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rhsm_repository"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rhsm_repository`
}

/// TaskBuilder class for rhsm_repository
class RhsmRepository extends Playbook.TaskBuilder {
    /// Options for community.general.rhsm_repository
    options: RhsmRepositoryOptions?
    /// todo doc
    function Task(): RhsmRepositoryTask = this
        .toMap()
        .put("community.general.rhsm_repository", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RhsmRepositoryTask)
}

/// This module handles some common Riak operations
/// This module can be used to join nodes to a cluster, check the status of the cluster.
class RiakOptions {
    /// The command you would like to perform against the cluster.
    command: ("ping"|"kv_test"|"join"|"plan"|"commit")?
    /// The path to the riak configuration directory
    config_dir: String?
    /// The ip address and port that is listening for Riak HTTP queries
    http_conn: String?
    /// The target node for certain operations (join, ping)
    target_node: String?
    /// If V(false), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
    validate_certs: Boolean?
    /// Number of seconds to wait for handoffs to complete.
    wait_for_handoffs: Int?
    /// Number of seconds to wait for all nodes to agree on the ring.
    wait_for_ring: Int?
    /// Waits for a riak service to come online before continuing.
    wait_for_service: ("kv")?
}

/// Task class for riak
class RiakTask extends Playbook.Task {
    /// todo doc
    `community.general.riak`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.riak"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.riak`
}

/// TaskBuilder class for riak
class Riak extends Playbook.TaskBuilder {
    /// Options for community.general.riak
    options: RiakOptions?
    /// todo doc
    function Task(): RiakTask = this
        .toMap()
        .put("community.general.riak", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RiakTask)
}

/// Send notifications to Rocket Chat
/// The C(rocketchat) module sends notifications to Rocket Chat via the Incoming WebHook integration
class RocketchatOptions {
    /// Define a list of attachments.
    attachments: Listing<Any>?
    /// Channel to send the message to. If absent, the message goes to the channel selected for the O(token) specified during the creation of webhook.
    channel: String?
    /// Allow text to use default colors - use the default of 'normal' to not send a custom color bar at the start of the message
    color: ("normal"|"good"|"warning"|"danger")?
    /// The domain for your environment without protocol. (For example V(example.com) or V(chat.example.com).)
    domain: String
    /// Emoji for the message sender. The representation for the available emojis can be got from Rocket Chat.
    /// For example V(:thumbsup:).
    /// If O(icon_emoji) is set, O(icon_url) will not be used.
    icon_emoji: String?
    /// URL for the message sender's icon.
    icon_url: String?
    /// Automatically create links for channels and usernames in O(msg).
    link_names: Int?
    /// Message to be sent.
    msg: String?
    /// Specify the protocol used to send notification messages before the webhook URL (that is, V(http) or V(https)).
    protocol: ("http"|"https")?
    /// Rocket Chat Incoming Webhook integration token.  This provides authentication to Rocket Chat's Incoming webhook for posting messages.
    token: String
    /// This is the sender of the message.
    username: String?
    /// If V(false), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
    validate_certs: Boolean?
}

/// Task class for rocketchat
class RocketchatTask extends Playbook.Task {
    /// todo doc
    `community.general.rocketchat`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rocketchat"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rocketchat`
}

/// TaskBuilder class for rocketchat
class Rocketchat extends Playbook.TaskBuilder {
    /// Options for community.general.rocketchat
    options: RocketchatOptions?
    /// todo doc
    function Task(): RocketchatTask = this
        .toMap()
        .put("community.general.rocketchat", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RocketchatTask)
}

/// Notify Rollbar about app deployments
/// Notify Rollbar about app deployments (see https://rollbar.com/docs/deploys_other/)
class RollbarDeploymentOptions {
    /// Deploy comment (e.g. what is being deployed).
    comment: String?
    /// Name of the environment being deployed, e.g. 'production'.
    environment: String
    /// Revision number/sha being deployed.
    revision: String
    /// Rollbar username of the user who deployed.
    rollbar_user: String?
    /// Your project access token.
    token: String
    /// Optional URL to submit the notification to.
    url: String?
    /// User who deployed.
    user: String?
    /// If V(false), SSL certificates for the target url will not be validated. This should only be used on personally controlled sites using self-signed certificates.
    validate_certs: Boolean?
}

/// Task class for rollbar_deployment
class RollbarDeploymentTask extends Playbook.Task {
    /// todo doc
    `community.general.rollbar_deployment`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rollbar_deployment"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rollbar_deployment`
}

/// TaskBuilder class for rollbar_deployment
class RollbarDeployment extends Playbook.TaskBuilder {
    /// Options for community.general.rollbar_deployment
    options: RollbarDeploymentOptions?
    /// todo doc
    function Task(): RollbarDeploymentTask = this
        .toMap()
        .put("community.general.rollbar_deployment", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RollbarDeploymentTask)
}

/// Install or uninstall overlay additional packages
/// Install or uninstall overlay additional packages using C(rpm-ostree) command.
class RpmOstreePkgOptions {
    /// Name of overlay package to install or remove.
    name: Listing<String>
    /// State of the overlay package.
    /// V(present) simply ensures that a desired package is installed.
    /// V(absent) removes the specified package.
    state: ("absent"|"present")?
}

/// Task class for rpm_ostree_pkg
class RpmOstreePkgTask extends Playbook.Task {
    /// todo doc
    `community.general.rpm_ostree_pkg`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rpm_ostree_pkg"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rpm_ostree_pkg`
}

/// TaskBuilder class for rpm_ostree_pkg
class RpmOstreePkg extends Playbook.TaskBuilder {
    /// Options for community.general.rpm_ostree_pkg
    options: RpmOstreePkgOptions?
    /// todo doc
    function Task(): RpmOstreePkgTask = this
        .toMap()
        .put("community.general.rpm_ostree_pkg", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RpmOstreePkgTask)
}

/// Manage Rundeck ACL policies
/// Create, update and remove Rundeck ACL policies through HTTP API.
class RundeckAclPolicyOptions {
    /// Sets the token to authenticate against Rundeck API.
    api_token: Any?
    client_cert: Any?
    client_key: Any?
    force: Any?
    force_basic_auth: Any?
    http_agent: Any?
    /// Sets the project name.
    name: String
    /// Sets the ACL policy content.
    /// ACL policy content is a YAML object as described in http://rundeck.org/docs/man5/aclpolicy.html.
    /// It can be a YAML string or a pure Ansible inventory YAML object.
    policy: String?
    /// Sets the project which receive the ACL policy.
    /// If unset, it's a system ACL policy.
    project: String?
    /// Create or remove Rundeck project.
    state: ("present"|"absent")?
    url_password: Any?
    url_username: Any?
    use_proxy: Any?
    validate_certs: Any?
}

/// Task class for rundeck_acl_policy
class RundeckAclPolicyTask extends Playbook.Task {
    /// todo doc
    `community.general.rundeck_acl_policy`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rundeck_acl_policy"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rundeck_acl_policy`
}

/// TaskBuilder class for rundeck_acl_policy
class RundeckAclPolicy extends Playbook.TaskBuilder {
    /// Options for community.general.rundeck_acl_policy
    options: RundeckAclPolicyOptions?
    /// todo doc
    function Task(): RundeckAclPolicyTask = this
        .toMap()
        .put("community.general.rundeck_acl_policy", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RundeckAclPolicyTask)
}

/// Query executions for a Rundeck job
/// This module gets the list of executions for a specified Rundeck job.
class RundeckJobExecutionsInfoOptions {
    /// The job unique ID.
    job_id: String
    /// Max results to return.
    max: Int?
    /// The start point to return the results.
    offset: Int?
    /// The job status to filter.
    status: ("succeeded"|"failed"|"aborted"|"running")?
}

/// Task class for rundeck_job_executions_info
class RundeckJobExecutionsInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.rundeck_job_executions_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rundeck_job_executions_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rundeck_job_executions_info`
}

/// TaskBuilder class for rundeck_job_executions_info
class RundeckJobExecutionsInfo extends Playbook.TaskBuilder {
    /// Options for community.general.rundeck_job_executions_info
    options: RundeckJobExecutionsInfoOptions?
    /// todo doc
    function Task(): RundeckJobExecutionsInfoTask = this
        .toMap()
        .put("community.general.rundeck_job_executions_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RundeckJobExecutionsInfoTask)
}

/// Run a Rundeck job
/// This module runs a Rundeck job specified by ID.
class RundeckJobRunOptions {
    /// Send a job abort request if exceeded the O(wait_execution_timeout) specified.
    abort_on_timeout: Boolean?
    /// Filter the nodes where the jobs must run.
    /// See U(https://docs.rundeck.com/docs/manual/11-node-filters.html#node-filter-syntax).
    filter_nodes: String?
    /// The job unique ID.
    job_id: String
    /// The job options for the steps.
    /// Numeric values must be quoted.
    job_options: Any?
    /// Log level configuration.
    loglevel: ("debug"|"verbose"|"info"|"warn"|"error")?
    /// Schedule the job execution to run at specific date and time.
    /// ISO-8601 date and time format like V(2021-10-05T15:45:00-03:00).
    run_at_time: String?
    /// Wait until the job finished the execution.
    wait_execution: Boolean?
    /// Delay, in seconds, between job execution status check requests.
    wait_execution_delay: Int?
    /// Job execution wait timeout in seconds.
    /// If the timeout is reached, the job will be aborted.
    /// Keep in mind that there is a sleep based on O(wait_execution_delay) after each job status check.
    wait_execution_timeout: Int?
}

/// Task class for rundeck_job_run
class RundeckJobRunTask extends Playbook.Task {
    /// todo doc
    `community.general.rundeck_job_run`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rundeck_job_run"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rundeck_job_run`
}

/// TaskBuilder class for rundeck_job_run
class RundeckJobRun extends Playbook.TaskBuilder {
    /// Options for community.general.rundeck_job_run
    options: RundeckJobRunOptions?
    /// todo doc
    function Task(): RundeckJobRunTask = this
        .toMap()
        .put("community.general.rundeck_job_run", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RundeckJobRunTask)
}

/// Manage Rundeck projects
/// Create and remove Rundeck projects through HTTP API.
class RundeckProjectOptions {
    /// Sets the token to authenticate against Rundeck API.
    api_token: Any?
    client_cert: Any?
    client_key: Any?
    force: Any?
    force_basic_auth: Any?
    http_agent: Any?
    /// Sets the project name.
    name: String
    /// Create or remove Rundeck project.
    state: ("present"|"absent")?
    url_password: Any?
    url_username: Any?
    use_proxy: Any?
    validate_certs: Any?
}

/// Task class for rundeck_project
class RundeckProjectTask extends Playbook.Task {
    /// todo doc
    `community.general.rundeck_project`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.rundeck_project"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.rundeck_project`
}

/// TaskBuilder class for rundeck_project
class RundeckProject extends Playbook.TaskBuilder {
    /// Options for community.general.rundeck_project
    options: RundeckProjectOptions?
    /// todo doc
    function Task(): RundeckProjectTask = this
        .toMap()
        .put("community.general.rundeck_project", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RundeckProjectTask)
}

/// Manage runit services
/// Controls runit services on remote hosts using the sv utility.
class RunitOptions {
    /// Whether the service is enabled or not, if disabled it also implies stopped.
    enabled: Boolean?
    /// Name of the service to manage.
    name: String
    /// directory runsv watches for services
    service_dir: String?
    /// directory where services are defined, the source of symlinks to service_dir.
    service_src: String?
    /// V(started)/V(stopped) are idempotent actions that will not run commands unless necessary.  V(restarted) will always bounce the service (sv restart) and V(killed) will always bounce the service (sv force-stop). V(reloaded) will send a HUP (sv reload). V(once) will run a normally downed sv once (sv once), not really an idempotent operation.
    state: ("killed"|"once"|"reloaded"|"restarted"|"started"|"stopped")?
}

/// Task class for runit
class RunitTask extends Playbook.Task {
    /// todo doc
    `community.general.runit`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.runit"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.runit`
}

/// TaskBuilder class for runit
class Runit extends Playbook.TaskBuilder {
    /// Options for community.general.runit
    options: RunitOptions?
    /// todo doc
    function Task(): RunitTask = this
        .toMap()
        .put("community.general.runit", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(RunitTask)
}

/// Makes a computer to speak
/// makes a computer speak! Amuse your friends, annoy your coworkers!
class SayOptions {
    /// What to say.
    msg: String
    /// What voice to use.
    voice: String?
}

/// Task class for say
class SayTask extends Playbook.Task {
    /// todo doc
    `community.general.say`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.say"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.say`
}

/// TaskBuilder class for say
class Say extends Playbook.TaskBuilder {
    /// Options for community.general.say
    options: SayOptions?
    /// todo doc
    function Task(): SayTask = this
        .toMap()
        .put("community.general.say", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SayTask)
}

/// Scaleway compute management module
/// This module manages compute instances on Scaleway.
class ScalewayComputeOptions {
    /// Commercial name of the compute node
    commercial_type: String
    /// Enable public IPv6 connectivity on the instance
    enable_ipv6: Boolean?
    /// Image identifier used to start the instance with
    image: String
    /// Name of the instance
    name: String?
    /// Organization identifier.
    /// Exactly one of O(project) and O(organization) must be specified.
    organization: String?
    /// Project identifier.
    /// Exactly one of O(project) and O(organization) must be specified.
    project: String?
    /// Manage public IP on a Scaleway server
    /// Could be Scaleway IP address UUID
    /// V(dynamic) Means that IP is destroyed at the same time the host is destroyed
    /// V(absent) Means no public IP at all
    public_ip: String?
    /// Scaleway compute zone
    region: ("ams1"|"EMEA-NL-EVS"|"par1"|"EMEA-FR-PAR1"|"par2"|"EMEA-FR-PAR2"|"waw1"|"EMEA-PL-WAW1")
    /// Security group unique identifier
    /// If no value provided, the default security group or current security group will be used
    security_group: String?
    /// Indicate desired state of the instance.
    state: ("present"|"absent"|"running"|"restarted"|"stopped")?
    /// List of tags to apply to the instance (5 max)
    tags: Listing<String>?
    /// Wait for the instance to reach its desired state before returning.
    wait: Boolean?
    /// Time to wait before every attempt to check the state of the server
    wait_sleep_time: Int?
    /// Time to wait for the server to reach the expected state
    wait_timeout: Int?
}

/// Task class for scaleway_compute
class ScalewayComputeTask extends Playbook.Task {
    /// todo doc
    `community.general.scaleway_compute`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.scaleway_compute"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.scaleway_compute`
}

/// TaskBuilder class for scaleway_compute
class ScalewayCompute extends Playbook.TaskBuilder {
    /// Options for community.general.scaleway_compute
    options: ScalewayComputeOptions?
    /// todo doc
    function Task(): ScalewayComputeTask = this
        .toMap()
        .put("community.general.scaleway_compute", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ScalewayComputeTask)
}

/// Scaleway compute - private network management
/// This module add or remove a private network to a compute instance (U(https://developer.scaleway.com)).
class ScalewayComputePrivateNetworkOptions {
    /// ID of the compute instance (see M(community.general.scaleway_compute)).
    compute_id: String
    /// ID of the private network (see M(community.general.scaleway_private_network)).
    private_network_id: String
    /// Project identifier.
    project: String
    /// Scaleway region to use (for example V(par1)).
    region: ("ams1"|"EMEA-NL-EVS"|"par1"|"EMEA-FR-PAR1"|"par2"|"EMEA-FR-PAR2"|"waw1"|"EMEA-PL-WAW1")
    /// Indicate desired state of the VPC.
    state: ("present"|"absent")?
}

/// Task class for scaleway_compute_private_network
class ScalewayComputePrivateNetworkTask extends Playbook.Task {
    /// todo doc
    `community.general.scaleway_compute_private_network`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.scaleway_compute_private_network"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.scaleway_compute_private_network`
}

/// TaskBuilder class for scaleway_compute_private_network
class ScalewayComputePrivateNetwork extends Playbook.TaskBuilder {
    /// Options for community.general.scaleway_compute_private_network
    options: ScalewayComputePrivateNetworkOptions?
    /// todo doc
    function Task(): ScalewayComputePrivateNetworkTask = this
        .toMap()
        .put("community.general.scaleway_compute_private_network", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ScalewayComputePrivateNetworkTask)
}

/// Scaleway Container management
/// This module manages container on Scaleway account.
class ScalewayContainerOptions {
    /// The length of time your handler can spend processing a request before being stopped.
    container_timeout: String?
    /// Description of the container namespace.
    description: String?
    /// Environment variables of the container namespace.
    /// Injected in container at runtime.
    environment_variables: Any?
    /// Maximum number of connections per container.
    /// This parameter will be used to trigger autoscaling.
    max_concurrency: Int?
    /// Maximum number of replicas for the container.
    max_scale: Int?
    /// Resources define performance characteristics of your container.
    /// They are allocated to your container at runtime.
    memory_limit: Int?
    /// Minimum number of replicas for the container.
    min_scale: Int?
    /// Name of the container namespace.
    name: String
    /// Container namespace identifier.
    namespace_id: String
    /// Listen port used to expose the container.
    port: Int?
    /// Privacy policies define whether a container can be executed anonymously.
    /// Choose V(public) to enable anonymous execution, or V(private) to protect your container with an authentication mechanism provided by the Scaleway API.
    privacy: ("public"|"private")?
    /// Communication protocol of the container.
    protocol: ("http1"|"h2c")?
    /// Redeploy the container if update is required.
    redeploy: Boolean?
    /// Scaleway region to use (for example V(fr-par)).
    region: ("fr-par"|"nl-ams"|"pl-waw")
    /// The name of image used for the container.
    registry_image: String
    /// Secret environment variables of the container namespace.
    /// Updating those values will not output a C(changed) state in Ansible.
    /// Injected in container at runtime.
    secret_environment_variables: Any?
    /// Indicate desired state of the container.
    state: ("present"|"absent")?
}

/// Task class for scaleway_container
class ScalewayContainerTask extends Playbook.Task {
    /// todo doc
    `community.general.scaleway_container`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.scaleway_container"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.scaleway_container`
}

/// TaskBuilder class for scaleway_container
class ScalewayContainer extends Playbook.TaskBuilder {
    /// Options for community.general.scaleway_container
    options: ScalewayContainerOptions?
    /// todo doc
    function Task(): ScalewayContainerTask = this
        .toMap()
        .put("community.general.scaleway_container", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ScalewayContainerTask)
}

/// Retrieve information on Scaleway Container
/// This module return information about a container on Scaleway account.
class ScalewayContainerInfoOptions {
    /// Name of the container.
    name: String
    /// Container namespace identifier.
    namespace_id: String
    /// Scaleway region to use (for example C(fr-par)).
    region: ("fr-par"|"nl-ams"|"pl-waw")
}

/// Task class for scaleway_container_info
class ScalewayContainerInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.scaleway_container_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.scaleway_container_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.scaleway_container_info`
}

/// TaskBuilder class for scaleway_container_info
class ScalewayContainerInfo extends Playbook.TaskBuilder {
    /// Options for community.general.scaleway_container_info
    options: ScalewayContainerInfoOptions?
    /// todo doc
    function Task(): ScalewayContainerInfoTask = this
        .toMap()
        .put("community.general.scaleway_container_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ScalewayContainerInfoTask)
}

/// Scaleway Container namespace management
/// This module manages container namespaces on Scaleway account.
class ScalewayContainerNamespaceOptions {
    /// Description of the container namespace.
    description: String?
    /// Environment variables of the container namespace.
    /// Injected in containers at runtime.
    environment_variables: Any?
    /// Name of the container namespace.
    name: String
    /// Project identifier.
    project_id: String
    /// Scaleway region to use (for example V(fr-par)).
    region: ("fr-par"|"nl-ams"|"pl-waw")
    /// Secret environment variables of the container namespace.
    /// Updating those values will not output a C(changed) state in Ansible.
    /// Injected in containers at runtime.
    secret_environment_variables: Any?
    /// Indicate desired state of the container namespace.
    state: ("present"|"absent")?
}

/// Task class for scaleway_container_namespace
class ScalewayContainerNamespaceTask extends Playbook.Task {
    /// todo doc
    `community.general.scaleway_container_namespace`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.scaleway_container_namespace"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.scaleway_container_namespace`
}

/// TaskBuilder class for scaleway_container_namespace
class ScalewayContainerNamespace extends Playbook.TaskBuilder {
    /// Options for community.general.scaleway_container_namespace
    options: ScalewayContainerNamespaceOptions?
    /// todo doc
    function Task(): ScalewayContainerNamespaceTask = this
        .toMap()
        .put("community.general.scaleway_container_namespace", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ScalewayContainerNamespaceTask)
}

/// Retrieve information on Scaleway Container namespace
/// This module return information about a container namespace on Scaleway account.
class ScalewayContainerNamespaceInfoOptions {
    /// Name of the container namespace.
    name: String
    /// Project identifier.
    project_id: String
    /// Scaleway region to use (for example C(fr-par)).
    region: ("fr-par"|"nl-ams"|"pl-waw")
}

/// Task class for scaleway_container_namespace_info
class ScalewayContainerNamespaceInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.scaleway_container_namespace_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.scaleway_container_namespace_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.scaleway_container_namespace_info`
}

/// TaskBuilder class for scaleway_container_namespace_info
class ScalewayContainerNamespaceInfo extends Playbook.TaskBuilder {
    /// Options for community.general.scaleway_container_namespace_info
    options: ScalewayContainerNamespaceInfoOptions?
    /// todo doc
    function Task(): ScalewayContainerNamespaceInfoTask = this
        .toMap()
        .put("community.general.scaleway_container_namespace_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ScalewayContainerNamespaceInfoTask)
}

/// Scaleway Container registry management module
/// This module manages container registries on Scaleway account.
class ScalewayContainerRegistryOptions {
    /// Description of the container registry.
    description: String?
    /// Name of the container registry.
    name: String
    /// Default visibility policy.
    /// Everyone will be able to pull images from a V(public) registry.
    privacy_policy: ("public"|"private")?
    /// Project identifier.
    project_id: String
    /// Scaleway region to use (for example V(fr-par)).
    region: ("fr-par"|"nl-ams"|"pl-waw")
    /// Indicate desired state of the container registry.
    state: ("present"|"absent")?
}

/// Task class for scaleway_container_registry
class ScalewayContainerRegistryTask extends Playbook.Task {
    /// todo doc
    `community.general.scaleway_container_registry`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.scaleway_container_registry"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.scaleway_container_registry`
}

/// TaskBuilder class for scaleway_container_registry
class ScalewayContainerRegistry extends Playbook.TaskBuilder {
    /// Options for community.general.scaleway_container_registry
    options: ScalewayContainerRegistryOptions?
    /// todo doc
    function Task(): ScalewayContainerRegistryTask = this
        .toMap()
        .put("community.general.scaleway_container_registry", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ScalewayContainerRegistryTask)
}

/// Scaleway Container registry info module
/// This module return information about a container registry on Scaleway account.
class ScalewayContainerRegistryInfoOptions {
    /// Name of the container registry.
    name: String
    /// Project identifier.
    project_id: String
    /// Scaleway region to use (for example C(fr-par)).
    region: ("fr-par"|"nl-ams"|"pl-waw")
}

/// Task class for scaleway_container_registry_info
class ScalewayContainerRegistryInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.scaleway_container_registry_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.scaleway_container_registry_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.scaleway_container_registry_info`
}

/// TaskBuilder class for scaleway_container_registry_info
class ScalewayContainerRegistryInfo extends Playbook.TaskBuilder {
    /// Options for community.general.scaleway_container_registry_info
    options: ScalewayContainerRegistryInfoOptions?
    /// todo doc
    function Task(): ScalewayContainerRegistryInfoTask = this
        .toMap()
        .put("community.general.scaleway_container_registry_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ScalewayContainerRegistryInfoTask)
}

/// Scaleway database backups management module
/// This module manages database backups on Scaleway account U(https://developer.scaleway.com).
class ScalewayDatabaseBackupOptions {
    /// Name used to identify the database.
    /// Required for V(present) and V(restored) states.
    /// Ignored when O(state=absent) or O(state=exported).
    database_name: String?
    /// Expiration datetime of the database backup (ISO 8601 format).
    /// Ignored when O(state=absent), O(state=exported) or O(state=restored).
    expires_at: String?
    /// UUID used to identify the database backup.
    /// Required for V(absent), V(exported) and V(restored) states.
    id: String?
    /// UUID of the instance associated to the database backup.
    /// Required for V(present) and V(restored) states.
    /// Ignored when O(state=absent) or O(state=exported).
    instance_id: String?
    /// Name used to identify the database backup.
    /// Required for V(present) state.
    /// Ignored when O(state=absent), O(state=exported) or O(state=restored).
    name: String?
    /// Scaleway region to use (for example V(fr-par)).
    region: ("fr-par"|"nl-ams"|"pl-waw")
    /// Indicate desired state of the database backup.
    /// V(present) creates a backup.
    /// V(absent) deletes the backup.
    /// V(exported) creates a download link for the backup.
    /// V(restored) restores the backup to a new database.
    state: ("present"|"absent"|"exported"|"restored")?
    /// Wait for the instance to reach its desired state before returning.
    wait: Boolean?
    /// Time to wait before every attempt to check the state of the backup.
    wait_sleep_time: Int?
    /// Time to wait for the backup to reach the expected state.
    wait_timeout: Int?
}

/// Task class for scaleway_database_backup
class ScalewayDatabaseBackupTask extends Playbook.Task {
    /// todo doc
    `community.general.scaleway_database_backup`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.scaleway_database_backup"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.scaleway_database_backup`
}

/// TaskBuilder class for scaleway_database_backup
class ScalewayDatabaseBackup extends Playbook.TaskBuilder {
    /// Options for community.general.scaleway_database_backup
    options: ScalewayDatabaseBackupOptions?
    /// todo doc
    function Task(): ScalewayDatabaseBackupTask = this
        .toMap()
        .put("community.general.scaleway_database_backup", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ScalewayDatabaseBackupTask)
}

/// Scaleway Function management
/// This module manages function on Scaleway account.
class ScalewayFunctionOptions {
    /// Description of the function.
    description: String?
    /// Environment variables of the function.
    /// Injected in function at runtime.
    environment_variables: Any?
    /// The length of time your handler can spend processing a request before being stopped.
    function_timeout: String?
    /// The C(module-name.export) value in your function.
    handler: String?
    /// Maximum number of replicas for the function.
    max_scale: Int?
    /// Resources define performance characteristics of your function.
    /// They are allocated to your function at runtime.
    memory_limit: Int?
    /// Minimum number of replicas for the function.
    min_scale: Int?
    /// Name of the function.
    name: String
    /// Function namespace identifier.
    namespace_id: String
    /// Privacy policies define whether a function can be executed anonymously.
    /// Choose V(public) to enable anonymous execution, or V(private) to protect your function with an authentication mechanism provided by the Scaleway API.
    privacy: ("public"|"private")?
    /// Redeploy the function if update is required.
    redeploy: Boolean?
    /// Scaleway region to use (for example V(fr-par)).
    region: ("fr-par"|"nl-ams"|"pl-waw")
    /// Runtime of the function
    /// See U(https://www.scaleway.com/en/docs/compute/functions/reference-content/functions-lifecycle/) for all available runtimes
    runtime: String
    /// Secret environment variables of the function.
    /// Updating those values will not output a C(changed) state in Ansible.
    /// Injected in function at runtime.
    secret_environment_variables: Any?
    /// Indicate desired state of the function.
    state: ("present"|"absent")?
}

/// Task class for scaleway_function
class ScalewayFunctionTask extends Playbook.Task {
    /// todo doc
    `community.general.scaleway_function`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.scaleway_function"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.scaleway_function`
}

/// TaskBuilder class for scaleway_function
class ScalewayFunction extends Playbook.TaskBuilder {
    /// Options for community.general.scaleway_function
    options: ScalewayFunctionOptions?
    /// todo doc
    function Task(): ScalewayFunctionTask = this
        .toMap()
        .put("community.general.scaleway_function", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ScalewayFunctionTask)
}

/// Retrieve information on Scaleway Function
/// This module return information about a function on Scaleway account.
class ScalewayFunctionInfoOptions {
    /// Name of the function.
    name: String
    /// Container namespace identifier.
    namespace_id: String
    /// Scaleway region to use (for example C(fr-par)).
    region: ("fr-par"|"nl-ams"|"pl-waw")
}

/// Task class for scaleway_function_info
class ScalewayFunctionInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.scaleway_function_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.scaleway_function_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.scaleway_function_info`
}

/// TaskBuilder class for scaleway_function_info
class ScalewayFunctionInfo extends Playbook.TaskBuilder {
    /// Options for community.general.scaleway_function_info
    options: ScalewayFunctionInfoOptions?
    /// todo doc
    function Task(): ScalewayFunctionInfoTask = this
        .toMap()
        .put("community.general.scaleway_function_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ScalewayFunctionInfoTask)
}

/// Scaleway Function namespace management
/// This module manages function namespaces on Scaleway account.
class ScalewayFunctionNamespaceOptions {
    /// Description of the function namespace.
    description: String?
    /// Environment variables of the function namespace.
    /// Injected in functions at runtime.
    environment_variables: Any?
    /// Name of the function namespace.
    name: String
    /// Project identifier.
    project_id: String
    /// Scaleway region to use (for example V(fr-par)).
    region: ("fr-par"|"nl-ams"|"pl-waw")
    /// Secret environment variables of the function namespace.
    /// Updating those values will not output a C(changed) state in Ansible.
    /// Injected in functions at runtime.
    secret_environment_variables: Any?
    /// Indicate desired state of the function namespace.
    state: ("present"|"absent")?
}

/// Task class for scaleway_function_namespace
class ScalewayFunctionNamespaceTask extends Playbook.Task {
    /// todo doc
    `community.general.scaleway_function_namespace`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.scaleway_function_namespace"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.scaleway_function_namespace`
}

/// TaskBuilder class for scaleway_function_namespace
class ScalewayFunctionNamespace extends Playbook.TaskBuilder {
    /// Options for community.general.scaleway_function_namespace
    options: ScalewayFunctionNamespaceOptions?
    /// todo doc
    function Task(): ScalewayFunctionNamespaceTask = this
        .toMap()
        .put("community.general.scaleway_function_namespace", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ScalewayFunctionNamespaceTask)
}

/// Retrieve information on Scaleway Function namespace
/// This module return information about a function namespace on Scaleway account.
class ScalewayFunctionNamespaceInfoOptions {
    /// Name of the function namespace.
    name: String
    /// Project identifier.
    project_id: String
    /// Scaleway region to use (for example C(fr-par)).
    region: ("fr-par"|"nl-ams"|"pl-waw")
}

/// Task class for scaleway_function_namespace_info
class ScalewayFunctionNamespaceInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.scaleway_function_namespace_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.scaleway_function_namespace_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.scaleway_function_namespace_info`
}

/// TaskBuilder class for scaleway_function_namespace_info
class ScalewayFunctionNamespaceInfo extends Playbook.TaskBuilder {
    /// Options for community.general.scaleway_function_namespace_info
    options: ScalewayFunctionNamespaceInfoOptions?
    /// todo doc
    function Task(): ScalewayFunctionNamespaceInfoTask = this
        .toMap()
        .put("community.general.scaleway_function_namespace_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ScalewayFunctionNamespaceInfoTask)
}

/// Gather information about the Scaleway images available
/// Gather information about the Scaleway images available.
class ScalewayImageInfoOptions {
    /// Scaleway compute zone.
    region: ("ams1"|"EMEA-NL-EVS"|"par1"|"EMEA-FR-PAR1"|"par2"|"EMEA-FR-PAR2"|"waw1"|"EMEA-PL-WAW1")
}

/// Task class for scaleway_image_info
class ScalewayImageInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.scaleway_image_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.scaleway_image_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.scaleway_image_info`
}

/// TaskBuilder class for scaleway_image_info
class ScalewayImageInfo extends Playbook.TaskBuilder {
    /// Options for community.general.scaleway_image_info
    options: ScalewayImageInfoOptions?
    /// todo doc
    function Task(): ScalewayImageInfoTask = this
        .toMap()
        .put("community.general.scaleway_image_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ScalewayImageInfoTask)
}

/// Scaleway IP management module
/// This module manages IP on Scaleway account U(https://developer.scaleway.com)
class ScalewayIpOptions {
    /// id of the Scaleway IP (UUID)
    id: String?
    /// Scaleway organization identifier
    organization: String
    /// Scaleway region to use (for example par1).
    region: ("ams1"|"EMEA-NL-EVS"|"par1"|"EMEA-FR-PAR1"|"par2"|"EMEA-FR-PAR2"|"waw1"|"EMEA-PL-WAW1")
    /// Reverse to assign to the IP
    reverse: String?
    /// id of the server you want to attach an IP to.
    /// To unattach an IP don't specify this option
    server: String?
    /// Indicate desired state of the IP.
    state: ("present"|"absent")?
}

/// Task class for scaleway_ip
class ScalewayIpTask extends Playbook.Task {
    /// todo doc
    `community.general.scaleway_ip`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.scaleway_ip"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.scaleway_ip`
}

/// TaskBuilder class for scaleway_ip
class ScalewayIp extends Playbook.TaskBuilder {
    /// Options for community.general.scaleway_ip
    options: ScalewayIpOptions?
    /// todo doc
    function Task(): ScalewayIpTask = this
        .toMap()
        .put("community.general.scaleway_ip", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ScalewayIpTask)
}

/// Gather information about the Scaleway ips available
/// Gather information about the Scaleway ips available.
class ScalewayIpInfoOptions {
    /// Scaleway region to use (for example C(par1)).
    region: ("ams1"|"EMEA-NL-EVS"|"par1"|"EMEA-FR-PAR1"|"par2"|"EMEA-FR-PAR2"|"waw1"|"EMEA-PL-WAW1")
}

/// Task class for scaleway_ip_info
class ScalewayIpInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.scaleway_ip_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.scaleway_ip_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.scaleway_ip_info`
}

/// TaskBuilder class for scaleway_ip_info
class ScalewayIpInfo extends Playbook.TaskBuilder {
    /// Options for community.general.scaleway_ip_info
    options: ScalewayIpInfoOptions?
    /// todo doc
    function Task(): ScalewayIpInfoTask = this
        .toMap()
        .put("community.general.scaleway_ip_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ScalewayIpInfoTask)
}

/// Scaleway load-balancer management module
/// This module manages load-balancers on Scaleway.
class ScalewayLbOptions {
    /// Description of the load-balancer.
    description: String
    /// Name of the load-balancer.
    name: String
    /// Organization identifier.
    organization_id: String
    /// Scaleway zone.
    region: ("nl-ams"|"fr-par"|"pl-waw")
    /// Indicate desired state of the instance.
    state: ("present"|"absent")?
    /// List of tags to apply to the load-balancer.
    tags: Listing<String>?
    /// Wait for the load-balancer to reach its desired state before returning.
    wait: Boolean?
    /// Time to wait before every attempt to check the state of the load-balancer.
    wait_sleep_time: Int?
    /// Time to wait for the load-balancer to reach the expected state.
    wait_timeout: Int?
}

/// Task class for scaleway_lb
class ScalewayLbTask extends Playbook.Task {
    /// todo doc
    `community.general.scaleway_lb`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.scaleway_lb"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.scaleway_lb`
}

/// TaskBuilder class for scaleway_lb
class ScalewayLb extends Playbook.TaskBuilder {
    /// Options for community.general.scaleway_lb
    options: ScalewayLbOptions?
    /// todo doc
    function Task(): ScalewayLbTask = this
        .toMap()
        .put("community.general.scaleway_lb", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ScalewayLbTask)
}

/// Gather information about the Scaleway organizations available
/// Gather information about the Scaleway organizations available.
class ScalewayOrganizationInfoOptions {
    /// Scaleway API URL.
    api_url: Any?
}

/// Task class for scaleway_organization_info
class ScalewayOrganizationInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.scaleway_organization_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.scaleway_organization_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.scaleway_organization_info`
}

/// TaskBuilder class for scaleway_organization_info
class ScalewayOrganizationInfo extends Playbook.TaskBuilder {
    /// Options for community.general.scaleway_organization_info
    options: ScalewayOrganizationInfoOptions?
    /// todo doc
    function Task(): ScalewayOrganizationInfoTask = this
        .toMap()
        .put("community.general.scaleway_organization_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ScalewayOrganizationInfoTask)
}

/// Scaleway private network management
/// This module manages private network on Scaleway account (U(https://developer.scaleway.com)).
class ScalewayPrivateNetworkOptions {
    /// Name of the VPC.
    name: String?
    /// Project identifier.
    project: String
    /// Scaleway region to use (for example V(par1)).
    region: ("ams1"|"EMEA-NL-EVS"|"par1"|"EMEA-FR-PAR1"|"par2"|"EMEA-FR-PAR2"|"waw1"|"EMEA-PL-WAW1")
    /// Indicate desired state of the VPC.
    state: ("present"|"absent")?
    /// List of tags to apply to the instance.
    tags: Listing<String>?
}

/// Task class for scaleway_private_network
class ScalewayPrivateNetworkTask extends Playbook.Task {
    /// todo doc
    `community.general.scaleway_private_network`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.scaleway_private_network"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.scaleway_private_network`
}

/// TaskBuilder class for scaleway_private_network
class ScalewayPrivateNetwork extends Playbook.TaskBuilder {
    /// Options for community.general.scaleway_private_network
    options: ScalewayPrivateNetworkOptions?
    /// todo doc
    function Task(): ScalewayPrivateNetworkTask = this
        .toMap()
        .put("community.general.scaleway_private_network", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ScalewayPrivateNetworkTask)
}

/// Scaleway Security Group management module
/// This module manages Security Group on Scaleway account U(https://developer.scaleway.com).
class ScalewaySecurityGroupOptions {
    /// Description of the Security Group.
    description: String?
    /// Default policy for incoming traffic.
    inbound_default_policy: ("accept"|"drop")?
    /// Name of the Security Group.
    name: String
    /// Organization identifier.
    organization: String
    /// Create security group to be the default one.
    organization_default: Boolean?
    /// Default policy for outcoming traffic.
    outbound_default_policy: ("accept"|"drop")?
    /// Scaleway region to use (for example V(par1)).
    region: ("ams1"|"EMEA-NL-EVS"|"par1"|"EMEA-FR-PAR1"|"par2"|"EMEA-FR-PAR2"|"waw1"|"EMEA-PL-WAW1")
    /// Indicate desired state of the Security Group.
    state: ("absent"|"present")?
    /// Create a stateful security group which allows established connections in and out.
    stateful: Boolean
}

/// Task class for scaleway_security_group
class ScalewaySecurityGroupTask extends Playbook.Task {
    /// todo doc
    `community.general.scaleway_security_group`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.scaleway_security_group"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.scaleway_security_group`
}

/// TaskBuilder class for scaleway_security_group
class ScalewaySecurityGroup extends Playbook.TaskBuilder {
    /// Options for community.general.scaleway_security_group
    options: ScalewaySecurityGroupOptions?
    /// todo doc
    function Task(): ScalewaySecurityGroupTask = this
        .toMap()
        .put("community.general.scaleway_security_group", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ScalewaySecurityGroupTask)
}

/// Gather information about the Scaleway security groups available
/// Gather information about the Scaleway security groups available.
class ScalewaySecurityGroupInfoOptions {
    /// Scaleway region to use (for example C(par1)).
    region: ("ams1"|"EMEA-NL-EVS"|"par1"|"EMEA-FR-PAR1"|"par2"|"EMEA-FR-PAR2"|"waw1"|"EMEA-PL-WAW1")
}

/// Task class for scaleway_security_group_info
class ScalewaySecurityGroupInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.scaleway_security_group_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.scaleway_security_group_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.scaleway_security_group_info`
}

/// TaskBuilder class for scaleway_security_group_info
class ScalewaySecurityGroupInfo extends Playbook.TaskBuilder {
    /// Options for community.general.scaleway_security_group_info
    options: ScalewaySecurityGroupInfoOptions?
    /// todo doc
    function Task(): ScalewaySecurityGroupInfoTask = this
        .toMap()
        .put("community.general.scaleway_security_group_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ScalewaySecurityGroupInfoTask)
}

/// Scaleway Security Group Rule management module
/// This module manages Security Group Rule on Scaleway account U(https://developer.scaleway.com).
class ScalewaySecurityGroupRuleOptions {
    /// Rule action.
    action: ("accept"|"drop")
    /// Rule direction.
    direction: ("inbound"|"outbound")
    /// IPV4 CIDR notation to apply to the rule.
    ip_range: String?
    /// Port related to the rule, null value for all the ports.
    port: Int
    /// Network protocol to use.
    protocol: ("TCP"|"UDP"|"ICMP")
    /// Scaleway region to use (for example V(par1)).
    region: ("ams1"|"EMEA-NL-EVS"|"par1"|"EMEA-FR-PAR1"|"par2"|"EMEA-FR-PAR2"|"waw1"|"EMEA-PL-WAW1")
    /// Security Group unique identifier.
    security_group: String
    /// Indicate desired state of the Security Group Rule.
    state: ("present"|"absent")?
}

/// Task class for scaleway_security_group_rule
class ScalewaySecurityGroupRuleTask extends Playbook.Task {
    /// todo doc
    `community.general.scaleway_security_group_rule`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.scaleway_security_group_rule"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.scaleway_security_group_rule`
}

/// TaskBuilder class for scaleway_security_group_rule
class ScalewaySecurityGroupRule extends Playbook.TaskBuilder {
    /// Options for community.general.scaleway_security_group_rule
    options: ScalewaySecurityGroupRuleOptions?
    /// todo doc
    function Task(): ScalewaySecurityGroupRuleTask = this
        .toMap()
        .put("community.general.scaleway_security_group_rule", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ScalewaySecurityGroupRuleTask)
}

/// Gather information about the Scaleway servers available
/// Gather information about the Scaleway servers available.
class ScalewayServerInfoOptions {
    /// Scaleway region to use (for example C(par1)).
    region: ("ams1"|"EMEA-NL-EVS"|"par1"|"EMEA-FR-PAR1"|"par2"|"EMEA-FR-PAR2"|"waw1"|"EMEA-PL-WAW1")
}

/// Task class for scaleway_server_info
class ScalewayServerInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.scaleway_server_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.scaleway_server_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.scaleway_server_info`
}

/// TaskBuilder class for scaleway_server_info
class ScalewayServerInfo extends Playbook.TaskBuilder {
    /// Options for community.general.scaleway_server_info
    options: ScalewayServerInfoOptions?
    /// todo doc
    function Task(): ScalewayServerInfoTask = this
        .toMap()
        .put("community.general.scaleway_server_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ScalewayServerInfoTask)
}

/// Gather information about the Scaleway snapshots available
/// Gather information about the Scaleway snapshot available.
class ScalewaySnapshotInfoOptions {
    /// Scaleway region to use (for example C(par1)).
    region: ("ams1"|"EMEA-NL-EVS"|"par1"|"EMEA-FR-PAR1"|"par2"|"EMEA-FR-PAR2"|"waw1"|"EMEA-PL-WAW1")
}

/// Task class for scaleway_snapshot_info
class ScalewaySnapshotInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.scaleway_snapshot_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.scaleway_snapshot_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.scaleway_snapshot_info`
}

/// TaskBuilder class for scaleway_snapshot_info
class ScalewaySnapshotInfo extends Playbook.TaskBuilder {
    /// Options for community.general.scaleway_snapshot_info
    options: ScalewaySnapshotInfoOptions?
    /// todo doc
    function Task(): ScalewaySnapshotInfoTask = this
        .toMap()
        .put("community.general.scaleway_snapshot_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ScalewaySnapshotInfoTask)
}

/// Scaleway SSH keys management module
/// This module manages SSH keys on Scaleway account U(https://developer.scaleway.com).
class ScalewaySshkeyOptions {
    /// Scaleway API URL.
    api_url: String?
    /// The public SSH key as a string to add.
    ssh_pub_key: String
    /// Indicate desired state of the SSH key.
    state: ("present"|"absent")?
}

/// Task class for scaleway_sshkey
class ScalewaySshkeyTask extends Playbook.Task {
    /// todo doc
    `community.general.scaleway_sshkey`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.scaleway_sshkey"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.scaleway_sshkey`
}

/// TaskBuilder class for scaleway_sshkey
class ScalewaySshkey extends Playbook.TaskBuilder {
    /// Options for community.general.scaleway_sshkey
    options: ScalewaySshkeyOptions?
    /// todo doc
    function Task(): ScalewaySshkeyTask = this
        .toMap()
        .put("community.general.scaleway_sshkey", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ScalewaySshkeyTask)
}

/// Scaleway user_data management module
/// This module manages user_data on compute instances on Scaleway.
/// It can be used to configure cloud-init for instance.
class ScalewayUserDataOptions {
    /// Scaleway compute zone.
    region: ("ams1"|"EMEA-NL-EVS"|"par1"|"EMEA-FR-PAR1"|"par2"|"EMEA-FR-PAR2"|"waw1"|"EMEA-PL-WAW1")
    /// Scaleway Compute instance ID of the server.
    server_id: String
    /// User defined data. Typically used with C(cloud-init).
    /// Pass your C(cloud-init) script here as a string.
    user_data: Any?
}

/// Task class for scaleway_user_data
class ScalewayUserDataTask extends Playbook.Task {
    /// todo doc
    `community.general.scaleway_user_data`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.scaleway_user_data"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.scaleway_user_data`
}

/// TaskBuilder class for scaleway_user_data
class ScalewayUserData extends Playbook.TaskBuilder {
    /// Options for community.general.scaleway_user_data
    options: ScalewayUserDataOptions?
    /// todo doc
    function Task(): ScalewayUserDataTask = this
        .toMap()
        .put("community.general.scaleway_user_data", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ScalewayUserDataTask)
}

/// Scaleway volumes management module
/// This module manages volumes on Scaleway account U(https://developer.scaleway.com).
class ScalewayVolumeOptions {
    /// Name used to identify the volume.
    name: String
    /// ScaleWay organization ID to which volume belongs.
    organization: String?
    /// Scaleway project ID to which volume belongs.
    project: String?
    /// Scaleway region to use (for example par1).
    region: ("ams1"|"EMEA-NL-EVS"|"par1"|"EMEA-FR-PAR1"|"par2"|"EMEA-FR-PAR2"|"waw1"|"EMEA-PL-WAW1")
    /// Size of the volume in bytes.
    size: Int?
    /// Indicate desired state of the volume.
    state: ("present"|"absent")?
    /// Type of the volume (for example 'l_ssd').
    volume_type: String?
}

/// Task class for scaleway_volume
class ScalewayVolumeTask extends Playbook.Task {
    /// todo doc
    `community.general.scaleway_volume`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.scaleway_volume"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.scaleway_volume`
}

/// TaskBuilder class for scaleway_volume
class ScalewayVolume extends Playbook.TaskBuilder {
    /// Options for community.general.scaleway_volume
    options: ScalewayVolumeOptions?
    /// todo doc
    function Task(): ScalewayVolumeTask = this
        .toMap()
        .put("community.general.scaleway_volume", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ScalewayVolumeTask)
}

/// Gather information about the Scaleway volumes available
/// Gather information about the Scaleway volumes available.
class ScalewayVolumeInfoOptions {
    /// Scaleway region to use (for example C(par1)).
    region: ("ams1"|"EMEA-NL-EVS"|"par1"|"EMEA-FR-PAR1"|"par2"|"EMEA-FR-PAR2"|"waw1"|"EMEA-PL-WAW1")
}

/// Task class for scaleway_volume_info
class ScalewayVolumeInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.scaleway_volume_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.scaleway_volume_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.scaleway_volume_info`
}

/// TaskBuilder class for scaleway_volume_info
class ScalewayVolumeInfo extends Playbook.TaskBuilder {
    /// Options for community.general.scaleway_volume_info
    options: ScalewayVolumeInfoOptions?
    /// todo doc
    function Task(): ScalewayVolumeInfoTask = this
        .toMap()
        .put("community.general.scaleway_volume_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ScalewayVolumeInfoTask)
}

/// Manages SELinux file context mapping definitions
/// Manages SELinux file context mapping definitions.
/// Similar to the C(semanage fcontext) command.
class SefcontextOptions {
    /// The file type that should have SELinux contexts applied.
    /// The following file type options are available:
    /// V(a) for all files,
    /// V(b) for block devices,
    /// V(c) for character devices,
    /// V(d) for directories,
    /// V(f) for regular files,
    /// V(l) for symbolic links,
    /// V(p) for named pipes,
    /// V(s) for socket files.
    ftype: ("a"|"b"|"c"|"d"|"f"|"l"|"p"|"s")?
    /// Useful for scenarios (chrooted environment) that you can't get the real SELinux state.
    ignore_selinux_state: Boolean?
    /// Reload SELinux policy after commit.
    /// Note that this does not apply SELinux file contexts to existing files.
    reload: Boolean?
    /// SELinux range for the specified O(target).
    /// Defaults to V(s0) for new file contexts and to existing value when modifying file contexts.
    selevel: String?
    /// SELinux type for the specified O(target).
    setype: String?
    /// SELinux user for the specified O(target).
    /// Defaults to V(system_u) for new file contexts and to existing value when modifying file contexts.
    seuser: String?
    /// Whether the SELinux file context must be V(absent) or V(present).
    /// Specifying V(absent) without either O(setype) or O(substitute) deletes both SELinux type or path substitution mappings that match O(target).
    state: ("absent"|"present")?
    /// Path to use to substitute file context(s) for the specified O(target). The context labeling for the O(target) subtree is made equivalent to this path.
    /// This is also referred to as SELinux file context equivalence and it implements the C(equal) functionality of the SELinux management tools.
    substitute: String?
    /// Target path (expression).
    target: String
}

/// Task class for sefcontext
class SefcontextTask extends Playbook.Task {
    /// todo doc
    `community.general.sefcontext`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.sefcontext"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.sefcontext`
}

/// TaskBuilder class for sefcontext
class Sefcontext extends Playbook.TaskBuilder {
    /// Options for community.general.sefcontext
    options: SefcontextOptions?
    /// todo doc
    function Task(): SefcontextTask = this
        .toMap()
        .put("community.general.sefcontext", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SefcontextTask)
}

/// Change permissive domain in SELinux policy
/// Add and remove a domain from the list of permissive domains.
class SelinuxPermissiveOptions {
    /// The domain that will be added or removed from the list of permissive domains.
    domain: String
    /// Disable reloading of the SELinux policy after making change to a domain's permissive setting.
    /// The default is V(false), which causes policy to be reloaded when a domain changes state.
    /// Reloading the policy does not work on older versions of the C(policycoreutils-python) library, for example in EL 6."
    no_reload: Boolean?
    /// Indicate if the domain should or should not be set as permissive.
    permissive: Boolean
    /// Name of the SELinux policy store to use.
    store: String?
}

/// Task class for selinux_permissive
class SelinuxPermissiveTask extends Playbook.Task {
    /// todo doc
    `community.general.selinux_permissive`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.selinux_permissive"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.selinux_permissive`
}

/// TaskBuilder class for selinux_permissive
class SelinuxPermissive extends Playbook.TaskBuilder {
    /// Options for community.general.selinux_permissive
    options: SelinuxPermissiveOptions?
    /// todo doc
    function Task(): SelinuxPermissiveTask = this
        .toMap()
        .put("community.general.selinux_permissive", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SelinuxPermissiveTask)
}

/// Manages linux user to SELinux user mapping
/// Manages linux user to SELinux user mapping
class SeloginOptions {
    /// Run independent of selinux runtime state
    ignore_selinux_state: Boolean?
    /// a Linux user
    login: String
    /// Reload SELinux policy after commit.
    reload: Boolean?
    /// MLS/MCS Security Range (MLS/MCS Systems only) SELinux Range for SELinux login mapping defaults to the SELinux user record range.
    selevel: String?
    /// SELinux user name
    seuser: String?
    /// Desired mapping value.
    state: ("present"|"absent")?
}

/// Task class for selogin
class SeloginTask extends Playbook.Task {
    /// todo doc
    `community.general.selogin`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.selogin"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.selogin`
}

/// TaskBuilder class for selogin
class Selogin extends Playbook.TaskBuilder {
    /// Options for community.general.selogin
    options: SeloginOptions?
    /// todo doc
    function Task(): SeloginTask = this
        .toMap()
        .put("community.general.selogin", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SeloginTask)
}

/// Sends an email with the SendGrid API
/// Sends an email with a SendGrid account through their API, not through the SMTP service.
class SendgridOptions {
    /// Sendgrid API key to use instead of username/password.
    api_key: String?
    /// A list of relative or explicit paths of files you want to attach (7MB limit as per SendGrid docs).
    attachments: Listing<String>?
    /// A list of email addresses to bcc.
    bcc: Listing<String>?
    /// The e-mail body content.
    body: String
    /// A list of email addresses to cc.
    cc: Listing<String>?
    /// The address in the "from" field for the email.
    from_address: String
    /// The name you want to appear in the from field, i.e 'John Doe'.
    from_name: String?
    /// A dict to pass on as headers.
    headers: Any?
    /// Whether the body is html content that should be rendered.
    html_body: Boolean?
    /// Password that corresponds to the username.
    /// It is only required if O(api_key) is not supplied.
    password: String?
    /// The desired subject for the email.
    subject: String
    /// A list with one or more recipient email addresses.
    to_addresses: Listing<String>
    /// Username for logging into the SendGrid account.
    /// It is only required if O(api_key) is not supplied.
    username: String?
}

/// Task class for sendgrid
class SendgridTask extends Playbook.Task {
    /// todo doc
    `community.general.sendgrid`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.sendgrid"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.sendgrid`
}

/// TaskBuilder class for sendgrid
class Sendgrid extends Playbook.TaskBuilder {
    /// Options for community.general.sendgrid
    options: SendgridOptions?
    /// todo doc
    function Task(): SendgridTask = this
        .toMap()
        .put("community.general.sendgrid", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SendgridTask)
}

/// Manage Sensu checks
/// Manage the checks that should be run on a machine by I(Sensu).
/// Most options do not have a default and will not be added to the check definition unless specified.
/// All defaults except O(path), O(state), O(backup) and O(metric) are not managed by this module,
/// they are simply specified for your convenience.
class SensuCheckOptions {
    /// Classifies the check as an aggregate check,
    /// making it available via the aggregate API
    /// Default is V(false).
    aggregate: Boolean?
    /// Create a backup file (if yes), including the timestamp information so
    /// you can get the original file back if you somehow clobbered it incorrectly.
    backup: Boolean?
    /// Path to the sensu check to run (not required when O(state=absent))
    command: String?
    /// A hash/dictionary of custom parameters for mixing to the configuration.
    /// You can't rewrite others module parameters using this
    custom: Any?
    /// Other checks this check depends on, if dependencies fail handling of this check will be disabled
    dependencies: Listing<String>?
    /// Whether the check should be handled or not
    /// Default is V(false).
    handle: Boolean?
    /// List of handlers to notify when the check fails
    handlers: Listing<String>?
    /// The high threshold for flap detection
    high_flap_threshold: Int?
    /// Check interval in seconds
    interval: Int?
    /// The low threshold for flap detection
    low_flap_threshold: Int?
    /// Whether the check is a metric
    metric: Boolean?
    /// The name of the check
    /// This is the key that is used to determine whether a check exists
    name: String
    /// Number of event occurrences before the handler should take action
    /// If not specified, defaults to 1.
    occurrences: Int?
    /// Path to the json file of the check to be added/removed.
    /// Will be created if it does not exist (unless O(state=absent)).
    /// The parent folders need to exist when O(state=present), otherwise an error will be thrown
    path: String?
    /// Whether the check should be scheduled at all.
    /// You can still issue it via the sensu api
    /// Default is V(false).
    publish: Boolean?
    /// Number of seconds handlers should wait before taking second action
    refresh: Int?
    /// The check source, used to create a JIT Sensu client for an external resource (e.g. a network switch).
    source: String?
    /// Whether the check should be scheduled by the sensu client or server
    /// This option obviates the need for specifying the O(subscribers) option
    /// Default is V(false).
    standalone: Boolean?
    /// Whether the check should be present or not
    state: ("present"|"absent")?
    /// When to disable handling of check failures
    subdue_begin: String?
    /// When to enable handling of check failures
    subdue_end: String?
    /// List of subscribers/channels this check should run for
    /// See sensu_subscribers to subscribe a machine to a channel
    subscribers: Listing<String>?
    /// Timeout for the check
    /// If not specified, it defaults to 10.
    timeout: Int?
    /// Time to live in seconds until the check is considered stale
    ttl: Int?
}

/// Task class for sensu_check
class SensuCheckTask extends Playbook.Task {
    /// todo doc
    `community.general.sensu_check`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.sensu_check"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.sensu_check`
}

/// TaskBuilder class for sensu_check
class SensuCheck extends Playbook.TaskBuilder {
    /// Options for community.general.sensu_check
    options: SensuCheckOptions?
    /// todo doc
    function Task(): SensuCheckTask = this
        .toMap()
        .put("community.general.sensu_check", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SensuCheckTask)
}

/// Manages Sensu client configuration
/// Manages Sensu client configuration.
/// For more information, refer to the Sensu documentation: U(https://sensuapp.org/docs/latest/reference/clients.html)
class SensuClientOptions {
    /// An address to help identify and reach the client. This is only informational, usually an IP address or hostname.
    /// If not specified it defaults to non-loopback IPv4 address as determined by Ruby Socket.ip_address_list (provided by Sensu).
    address: String?
    /// The chef definition scope, used to configure the Sensu Enterprise Chef integration (Sensu Enterprise users only).
    chef: Any?
    /// If a deregistration event should be created upon Sensu client process stop.
    /// Default is V(false).
    deregister: Boolean?
    /// The deregistration definition scope, used to configure automated Sensu client de-registration.
    deregistration: Any?
    /// The ec2 definition scope, used to configure the Sensu Enterprise AWS EC2 integration (Sensu Enterprise users only).
    ec2: Any?
    /// The keepalive definition scope, used to configure Sensu client keepalives behavior (e.g. keepalive thresholds, etc).
    keepalive: Any?
    /// If Sensu should monitor keepalives for this client.
    keepalives: Boolean?
    /// A unique name for the client. The name cannot contain special characters or spaces.
    /// If not specified, it defaults to the system hostname as determined by Ruby Socket.gethostname (provided by Sensu).
    name: String?
    /// The puppet definition scope, used to configure the Sensu Enterprise Puppet integration (Sensu Enterprise users only).
    puppet: Any?
    /// Client definition attributes to redact (values) when logging and sending client keepalives.
    redact: Listing<String>?
    /// The registration definition scope, used to configure Sensu registration event handlers.
    registration: Any?
    /// If safe mode is enabled for the client. Safe mode requires local check definitions in order to accept a check request and execute the check.
    safe_mode: Boolean?
    /// The servicenow definition scope, used to configure the Sensu Enterprise ServiceNow integration (Sensu Enterprise users only).
    servicenow: Any?
    /// The socket definition scope, used to configure the Sensu client socket.
    socket: Any?
    /// Whether the client should be present or not
    state: ("present"|"absent")?
    /// An array of client subscriptions, a list of roles and/or responsibilities assigned to the system (e.g. webserver).
    /// These subscriptions determine which monitoring checks are executed by the client, as check requests are sent to subscriptions.
    /// The subscriptions array items must be strings.
    subscriptions: Listing<String>?
}

/// Task class for sensu_client
class SensuClientTask extends Playbook.Task {
    /// todo doc
    `community.general.sensu_client`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.sensu_client"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.sensu_client`
}

/// TaskBuilder class for sensu_client
class SensuClient extends Playbook.TaskBuilder {
    /// Options for community.general.sensu_client
    options: SensuClientOptions?
    /// todo doc
    function Task(): SensuClientTask = this
        .toMap()
        .put("community.general.sensu_client", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SensuClientTask)
}

/// Manages Sensu handler configuration
/// Manages Sensu handler configuration
/// For more information, refer to the Sensu documentation: U(https://sensuapp.org/docs/latest/reference/handlers.html)
class SensuHandlerOptions {
    /// The handler command to be executed.
    /// The event data is passed to the process via STDIN.
    /// NOTE: the command attribute is only required for Pipe handlers (i.e. handlers configured with "type": "pipe").
    command: String?
    /// The Sensu event filter (name) to use when filtering events for the handler.
    filter: String?
    /// An array of Sensu event filters (names) to use when filtering events for the handler.
    /// Each array item must be a string.
    filters: Listing<String>?
    /// If events in the flapping state should be handled.
    handle_flapping: Boolean?
    /// If events matching one or more silence entries should be handled.
    handle_silenced: Boolean?
    /// An array of Sensu event handlers (names) to use for events using the handler set.
    /// NOTE: the handlers attribute is only required for handler sets (i.e. handlers configured with "type": "set").
    handlers: Listing<String>?
    /// The Sensu event mutator (name) to use to mutate event data for the handler.
    mutator: String?
    /// A unique name for the handler. The name cannot contain special characters or spaces.
    name: String
    /// The pipe definition scope, used to configure the Sensu transport pipe.
    /// NOTE: the pipe attribute is only required for Transport handlers (i.e. handlers configured with "type": "transport").
    pipe: Any?
    /// An array of check result severities the handler will handle.
    /// NOTE: event resolution bypasses this filtering.
    /// Example: [ 'warning', 'critical', 'unknown' ].
    severities: Listing<String>?
    /// The socket definition scope, used to configure the TCP/UDP handler socket.
    /// NOTE: the socket attribute is only required for TCP/UDP handlers (i.e. handlers configured with "type": "tcp" or "type": "udp").
    socket: Any?
    /// Whether the handler should be present or not
    state: ("present"|"absent")?
    /// The handler execution duration timeout in seconds (hard stop).
    /// Only used by pipe and tcp handler types.
    timeout: Int?
    /// The handler type
    type: ("pipe"|"tcp"|"udp"|"transport"|"set")?
}

/// Task class for sensu_handler
class SensuHandlerTask extends Playbook.Task {
    /// todo doc
    `community.general.sensu_handler`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.sensu_handler"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.sensu_handler`
}

/// TaskBuilder class for sensu_handler
class SensuHandler extends Playbook.TaskBuilder {
    /// Options for community.general.sensu_handler
    options: SensuHandlerOptions?
    /// todo doc
    function Task(): SensuHandlerTask = this
        .toMap()
        .put("community.general.sensu_handler", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SensuHandlerTask)
}

/// Manage Sensu silence entries
/// Create and clear (delete) a silence entries via the Sensu API for subscriptions and checks.
class SensuSilenceOptions {
    /// Specifies the check which the silence entry applies to.
    check: String?
    /// Specifies the entity responsible for this entry.
    creator: String?
    /// If specified, the silence entry will be automatically cleared after this number of seconds.
    expire: Int?
    /// If specified as true, the silence entry will be automatically cleared once the condition it is silencing is resolved.
    expire_on_resolve: Boolean?
    /// If specified, this free-form string is used to provide context or rationale for the reason this silence entry was created.
    reason: String?
    /// Specifies to create or clear (delete) a silence entry via the Sensu API
    state: ("present"|"absent")?
    /// Specifies the subscription which the silence entry applies to.
    /// To create a silence entry for a client prepend C(client:) to client name. Example - C(client:server1.example.dev)
    subscription: String
    /// Specifies the URL of the Sensu monitoring host server.
    url: String?
}

/// Task class for sensu_silence
class SensuSilenceTask extends Playbook.Task {
    /// todo doc
    `community.general.sensu_silence`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.sensu_silence"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.sensu_silence`
}

/// TaskBuilder class for sensu_silence
class SensuSilence extends Playbook.TaskBuilder {
    /// Options for community.general.sensu_silence
    options: SensuSilenceOptions?
    /// todo doc
    function Task(): SensuSilenceTask = this
        .toMap()
        .put("community.general.sensu_silence", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SensuSilenceTask)
}

/// Manage Sensu subscriptions
/// Manage which I(sensu channels) a machine should subscribe to
class SensuSubscriptionOptions {
    /// Create a backup file (if yes), including the timestamp information so you
    /// can get the original file back if you somehow clobbered it incorrectly.
    backup: Boolean?
    /// The name of the channel
    name: String
    /// Path to the subscriptions json file
    path: String?
    /// Whether the machine should subscribe or unsubscribe from the channel
    state: ("present"|"absent")?
}

/// Task class for sensu_subscription
class SensuSubscriptionTask extends Playbook.Task {
    /// todo doc
    `community.general.sensu_subscription`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.sensu_subscription"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.sensu_subscription`
}

/// TaskBuilder class for sensu_subscription
class SensuSubscription extends Playbook.TaskBuilder {
    /// Options for community.general.sensu_subscription
    options: SensuSubscriptionOptions?
    /// todo doc
    function Task(): SensuSubscriptionTask = this
        .toMap()
        .put("community.general.sensu_subscription", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SensuSubscriptionTask)
}

/// Manages SELinux network port type definitions
/// Manages SELinux network port type definitions.
class SeportOptions {
    /// Run independent of selinux runtime state
    ignore_selinux_state: Boolean?
    /// Work with local modifications only.
    `local`: Boolean?
    /// Ports or port ranges.
    /// Can be a list (since 2.6) or comma separated string.
    ports: Listing<String>
    /// Protocol for the specified port.
    proto: ("tcp"|"udp")
    /// Reload SELinux policy after commit.
    reload: Boolean?
    /// SELinux type for the specified port.
    setype: String
    /// Desired boolean value.
    state: ("absent"|"present")?
}

/// Task class for seport
class SeportTask extends Playbook.Task {
    /// todo doc
    `community.general.seport`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.seport"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.seport`
}

/// TaskBuilder class for seport
class Seport extends Playbook.TaskBuilder {
    /// Options for community.general.seport
    options: SeportOptions?
    /// todo doc
    function Task(): SeportTask = this
        .toMap()
        .put("community.general.seport", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SeportTask)
}

/// Manages a Serverless Framework project
/// Provides support for managing Serverless Framework (U(https://serverless.com/)) project deployments and stacks.
class ServerlessOptions {
    /// Whether or not to deploy artifacts after building them.
    /// When this option is V(false) all the functions will be built, but no stack update will be run to send them out.
    /// This is mostly useful for generating artifacts to be stored/deployed elsewhere.
    deploy: Boolean?
    /// Whether or not to force full deployment, equivalent to serverless C(--force) option.
    force: Boolean?
    /// AWS region to deploy the service to.
    /// This parameter defaults to V(us-east-1).
    region: String?
    /// The path of a serverless framework binary relative to the 'service_path' eg. node_module/.bin/serverless
    serverless_bin_path: String?
    /// The path to the root of the Serverless Service to be operated on.
    service_path: String
    /// The name of the serverless framework project stage to deploy to.
    /// This uses the serverless framework default "dev".
    stage: String?
    /// Goal state of given stage/project.
    state: ("absent"|"present")?
    /// Shows all stack events during deployment, and display any Stack Output.
    verbose: Boolean?
}

/// Task class for serverless
class ServerlessTask extends Playbook.Task {
    /// todo doc
    `community.general.serverless`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.serverless"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.serverless`
}

/// TaskBuilder class for serverless
class Serverless extends Playbook.TaskBuilder {
    /// Options for community.general.serverless
    options: ServerlessOptions?
    /// todo doc
    function Task(): ServerlessTask = this
        .toMap()
        .put("community.general.serverless", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ServerlessTask)
}

/// Shut down a machine
/// Shut downs a machine.
class ShutdownOptions {
    /// Seconds to wait before shutdown. Passed as a parameter to the shutdown command.
    /// On Linux, macOS and OpenBSD, this is converted to minutes and rounded down. If less than 60, it will be set to 0.
    /// On Solaris and FreeBSD, this will be seconds.
    delay: Int?
    /// Message to display to users before shutdown.
    msg: String?
    /// Paths to search on the remote machine for the C(shutdown) command.
    /// I(Only) these paths will be searched for the C(shutdown) command. E(PATH) is ignored in the remote node when searching for the C(shutdown) command.
    search_paths: Listing<String>?
}

/// Task class for shutdown
class ShutdownTask extends Playbook.Task {
    /// todo doc
    `community.general.shutdown`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.shutdown"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.shutdown`
}

/// TaskBuilder class for shutdown
class Shutdown extends Playbook.TaskBuilder {
    /// Options for community.general.shutdown
    options: ShutdownOptions?
    /// todo doc
    function Task(): ShutdownTask = this
        .toMap()
        .put("community.general.shutdown", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ShutdownTask)
}

/// Manage services on Source Mage GNU/Linux
/// Controls services on remote hosts using C(simpleinit-msb).
class SimpleinitMsbOptions {
    /// Whether the service should start on boot.
    /// At least one of O(state) and O(enabled) are required.
    enabled: Boolean?
    /// Name of the service.
    name: String
    /// V(started)/V(stopped) are idempotent actions that will not run commands unless necessary.  V(restarted) will always bounce the service.  V(reloaded) will always reload.
    /// At least one of O(state) and O(enabled) are required.
    /// Note that V(reloaded) will start the service if it is not already started, even if your chosen init system would not normally.
    state: ("running"|"started"|"stopped"|"restarted"|"reloaded")?
}

/// Task class for simpleinit_msb
class SimpleinitMsbTask extends Playbook.Task {
    /// todo doc
    `community.general.simpleinit_msb`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.simpleinit_msb"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.simpleinit_msb`
}

/// TaskBuilder class for simpleinit_msb
class SimpleinitMsb extends Playbook.TaskBuilder {
    /// Options for community.general.simpleinit_msb
    options: SimpleinitMsbOptions?
    /// todo doc
    function Task(): SimpleinitMsbTask = this
        .toMap()
        .put("community.general.simpleinit_msb", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SimpleinitMsbTask)
}

/// Create or cancel a virtual instance in SoftLayer
/// Creates or cancels SoftLayer instances.
/// When created, optionally waits for it to be 'running'.
class SlVmOptions {
    /// Count of cpus to be assigned to new virtual instance.
    cpus: Int?
    /// Datacenter for the virtual instance to be deployed.
    datacenter: ("ams01"|"ams03"|"che01"|"dal01"|"dal05"|"dal06"|"dal09"|"dal10"|"dal12"|"dal13"|"fra02"|"fra04"|"fra05"|"hkg02"|"hou02"|"lon02"|"lon04"|"lon06"|"mel01"|"mex01"|"mil01"|"mon01"|"osl01"|"par01"|"sao01"|"sea01"|"seo01"|"sjc01"|"sjc03"|"sjc04"|"sng01"|"syd01"|"syd04"|"tok02"|"tor01"|"wdc01"|"wdc04"|"wdc06"|"wdc07")?
    /// Flag to determine if the instance should be deployed in dedicated space.
    dedicated: Boolean?
    /// List of disk sizes to be assigned to new virtual instance.
    disks: Listing<Int>?
    /// Domain name to be provided to a virtual instance.
    domain: String?
    /// Specify which SoftLayer flavor template to use instead of cpus and memory.
    flavor: String?
    /// Hostname to be provided to a virtual instance.
    hostname: String?
    /// Flag to determine if the instance should be hourly billed.
    hourly: Boolean?
    /// Image Template to be used for new virtual instance.
    image_id: String?
    /// Instance Id of the virtual instance to perform action option.
    instance_id: String?
    /// Flag to determine if local disk should be used for the new instance.
    local_disk: Boolean?
    /// Amount of memory to be assigned to new virtual instance.
    memory: Int?
    /// NIC Speed to be assigned to new virtual instance.
    nic_speed: Int?
    /// OS Code to be used for new virtual instance.
    os_code: String?
    /// URL of a post provisioning script to be loaded and executed on virtual instance.
    post_uri: String?
    /// Flag to determine if the instance should be private only.
    private: Boolean?
    /// VLAN by its Id to be assigned to the private NIC.
    private_vlan: String?
    /// VLAN by its Id to be assigned to the public NIC.
    public_vlan: String?
    /// List of ssh keys by their Id to be assigned to a virtual instance.
    ssh_keys: Listing<String>?
    /// Create, or cancel a virtual instance.
    /// Specify V(present) for create, V(absent) to cancel.
    state: ("absent"|"present")?
    /// Tag or list of tags to be provided to a virtual instance.
    tags: String?
    /// Flag used to wait for active status before returning.
    wait: Boolean?
    /// Time in seconds before wait returns.
    wait_time: Int?
}

/// Task class for sl_vm
class SlVmTask extends Playbook.Task {
    /// todo doc
    `community.general.sl_vm`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.sl_vm"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.sl_vm`
}

/// TaskBuilder class for sl_vm
class SlVm extends Playbook.TaskBuilder {
    /// Options for community.general.sl_vm
    options: SlVmOptions?
    /// todo doc
    function Task(): SlVmTask = this
        .toMap()
        .put("community.general.sl_vm", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SlVmTask)
}

/// Send Slack notifications
/// The M(community.general.slack) module sends notifications to U(http://slack.com) via the Incoming WebHook integration
class SlackOptions {
    /// Define a list of attachments. This list mirrors the Slack JSON API.
    /// For more information, see U(https://api.slack.com/docs/attachments).
    attachments: Listing<Any>?
    /// Define a list of blocks. This list mirrors the Slack JSON API.
    /// For more information, see U(https://api.slack.com/block-kit).
    blocks: Listing<Any>?
    /// Channel to send the message to. If absent, the message goes to the channel selected for the O(token).
    channel: String?
    /// Allow text to use default colors - use the default of 'normal' to not send a custom color bar at the start of the message.
    /// Allowed values for color can be one of 'normal', 'good', 'warning', 'danger', any valid 3 digit or 6 digit hex color value.
    color: String?
    /// Slack (sub)domain for your environment without protocol. (For example V(example.slack.com).) In Ansible 1.8 and beyond, this is deprecated and may be ignored.  See token documentation for information.
    domain: String?
    /// Emoji for the message sender. See Slack documentation for options.
    /// If O(icon_emoji) is set, O(icon_url) will not be used.
    icon_emoji: String?
    /// URL for the message sender's icon.
    icon_url: String?
    /// Automatically create links for channels and usernames in O(msg).
    link_names: Int?
    /// Optional. Message ID to edit, instead of posting a new message.
    /// If supplied O(channel) must be in form of C(C0xxxxxxx). use C({{ slack_response.channel_id }}) to get RV(ignore:channel_id) from previous task run.
    /// Corresponds to C(ts) in the Slack API (U(https://api.slack.com/messaging/modifying)).
    message_id: String?
    /// Message to send. Note that the module does not handle escaping characters. Plain-text angle brackets and ampersands should be converted to HTML entities (e.g. & to &amp;) before sending. See Slack's documentation (U(https://api.slack.com/docs/message-formatting)) for more.
    msg: String?
    /// Setting for the message parser at Slack
    parse: ("full"|"none")?
    /// Setting for automatically prepending a V(#) symbol on the passed in O(channel).
    /// The V(auto) method prepends a V(#) unless O(channel) starts with one of V(#), V(@), V(C0), V(GF), V(G0), V(CP). These prefixes only cover a small set of the prefixes that should not have a V(#) prepended. Since an exact condition which O(channel) values must not have the V(#) prefix is not known, the value V(auto) for this option will be deprecated in the future. It is best to explicitly set O(prepend_hash=always) or O(prepend_hash=never) to obtain the needed behavior.
    prepend_hash: ("always"|"never"|"auto")?
    /// Optional. Timestamp of parent message to thread this message. https://api.slack.com/docs/message-threading
    thread_id: String?
    /// Slack integration token. This authenticates you to the slack service. Make sure to use the correct type of token, depending on what method you use.
    /// Webhook token: Prior to Ansible 1.8, a token looked like V(3Ffe373sfhRE6y42Fg3rvf4GlK).  In Ansible 1.8 and above, Ansible adapts to the new slack API where tokens look like V(G922VJP24/D921DW937/3Ffe373sfhRE6y42Fg3rvf4GlK).  If tokens are in the new format then slack will ignore any value of domain.  If the token is in the old format the domain is required.  Ansible has no control of when slack will get rid of the old API.  When slack does that the old format will stop working.  ** Please keep in mind the tokens are not the API tokens but are the webhook tokens.  In slack these are found in the webhook URL which are obtained under the apps and integrations. The incoming webhooks can be added in that area.  In some cases this may be locked by your Slack admin and you must request access.  It is there that the incoming webhooks can be added.  The key is on the end of the URL given to you in that section.
    /// WebAPI token: Slack WebAPI requires a personal, bot or work application token. These tokens start with V(xoxp-), V(xoxb-) or V(xoxa-), for example V(xoxb-1234-56789abcdefghijklmnop). WebAPI token is required if you intend to receive thread_id. See Slack's documentation (U(https://api.slack.com/docs/token-types)) for more information.
    token: String
    /// This is the sender of the message.
    username: String?
    /// If V(false), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
    validate_certs: Boolean?
}

/// Task class for slack
class SlackTask extends Playbook.Task {
    /// todo doc
    `community.general.slack`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.slack"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.slack`
}

/// TaskBuilder class for slack
class Slack extends Playbook.TaskBuilder {
    /// Options for community.general.slack
    options: SlackOptions?
    /// todo doc
    function Task(): SlackTask = this
        .toMap()
        .put("community.general.slack", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SlackTask)
}

/// Package manager for Slackware >= 12.2
/// Manage binary packages for Slackware using 'slackpkg' which is available in versions after 12.2.
class SlackpkgOptions {
    /// name of package to install/remove
    name: Listing<String>
    /// State of the package, you can use V(installed) as an alias for V(present) and V(removed) as one for V(absent).
    state: ("present"|"absent"|"latest"|"installed"|"removed")?
    /// update the package database first
    update_cache: Boolean?
}

/// Task class for slackpkg
class SlackpkgTask extends Playbook.Task {
    /// todo doc
    `community.general.slackpkg`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.slackpkg"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.slackpkg`
}

/// TaskBuilder class for slackpkg
class Slackpkg extends Playbook.TaskBuilder {
    /// Options for community.general.slackpkg
    options: SlackpkgOptions?
    /// todo doc
    function Task(): SlackpkgTask = this
        .toMap()
        .put("community.general.slackpkg", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SlackpkgTask)
}

/// Get SmartOS image details
/// Retrieve information about all installed images on SmartOS.
class SmartosImageInfoOptions {
    /// Criteria for selecting image. Can be any value from image manifest and C(published_date), C(published), C(source), C(clones), and C(size). More information can be found at U(https://smartos.org/man/1m/imgadm) under C(imgadm list).
    filters: String?
}

/// Task class for smartos_image_info
class SmartosImageInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.smartos_image_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.smartos_image_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.smartos_image_info`
}

/// TaskBuilder class for smartos_image_info
class SmartosImageInfo extends Playbook.TaskBuilder {
    /// Options for community.general.smartos_image_info
    options: SmartosImageInfoOptions?
    /// todo doc
    function Task(): SmartosImageInfoTask = this
        .toMap()
        .put("community.general.smartos_image_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SmartosImageInfoTask)
}

/// Manages snaps
/// Manages snaps packages.
class SnapOptions {
    /// Define which release of a snap is installed and tracked for updates. This option can only be specified if there is a single snap in the task.
    /// If not passed, the C(snap) command will default to V(stable).
    /// If the value passed does not contain the C(track), it will default to C(latest). For example, if V(edge) is passed, the module will assume the channel to be V(latest/edge).
    /// See U(https://snapcraft.io/docs/channels) for more details about snap channels.
    channel: String?
    /// Confinement policy. The classic confinement allows a snap to have the same level of access to the system as "classic" packages, like those managed by APT. This option corresponds to the C(--classic) argument. This option can only be specified if there is a single snap in the task.
    classic: Boolean?
    /// Install the given snap file even if there are no pre-acknowledged signatures for it, meaning it was not verified and could be dangerous.
    dangerous: Boolean?
    /// Name of the snaps to be installed.
    /// Any named snap accepted by the C(snap) command is valid.
    /// Notice that snap files might require O(dangerous=true) to ignore the error "cannot find signatures with metadata for snap".
    name: Listing<String>
    /// Set options with pattern C(key=value) or C(snap:key=value). If a snap name is given, the option will be applied to that snap only. If the snap name is omitted, the options will be applied to all snaps listed in O(name). Options will only be applied to active snaps.
    options: Listing<String>?
    /// Desired state of the package.
    /// When O(state=present) the module will use C(snap install) if the snap is not installed, and C(snap refresh) if it is installed but from a different channel.
    state: ("absent"|"present"|"enabled"|"disabled")?
}

/// Task class for snap
class SnapTask extends Playbook.Task {
    /// todo doc
    `community.general.snap`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.snap"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.snap`
}

/// TaskBuilder class for snap
class Snap extends Playbook.TaskBuilder {
    /// Options for community.general.snap
    options: SnapOptions?
    /// todo doc
    function Task(): SnapTask = this
        .toMap()
        .put("community.general.snap", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SnapTask)
}

/// Manages snap aliases
/// Manages snaps aliases.
class SnapAliasOptions {
    /// Aliases to be created or removed.
    alias: Listing<String>?
    /// Name of the snap.
    name: String?
    /// Desired state of the alias.
    state: ("absent"|"present")?
}

/// Task class for snap_alias
class SnapAliasTask extends Playbook.Task {
    /// todo doc
    `community.general.snap_alias`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.snap_alias"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.snap_alias`
}

/// TaskBuilder class for snap_alias
class SnapAlias extends Playbook.TaskBuilder {
    /// Options for community.general.snap_alias
    options: SnapAliasOptions?
    /// todo doc
    function Task(): SnapAliasTask = this
        .toMap()
        .put("community.general.snap_alias", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SnapAliasTask)
}

/// Retrieve facts for a device using SNMP
/// Retrieve facts for a device using SNMP, the facts will be inserted to the ansible_facts key.
class SnmpFactsOptions {
    /// Authentication key.
    /// Required O(version=v3).
    authkey: String?
    /// The SNMP community string, required if O(version) is V(v2) or V(v2c).
    community: String?
    /// Set to target SNMP server (normally C({{ inventory_hostname }})).
    host: String
    /// Hashing algorithm.
    /// Required if O(version=v3).
    integrity: ("md5"|"sha")?
    /// Authentication level.
    /// Required if O(version=v3).
    level: ("authNoPriv"|"authPriv")?
    /// Encryption algorithm.
    /// Required if O(level=authPriv).
    privacy: ("aes"|"des")?
    /// Encryption key.
    /// Required if O(level=authPriv).
    privkey: String?
    /// Maximum number of request retries, 0 retries means just a single request.
    retries: Int?
    /// Response timeout in seconds.
    timeout: Int?
    /// Username for SNMPv3.
    /// Required if O(version=v3).
    username: String?
    /// SNMP Version to use, V(v2), V(v2c) or V(v3).
    version: ("v2"|"v2c"|"v3")
}

/// Task class for snmp_facts
class SnmpFactsTask extends Playbook.Task {
    /// todo doc
    `community.general.snmp_facts`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.snmp_facts"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.snmp_facts`
}

/// TaskBuilder class for snmp_facts
class SnmpFacts extends Playbook.TaskBuilder {
    /// Options for community.general.snmp_facts
    options: SnmpFactsOptions?
    /// todo doc
    function Task(): SnmpFactsTask = this
        .toMap()
        .put("community.general.snmp_facts", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SnmpFactsTask)
}

/// Manage Solaris zones
/// Create, start, stop and delete Solaris zones.
/// This module does not currently allow changing of options for a zone that is already been created.
class SolarisZoneOptions {
    /// Extra options to the zoneadm attach command. For example, this can be used to specify whether a minimum or full update of packages is required and if any packages need to be deleted. For valid values, see zoneadm(1M)
    attach_options: String?
    /// The zonecfg configuration commands for this zone. See zonecfg(1M) for the valid options and syntax. Typically this is a list of options separated by semi-colons or new lines, e.g. "set auto-boot=true;add net;set physical=bge0;set address=10.1.1.1;end"
    config: String?
    /// Extra options to the zonecfg(1M) create command.
    create_options: String?
    /// Extra options to the zoneadm(1M) install command. To automate Solaris 11 zone creation, use this to specify the profile XML file, e.g. install_options="-c sc_profile.xml"
    install_options: String?
    /// Zone name.
    /// A zone name must be unique name.
    /// A zone name must begin with an alphanumeric character.
    /// The name can contain alphanumeric characters, underscores V(_), hyphens V(-), and periods V(.).
    /// The name cannot be longer than 64 characters.
    name: String
    /// The path where the zone will be created. This is required when the zone is created, but not used otherwise.
    path: String?
    /// The password hash for the root account. If not specified, the zone's root account will not have a password.
    root_password: String?
    /// Whether to create a sparse (V(true)) or whole root (V(false)) zone.
    sparse: Boolean?
    /// V(present), configure and install the zone.
    /// V(installed), synonym for V(present).
    /// V(running), if the zone already exists, boot it, otherwise, configure and install the zone first, then boot it.
    /// V(started), synonym for V(running).
    /// V(stopped), shutdown a zone.
    /// V(absent), destroy the zone.
    /// V(configured), configure the ready so that it's to be attached.
    /// V(attached), attach a zone, but do not boot it.
    /// V(detached), shutdown and detach a zone
    state: ("absent"|"attached"|"configured"|"detached"|"installed"|"present"|"running"|"started"|"stopped")?
    /// Timeout, in seconds, for zone to boot.
    timeout: Int?
}

/// Task class for solaris_zone
class SolarisZoneTask extends Playbook.Task {
    /// todo doc
    `community.general.solaris_zone`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.solaris_zone"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.solaris_zone`
}

/// TaskBuilder class for solaris_zone
class SolarisZone extends Playbook.TaskBuilder {
    /// Options for community.general.solaris_zone
    options: SolarisZoneOptions?
    /// todo doc
    function Task(): SolarisZoneTask = this
        .toMap()
        .put("community.general.solaris_zone", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SolarisZoneTask)
}

/// Package manager for Source Mage GNU/Linux
/// Manages "spells" on Source Mage GNU/Linux using I(sorcery) toolchain
class SorceryOptions {
    /// Time in seconds to invalidate grimoire collection on update.
    /// Especially useful for SCM and rsync grimoires.
    /// Makes sense only in pair with O(update_cache).
    cache_valid_time: Int?
    /// Comma-separated list of _optional_ dependencies to build a spell (or make sure it is built) with; use V(+)/V(-) in front of dependency to turn it on/off (V(+) is optional though).
    /// This option is ignored if O(name) parameter is equal to V(*) or contains more than one spell.
    /// Providers must be supplied in the form recognized by Sorcery, for example 'V(openssl(SSL\))'.
    depends: String?
    /// Name of the spell or grimoire.
    /// Multiple names can be given, separated by commas.
    /// Special value V(*) in conjunction with states V(latest) or V(rebuild) will update or rebuild the whole system respectively
    /// The alias O(grimoire) was added in community.general 7.3.0.
    name: Listing<String>?
    /// Repository location.
    /// If specified, O(name) represents grimoire(s) instead of spell(s).
    /// Special value V(*) will pull grimoire from the official location.
    /// Only single item in O(name) in conjunction with V(*) can be used.
    /// O(state=absent) must be used with a special value V(*).
    repository: String?
    /// Whether to cast, dispel or rebuild a package.
    /// State V(cast) is an equivalent of V(present), not V(latest).
    /// State V(rebuild) implies cast of all specified spells, not only those existed before.
    state: ("present"|"latest"|"absent"|"cast"|"dispelled"|"rebuild")?
    /// Whether or not to update sorcery scripts at the very first stage.
    update: Boolean?
    /// Whether or not to update grimoire collection before casting spells.
    update_cache: Boolean?
}

/// Task class for sorcery
class SorceryTask extends Playbook.Task {
    /// todo doc
    `community.general.sorcery`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.sorcery"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.sorcery`
}

/// TaskBuilder class for sorcery
class Sorcery extends Playbook.TaskBuilder {
    /// Options for community.general.sorcery
    options: SorceryOptions?
    /// todo doc
    function Task(): SorceryTask = this
        .toMap()
        .put("community.general.sorcery", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SorceryTask)
}

/// Creates/deletes devices in CA Spectrum
/// This module allows you to create and delete devices in CA Spectrum U(https://www.ca.com/us/products/ca-spectrum.html).
/// Tested on CA Spectrum 9.4.2, 10.1.1 and 10.2.1
class SpectrumDeviceOptions {
    /// UDP port used for SNMP discovery.
    agentport: Int?
    /// SNMP community used for device discovery.
    /// Required when O(state=present).
    community: String
    /// IP address of the device.
    /// If a hostname is given, it will be resolved to the IP address.
    device: String
    /// Landscape handle of the SpectroServer to which add or remove the device.
    landscape: String
    /// On V(present) creates the device when it does not exist.
    /// On V(absent) removes the device when it exists.
    state: ("present"|"absent")?
    /// HTTP, HTTPS URL of the Oneclick server in the form V((http|https\)://host.domain[:port]).
    url: String
    /// Oneclick user password.
    url_password: String
    /// Oneclick user name.
    url_username: String
    /// if V(false), it will not use a proxy, even if one is defined in an environment variable on the target hosts.
    use_proxy: Boolean?
    /// If V(false), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
    validate_certs: Boolean?
}

/// Task class for spectrum_device
class SpectrumDeviceTask extends Playbook.Task {
    /// todo doc
    `community.general.spectrum_device`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.spectrum_device"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.spectrum_device`
}

/// TaskBuilder class for spectrum_device
class SpectrumDevice extends Playbook.TaskBuilder {
    /// Options for community.general.spectrum_device
    options: SpectrumDeviceOptions?
    /// todo doc
    function Task(): SpectrumDeviceTask = this
        .toMap()
        .put("community.general.spectrum_device", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SpectrumDeviceTask)
}

/// Enforce a model's attributes in CA Spectrum
/// This module can be used to enforce a model's attributes in CA Spectrum.
class SpectrumModelAttrsOptions {
    /// A list of attribute names and values to enforce.
    /// All values and parameters are case sensitive and must be provided as strings only.
    attributes: Listing<Any>
    /// Model name.
    name: String
    /// Model type.
    type: String
    /// URL of OneClick server.
    url: String
    /// OneClick password.
    url_password: String
    /// OneClick username.
    url_username: String
    /// if V(false), it will not use a proxy, even if one is defined in an environment variable on the target hosts.
    use_proxy: Boolean?
    /// Validate SSL certificates. Only change this to V(false) if you can guarantee that you are talking to the correct endpoint and there is no man-in-the-middle attack happening.
    validate_certs: Boolean?
}

/// Task class for spectrum_model_attrs
class SpectrumModelAttrsTask extends Playbook.Task {
    /// todo doc
    `community.general.spectrum_model_attrs`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.spectrum_model_attrs"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.spectrum_model_attrs`
}

/// TaskBuilder class for spectrum_model_attrs
class SpectrumModelAttrs extends Playbook.TaskBuilder {
    /// Options for community.general.spectrum_model_attrs
    options: SpectrumModelAttrsOptions?
    /// todo doc
    function Task(): SpectrumModelAttrsTask = this
        .toMap()
        .put("community.general.spectrum_model_attrs", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SpectrumModelAttrsTask)
}

/// Create, update or delete Spotinst AWS Elastigroups
/// Can create, update, or delete Spotinst AWS Elastigroups Launch configuration is part of the elastigroup configuration, so no additional modules are necessary for handling the launch configuration. You will have to have a credentials file in this location - <home>/.spotinst/credentials The credentials file must contain a row that looks like this token = <YOUR TOKEN> Full documentation available at https://help.spotinst.com/hc/en-us/articles/115003530285-Ansible-
class SpotinstAwsElastigroupOptions {
    /// Optional parameter that allows to set an account-id inside the module configuration. By default this is retrieved from the credentials path.
    account_id: String?
    /// The strategy orientation.
    /// The choices available are: V(availabilityOriented), V(costOriented), V(balanced).
    availability_vs_cost: String
    /// A list of hash/dictionaries of Availability Zones that are configured in the elastigroup; '[{"key":"value", "key":"value"}]'; keys allowed are name (String), subnet_id (String), placement_group_name (String),
    availability_zones: Listing<Any>
    /// A list of hash/dictionaries of Block Device Mappings for elastigroup instances; You can specify virtual devices and EBS volumes.; '[{"key":"value", "key":"value"}]'; keys allowed are device_name (List of Strings), virtual_name (String), no_device (String), ebs (Object, expects the following keys- delete_on_termination(Boolean), encrypted(Boolean), iops (Integer), snapshot_id(Integer), volume_type(String), volume_size(Integer))
    block_device_mappings: Listing<Any>?
    /// The Chef integration configuration.; Expects the following keys - chef_server (String), organization (String), user (String), pem_key (String), chef_version (String)
    chef: Any?
    /// Optional parameter that allows to set a non-default credentials path.
    credentials_path: String?
    /// TODO document.
    do_not_update: Listing<String>?
    /// A list of hash/dictionaries of scaling policies to configure in the elastigroup; '[{"key":"value", "key":"value"}]'; keys allowed are - policy_name (String, required), namespace (String, required), metric_name (String, required), dimensions ((List of Objects), Keys allowed are name (String, required) and value (String)), statistic (String, required), evaluation_periods (String, required), period (String, required), threshold (String, required), cooldown (String, required), unit (String, required), operator (String, required), action_type (String, required), adjustment (String), max_target_capacity (String), target (String), maximum (String), minimum (String)
    down_scaling_policies: Listing<Any>?
    /// Time for instance to be drained from incoming requests and deregistered from ELB before termination.
    draining_timeout: Int?
    /// Enable EBS optimization for supported instances which are not enabled by default.; Note - additional charges will be applied.
    ebs_optimized: Boolean?
    /// A list of hash/dictionaries of EBS devices to reattach to the elastigroup when available; '[{"key":"value", "key":"value"}]'; keys allowed are - volume_ids (List of Strings), device_name (String)
    ebs_volume_pool: Listing<Any>?
    /// The ECS integration configuration.; Expects the following key - cluster_name (String)
    ecs: Any?
    /// Placeholder parameter for future implementation of Elastic Beanstalk configurations.
    elastic_beanstalk: Any?
    /// List of ElasticIps Allocation Ids (example V(eipalloc-9d4e16f8)) to associate to the group instances
    elastic_ips: Listing<String>?
    /// In case of no spots available, Elastigroup will launch an On-demand instance instead
    fallback_to_od: Boolean?
    /// The amount of time, in seconds, after the instance has launched to start and check its health.
    /// If not specified, it defaults to V(300).
    health_check_grace_period: Int?
    /// The service to use for the health check.
    /// The choices available are: V(ELB), V(HCS), V(TARGET_GROUP), V(MLB), V(EC2).
    health_check_type: String?
    /// Minimal mount of time instance should be unhealthy for us to consider it unhealthy.
    health_check_unhealthy_duration_before_replacement: Int?
    /// The instance profile iamRole arn
    /// Only use iam_role_arn, or iam_role_name
    iam_role_arn: String?
    /// The instance profile iamRole name
    /// Only use iam_role_arn, or iam_role_name
    iam_role_name: String?
    /// The group id if it already exists and you want to update, or delete it. This will not work unless the uniqueness_by field is set to id. When this is set, and the uniqueness_by field is set, the group will either be updated or deleted, but not created.
    id: String?
    /// The image Id used to launch the instance.; In case of conflict between Instance type and image type, an error will be returned
    image_id: String
    /// Specify a Key Pair to attach to the instances
    key_pair: String?
    /// The Kubernetes integration configuration. Expects the following keys - api_server (String), token (String)
    kubernetes: Any?
    /// Lifetime period
    lifetime_period: Int?
    /// List of classic ELB names
    load_balancers: Listing<String>?
    /// The upper limit number of instances that you can scale up to
    max_size: Int
    /// The Mesosphere integration configuration. Expects the following key - api_server (String)
    mesosphere: Any?
    /// The lower limit number of instances that you can scale down to
    min_size: Int
    /// Describes whether instance Enhanced Monitoring is enabled
    monitoring: String?
    /// Configuration parameters for Multai load balancers.
    multai_load_balancers: Listing<Any>?
    /// Token used for Multai configuration.
    multai_token: String?
    /// Unique name for elastigroup to be created, updated or deleted
    name: String
    /// A list of hash/dictionaries of network interfaces to add to the elastigroup; '[{"key":"value", "key":"value"}]'; keys allowed are - description (String), device_index (Integer), secondary_private_ip_address_count (Integer), associate_public_ip_address (Boolean), delete_on_termination (Boolean), groups (List of Strings), network_interface_id (String), private_ip_address (String), subnet_id (String), associate_ipv6_address (Boolean), private_ip_addresses (List of Objects, Keys are privateIpAddress (String, required) and primary (Boolean))
    network_interfaces: Listing<Any>?
    /// Required if risk is not set
    /// Number of on demand instances to launch. All other instances will be spot instances.; Either set this parameter or the risk parameter
    on_demand_count: Int?
    /// On-demand instance type that will be provisioned
    on_demand_instance_type: String?
    /// The elastigroup OpsWorks integration configuration.; Expects the following key - layer_id (String)
    opsworks: Any?
    /// The Stateful elastigroup configuration.; Accepts the following keys - should_persist_root_device (Boolean), should_persist_block_devices (Boolean), should_persist_private_ip (Boolean)
    persistence: Any?
    /// Operation system type.
    /// Available choices are: V(Linux/UNIX), V(SUSE Linux), V(Windows), V(Linux/UNIX (Amazon VPC)), V(SUSE Linux (Amazon VPC)).
    product: String
    /// The Rancher integration configuration.; Expects the following keys - version (String), access_key (String), secret_key (String), master_host (String)
    rancher: Any?
    /// The Rightscale integration configuration.; Expects the following keys - account_id (String), refresh_token (String)
    right_scale: Any?
    /// Required if on demand is not set. The percentage of Spot instances to launch (0 - 100).
    risk: Int?
    /// Roll configuration.; If you would like the group to roll after updating, please use this feature. Accepts the following keys - batch_size_percentage(Integer, Required), grace_period - (Integer, Required), health_check_type(String, Optional)
    roll_config: Any?
    /// A list of hash/dictionaries of scheduled tasks to configure in the elastigroup; '[{"key":"value", "key":"value"}]'; keys allowed are - adjustment (Integer), scale_target_capacity (Integer), scale_min_capacity (Integer), scale_max_capacity (Integer), adjustment_percentage (Integer), batch_size_percentage (Integer), cron_expression (String), frequency (String), grace_period (Integer), task_type (String, required), is_enabled (Boolean)
    scheduled_tasks: Listing<Any>?
    /// One or more security group IDs. ; In case of update it will override the existing Security Group with the new given array
    security_group_ids: Listing<String>
    /// The Base64-encoded shutdown script that executes prior to instance termination. Encode before setting.
    shutdown_script: String?
    /// A list of hash/dictionaries of signals to configure in the elastigroup; keys allowed are - name (String, required), timeout (Integer)
    signals: Listing<Any>?
    /// Spin up time, in seconds, for the instance
    spin_up_time: Int?
    /// Spot instance type that will be provisioned.
    spot_instance_types: Listing<String>
    /// Create or delete the elastigroup
    state: ("present"|"absent")?
    /// A list of tags to configure in the elastigroup. Please specify list of keys and values (key colon value);
    tags: Listing<Any>?
    /// The number of instances to launch
    target: Int
    /// List of target group arns instances should be registered to
    target_group_arns: Listing<String>?
    /// A list of hash/dictionaries of target tracking policies to configure in the elastigroup; '[{"key":"value", "key":"value"}]'; keys allowed are - policy_name (String, required), namespace (String, required), source (String, required), metric_name (String, required), statistic (String, required), unit (String, required), cooldown (String, required), target (String, required)
    target_tracking_policies: Listing<Any>?
    /// Dedicated vs shared tenancy.
    /// The available choices are: V(default), V(dedicated).
    tenancy: String?
    /// Terminate at the end of billing hour
    terminate_at_end_of_billing_hour: Boolean?
    /// A Personal API Access Token issued by Spotinst.
    /// When not specified, the module will try to obtain it, in that order, from: environment variable E(SPOTINST_TOKEN), or from the credentials path.
    token: String?
    /// If your group names are not unique, you may use this feature to update or delete a specific group. Whenever this property is set, you must set a group_id in order to update or delete a group, otherwise a group will be created.
    uniqueness_by: ("id"|"name")?
    /// The capacity unit to launch instances by.
    /// The available choices are: V(instance), V(weight).
    unit: String?
    /// A list of hash/dictionaries of scaling policies to configure in the elastigroup; '[{"key":"value", "key":"value"}]'; keys allowed are - policy_name (String, required), namespace (String, required), metric_name (String, required), dimensions (List of Objects, Keys allowed are name (String, required) and value (String)), statistic (String, required) evaluation_periods (String, required), period (String, required), threshold (String, required), cooldown (String, required), unit (String, required), operator (String, required), action_type (String, required), adjustment (String), min_target_capacity (String), target (String), maximum (String), minimum (String)
    up_scaling_policies: Listing<Any>?
    /// Base64-encoded MIME user data. Encode before setting the value.
    user_data: String?
    /// In case of any available Reserved Instances, Elastigroup will utilize your reservations before purchasing Spot instances.
    utilize_reserved_instances: Boolean?
    /// Whether or not the elastigroup creation / update actions should wait for the instances to spin
    wait_for_instances: Boolean?
    /// How long the module should wait for instances before failing the action.; Only works if wait_for_instances is True.
    wait_timeout: Int?
}

/// Task class for spotinst_aws_elastigroup
class SpotinstAwsElastigroupTask extends Playbook.Task {
    /// todo doc
    `community.general.spotinst_aws_elastigroup`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.spotinst_aws_elastigroup"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.spotinst_aws_elastigroup`
}

/// TaskBuilder class for spotinst_aws_elastigroup
class SpotinstAwsElastigroup extends Playbook.TaskBuilder {
    /// Options for community.general.spotinst_aws_elastigroup
    options: SpotinstAwsElastigroupOptions?
    /// todo doc
    function Task(): SpotinstAwsElastigroupTask = this
        .toMap()
        .put("community.general.spotinst_aws_elastigroup", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SpotinstAwsElastigroupTask)
}

/// Manage HPE StoreServ 3PAR CPG
/// Create and delete CPG on HPE 3PAR.
class Ss3ParCpgOptions {
    /// Name of the CPG.
    cpg_name: String
    /// Specifies that physical disks must have the specified device type.
    disk_type: ("FC"|"NL"|"SSD")?
    /// Specifies the name of the domain in which the object will reside.
    domain: String?
    /// Specifies the growth increment(in MiB, GiB or TiB) the amount of logical disk storage created on each auto-grow operation.
    growth_increment: String?
    /// Specifies that the autogrow operation is limited to the specified storage amount that sets the growth limit(in MiB, GiB or TiB).
    growth_limit: String?
    /// Specifies that the threshold(in MiB, GiB or TiB) of used logical disk space when exceeded results in a warning alert.
    growth_warning: String?
    /// Specifies that the layout must support the failure of one port pair, one cage, or one magazine.
    high_availability: ("PORT"|"CAGE"|"MAG")?
    /// Specifies the RAID type for the logical disk.
    raid_type: ("R0"|"R1"|"R5"|"R6")?
    /// Specifies whether the certificate needs to be validated while communicating.
    secure: Boolean?
    /// Specifies the set size in the number of chunklets.
    set_size: Int?
    /// Whether the specified CPG should exist or not.
    state: ("present"|"absent")
}

/// Task class for ss_3par_cpg
class Ss3ParCpgTask extends Playbook.Task {
    /// todo doc
    `community.general.ss_3par_cpg`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ss_3par_cpg"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ss_3par_cpg`
}

/// TaskBuilder class for ss_3par_cpg
class Ss3ParCpg extends Playbook.TaskBuilder {
    /// Options for community.general.ss_3par_cpg
    options: Ss3ParCpgOptions?
    /// todo doc
    function Task(): Ss3ParCpgTask = this
        .toMap()
        .put("community.general.ss_3par_cpg", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(Ss3ParCpgTask)
}

/// Manage SSH config for user
/// Configures SSH hosts with special C(IdentityFile)s and hostnames.
class SshConfigOptions {
    /// Sets the C(AddKeysToAgent) option.
    add_keys_to_agent: Boolean?
    /// Sets the C(ControlMaster) option.
    controlmaster: ("yes"|"no"|"ask"|"auto"|"autoask")?
    /// Sets the C(ControlPath) option.
    controlpath: String?
    /// Sets the C(ControlPersist) option.
    controlpersist: String?
    /// Sets the C(ForwardAgent) option.
    forward_agent: Boolean?
    /// Which group this configuration file belongs to.
    /// If none given, O(user) is used.
    group: String?
    /// The endpoint this configuration is valid for.
    /// Can be an actual address on the internet or an alias that will connect to the value of O(hostname).
    host: String
    /// Sets the C(HostKeyAlgorithms) option.
    host_key_algorithms: String?
    /// The actual host to connect to when connecting to the host defined.
    hostname: String?
    /// Specifies that SSH should only use the configured authentication identity and certificate files (either the default files, or those explicitly configured in the C(ssh_config) files or passed on the ssh command-line), even if ssh-agent or a PKCS11Provider or SecurityKeyProvider offers more identities.
    identities_only: Boolean?
    /// The path to an identity file (SSH private key) that will be used when connecting to this host.
    /// File need to exist and have mode V(0600) to be valid.
    identity_file: String?
    /// The actual port to connect to when connecting to the host defined.
    port: String?
    /// Sets the C(ProxyCommand) option.
    /// Mutually exclusive with O(proxyjump).
    proxycommand: String?
    /// Sets the C(ProxyJump) option.
    /// Mutually exclusive with O(proxycommand).
    proxyjump: String?
    /// Specifies the user to log in as.
    remote_user: String?
    /// SSH config file.
    /// If O(user) and this option are not specified, C(/etc/ssh/ssh_config) is used.
    /// Mutually exclusive with O(user).
    ssh_config_file: String?
    /// Whether a host entry should exist or not.
    state: ("present"|"absent")?
    /// Whether to strictly check the host key when doing connections to the remote host.
    /// The value V(accept-new) is supported since community.general 8.6.0.
    strict_host_key_checking: ("yes"|"no"|"ask"|"accept-new")?
    /// Which user account this configuration file belongs to.
    /// If none given and O(ssh_config_file) is not specified, C(/etc/ssh/ssh_config) is used.
    /// If a user is given, C(~/.ssh/config) is used.
    /// Mutually exclusive with O(ssh_config_file).
    user: String?
    /// Sets the user known hosts file option.
    user_known_hosts_file: String?
}

/// Task class for ssh_config
class SshConfigTask extends Playbook.Task {
    /// todo doc
    `community.general.ssh_config`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ssh_config"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ssh_config`
}

/// TaskBuilder class for ssh_config
class SshConfig extends Playbook.TaskBuilder {
    /// Options for community.general.ssh_config
    options: SshConfigOptions?
    /// todo doc
    function Task(): SshConfigTask = this
        .toMap()
        .put("community.general.ssh_config", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SshConfigTask)
}

/// Send code deploy and annotation events to stackdriver
/// Send code deploy and annotation events to Stackdriver
class StackdriverOptions {
    /// The person or robot who the annotation should be attributed to.
    annotated_by: String?
    /// The person or robot responsible for deploying the code
    deployed_by: String?
    /// The environment code was deployed to. (ie: development, staging, production)
    deployed_to: String?
    /// The type of event to send, either annotation or deploy
    event: ("annotation"|"deploy")
    /// Unix timestamp of where the event should appear in the timeline, defaults to now. Be careful with this.
    event_epoch: String?
    /// id of an EC2 instance that this event should be attached to, which will limit the contexts where this event is shown
    instance_id: String?
    /// API key.
    key: String
    /// one of INFO/WARN/ERROR, defaults to INFO if not supplied. May affect display.
    level: ("INFO"|"WARN"|"ERROR")?
    /// The contents of the annotation message, in plain text. Limited to 256 characters. Required for annotation.
    msg: String?
    /// The repository (or project) deployed
    repository: String?
    /// The revision of the code that was deployed. Required for deploy events
    revision_id: String?
}

/// Task class for stackdriver
class StackdriverTask extends Playbook.Task {
    /// todo doc
    `community.general.stackdriver`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.stackdriver"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.stackdriver`
}

/// TaskBuilder class for stackdriver
class Stackdriver extends Playbook.TaskBuilder {
    /// Options for community.general.stackdriver
    options: StackdriverOptions?
    /// todo doc
    function Task(): StackdriverTask = this
        .toMap()
        .put("community.general.stackdriver", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(StackdriverTask)
}

/// Add or remove host to stacki front-end
/// Use this module to add or remove hosts to a stacki front-end via API.
/// Information on stacki can be found at U(https://github.com/StackIQ/stacki).
class StackiHostOptions {
    /// Appliance to be used in host creation.
    /// Required if O(state=present) and host does not yet exist.
    appliance: String?
    /// Set value to V(true) to force node into install state if it already exists in stacki.
    force_install: Boolean?
    /// Name of the host to be added to Stacki.
    name: String
    /// Network to be configured in the host.
    /// Currently not used by the module.
    network: String?
    /// Name of the primary network interface.
    /// Currently not used by the module.
    prim_intf: String?
    /// IP Address for the primary network interface.
    /// Currently not used by the module.
    prim_intf_ip: String?
    /// MAC Address for the primary PXE boot network interface.
    /// Currently not used by the module.
    prim_intf_mac: String?
    /// Rack to be used in host creation.
    /// Required if O(state=present) and host does not yet exist.
    rack: Int?
    /// Rank to be used in host creation.
    /// In Stacki terminology, the rank is the position of the machine in a rack.
    /// Required if O(state=present) and host does not yet exist.
    rank: Int?
    /// URL for the Stacki API Endpoint.
    stacki_endpoint: String
    /// Password for authenticating with Stacki API, but if not specified, the environment variable E(stacki_password) is used instead.
    stacki_password: String
    /// Username for authenticating with Stacki API, but if not specified, the environment variable E(stacki_user) is used instead.
    stacki_user: String
    /// Set value to the desired state for the specified host.
    state: ("absent"|"present")?
}

/// Task class for stacki_host
class StackiHostTask extends Playbook.Task {
    /// todo doc
    `community.general.stacki_host`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.stacki_host"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.stacki_host`
}

/// TaskBuilder class for stacki_host
class StackiHost extends Playbook.TaskBuilder {
    /// Options for community.general.stacki_host
    options: StackiHostOptions?
    /// todo doc
    function Task(): StackiHostTask = this
        .toMap()
        .put("community.general.stacki_host", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(StackiHostTask)
}

/// Send metrics to StatsD
/// The C(statsd) module sends metrics to StatsD.
/// For more information, see U(https://statsd-metrics.readthedocs.io/en/latest/).
/// Supported metric types are V(counter) and V(gauge). Currently unupported metric types are V(timer), V(set), and V(gaugedelta).
class StatsdOptions {
    /// If the metric is of type V(gauge), change the value by O(delta).
    delta: Boolean?
    /// StatsD host (hostname or IP) to send metrics to.
    host: String?
    /// The name of the metric.
    metric: String
    /// The prefix to add to the metric.
    metric_prefix: String?
    /// The type of metric.
    metric_type: ("counter"|"gauge")
    /// The port on O(host) which StatsD is listening on.
    port: Int?
    /// The transport protocol to send metrics over.
    protocol: ("udp"|"tcp")?
    /// State of the check, only V(present) makes sense.
    state: ("present")?
    /// Sender timeout, only applicable if O(protocol) is V(tcp).
    timeout: Any?
    /// The value of the metric.
    value: Int
}

/// Task class for statsd
class StatsdTask extends Playbook.Task {
    /// todo doc
    `community.general.statsd`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.statsd"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.statsd`
}

/// TaskBuilder class for statsd
class Statsd extends Playbook.TaskBuilder {
    /// Options for community.general.statsd
    options: StatsdOptions?
    /// todo doc
    function Task(): StatsdTask = this
        .toMap()
        .put("community.general.statsd", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(StatsdTask)
}

/// Create maintenance windows for your status.io dashboard
/// Creates a maintenance window for status.io
/// Deletes a maintenance window for status.io
class StatusioMaintenanceOptions {
    /// If it affects all components and containers
    all_infrastructure_affected: Boolean?
    /// Your unique API ID from status.io
    api_id: String
    /// Your unique API Key from status.io
    api_key: String
    /// Automatically start and end the maintenance window
    automation: Boolean?
    /// The given name of your component (server name)
    components: Listing<String>?
    /// The given name of your container (data center)
    containers: Listing<String>?
    /// Message describing the maintenance window
    desc: String?
    /// The maintenance id number when deleting a maintenance window
    maintenance_id: String?
    /// Notify subscribers 1 hour before maintenance start time
    maintenance_notify_1_hr: Boolean?
    /// Notify subscribers 24 hours before maintenance start time
    maintenance_notify_24_hr: Boolean?
    /// Notify subscribers 72 hours before maintenance start time
    maintenance_notify_72_hr: Boolean?
    /// Notify subscribers now
    maintenance_notify_now: Boolean?
    /// The length of time in UTC that the maintenance will run (starting from playbook runtime)
    minutes: Int?
    /// Date maintenance is expected to start (Month/Day/Year) (UTC)
    /// End Date is worked out from start_date + minutes
    start_date: String?
    /// Time maintenance is expected to start (Hour:Minutes) (UTC)
    /// End Time is worked out from start_time + minutes
    start_time: String?
    /// Desired state of the package.
    state: ("present"|"absent")?
    /// Your unique StatusPage ID from status.io
    statuspage: String
    /// A descriptive title for the maintenance window
    title: String?
    /// Status.io API URL. A private apiary can be used instead.
    url: String?
}

/// Task class for statusio_maintenance
class StatusioMaintenanceTask extends Playbook.Task {
    /// todo doc
    `community.general.statusio_maintenance`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.statusio_maintenance"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.statusio_maintenance`
}

/// TaskBuilder class for statusio_maintenance
class StatusioMaintenance extends Playbook.TaskBuilder {
    /// Options for community.general.statusio_maintenance
    options: StatusioMaintenanceOptions?
    /// todo doc
    function Task(): StatusioMaintenanceTask = this
        .toMap()
        .put("community.general.statusio_maintenance", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(StatusioMaintenanceTask)
}

/// Manage sudoers files
/// This module allows for the manipulation of sudoers files.
class SudoersOptions {
    /// The commands allowed by the sudoers rule.
    /// Multiple can be added by passing a list of commands.
    /// Use V(ALL) for all commands.
    commands: Listing<String>?
    /// The name of the group for the sudoers rule.
    /// This option cannot be used in conjunction with O(user).
    group: String?
    /// Specify the host the rule is for.
    host: String?
    /// The name of the sudoers rule.
    /// This will be used for the filename for the sudoers file managed by this rule.
    name: String
    /// Whether a command is prevented to run further commands itself.
    noexec: Boolean?
    /// Whether a password will be required to run the sudo'd command.
    nopassword: Boolean?
    /// Specify the target user the command(s) will run as.
    runas: String?
    /// Whether to allow keeping the environment when command is run with sudo.
    setenv: Boolean?
    /// Whether the rule should exist or not.
    state: ("present"|"absent")?
    /// The path which sudoers config files will be managed in.
    sudoers_path: String?
    /// The name of the user for the sudoers rule.
    /// This option cannot be used in conjunction with O(group).
    user: String?
    /// If V(absent), the sudoers rule will be added without validation.
    /// If V(detect) and visudo is available, then the sudoers rule will be validated by visudo.
    /// If V(required), visudo must be available to validate the sudoers rule.
    validation: ("absent"|"detect"|"required")?
}

/// Task class for sudoers
class SudoersTask extends Playbook.Task {
    /// todo doc
    `community.general.sudoers`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.sudoers"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.sudoers`
}

/// TaskBuilder class for sudoers
class Sudoers extends Playbook.TaskBuilder {
    /// Options for community.general.sudoers
    options: SudoersOptions?
    /// todo doc
    function Task(): SudoersTask = this
        .toMap()
        .put("community.general.sudoers", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SudoersTask)
}

/// Manage the state of a program or group of programs running via supervisord
/// Manage the state of a program or group of programs running via supervisord
class SupervisorctlOptions {
    /// The supervisor configuration file path
    config: String?
    /// The name of the supervisord program or group to manage.
    /// The name will be taken as group name when it ends with a colon V(:).
    /// If O(name=all), all programs and program groups will be managed.
    name: String
    /// password to use for authentication
    password: String?
    /// URL on which supervisord server is listening
    server_url: String?
    /// The signal to send to the program/group, when combined with the 'signalled' state. Required when l(state=signalled).
    signal: String?
    /// The desired state of program/group.
    state: ("present"|"started"|"stopped"|"restarted"|"absent"|"signalled")
    /// Use O(stop_before_removing=true) to stop the program/group before removing it
    stop_before_removing: Boolean?
    /// path to supervisorctl executable
    supervisorctl_path: String?
    /// username to use for authentication
    username: String?
}

/// Task class for supervisorctl
class SupervisorctlTask extends Playbook.Task {
    /// todo doc
    `community.general.supervisorctl`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.supervisorctl"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.supervisorctl`
}

/// TaskBuilder class for supervisorctl
class Supervisorctl extends Playbook.TaskBuilder {
    /// Options for community.general.supervisorctl
    options: SupervisorctlOptions?
    /// todo doc
    function Task(): SupervisorctlTask = this
        .toMap()
        .put("community.general.supervisorctl", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SupervisorctlTask)
}

/// Manage daemontools services
/// Controls daemontools services on remote hosts using the svc utility.
class SvcOptions {
    /// Should a 'down' file exist or not, if it exists it disables auto startup. Defaults to no. Downed does not imply stopped.
    downed: Boolean?
    /// Whether the service is enabled or not, if disabled it also implies stopped. Take note that a service can be enabled and downed (no auto restart).
    enabled: Boolean?
    /// Name of the service to manage.
    name: String
    /// Directory svscan watches for services
    service_dir: String?
    /// Directory where services are defined, the source of symlinks to service_dir.
    service_src: String?
    /// V(started)/V(stopped) are idempotent actions that will not run commands unless necessary.  V(restarted) will always bounce the svc (svc -t) and V(killed) will always bounce the svc (svc -k). V(reloaded) will send a sigusr1 (svc -1). V(once) will run a normally downed svc once (svc -o), not really an idempotent operation.
    state: ("killed"|"once"|"reloaded"|"restarted"|"started"|"stopped")?
}

/// Task class for svc
class SvcTask extends Playbook.Task {
    /// todo doc
    `community.general.svc`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.svc"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.svc`
}

/// TaskBuilder class for svc
class Svc extends Playbook.TaskBuilder {
    /// Options for community.general.svc
    options: SvcOptions?
    /// todo doc
    function Task(): SvcTask = this
        .toMap()
        .put("community.general.svc", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SvcTask)
}

/// Manage Solaris SVR4 packages
/// Manages SVR4 packages on Solaris 10 and 11.
/// These were the native packages on Solaris <= 10 and are available as a legacy feature in Solaris 11.
/// Note that this is a very basic packaging system. It will not enforce dependencies on install or remove.
class Svr4PkgOptions {
    /// Install/Remove category instead of a single package.
    category: Boolean?
    /// Package name, for example V(SUNWcsr).
    name: String
    /// HTTP[s] proxy to be used if O(src) is a URL.
    proxy: String?
    /// Specifies the location of a response file to be used if package expects input on install.
    response_file: String?
    /// Specifies the location to install the package from. Required when O(state=present).
    /// Can be any path acceptable to the C(pkgadd) command's C(-d) option. For example: V(somefile.pkg), V(/dir/with/pkgs), V(http:/server/mypkgs.pkg).
    /// If using a file or directory, they must already be accessible by the host. See the M(ansible.builtin.copy) module for a way to get them there.
    src: String?
    /// Whether to install (V(present)), or remove (V(absent)) a package.
    /// If the package is to be installed, then O(src) is required.
    /// The SVR4 package system doesn't provide an upgrade operation. You need to uninstall the old, then install the new package.
    state: ("present"|"absent")
    /// Whether to install the package only in the current zone, or install it into all zones.
    /// The installation into all zones works only if you are working with the global zone.
    zone: ("current"|"all")?
}

/// Task class for svr4pkg
class Svr4PkgTask extends Playbook.Task {
    /// todo doc
    `community.general.svr4pkg`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.svr4pkg"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.svr4pkg`
}

/// TaskBuilder class for svr4pkg
class Svr4Pkg extends Playbook.TaskBuilder {
    /// Options for community.general.svr4pkg
    options: Svr4PkgOptions?
    /// todo doc
    function Task(): Svr4PkgTask = this
        .toMap()
        .put("community.general.svr4pkg", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(Svr4PkgTask)
}

/// Manage packages with swdepot package manager (HP-UX)
/// Will install, upgrade and remove packages with swdepot package manager (HP-UX)
class SwdepotOptions {
    /// The source repository from which install or upgrade a package.
    depot: String?
    /// package name.
    name: String
    /// whether to install (V(present), V(latest)), or remove (V(absent)) a package.
    state: ("present"|"latest"|"absent")
}

/// Task class for swdepot
class SwdepotTask extends Playbook.Task {
    /// todo doc
    `community.general.swdepot`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.swdepot"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.swdepot`
}

/// TaskBuilder class for swdepot
class Swdepot extends Playbook.TaskBuilder {
    /// Options for community.general.swdepot
    options: SwdepotOptions?
    /// todo doc
    function Task(): SwdepotTask = this
        .toMap()
        .put("community.general.swdepot", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SwdepotTask)
}

/// Manages updates and bundles in ClearLinux systems
/// Manages updates and bundles with the swupd bundle manager, which is used by the Clear Linux Project for Intel Architecture.
class SwupdOptions {
    /// URL pointing to the contents of available bundles. If not specified, the contents are retrieved from clearlinux.org.
    contenturl: String?
    /// The format suffix for version file downloads. For example [1,2,3,staging,etc]. If not specified, the default format is used.
    format: String?
    /// The manifest contains information about the bundles at certain version of the OS. Specify a Manifest version to verify against that version or leave unspecified to verify against the current version.
    manifest: Int?
    /// Name of the (I)bundle to install or remove.
    name: String?
    /// Indicates the desired (I)bundle state. V(present) ensures the bundle is installed while V(absent) ensures the (I)bundle is not installed.
    state: ("present"|"absent")?
    /// Updates the OS to the latest version.
    update: Boolean?
    /// Overrides both O(contenturl) and O(versionurl).
    url: String?
    /// Verify content for OS version.
    verify: Boolean?
    /// URL for version string download.
    versionurl: String?
}

/// Task class for swupd
class SwupdTask extends Playbook.Task {
    /// todo doc
    `community.general.swupd`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.swupd"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.swupd`
}

/// TaskBuilder class for swupd
class Swupd extends Playbook.TaskBuilder {
    /// Options for community.general.swupd
    options: SwupdOptions?
    /// todo doc
    function Task(): SwupdTask = this
        .toMap()
        .put("community.general.swupd", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SwupdTask)
}

/// Log messages in the syslog
/// Uses syslog to add log entries to the host.
class SysloggerOptions {
    /// Set the log facility.
    facility: ("kern"|"user"|"mail"|"daemon"|"auth"|"lpr"|"news"|"uucp"|"cron"|"syslog"|"local0"|"local1"|"local2"|"local3"|"local4"|"local5"|"local6"|"local7")?
    /// Specify the name of application name which is sending the log to syslog.
    ident: String?
    /// Log the PID in brackets.
    log_pid: Boolean?
    /// This is the message to place in syslog.
    msg: String
    /// Set the log priority.
    priority: ("emerg"|"alert"|"crit"|"err"|"warning"|"notice"|"info"|"debug")?
}

/// Task class for syslogger
class SysloggerTask extends Playbook.Task {
    /// todo doc
    `community.general.syslogger`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.syslogger"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.syslogger`
}

/// TaskBuilder class for syslogger
class Syslogger extends Playbook.TaskBuilder {
    /// Options for community.general.syslogger
    options: SysloggerOptions?
    /// todo doc
    function Task(): SysloggerTask = this
        .toMap()
        .put("community.general.syslogger", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SysloggerTask)
}

/// Manage OpenBSD system patches
/// Manage OpenBSD system patches using syspatch.
class SyspatchOptions {
    /// Revert system patches.
    revert: ("all"|"one")?
}

/// Task class for syspatch
class SyspatchTask extends Playbook.Task {
    /// todo doc
    `community.general.syspatch`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.syspatch"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.syspatch`
}

/// TaskBuilder class for syspatch
class Syspatch extends Playbook.TaskBuilder {
    /// Options for community.general.syspatch
    options: SyspatchOptions?
    /// todo doc
    function Task(): SyspatchTask = this
        .toMap()
        .put("community.general.syspatch", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SyspatchTask)
}

/// Manage FreeBSD using sysrc
/// Manages C(/etc/rc.conf) for FreeBSD.
class SysrcOptions {
    /// Delimiter to be used instead of V(" ") (space).
    /// Only used when O(state=value_present) or O(state=value_absent).
    delim: String?
    /// Name or ID of the jail to operate on.
    jail: String?
    /// Name of variable in C(/etc/rc.conf) to manage.
    name: String
    /// Path to file to use instead of V(/etc/rc.conf).
    path: String?
    /// Use V(present) to add the variable.
    /// Use V(absent) to remove the variable.
    /// Use V(value_present) to add the value to the existing variable.
    /// Use V(value_absent) to remove the value from the existing variable.
    state: ("absent"|"present"|"value_present"|"value_absent")?
    /// The value to set when O(state=present).
    /// The value to add when O(state=value_present).
    /// The value to remove when O(state=value_absent).
    value: String?
}

/// Task class for sysrc
class SysrcTask extends Playbook.Task {
    /// todo doc
    `community.general.sysrc`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.sysrc"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.sysrc`
}

/// TaskBuilder class for sysrc
class Sysrc extends Playbook.TaskBuilder {
    /// Options for community.general.sysrc
    options: SysrcOptions?
    /// todo doc
    function Task(): SysrcTask = this
        .toMap()
        .put("community.general.sysrc", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SysrcTask)
}

/// Manage OpenBSD system upgrades
/// Manage OpenBSD system upgrades using sysupgrade.
class SysupgradeOptions {
    /// Fetch and verify files and create /bsd.upgrade but do not reboot.
    /// Set to V(false) if you want sysupgrade to reboot. This will cause Ansible to error, as it expects the module to exit gracefully. See the examples.
    fetch_only: Boolean?
    /// Force upgrade (for snapshots only).
    force: Boolean?
    /// OpenBSD mirror top-level URL for fetching an upgrade.
    /// By default, the mirror URL is pulled from /etc/installurl.
    installurl: String?
    /// Keep the files under /home/_sysupgrade.
    /// By default, the files will be deleted after the upgrade.
    keep_files: Boolean?
    /// Apply the latest snapshot.
    /// Otherwise release will be applied.
    snapshot: Boolean?
}

/// Task class for sysupgrade
class SysupgradeTask extends Playbook.Task {
    /// todo doc
    `community.general.sysupgrade`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.sysupgrade"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.sysupgrade`
}

/// TaskBuilder class for sysupgrade
class Sysupgrade extends Playbook.TaskBuilder {
    /// Options for community.general.sysupgrade
    options: SysupgradeOptions?
    /// todo doc
    function Task(): SysupgradeTask = this
        .toMap()
        .put("community.general.sysupgrade", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(SysupgradeTask)
}

/// Creates/deletes an issue in a Taiga Project Management Platform
/// Creates/deletes an issue in a Taiga Project Management Platform (U(https://taiga.io)).
/// An issue is identified by the combination of project, issue subject and issue type.
/// This module implements the creation or deletion of issues (not the update).
class TaigaIssueOptions {
    /// Path to a file to be attached to the issue.
    attachment: String?
    /// A string describing the file to be attached to the issue.
    attachment_description: String?
    /// The issue description.
    description: String?
    /// The issue type. Must exist previously.
    issue_type: String
    /// The issue priority. Must exist previously.
    priority: String?
    /// Name of the project containing the issue. Must exist previously.
    project: String
    /// The issue severity. Must exist previously.
    severity: String?
    /// Whether the issue should be present or not.
    state: ("present"|"absent")?
    /// The issue status. Must exist previously.
    status: String?
    /// The issue subject.
    subject: String
    /// A lists of tags to be assigned to the issue.
    tags: Listing<String>?
    /// The hostname of the Taiga instance.
    taiga_host: String?
}

/// Task class for taiga_issue
class TaigaIssueTask extends Playbook.Task {
    /// todo doc
    `community.general.taiga_issue`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.taiga_issue"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.taiga_issue`
}

/// TaskBuilder class for taiga_issue
class TaigaIssue extends Playbook.TaskBuilder {
    /// Options for community.general.taiga_issue
    options: TaigaIssueOptions?
    /// todo doc
    function Task(): TaigaIssueTask = this
        .toMap()
        .put("community.general.taiga_issue", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(TaigaIssueTask)
}

/// Send notifications via telegram
/// Send notifications via telegram bot, to a verified group or user.
/// Also, the user may try to use any other telegram bot API method, if you specify O(api_method) argument.
class TelegramOptions {
    /// Any parameters for the method.
    /// For reference to default method, V(SendMessage), see U(https://core.telegram.org/bots/api#sendmessage).
    api_args: Any?
    /// Bot API method.
    /// For reference, see U(https://core.telegram.org/bots/api).
    api_method: String?
    /// Token identifying your telegram bot.
    token: String
}

/// Task class for telegram
class TelegramTask extends Playbook.Task {
    /// todo doc
    `community.general.telegram`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.telegram"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.telegram`
}

/// TaskBuilder class for telegram
class Telegram extends Playbook.TaskBuilder {
    /// Options for community.general.telegram
    options: TelegramOptions?
    /// todo doc
    function Task(): TelegramTask = this
        .toMap()
        .put("community.general.telegram", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(TelegramTask)
}

/// Manages a Terraform deployment (and plans)
/// Provides support for deploying resources with Terraform and pulling resource information back into Ansible.
class TerraformOptions {
    /// A group of key-values to provide at init stage to the -backend-config parameter.
    backend_config: Any?
    /// The path to a configuration file to provide at init state to the -backend-config parameter. This can accept a list of paths to multiple configuration files.
    backend_config_files: Listing<String>?
    /// The path of a terraform binary to use, relative to the 'service_path' unless you supply an absolute path.
    binary_path: String?
    /// Apply only when no resources are destroyed. Note that this only prevents "destroy" actions, but not "destroy and re-create" actions. This option is ignored when O(state=absent).
    check_destroy: Boolean?
    /// Enable/disable capability to handle complex variable structures for C(terraform).
    /// If V(true) the O(variables) also accepts dictionaries, lists, and booleans to be passed to C(terraform). Strings that are passed are correctly quoted.
    /// When disabled, supports only simple variables (strings, integers, and floats), and passes them on unquoted.
    complex_vars: Boolean?
    /// To avoid duplicating infra, if a state file can't be found this will force a C(terraform init). Generally, this should be turned off unless you intend to provision an entirely new Terraform deployment.
    force_init: Boolean?
    /// Forces backend reconfiguration during init.
    init_reconfigure: Boolean?
    /// Enable statefile locking, if you use a service that accepts locks (such as S3+DynamoDB) to store your statefile.
    lock: Boolean?
    /// How long to maintain the lock on the statefile, if you use a service that accepts locks (such as S3+DynamoDB).
    lock_timeout: Int?
    /// Run init even if C(.terraform/terraform.tfstate) already exists in O(project_path).
    overwrite_init: Boolean?
    /// Restrict concurrent operations when Terraform applies the plan.
    parallelism: Int?
    /// The path to an existing Terraform plan file to apply. If this is not specified, Ansible will build a new TF plan and execute it. Note that this option is required if 'state' has the 'planned' value.
    plan_file: String?
    /// List of paths containing Terraform plugin executable files.
    /// Plugin executables can be downloaded from U(https://releases.hashicorp.com/).
    /// When set, the plugin discovery and auto-download behavior of Terraform is disabled.
    /// The directory structure in the plugin path can be tricky. The Terraform docs U(https://learn.hashicorp.com/tutorials/terraform/automate-terraform#pre-installed-plugins) show a simple directory of files, but actually, the directory structure has to follow the same structure you would see if Terraform auto-downloaded the plugins. See the examples below for a tree output of an example plugin directory.
    plugin_paths: Listing<String>?
    /// The path to the root of the Terraform directory with the vars.tf/main.tf/etc to use.
    project_path: String
    /// Allows Terraform init to upgrade providers to versions specified in the project's version constraints.
    provider_upgrade: Boolean?
    /// Only works with state = absent
    /// If true, the workspace will be deleted after the "terraform destroy" action.
    /// The 'default' workspace will not be deleted.
    purge_workspace: Boolean?
    /// Goal state of given stage/project
    state: ("planned"|"present"|"absent")?
    /// The path to an existing Terraform state file to use when building plan. If this is not specified, the default C(terraform.tfstate) will be used.
    /// This option is ignored when plan is specified.
    state_file: String?
    /// A list of specific resources to target in this plan/application. The resources selected here will also auto-include any dependencies.
    targets: Listing<String>?
    /// A group of key-values pairs to override template variables or those in variables files. By default, only string and number values are allowed, which are passed on unquoted.
    /// Support complex variable structures (lists, dictionaries, numbers, and booleans) to reflect terraform variable syntax when O(complex_vars=true).
    /// Ansible integers or floats are mapped to terraform numbers.
    /// Ansible strings are mapped to terraform strings.
    /// Ansible dictionaries are mapped to terraform objects.
    /// Ansible lists are mapped to terraform lists.
    /// Ansible booleans are mapped to terraform booleans.
    /// B(Note) passwords passed as variables will be visible in the log output. Make sure to use C(no_log=true) in production!
    variables: Any?
    /// The path to a variables file for Terraform to fill into the TF configurations. This can accept a list of paths to multiple variables files.
    variables_files: Listing<String>?
    /// The terraform workspace to work with. This sets the E(TF_WORKSPACE) environmental variable that is used to override workspace selection. For more information about workspaces have a look at U(https://developer.hashicorp.com/terraform/language/state/workspaces).
    workspace: String?
}

/// Task class for terraform
class TerraformTask extends Playbook.Task {
    /// todo doc
    `community.general.terraform`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.terraform"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.terraform`
}

/// TaskBuilder class for terraform
class Terraform extends Playbook.TaskBuilder {
    /// Options for community.general.terraform
    options: TerraformOptions?
    /// todo doc
    function Task(): TerraformTask = this
        .toMap()
        .put("community.general.terraform", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(TerraformTask)
}

/// Configure timezone setting
/// This module configures the timezone setting, both of the system clock and of the hardware clock. If you want to set up the NTP, use M(ansible.builtin.service) module.
/// It is recommended to restart C(crond) after changing the timezone, otherwise the jobs may run at the wrong time.
/// Several different tools are used depending on the OS/Distribution involved. For Linux it can use C(timedatectl) or edit C(/etc/sysconfig/clock) or C(/etc/timezone) and C(hwclock). On SmartOS, C(sm-set-timezone), for macOS, C(systemsetup), for BSD, C(/etc/localtime) is modified. On AIX, C(chtz) is used.
/// Make sure that the zoneinfo files are installed with the appropriate OS package, like C(tzdata) (usually always installed, when not using a minimal installation like Alpine Linux).
/// Windows and HPUX are not supported, please let us know if you find any other OS/distro in which this fails.
class TimezoneOptions {
    /// Whether the hardware clock is in UTC or in local timezone.
    /// Default is to keep current setting.
    /// Note that this option is recommended not to change and may fail to configure, especially on virtual environments such as AWS.
    /// B(At least one of name and hwclock are required.)
    /// I(Only used on Linux.)
    hwclock: ("local"|"UTC")?
    /// Name of the timezone for the system clock.
    /// Default is to keep current setting.
    /// B(At least one of name and hwclock are required.)
    name: String?
}

/// Task class for timezone
class TimezoneTask extends Playbook.Task {
    /// todo doc
    `community.general.timezone`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.timezone"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.timezone`
}

/// TaskBuilder class for timezone
class Timezone extends Playbook.TaskBuilder {
    /// Options for community.general.timezone
    options: TimezoneOptions?
    /// todo doc
    function Task(): TimezoneTask = this
        .toMap()
        .put("community.general.timezone", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(TimezoneTask)
}

/// Sends a text message to a mobile phone through Twilio
/// Sends a text message to a phone number through the Twilio messaging API.
class TwilioOptions {
    /// User's Twilio account token found on the account page.
    account_sid: String
    /// User's Twilio authentication token.
    auth_token: String
    /// The Twilio number to send the text message from, format C(+15551112222).
    from_number: String
    /// A URL with a picture, video or sound clip to send with an MMS (multimedia message) instead of a plain SMS.
    media_url: String?
    /// The body of the text message.
    msg: String
    /// One or more phone numbers to send the text message to, format C(+15551112222).
    to_numbers: Listing<String>
}

/// Task class for twilio
class TwilioTask extends Playbook.Task {
    /// todo doc
    `community.general.twilio`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.twilio"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.twilio`
}

/// TaskBuilder class for twilio
class Twilio extends Playbook.TaskBuilder {
    /// Options for community.general.twilio
    options: TwilioOptions?
    /// todo doc
    function Task(): TwilioTask = this
        .toMap()
        .put("community.general.twilio", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(TwilioTask)
}

/// Send a message to typetalk
/// Send a message to typetalk using typetalk API
class TypetalkOptions {
    /// OAuth2 client ID
    client_id: String
    /// OAuth2 client secret
    client_secret: String
    /// message body
    msg: String
    /// topic id to post message
    topic: Int
}

/// Task class for typetalk
class TypetalkTask extends Playbook.Task {
    /// todo doc
    `community.general.typetalk`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.typetalk"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.typetalk`
}

/// TaskBuilder class for typetalk
class Typetalk extends Playbook.TaskBuilder {
    /// Options for community.general.typetalk
    options: TypetalkOptions?
    /// todo doc
    function Task(): TypetalkTask = this
        .toMap()
        .put("community.general.typetalk", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(TypetalkTask)
}

/// Manage dns entries on a univention corporate server
/// This module allows to manage dns records on a univention corporate server (UCS). It uses the python API of the UCS to create a new object or edit it.
class UdmDnsRecordOptions {
    /// Additional data for this record, for example V({'a': '192.0.2.1'}).
    /// Required if O(state=present).
    data: Any?
    /// Name of the record, this is also the DNS record. E.g. www for www.example.com.
    /// For PTR records this has to be the IP address.
    name: String
    /// Whether the dns record is present or not.
    state: ("present"|"absent")?
    /// Define the record type. V(host_record) is a A or AAAA record, V(alias) is a CNAME, V(ptr_record) is a PTR record, V(srv_record) is a SRV record and V(txt_record) is a TXT record.
    /// The available choices are: V(host_record), V(alias), V(ptr_record), V(srv_record), V(txt_record).
    type: String
    /// Corresponding DNS zone for this record, e.g. example.com.
    /// For PTR records this has to be the full reverse zone (for example V(1.1.192.in-addr.arpa)).
    zone: String
}

/// Task class for udm_dns_record
class UdmDnsRecordTask extends Playbook.Task {
    /// todo doc
    `community.general.udm_dns_record`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.udm_dns_record"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.udm_dns_record`
}

/// TaskBuilder class for udm_dns_record
class UdmDnsRecord extends Playbook.TaskBuilder {
    /// Options for community.general.udm_dns_record
    options: UdmDnsRecordOptions?
    /// todo doc
    function Task(): UdmDnsRecordTask = this
        .toMap()
        .put("community.general.udm_dns_record", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(UdmDnsRecordTask)
}

/// Manage dns zones on a univention corporate server
/// This module allows to manage dns zones on a univention corporate server (UCS). It uses the python API of the UCS to create a new object or edit it.
class UdmDnsZoneOptions {
    /// Contact person in the SOA record.
    contact: String?
    /// Specifies the upper limit on the time interval that can elapse before the zone is no longer authoritative.
    expire: Int?
    /// List of interface IP addresses, on which the server should response this zone. Required if O(state=present).
    interfaces: Listing<String>?
    /// List of MX servers. (Must declared as A or AAAA records).
    mx: Listing<String>?
    /// List of appropriate name servers. Required if O(state=present).
    nameserver: Listing<String>?
    /// Interval before the zone should be refreshed.
    refresh: Int?
    /// Interval that should elapse before a failed refresh should be retried.
    retry: Int?
    /// Whether the dns zone is present or not.
    state: ("present"|"absent")?
    /// Minimum TTL field that should be exported with any RR from this zone.
    ttl: Int?
    /// Define if the zone is a forward or reverse DNS zone.
    /// The available choices are: V(forward_zone), V(reverse_zone).
    type: String
    /// DNS zone name, for example V(example.com).
    zone: String
}

/// Task class for udm_dns_zone
class UdmDnsZoneTask extends Playbook.Task {
    /// todo doc
    `community.general.udm_dns_zone`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.udm_dns_zone"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.udm_dns_zone`
}

/// TaskBuilder class for udm_dns_zone
class UdmDnsZone extends Playbook.TaskBuilder {
    /// Options for community.general.udm_dns_zone
    options: UdmDnsZoneOptions?
    /// todo doc
    function Task(): UdmDnsZoneTask = this
        .toMap()
        .put("community.general.udm_dns_zone", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(UdmDnsZoneTask)
}

/// Manage of the posix group
/// This module allows to manage user groups on a univention corporate server (UCS). It uses the python API of the UCS to create a new object or edit it.
class UdmGroupOptions {
    /// Group description.
    description: String?
    /// Name of the posix group.
    name: String
    /// LDAP OU, e.g. school for LDAP OU C(ou=school,dc=example,dc=com).
    ou: String?
    /// define the whole ldap position of the group, e.g. C(cn=g123m-1A,cn=classes,cn=schueler,cn=groups,ou=schule,dc=example,dc=com).
    position: String?
    /// Whether the group is present or not.
    state: ("present"|"absent")?
    /// Subpath inside the OU, e.g. C(cn=classes,cn=students,cn=groups).
    subpath: String?
}

/// Task class for udm_group
class UdmGroupTask extends Playbook.Task {
    /// todo doc
    `community.general.udm_group`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.udm_group"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.udm_group`
}

/// TaskBuilder class for udm_group
class UdmGroup extends Playbook.TaskBuilder {
    /// Options for community.general.udm_group
    options: UdmGroupOptions?
    /// todo doc
    function Task(): UdmGroupTask = this
        .toMap()
        .put("community.general.udm_group", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(UdmGroupTask)
}

/// Manage samba shares on a univention corporate server
/// This module allows to manage samba shares on a univention corporate server (UCS). It uses the python API of the UCS to create a new object or edit it.
class UdmShareOptions {
    /// Permissions for the share's root directory.
    directorymode: String?
    /// Directory owner group of the share's root directory.
    group: String?
    /// Host FQDN (server which provides the share), for example V({{ ansible_fqdn }}). Required if O(state=present).
    host: String?
    /// Name
    name: String
    /// Option name in exports file.
    nfsCustomSettings: Listing<String>?
    /// Only allow access for this host, IP address or network.
    nfs_hosts: Listing<String>?
    /// Organisational unit, inside the LDAP Base DN.
    ou: String
    /// Directory owner of the share's root directory.
    owner: String?
    /// Directory on the providing server, for example V(/home). Required if O(state=present).
    path: String?
    /// Modify user ID for root user (root squashing).
    root_squash: Boolean?
    /// Blocking size.
    sambaBlockSize: String?
    /// Blocking locks.
    sambaBlockingLocks: Boolean?
    /// Show in Windows network environment.
    sambaBrowseable: Boolean?
    /// File mode.
    sambaCreateMode: String?
    /// Client-side caching policy.
    sambaCscPolicy: String?
    /// Option name in smb.conf and its value.
    sambaCustomSettings: Listing<Any>?
    /// Directory mode.
    sambaDirectoryMode: String?
    /// Directory security mode.
    sambaDirectorySecurityMode: String?
    /// Users with write access may modify permissions.
    sambaDosFilemode: Boolean?
    /// Fake oplocks.
    sambaFakeOplocks: Boolean?
    /// Force file mode.
    sambaForceCreateMode: Boolean?
    /// Force directory mode.
    sambaForceDirectoryMode: Boolean?
    /// Force directory security mode.
    sambaForceDirectorySecurityMode: Boolean?
    /// Force group.
    sambaForceGroup: String?
    /// Force security mode.
    sambaForceSecurityMode: Boolean?
    /// Force user.
    sambaForceUser: String?
    /// Hide files.
    sambaHideFiles: String?
    /// Hide unreadable files/directories.
    sambaHideUnreadable: Boolean?
    /// Allowed host/network.
    sambaHostsAllow: Listing<String>?
    /// Denied host/network.
    sambaHostsDeny: Listing<String>?
    /// Inherit ACLs.
    sambaInheritAcls: Boolean?
    /// Create files/directories with the owner of the parent directory.
    sambaInheritOwner: Boolean?
    /// Create files/directories with permissions of the parent directory.
    sambaInheritPermissions: Boolean?
    /// Invalid users or groups.
    sambaInvalidUsers: String?
    /// Level 2 oplocks.
    sambaLevel2Oplocks: Boolean?
    /// Locking.
    sambaLocking: Boolean?
    /// MSDFS root.
    sambaMSDFSRoot: Boolean?
    /// Windows name. Required if O(state=present).
    sambaName: String?
    /// NT ACL support.
    sambaNtAclSupport: Boolean?
    /// Oplocks.
    sambaOplocks: Boolean?
    /// Postexec script.
    sambaPostexec: String?
    /// Preexec script.
    sambaPreexec: String?
    /// Allow anonymous read-only access with a guest user.
    sambaPublic: Boolean?
    /// Security mode.
    sambaSecurityMode: String?
    /// Strict locking.
    sambaStrictLocking: String?
    /// VFS objects.
    sambaVFSObjects: String?
    /// Valid users or groups.
    sambaValidUsers: String?
    /// Restrict write access to these users/groups.
    sambaWriteList: String?
    /// Samba write access.
    sambaWriteable: Boolean?
    /// Whether the share is present or not.
    state: ("present"|"absent")?
    /// Subtree checking.
    subtree_checking: Boolean?
    /// NFS synchronisation.
    sync: String?
    /// NFS write access.
    writeable: Boolean?
}

/// Task class for udm_share
class UdmShareTask extends Playbook.Task {
    /// todo doc
    `community.general.udm_share`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.udm_share"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.udm_share`
}

/// TaskBuilder class for udm_share
class UdmShare extends Playbook.TaskBuilder {
    /// Options for community.general.udm_share
    options: UdmShareOptions?
    /// todo doc
    function Task(): UdmShareTask = this
        .toMap()
        .put("community.general.udm_share", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(UdmShareTask)
}

/// Manage posix users on a univention corporate server
/// This module allows to manage posix users on a univention corporate server (UCS). It uses the python API of the UCS to create a new object or edit it.
class UdmUserOptions {
    /// Birthday
    birthday: String?
    /// City of users business address.
    city: String?
    /// Country of users business address.
    country: String?
    /// Department number of users business address.
    department_number: String?
    /// Description (not gecos)
    description: String?
    /// Display name (not gecos)
    display_name: String?
    /// A list of e-mail addresses.
    email: Listing<String>?
    /// Employee number
    employee_number: String?
    /// Employee type
    employee_type: String?
    /// First name. Required if O(state=present).
    firstname: String?
    /// GECOS
    gecos: String?
    /// POSIX groups, the LDAP DNs of the groups will be found with the LDAP filter for each group as $GROUP: V((&(objectClass=posixGroup\)(cn=$GROUP\)\)).
    groups: Listing<String>?
    /// Home NFS share. Must be a LDAP DN, e.g. V(cn=home,cn=shares,ou=school,dc=example,dc=com).
    home_share: String?
    /// Path to home NFS share, inside the homeShare.
    home_share_path: String?
    /// List of private telephone numbers.
    home_telephone_number: Listing<String>?
    /// Windows home drive, for example V("H:").
    homedrive: String?
    /// Last name. Required if O(state=present).
    lastname: String?
    /// List of alternative e-mail addresses.
    mail_alternative_address: Listing<String>?
    /// FQDN of mail server
    mail_home_server: String?
    /// Primary e-mail address
    mail_primary_address: String?
    /// Mobile phone number
    mobile_telephone_number: Listing<String>?
    /// Organisation
    organisation: String?
    /// Organizational Unit inside the LDAP Base DN, for example V(school) for LDAP OU C(ou=school,dc=example,dc=com).
    ou: String?
    /// Override password history
    overridePWHistory: Boolean?
    /// Override password check
    overridePWLength: Boolean?
    /// List of pager telephone numbers.
    pager_telephonenumber: Listing<String>?
    /// Password. Required if O(state=present).
    password: String?
    /// List of telephone numbers.
    phone: Listing<String>?
    /// Define the whole position of users object inside the LDAP tree, for example V(cn=employee,cn=users,ou=school,dc=example,dc=com).
    position: String?
    /// Postal code of users business address.
    postcode: String?
    /// Primary group. This must be the group LDAP DN.
    /// If not specified, it defaults to V(cn=Domain Users,cn=groups,$LDAP_BASE_DN).
    primary_group: String?
    /// Windows profile directory
    profilepath: String?
    /// Change password on next login.
    pwd_change_next_login: ("0"|"1")?
    /// Room number of users business address.
    room_number: String?
    /// Samba privilege, like allow printer administration, do domain join.
    samba_privileges: Listing<String>?
    /// Allow the authentication only on this Microsoft Windows host.
    samba_user_workstations: Listing<String>?
    /// Windows home path, for example V('\\\\$FQDN\\$USERNAME').
    sambahome: String?
    /// Windows logon script.
    scriptpath: String?
    /// A list of superiors as LDAP DNs.
    secretary: Listing<String>?
    /// Enable user for the following service providers.
    serviceprovider: Listing<String>?
    /// Login shell
    shell: String?
    /// Whether the user is present or not.
    state: ("present"|"absent")?
    /// Street of users business address.
    street: String?
    /// LDAP subpath inside the organizational unit, for example V(cn=teachers,cn=users) for LDAP container C(cn=teachers,cn=users,dc=example,dc=com).
    subpath: String?
    /// Title, for example V(Prof.).
    title: String?
    /// Unix home directory
    /// If not specified, it defaults to C(/home/$USERNAME).
    unixhome: String?
    /// V(always) will update passwords if they differ. V(on_create) will only set the password for newly created users.
    update_password: ("always"|"on_create")?
    /// Account expiry date, for example V(1999-12-31).
    /// If not specified, it defaults to the current day plus one year.
    userexpiry: String?
    /// User name
    username: String
}

/// Task class for udm_user
class UdmUserTask extends Playbook.Task {
    /// todo doc
    `community.general.udm_user`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.udm_user"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.udm_user`
}

/// TaskBuilder class for udm_user
class UdmUser extends Playbook.TaskBuilder {
    /// Options for community.general.udm_user
    options: UdmUserOptions?
    /// todo doc
    function Task(): UdmUserTask = this
        .toMap()
        .put("community.general.udm_user", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(UdmUserTask)
}

/// Manage firewall with UFW
/// Manage firewall with UFW.
class UfwOptions {
    /// Add a comment to the rule. Requires UFW version >=0.35.
    comment: String?
    /// Change the default policy for incoming or outgoing traffic.
    default: ("allow"|"deny"|"reject")?
    /// Delete rule.
    /// If O(delete=true) and a value is provided for O(insert), then O(insert) is ignored.
    `delete`: Boolean?
    /// Select direction for a rule or default policy command.  Mutually exclusive with O(interface_in) and O(interface_out).
    direction: ("in"|"incoming"|"out"|"outgoing"|"routed")?
    /// Source IP address.
    from_ip: String?
    /// Source port.
    from_port: String?
    /// Insert the corresponding rule as rule number NUM.
    /// Note that ufw numbers rules starting with 1.
    /// If O(delete=true) and a value is provided for O(insert), then O(insert) is ignored.
    insert: Int?
    /// Allows to interpret the index in O(insert) relative to a position.
    /// V(zero) interprets the rule number as an absolute index (i.e. 1 is the first rule).
    /// V(first-ipv4) interprets the rule number relative to the index of the first IPv4 rule, or relative to the position where the first IPv4 rule would be if there is currently none.
    /// V(last-ipv4) interprets the rule number relative to the index of the last IPv4 rule, or relative to the position where the last IPv4 rule would be if there is currently none.
    /// V(first-ipv6) interprets the rule number relative to the index of the first IPv6 rule, or relative to the position where the first IPv6 rule would be if there is currently none.
    /// V(last-ipv6) interprets the rule number relative to the index of the last IPv6 rule, or relative to the position where the last IPv6 rule would be if there is currently none.
    insert_relative_to: ("first-ipv4"|"first-ipv6"|"last-ipv4"|"last-ipv6"|"zero")?
    /// Specify interface for the rule.  The direction (in or out) used for the interface depends on the value of O(direction).  See O(interface_in) and O(interface_out) for routed rules that needs to supply both an input and output interface.  Mutually exclusive with O(interface_in) and O(interface_out).
    interface: String?
    /// Specify input interface for the rule.  This is mutually exclusive with O(direction) and O(interface).  However, it is compatible with O(interface_out) for routed rules.
    interface_in: String?
    /// Specify output interface for the rule.  This is mutually exclusive with O(direction) and O(interface).  However, it is compatible with O(interface_in) for routed rules.
    interface_out: String?
    /// Log new connections matched to this rule
    log: Boolean?
    /// Toggles logging. Logged packets use the LOG_KERN syslog facility.
    logging: ("on"|"off"|"low"|"medium"|"high"|"full")?
    /// Use profile located in C(/etc/ufw/applications.d).
    name: String?
    /// TCP/IP protocol.
    proto: ("any"|"tcp"|"udp"|"ipv6"|"esp"|"ah"|"gre"|"igmp")?
    /// Apply the rule to routed/forwarded packets.
    route: Boolean?
    /// Add firewall rule
    rule: ("allow"|"deny"|"limit"|"reject")?
    /// V(enabled) reloads firewall and enables firewall on boot.
    /// V(disabled) unloads firewall and disables firewall on boot.
    /// V(reloaded) reloads firewall.
    /// V(reset) disables and resets firewall to installation defaults.
    state: ("disabled"|"enabled"|"reloaded"|"reset")?
    /// Destination IP address.
    to_ip: String?
    /// Destination port.
    to_port: String?
}

/// Task class for ufw
class UfwTask extends Playbook.Task {
    /// todo doc
    `community.general.ufw`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.ufw"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.ufw`
}

/// TaskBuilder class for ufw
class Ufw extends Playbook.TaskBuilder {
    /// Options for community.general.ufw
    options: UfwOptions?
    /// todo doc
    function Task(): UfwTask = this
        .toMap()
        .put("community.general.ufw", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(UfwTask)
}

/// Pause and start Uptime Robot monitoring
/// This module will let you start and pause Uptime Robot Monitoring
class UptimerobotOptions {
    /// Uptime Robot API key.
    apikey: String
    /// ID of the monitor to check.
    monitorid: String
    /// Define whether or not the monitor should be running or paused.
    state: ("started"|"paused")
}

/// Task class for uptimerobot
class UptimerobotTask extends Playbook.Task {
    /// todo doc
    `community.general.uptimerobot`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.uptimerobot"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.uptimerobot`
}

/// TaskBuilder class for uptimerobot
class Uptimerobot extends Playbook.TaskBuilder {
    /// Options for community.general.uptimerobot
    options: UptimerobotOptions?
    /// todo doc
    function Task(): UptimerobotTask = this
        .toMap()
        .put("community.general.uptimerobot", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(UptimerobotTask)
}

/// Urpmi manager
/// Manages packages with C(urpmi) (such as for Mageia or Mandriva)
class UrpmiOptions {
    /// Assume "yes" is the answer to any question urpmi has to ask. Corresponds to the C(--force) option for C(urpmi).
    force: Boolean?
    /// A list of package names to install, upgrade or remove.
    name: Listing<String>
    /// Corresponds to the C(--no-recommends) option for C(urpmi).
    no_recommends: Boolean?
    /// Specifies an alternative install root, relative to which all packages will be installed. Corresponds to the C(--root) option for C(urpmi).
    root: String?
    /// Indicates the desired package state.
    state: ("absent"|"present"|"installed"|"removed")?
    /// Update the package database first C(urpmi.update -a).
    update_cache: Boolean?
}

/// Task class for urpmi
class UrpmiTask extends Playbook.Task {
    /// todo doc
    `community.general.urpmi`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.urpmi"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.urpmi`
}

/// TaskBuilder class for urpmi
class Urpmi extends Playbook.TaskBuilder {
    /// Options for community.general.urpmi
    options: UrpmiOptions?
    /// todo doc
    function Task(): UrpmiTask = this
        .toMap()
        .put("community.general.urpmi", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(UrpmiTask)
}

/// Allows listing information about USB devices
/// Allows retrieving information about available USB devices through C(lsusb).
class UsbFactsOptions {
}

/// Task class for usb_facts
class UsbFactsTask extends Playbook.Task {
    /// todo doc
    `community.general.usb_facts`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.usb_facts"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.usb_facts`
}

/// TaskBuilder class for usb_facts
class UsbFacts extends Playbook.TaskBuilder {
    /// Options for community.general.usb_facts
    options: UsbFactsOptions?
    /// todo doc
    function Task(): UsbFactsTask = this
        .toMap()
        .put("community.general.usb_facts", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(UsbFactsTask)
}

/// Create, update or destroy an aaa group object in Sophos UTM
/// Create, update or destroy an aaa group object in Sophos UTM.
/// This module needs to have the REST Ability of the UTM to be activated.
class UtmAaaGroupOptions {
    /// List of adirectory group strings.
    adirectory_groups: Listing<String>?
    /// Dictionary of group sids.
    adirectory_groups_sids: Any?
    /// The backend for the group.
    backend_match: ("none"|"adirectory"|"edirectory"|"radius"|"tacacs"|"ldap")?
    /// Comment that describes the AAA group.
    comment: String?
    /// Group type. Is static if none is selected.
    dynamic: ("none"|"ipsec_dn"|"directory_groups")?
    /// List of edirectory group strings.
    edirectory_groups: Listing<String>?
    /// The ipsec dn string.
    ipsec_dn: String?
    /// The ldap attribute to check against.
    ldap_attribute: String?
    /// The ldap attribute value to check against.
    ldap_attribute_value: String?
    /// A list of user ref names (aaa/user).
    members: Listing<String>?
    /// The name of the object. Will be used to identify the entry.
    name: String
    /// The network reference name. The objects contains the known ip addresses for the authentication object (network/aaa).
    network: String?
    /// A list of radius group strings.
    radius_groups: Listing<String>?
    /// A list of tacacs group strings.
    tacacs_groups: Listing<String>?
}

/// Task class for utm_aaa_group
class UtmAaaGroupTask extends Playbook.Task {
    /// todo doc
    `community.general.utm_aaa_group`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.utm_aaa_group"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.utm_aaa_group`
}

/// TaskBuilder class for utm_aaa_group
class UtmAaaGroup extends Playbook.TaskBuilder {
    /// Options for community.general.utm_aaa_group
    options: UtmAaaGroupOptions?
    /// todo doc
    function Task(): UtmAaaGroupTask = this
        .toMap()
        .put("community.general.utm_aaa_group", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(UtmAaaGroupTask)
}

/// Get info for reverse_proxy frontend entry in Sophos UTM
/// get info for a reverse_proxy frontend entry in SOPHOS UTM.
class UtmAaaGroupInfoOptions {
    /// The name of the object. Will be used to identify the entry
    name: String
}

/// Task class for utm_aaa_group_info
class UtmAaaGroupInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.utm_aaa_group_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.utm_aaa_group_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.utm_aaa_group_info`
}

/// TaskBuilder class for utm_aaa_group_info
class UtmAaaGroupInfo extends Playbook.TaskBuilder {
    /// Options for community.general.utm_aaa_group_info
    options: UtmAaaGroupInfoOptions?
    /// todo doc
    function Task(): UtmAaaGroupInfoTask = this
        .toMap()
        .put("community.general.utm_aaa_group_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(UtmAaaGroupInfoTask)
}

/// Create, update or destroy ca host_key_cert entry in Sophos UTM
/// Create, update or destroy a ca host_key_cert entry in SOPHOS UTM.
/// This module needs to have the REST Ability of the UTM to be activated.
class UtmCaHostKeyCertOptions {
    /// A reference to an existing utm_ca_signing_ca or utm_ca_verification_ca object.
    ca: String
    /// The certificate in PEM format.
    certificate: String
    /// Optional comment string.
    comment: String?
    /// Optionally enable encryption.
    encrypted: Boolean?
    /// Optional private key in PEM format.
    key: String?
    /// A reference to an existing utm_ca_meta_x509 object.
    meta: String
    /// The name of the object. Will be used to identify the entry.
    name: String
}

/// Task class for utm_ca_host_key_cert
class UtmCaHostKeyCertTask extends Playbook.Task {
    /// todo doc
    `community.general.utm_ca_host_key_cert`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.utm_ca_host_key_cert"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.utm_ca_host_key_cert`
}

/// TaskBuilder class for utm_ca_host_key_cert
class UtmCaHostKeyCert extends Playbook.TaskBuilder {
    /// Options for community.general.utm_ca_host_key_cert
    options: UtmCaHostKeyCertOptions?
    /// todo doc
    function Task(): UtmCaHostKeyCertTask = this
        .toMap()
        .put("community.general.utm_ca_host_key_cert", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(UtmCaHostKeyCertTask)
}

/// Get info for a ca host_key_cert entry in Sophos UTM
/// Get info for a ca host_key_cert entry in SOPHOS UTM.
class UtmCaHostKeyCertInfoOptions {
    /// The name of the object. Will be used to identify the entry
    name: String
}

/// Task class for utm_ca_host_key_cert_info
class UtmCaHostKeyCertInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.utm_ca_host_key_cert_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.utm_ca_host_key_cert_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.utm_ca_host_key_cert_info`
}

/// TaskBuilder class for utm_ca_host_key_cert_info
class UtmCaHostKeyCertInfo extends Playbook.TaskBuilder {
    /// Options for community.general.utm_ca_host_key_cert_info
    options: UtmCaHostKeyCertInfoOptions?
    /// todo doc
    function Task(): UtmCaHostKeyCertInfoTask = this
        .toMap()
        .put("community.general.utm_ca_host_key_cert_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(UtmCaHostKeyCertInfoTask)
}

/// Create, update or destroy dns entry in Sophos UTM
/// Create, update or destroy a dns entry in SOPHOS UTM.
/// This module needs to have the REST Ability of the UTM to be activated.
class UtmDnsHostOptions {
    /// The IPV4 Address of the entry. Can be left empty for automatic resolving.
    address: String?
    /// The IPV6 Address of the entry. Can be left empty for automatic resolving.
    address6: String?
    /// An optional comment to add to the dns host object
    comment: String?
    /// The hostname for the dns host object
    hostname: String?
    /// The reference name of the interface to use. If not provided the default interface will be used
    interface: String?
    /// The name of the object. Will be used to identify the entry
    name: String
    /// whether the hostname's ipv4 address is already resolved or not
    resolved: Boolean?
    /// whether the hostname's ipv6 address is already resolved or not
    resolved6: Boolean?
    /// the timeout for the utm to resolve the ip address for the hostname again
    timeout: Int?
}

/// Task class for utm_dns_host
class UtmDnsHostTask extends Playbook.Task {
    /// todo doc
    `community.general.utm_dns_host`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.utm_dns_host"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.utm_dns_host`
}

/// TaskBuilder class for utm_dns_host
class UtmDnsHost extends Playbook.TaskBuilder {
    /// Options for community.general.utm_dns_host
    options: UtmDnsHostOptions?
    /// todo doc
    function Task(): UtmDnsHostTask = this
        .toMap()
        .put("community.general.utm_dns_host", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(UtmDnsHostTask)
}

/// Create, update or destroy network/interface_address object
/// Create, update or destroy a network/interface_address object in SOPHOS UTM.
/// This module needs to have the REST Ability of the UTM to be activated.
class UtmNetworkInterfaceAddressOptions {
    /// The ip4 address of the network/interface_address object.
    address: String
    /// The ip6 address of the network/interface_address object.
    address6: String?
    /// An optional comment to add to the object
    comment: String?
    /// The name of the object. Will be used to identify the entry
    name: String
    /// Whether or not the object is resolved
    resolved: Boolean?
    /// Whether or not the object is resolved
    resolved6: Boolean?
}

/// Task class for utm_network_interface_address
class UtmNetworkInterfaceAddressTask extends Playbook.Task {
    /// todo doc
    `community.general.utm_network_interface_address`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.utm_network_interface_address"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.utm_network_interface_address`
}

/// TaskBuilder class for utm_network_interface_address
class UtmNetworkInterfaceAddress extends Playbook.TaskBuilder {
    /// Options for community.general.utm_network_interface_address
    options: UtmNetworkInterfaceAddressOptions?
    /// todo doc
    function Task(): UtmNetworkInterfaceAddressTask = this
        .toMap()
        .put("community.general.utm_network_interface_address", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(UtmNetworkInterfaceAddressTask)
}

/// Get info for a network/interface_address object
/// Get info for a network/interface_address object in SOPHOS UTM.
class UtmNetworkInterfaceAddressInfoOptions {
    /// The name of the object. Will be used to identify the entry
    name: String
}

/// Task class for utm_network_interface_address_info
class UtmNetworkInterfaceAddressInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.utm_network_interface_address_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.utm_network_interface_address_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.utm_network_interface_address_info`
}

/// TaskBuilder class for utm_network_interface_address_info
class UtmNetworkInterfaceAddressInfo extends Playbook.TaskBuilder {
    /// Options for community.general.utm_network_interface_address_info
    options: UtmNetworkInterfaceAddressInfoOptions?
    /// todo doc
    function Task(): UtmNetworkInterfaceAddressInfoTask = this
        .toMap()
        .put("community.general.utm_network_interface_address_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(UtmNetworkInterfaceAddressInfoTask)
}

/// Create, update or destroy reverse_proxy auth_profile entry in Sophos UTM
/// Create, update or destroy a reverse_proxy auth_profile entry in SOPHOS UTM.
/// This module needs to have the REST Ability of the UTM to be activated.
class UtmProxyAuthProfileOptions {
    /// List of references to utm_aaa objects (allowed users or groups)
    aaa: Listing<String>
    /// Specifies if the backend server needs authentication ([Basic|None])
    backend_mode: ("Basic"|"None")?
    /// Should the login data be stripped when proxying the request to the backend host
    backend_strip_basic_auth: Boolean?
    /// Prefix string to prepend to the username for backend authentication
    backend_user_prefix: String?
    /// Suffix string to append to the username for backend authentication
    backend_user_suffix: String?
    /// The message in the basic authentication prompt
    basic_prompt: String
    /// Optional comment string
    comment: String?
    /// Frontend cookie name
    frontend_cookie: String?
    /// Frontend cookie secret
    frontend_cookie_secret: String?
    /// Frontend authentication form name
    frontend_form: String?
    /// Frontend authentication form template
    frontend_form_template: String?
    /// Frontend login name
    frontend_login: String?
    /// Frontend logout name
    frontend_logout: String?
    /// Frontend authentication mode (Form|Basic)
    frontend_mode: ("Basic"|"Form")?
    /// Frontend authentication realm
    frontend_realm: String?
    /// Allow session persistency
    frontend_session_allow_persistency: Boolean?
    /// session lifetime
    frontend_session_lifetime: Int
    /// Specifies if limitation of session lifetime is active
    frontend_session_lifetime_limited: Boolean?
    /// scope for frontend_session_lifetime (days|hours|minutes)
    frontend_session_lifetime_scope: ("days"|"hours"|"minutes")?
    /// session timeout
    frontend_session_timeout: Int
    /// Specifies if session timeout is active
    frontend_session_timeout_enabled: Boolean?
    /// scope for frontend_session_timeout (days|hours|minutes)
    frontend_session_timeout_scope: ("days"|"hours"|"minutes")?
    /// List of logout URLs that logouts are delegated to
    logout_delegation_urls: Listing<String>?
    /// Mode of logout (None|Delegation)
    logout_mode: ("None"|"Delegation")?
    /// The name of the object. Will be used to identify the entry
    name: String
    /// Should a redirect to the requested URL be made
    redirect_to_requested_url: Boolean?
}

/// Task class for utm_proxy_auth_profile
class UtmProxyAuthProfileTask extends Playbook.Task {
    /// todo doc
    `community.general.utm_proxy_auth_profile`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.utm_proxy_auth_profile"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.utm_proxy_auth_profile`
}

/// TaskBuilder class for utm_proxy_auth_profile
class UtmProxyAuthProfile extends Playbook.TaskBuilder {
    /// Options for community.general.utm_proxy_auth_profile
    options: UtmProxyAuthProfileOptions?
    /// todo doc
    function Task(): UtmProxyAuthProfileTask = this
        .toMap()
        .put("community.general.utm_proxy_auth_profile", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(UtmProxyAuthProfileTask)
}

/// Create, update or destroy reverse_proxy exception entry in Sophos UTM
/// Create, update or destroy a reverse_proxy exception entry in SOPHOS UTM.
/// This module needs to have the REST Ability of the UTM to be activated.
class UtmProxyExceptionOptions {
    /// The name of the object. Will be used to identify the entry
    name: String
    /// The operand to be used with the entries of the path parameter
    op: ("AND"|"OR")?
    /// The paths the exception in the reverse proxy is defined for
    path: Listing<String>?
    /// A list of threats to be skipped
    skip_custom_threats_filters: Listing<String>?
    /// Define which categories of threats are skipped
    skip_threats_filter_categories: Listing<String>?
    /// Skip the Antivirus Scanning
    skipav: Boolean?
    /// Block clients with bad reputation
    skipbadclients: Boolean?
    /// Skip the Cookie Signing check
    skipcookie: Boolean?
    /// Enable form hardening
    skipform: Boolean?
    /// Enable form hardening with missing tokens
    skipform_missingtoken: Boolean?
    /// Protection against SQL
    skiphtmlrewrite: Boolean?
    /// Enable true file type control
    skiptft: Boolean?
    /// Enable static URL hardening
    skipurl: Boolean?
    /// Define which categories of threats are skipped
    source: Listing<String>?
    /// Status of the exception rule set
    status: Boolean?
}

/// Task class for utm_proxy_exception
class UtmProxyExceptionTask extends Playbook.Task {
    /// todo doc
    `community.general.utm_proxy_exception`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.utm_proxy_exception"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.utm_proxy_exception`
}

/// TaskBuilder class for utm_proxy_exception
class UtmProxyException extends Playbook.TaskBuilder {
    /// Options for community.general.utm_proxy_exception
    options: UtmProxyExceptionOptions?
    /// todo doc
    function Task(): UtmProxyExceptionTask = this
        .toMap()
        .put("community.general.utm_proxy_exception", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(UtmProxyExceptionTask)
}

/// Create, update or destroy reverse_proxy frontend entry in Sophos UTM
/// Create, update or destroy a reverse_proxy frontend entry in Sophos UTM.
/// This module needs to have the REST Ability of the UTM to be activated.
class UtmProxyFrontendOptions {
    /// Whether to add the content type header or not
    add_content_type_header: Boolean?
    /// The reference name of the network/interface_address object.
    address: String?
    /// A list of reference names for the allowed networks.
    allowed_networks: Listing<String>?
    /// The reference name of the ca/host_key_cert object.
    certificate: String?
    /// An optional comment to add to the object
    comment: String?
    /// Whether to enable the compression
    disable_compression: Boolean?
    /// A list of domain names for the frontend object
    domain: Listing<String>?
    /// A list of exception ref names (reverse_proxy/exception)
    exceptions: Listing<String>?
    /// Whether to enable html rewrite or not
    htmlrewrite: Boolean?
    /// Whether to enable html rewrite cookie or not
    htmlrewrite_cookies: Boolean?
    /// Whether to enable implicit redirection or not
    implicitredirect: Boolean?
    /// Which loadbalancer method should be used
    lbmethod: (""|"bybusyness"|"bytraffic"|"byrequests")?
    /// A list of location ref names (reverse_proxy/location)
    locations: Listing<String>?
    /// The name of the object. Will be used to identify the entry
    name: String
    /// The frontend http port
    port: Int?
    /// Whether to preserve host header
    preservehost: Boolean?
    /// The reference string of the reverse_proxy/profile
    profile: String?
    /// Whether to activate the frontend entry or not
    status: Boolean?
    /// Which protocol should be used
    type: ("http"|"https")?
    /// Whether to pass the host header or not
    xheaders: Boolean?
}

/// Task class for utm_proxy_frontend
class UtmProxyFrontendTask extends Playbook.Task {
    /// todo doc
    `community.general.utm_proxy_frontend`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.utm_proxy_frontend"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.utm_proxy_frontend`
}

/// TaskBuilder class for utm_proxy_frontend
class UtmProxyFrontend extends Playbook.TaskBuilder {
    /// Options for community.general.utm_proxy_frontend
    options: UtmProxyFrontendOptions?
    /// todo doc
    function Task(): UtmProxyFrontendTask = this
        .toMap()
        .put("community.general.utm_proxy_frontend", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(UtmProxyFrontendTask)
}

/// Create, update or destroy reverse_proxy frontend entry in Sophos UTM
/// Create, update or destroy a reverse_proxy frontend entry in SOPHOS UTM.
/// This module needs to have the REST Ability of the UTM to be activated.
class UtmProxyFrontendInfoOptions {
    /// The name of the object. Will be used to identify the entry
    name: String
}

/// Task class for utm_proxy_frontend_info
class UtmProxyFrontendInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.utm_proxy_frontend_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.utm_proxy_frontend_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.utm_proxy_frontend_info`
}

/// TaskBuilder class for utm_proxy_frontend_info
class UtmProxyFrontendInfo extends Playbook.TaskBuilder {
    /// Options for community.general.utm_proxy_frontend_info
    options: UtmProxyFrontendInfoOptions?
    /// todo doc
    function Task(): UtmProxyFrontendInfoTask = this
        .toMap()
        .put("community.general.utm_proxy_frontend_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(UtmProxyFrontendInfoTask)
}

/// Create, update or destroy reverse_proxy location entry in Sophos UTM
/// Create, update or destroy a reverse_proxy location entry in SOPHOS UTM.
/// This module needs to have the REST Ability of the UTM to be activated.
class UtmProxyLocationOptions {
    /// whether to activate the access control for the location
    access_control: ("0"|"1")?
    /// A list of allowed networks
    allowed_networks: Listing<String>?
    /// The reference name of the auth profile
    auth_profile: String?
    /// A list of backends that are connected with this location declaration
    backend: Listing<String>?
    /// The path of the backend
    be_path: String?
    /// The optional comment string
    comment: String?
    /// A list of denied network references
    denied_networks: Listing<String>?
    /// Activate hot standby mode
    hot_standby: Boolean?
    /// The name of the object. Will be used to identify the entry
    name: String
    /// The path of the location
    path: String?
    /// Whether the location is active or not
    status: Boolean?
    /// The stickysession id
    stickysession_id: String?
    /// Enable the stickysession
    stickysession_status: Boolean?
    /// Enable the websocket passthrough
    websocket_passthrough: Boolean?
}

/// Task class for utm_proxy_location
class UtmProxyLocationTask extends Playbook.Task {
    /// todo doc
    `community.general.utm_proxy_location`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.utm_proxy_location"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.utm_proxy_location`
}

/// TaskBuilder class for utm_proxy_location
class UtmProxyLocation extends Playbook.TaskBuilder {
    /// Options for community.general.utm_proxy_location
    options: UtmProxyLocationOptions?
    /// todo doc
    function Task(): UtmProxyLocationTask = this
        .toMap()
        .put("community.general.utm_proxy_location", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(UtmProxyLocationTask)
}

/// Create, update or destroy reverse_proxy location entry in Sophos UTM
/// Create, update or destroy a reverse_proxy location entry in SOPHOS UTM.
/// This module needs to have the REST Ability of the UTM to be activated.
class UtmProxyLocationInfoOptions {
    /// The name of the object. Will be used to identify the entry
    name: String
}

/// Task class for utm_proxy_location_info
class UtmProxyLocationInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.utm_proxy_location_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.utm_proxy_location_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.utm_proxy_location_info`
}

/// TaskBuilder class for utm_proxy_location_info
class UtmProxyLocationInfo extends Playbook.TaskBuilder {
    /// Options for community.general.utm_proxy_location_info
    options: UtmProxyLocationInfoOptions?
    /// todo doc
    function Task(): UtmProxyLocationInfoTask = this
        .toMap()
        .put("community.general.utm_proxy_location_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(UtmProxyLocationInfoTask)
}

/// Module to control VDO
/// This module controls the VDO dedupe and compression device.
/// VDO, or Virtual Data Optimizer, is a device-mapper target that provides inline block-level deduplication, compression, and thin provisioning capabilities to primary storage.
class VdoOptions {
    /// Specifies the number of threads to use for acknowledging completion of requested VDO I/O operations. Valid values are integer values from 1 to 100 (lower numbers are preferable due to overhead).  The default is 1.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
    ackthreads: String?
    /// The "activate" status for a VDO volume.  If this is set to V(false), the VDO volume cannot be started, and it will not start on system startup.  However, on initial creation, a VDO volume with "activated" set to "off" will be running, until stopped.  This is the default behavior of the "vdo create" command; it provides the user an opportunity to write a base amount of metadata (filesystem, LVM headers, etc.) to the VDO volume prior to stopping the volume, and leaving it deactivated until ready to use.
    activated: Boolean?
    /// Specifies the number of threads to use for submitting I/O operations to the storage device.  Valid values are integer values from 1 to 100 (lower numbers are preferable due to overhead).  The default is 4. Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
    biothreads: String?
    /// The amount of memory allocated for caching block map pages, in megabytes (or may be issued with an LVM-style suffix of K, M, G, or T).  The default (and minimum) value is 128M.  The value specifies the size of the cache; there is a 15% memory usage overhead. Each 1.25G of block map covers 1T of logical blocks, therefore a small amount of block map cache memory can cache a significantly large amount of block map data.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
    blockmapcachesize: String?
    /// Configures whether compression is enabled.  The default for a created volume is 'enabled'.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
    compression: ("disabled"|"enabled")?
    /// Specifies the number of threads to use for CPU-intensive work such as hashing or compression.  Valid values are integer values from 1 to 100 (lower numbers are preferable due to overhead).  The default is 2. Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
    cputhreads: String?
    /// Configures whether deduplication is enabled.  The default for a created volume is 'enabled'.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
    deduplication: ("disabled"|"enabled")?
    /// The full path of the device to use for VDO storage.
    /// This is required if "state" is "present".
    device: String?
    /// Enables 512-byte emulation mode, allowing drivers or filesystems to access the VDO volume at 512-byte granularity, instead of the default 4096-byte granularity. Default is 'disabled'; only recommended when a driver or filesystem requires 512-byte sector level access to a device.  This option is only available when creating a new volume, and cannot be changed for an existing volume.
    emulate512: Boolean?
    /// When creating a volume, ignores any existing file system or VDO signature already present in the storage device. When stopping or removing a VDO volume, first unmounts the file system stored on the device if mounted.
    /// B(Warning:) Since this parameter removes all safety checks it is important to make sure that all parameters provided are accurate and intentional.
    force: Boolean?
    /// Specifies whether to attempt to execute a growphysical operation, if there is enough unused space on the device.  A growphysical operation will be executed if there is at least 64 GB of free space, relative to the previous physical size of the affected VDO volume.
    growphysical: Boolean?
    /// Specifies the amount of index memory in gigabytes.  The default is 0.25.  The special decimal values 0.25, 0.5, and 0.75 can be used, as can any positive integer. This option is only available when creating a new volume, and cannot be changed for an existing volume.
    indexmem: String?
    /// Specifies the index mode of the Albireo index.  The default is 'dense', which has a deduplication window of 1 GB of index memory per 1 TB of incoming data, requiring 10 GB of index data on persistent storage. The 'sparse' mode has a deduplication window of 1 GB of index memory per 10 TB of incoming data, but requires 100 GB of index data on persistent storage.  This option is only available when creating a new volume, and cannot be changed for an existing volume.
    indexmode: ("dense"|"sparse")?
    /// The logical size of the VDO volume (in megabytes, or LVM suffix format).  If not specified for a new volume, this defaults to the same size as the underlying storage device, which is specified in the 'device' parameter. Existing volumes will maintain their size if the logicalsize parameter is not specified, or is smaller than or identical to the current size.  If the specified size is larger than the current size, a growlogical operation will be performed.
    logicalsize: String?
    /// Specifies the number of threads across which to subdivide parts of the VDO processing based on logical block addresses.  Valid values are integer values from 1 to 100 (lower numbers are preferable due to overhead). The default is 1.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
    logicalthreads: String?
    /// The name of the VDO volume.
    name: String
    /// Specifies the number of threads across which to subdivide parts of the VDO processing based on physical block addresses.  Valid values are integer values from 1 to 16 (lower numbers are preferable due to overhead). The physical space used by the VDO volume must be larger than (slabsize * physicalthreads).  The default is 1.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
    physicalthreads: String?
    /// Enables or disables the read cache.  The default is 'disabled'.  Choosing 'enabled' enables a read cache which may improve performance for workloads of high deduplication, read workloads with a high level of compression, or on hard disk storage.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
    /// The read cache feature is available in VDO 6.1 and older.
    readcache: ("disabled"|"enabled")?
    /// Specifies the extra VDO device read cache size in megabytes.  This is in addition to a system-defined minimum.  Using a value with a suffix of K, M, G, or T is optional.  The default value is 0.  1.125 MB of memory per bio thread will be used per 1 MB of read cache specified (for example, a VDO volume configured with 4 bio threads will have a read cache memory usage overhead of 4.5 MB per 1 MB of read cache specified). Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
    /// The read cache feature is available in VDO 6.1 and older.
    readcachesize: String?
    /// Whether this VDO volume is running.
    /// A VDO volume must be activated in order to be started.
    running: Boolean?
    /// The size of the increment by which the physical size of a VDO volume is grown, in megabytes (or may be issued with an LVM-style suffix of K, M, G, or T).  Must be a power of two between 128M and 32G.  The default is 2G, which supports volumes having a physical size up to 16T. The maximum, 32G, supports a physical size of up to 256T. This option is only available when creating a new volume, and cannot be changed for an existing volume.
    slabsize: String?
    /// Whether this VDO volume should be "present" or "absent". If a "present" VDO volume does not exist, it will be created.  If a "present" VDO volume already exists, it will be modified, by updating the configuration, which will take effect when the VDO volume is restarted. Not all parameters of an existing VDO volume can be modified; the "statusparamkeys" list contains the parameters that can be modified after creation. If an "absent" VDO volume does not exist, it will not be removed.
    state: ("absent"|"present")?
    /// Specifies the write policy of the VDO volume.  The 'sync' mode acknowledges writes only after data is on stable storage.  The 'async' mode acknowledges writes when data has been cached for writing to stable storage.  The default (and highly recommended) 'auto' mode checks the storage device to determine whether it supports flushes.  Devices that support flushes will result in a VDO volume in 'async' mode, while devices that do not support flushes will run in sync mode. Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
    writepolicy: ("async"|"auto"|"sync")?
}

/// Task class for vdo
class VdoTask extends Playbook.Task {
    /// todo doc
    `community.general.vdo`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.vdo"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.vdo`
}

/// TaskBuilder class for vdo
class Vdo extends Playbook.TaskBuilder {
    /// Options for community.general.vdo
    options: VdoOptions?
    /// todo doc
    function Task(): VdoTask = this
        .toMap()
        .put("community.general.vdo", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(VdoTask)
}

/// Updates Vertica configuration parameters
/// Updates Vertica configuration parameters.
class VerticaConfigurationOptions {
    /// Name of the Vertica cluster.
    cluster: String?
    /// Name of the Vertica database.
    db: String?
    /// The password used to authenticate with.
    login_password: String?
    /// The username used to authenticate with.
    login_user: String?
    /// Name of the parameter to update.
    parameter: String
    /// Vertica cluster port to connect to.
    port: String?
    /// Value of the parameter to be set.
    value: String?
}

/// Task class for vertica_configuration
class VerticaConfigurationTask extends Playbook.Task {
    /// todo doc
    `community.general.vertica_configuration`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.vertica_configuration"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.vertica_configuration`
}

/// TaskBuilder class for vertica_configuration
class VerticaConfiguration extends Playbook.TaskBuilder {
    /// Options for community.general.vertica_configuration
    options: VerticaConfigurationOptions?
    /// todo doc
    function Task(): VerticaConfigurationTask = this
        .toMap()
        .put("community.general.vertica_configuration", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(VerticaConfigurationTask)
}

/// Gathers Vertica database facts
/// Gathers Vertica database information.
class VerticaInfoOptions {
    /// Name of the cluster running the schema.
    cluster: String?
    /// Name of the database running the schema.
    db: String?
    /// The password used to authenticate with.
    login_password: String?
    /// The username used to authenticate with.
    login_user: String?
    /// Database port to connect to.
    port: String?
}

/// Task class for vertica_info
class VerticaInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.vertica_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.vertica_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.vertica_info`
}

/// TaskBuilder class for vertica_info
class VerticaInfo extends Playbook.TaskBuilder {
    /// Options for community.general.vertica_info
    options: VerticaInfoOptions?
    /// todo doc
    function Task(): VerticaInfoTask = this
        .toMap()
        .put("community.general.vertica_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(VerticaInfoTask)
}

/// Adds or removes Vertica database roles and assigns roles to them
/// Adds or removes Vertica database role and, optionally, assign other roles.
class VerticaRoleOptions {
    /// Comma separated list of roles to assign to the role.
    assigned_roles: String?
    /// Name of the Vertica cluster.
    cluster: String?
    /// Name of the Vertica database.
    db: String?
    /// The password used to authenticate with.
    login_password: String?
    /// The username used to authenticate with.
    login_user: String?
    /// Vertica cluster port to connect to.
    port: String?
    /// Name of the role to add or remove.
    role: String
    /// Whether to create V(present), drop V(absent) or lock V(locked) a role.
    state: ("present"|"absent")?
}

/// Task class for vertica_role
class VerticaRoleTask extends Playbook.Task {
    /// todo doc
    `community.general.vertica_role`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.vertica_role"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.vertica_role`
}

/// TaskBuilder class for vertica_role
class VerticaRole extends Playbook.TaskBuilder {
    /// Options for community.general.vertica_role
    options: VerticaRoleOptions?
    /// todo doc
    function Task(): VerticaRoleTask = this
        .toMap()
        .put("community.general.vertica_role", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(VerticaRoleTask)
}

/// Adds or removes Vertica database schema and roles
/// Adds or removes Vertica database schema and, optionally, roles with schema access privileges.
/// A schema will not be removed until all the objects have been dropped.
/// In such a situation, if the module tries to remove the schema it will fail and only remove roles created for the schema if they have no dependencies.
class VerticaSchemaOptions {
    /// Name of the Vertica cluster.
    cluster: String?
    /// Comma separated list of roles to create and grant usage and create access to the schema.
    create_roles: String?
    /// Name of the Vertica database.
    db: String?
    /// The password used to authenticate with.
    login_password: String?
    /// The username used to authenticate with.
    login_user: String?
    /// Name of the user to set as owner of the schema.
    owner: String?
    /// Vertica cluster port to connect to.
    port: String?
    /// Name of the schema to add or remove.
    schema: String
    /// Whether to create V(present), or drop V(absent) a schema.
    state: ("present"|"absent")?
    /// Comma separated list of roles to create and grant usage access to the schema.
    usage_roles: String?
}

/// Task class for vertica_schema
class VerticaSchemaTask extends Playbook.Task {
    /// todo doc
    `community.general.vertica_schema`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.vertica_schema"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.vertica_schema`
}

/// TaskBuilder class for vertica_schema
class VerticaSchema extends Playbook.TaskBuilder {
    /// Options for community.general.vertica_schema
    options: VerticaSchemaOptions?
    /// todo doc
    function Task(): VerticaSchemaTask = this
        .toMap()
        .put("community.general.vertica_schema", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(VerticaSchemaTask)
}

/// Adds or removes Vertica database users and assigns roles
/// Adds or removes Vertica database user and, optionally, assigns roles.
/// A user will not be removed until all the dependencies have been dropped.
/// In such a situation, if the module tries to remove the user it will fail and only remove roles granted to the user.
class VerticaUserOptions {
    /// Name of the Vertica cluster.
    cluster: String?
    /// Name of the Vertica database.
    db: String?
    /// Sets the user's password expiration.
    expired: Boolean?
    /// Set to true if users are authenticated via LDAP.
    /// The user will be created with password expired and set to V($ldap$).
    ldap: Boolean?
    /// The password used to authenticate with.
    login_password: String?
    /// The username used to authenticate with.
    login_user: String?
    /// The user's password encrypted by the MD5 algorithm.
    /// The password must be generated with the format C("md5" + md5[password + username]), resulting in a total of 35 characters. An easy way to do this is by querying the Vertica database with select V('md5'||md5('<user_password><user_name>'\)).
    password: String?
    /// Vertica cluster port to connect to.
    port: String?
    /// Sets the user's profile.
    profile: String?
    /// Sets the user's resource pool.
    resource_pool: String?
    /// Comma separated list of roles to assign to the user.
    roles: String?
    /// Whether to create (V(present)), drop (V(absent)), or lock (V(locked)) a user.
    state: ("present"|"absent"|"locked")?
    /// Name of the user to add or remove.
    user: String
}

/// Task class for vertica_user
class VerticaUserTask extends Playbook.Task {
    /// todo doc
    `community.general.vertica_user`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.vertica_user"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.vertica_user`
}

/// TaskBuilder class for vertica_user
class VerticaUser extends Playbook.TaskBuilder {
    /// Options for community.general.vertica_user
    options: VerticaUserOptions?
    /// todo doc
    function Task(): VerticaUserTask = this
        .toMap()
        .put("community.general.vertica_user", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(VerticaUserTask)
}

/// Manage export groups on Vexata VX100 storage arrays
/// Create or delete export groups on a Vexata VX100 array.
/// An export group is a tuple of a volume group, initiator group and port group that allows a set of volumes to be exposed to one or more hosts through specific array ports.
class VexataEgOptions {
    /// Initiator group name.
    ig: String?
    /// Export group name.
    name: String
    /// Port group name.
    pg: String?
    /// Creates export group when present or delete when absent.
    state: ("present"|"absent")?
    /// Volume group name.
    vg: String?
}

/// Task class for vexata_eg
class VexataEgTask extends Playbook.Task {
    /// todo doc
    `community.general.vexata_eg`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.vexata_eg"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.vexata_eg`
}

/// TaskBuilder class for vexata_eg
class VexataEg extends Playbook.TaskBuilder {
    /// Options for community.general.vexata_eg
    options: VexataEgOptions?
    /// todo doc
    function Task(): VexataEgTask = this
        .toMap()
        .put("community.general.vexata_eg", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(VexataEgTask)
}

/// Manage volumes on Vexata VX100 storage arrays
/// Create, deletes or extend volumes on a Vexata VX100 array.
class VexataVolumeOptions {
    /// Volume name.
    name: String
    /// Volume size in M, G, T units. M=2^20, G=2^30, T=2^40 bytes.
    size: String?
    /// Creates/Modifies volume when present or removes when absent.
    state: ("present"|"absent")?
}

/// Task class for vexata_volume
class VexataVolumeTask extends Playbook.Task {
    /// todo doc
    `community.general.vexata_volume`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.vexata_volume"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.vexata_volume`
}

/// TaskBuilder class for vexata_volume
class VexataVolume extends Playbook.TaskBuilder {
    /// Options for community.general.vexata_volume
    options: VexataVolumeOptions?
    /// todo doc
    function Task(): VexataVolumeTask = this
        .toMap()
        .put("community.general.vexata_volume", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(VexataVolumeTask)
}

/// Manage SmartOS virtual machines and zones
/// Manage SmartOS virtual machines through vmadm(1M).
class VmadmOptions {
    /// When enabled, the zone dataset will be mounted on C(/zones/archive) upon removal.
    archive_on_delete: Boolean?
    /// Whether or not a VM is booted when the system is rebooted.
    autoboot: Boolean?
    /// Set the boot order for KVM VMs.
    boot: String?
    /// Type of virtual machine. The V(bhyve) option was added in community.general 0.2.0.
    brand: ("joyent"|"joyent-minimal"|"lx"|"kvm"|"bhyve")?
    /// Sets a limit on the amount of CPU time that can be used by a VM. Use V(0) for no cap.
    cpu_cap: Int?
    /// Sets a limit on the number of fair share scheduler (FSS) CPU shares for a VM. This limit is relative to all other VMs on the system.
    cpu_shares: Int?
    /// Control the type of virtual CPU exposed to KVM VMs.
    cpu_type: ("qemu64"|"host")?
    /// Metadata to be set and associated with this VM, this contain customer modifiable keys.
    customer_metadata: Any?
    /// Whether to delegate a ZFS dataset to an OS VM.
    delegate_dataset: Boolean?
    /// Default value for a virtual disk model for KVM guests.
    disk_driver: String?
    /// A list of disks to add, valid properties are documented in vmadm(1M).
    disks: Listing<Any>?
    /// Domain value for C(/etc/hosts).
    dns_domain: String?
    /// Docker images need this flag enabled along with the O(brand) set to C(lx).
    docker: Boolean?
    /// Mount additional filesystems into an OS VM.
    filesystems: Listing<Any>?
    /// Enables the firewall, allowing fwadm(1M) rules to be applied.
    firewall_enabled: Boolean?
    /// Force a particular action (i.e. stop or delete a VM).
    force: Boolean?
    /// Comma separated list of filesystem types this zone is allowed to mount.
    fs_allowed: String?
    /// Zone/VM hostname.
    hostname: String?
    /// Image UUID.
    image_uuid: String?
    /// Adds an C(@indestructible) snapshot to delegated datasets.
    indestructible_delegated: Boolean?
    /// Adds an C(@indestructible) snapshot to zoneroot.
    indestructible_zoneroot: Boolean?
    /// Metadata to be set and associated with this VM, this contains operator generated keys.
    internal_metadata: Any?
    /// List of namespaces to be set as C(internal_metadata-only); these namespaces will come from O(internal_metadata) rather than O(customer_metadata).
    internal_metadata_namespace: String?
    /// Kernel version to emulate for LX VMs.
    kernel_version: String?
    /// Set (comma separated) list of privileges the zone is allowed to use.
    limit_priv: String?
    /// Resolvers in C(/etc/resolv.conf) will be updated when updating the O(resolvers) property.
    maintain_resolvers: Boolean?
    /// Total amount of memory (in MiBs) on the host that can be locked by this VM.
    max_locked_memory: Int?
    /// Maximum number of lightweight processes this VM is allowed to have running.
    max_lwps: Int?
    /// Maximum amount of memory (in MiBs) on the host that the VM is allowed to use.
    max_physical_memory: Int?
    /// Maximum amount of virtual memory (in MiBs) the VM is allowed to use.
    max_swap: Int?
    /// Timeout in seconds (or 0 to disable) for the C(svc:/smartdc/mdata:execute) service that runs user-scripts in the zone.
    mdata_exec_timeout: Int?
    /// Name of the VM. vmadm(1M) uses this as an optional name.
    name: String?
    /// Default value for a virtual NIC model for KVM guests.
    nic_driver: String?
    /// A list of nics to add, valid properties are documented in vmadm(1M).
    nics: Listing<Any>?
    /// Consider the provisioning complete when the VM first starts, rather than when the VM has rebooted.
    nowait: Boolean?
    /// Additional qemu cmdline arguments for KVM guests.
    qemu_extra_opts: String?
    /// Additional qemu arguments for KVM guests. This overwrites the default arguments provided by vmadm(1M) and should only be used for debugging.
    qemu_opts: String?
    /// Quota on zone filesystems (in MiBs).
    quota: Int?
    /// Amount of virtual RAM for a KVM guest (in MiBs).
    ram: Int?
    /// List of resolvers to be put into C(/etc/resolv.conf).
    resolvers: Listing<String>?
    /// Dictionary that maps destinations to gateways, these will be set as static routes in the VM.
    routes: Any?
    /// Addition options for SPICE-enabled KVM VMs.
    spice_opts: String?
    /// Password required to connect to SPICE. By default no password is set. Please note this can be read from the Global Zone.
    spice_password: String?
    /// States for the VM to be in. Please note that V(present), V(stopped) and V(restarted) operate on a VM that is currently provisioned. V(present) means that the VM will be created if it was absent, and that it will be in a running state. V(absent) will shutdown the zone before removing it. V(stopped) means the zone will be created if it does not exist already, before shutting it down.
    state: ("present"|"running"|"absent"|"deleted"|"stopped"|"created"|"restarted"|"rebooted")?
    /// Amount of memory (in MiBs) that will be available in the VM for the C(/tmp) filesystem.
    tmpfs: Int?
    /// UUID of the VM. Can either be a full UUID or V(*) for all VMs.
    uuid: String?
    /// Number of virtual CPUs for a KVM guest.
    vcpus: Int?
    /// Specify VGA emulation used by KVM VMs.
    vga: String?
    /// Number of packets that can be sent in a single flush of the tx queue of virtio NICs.
    virtio_txburst: Int?
    /// Timeout (in nanoseconds) for the TX timer of virtio NICs.
    virtio_txtimer: Int?
    /// Password required to connect to VNC. By default no password is set. Please note this can be read from the Global Zone.
    vnc_password: String?
    /// TCP port to listen of the VNC server. Or set V(0) for random, or V(-1) to disable.
    vnc_port: Int?
    /// Specifies compression algorithm used for this VMs data dataset. This option only has effect on delegated datasets.
    zfs_data_compression: String?
    /// Suggested block size (power of 2) for files in the delegated dataset's filesystem.
    zfs_data_recsize: Int?
    /// Maximum number of filesystems the VM can have.
    zfs_filesystem_limit: Int?
    /// IO throttle priority value relative to other VMs.
    zfs_io_priority: Int?
    /// Specifies compression algorithm used for this VMs root dataset. This option only has effect on the zoneroot dataset.
    zfs_root_compression: String?
    /// Suggested block size (power of 2) for files in the zoneroot dataset's filesystem.
    zfs_root_recsize: Int?
    /// Number of snapshots the VM can have.
    zfs_snapshot_limit: Int?
    /// ZFS pool the VM's zone dataset will be created in.
    zpool: String?
}

/// Task class for vmadm
class VmadmTask extends Playbook.Task {
    /// todo doc
    `community.general.vmadm`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.vmadm"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.vmadm`
}

/// TaskBuilder class for vmadm
class Vmadm extends Playbook.TaskBuilder {
    /// Options for community.general.vmadm
    options: VmadmOptions?
    /// todo doc
    function Task(): VmadmTask = this
        .toMap()
        .put("community.general.vmadm", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(VmadmTask)
}

/// Send a magic Wake-on-LAN (WoL) broadcast packet
/// The C(wakeonlan) module sends magic Wake-on-LAN (WoL) broadcast packets.
class WakeonlanOptions {
    /// Network broadcast address to use for broadcasting magic Wake-on-LAN packet.
    broadcast: String?
    /// MAC address to send Wake-on-LAN broadcast packet for.
    mac: String
    /// UDP port to use for magic Wake-on-LAN packet.
    port: Int?
}

/// Task class for wakeonlan
class WakeonlanTask extends Playbook.Task {
    /// todo doc
    `community.general.wakeonlan`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.wakeonlan"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.wakeonlan`
}

/// TaskBuilder class for wakeonlan
class Wakeonlan extends Playbook.TaskBuilder {
    /// Options for community.general.wakeonlan
    options: WakeonlanOptions?
    /// todo doc
    function Task(): WakeonlanTask = this
        .toMap()
        .put("community.general.wakeonlan", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(WakeonlanTask)
}

/// Manages WDC UltraStar Data102 Out-Of-Band controllers using Redfish APIs
/// Builds Redfish URIs locally and sends them to remote OOB controllers to perform an action.
/// Manages OOB controller firmware. For example, Firmware Activate, Update and Activate.
class WdcRedfishCommandOptions {
    /// Security token for authentication with OOB controller.
    auth_token: String?
    /// Base URI of OOB controller.  Must include this or O(ioms).
    baseuri: String?
    /// Category to execute on OOB controller.
    category: String
    /// List of commands to execute on OOB controller.
    command: Listing<String>
    /// List of IOM FQDNs for the enclosure.  Must include this or O(baseuri).
    ioms: Listing<String>?
    /// Password for authentication with OOB controller.
    password: String?
    /// ID of the component to modify, such as V(Enclosure), V(IOModuleAFRU), V(PowerSupplyBFRU), V(FanExternalFRU3), or V(FanInternalFRU).
    resource_id: String?
    /// Timeout in seconds for URL requests to OOB controller.
    timeout: Int?
    /// The credentials for retrieving the update image.
    update_creds: Any?
    /// The URI of the image for the update.
    update_image_uri: String?
    /// User for authentication with OOB controller.
    username: String?
}

/// Task class for wdc_redfish_command
class WdcRedfishCommandTask extends Playbook.Task {
    /// todo doc
    `community.general.wdc_redfish_command`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.wdc_redfish_command"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.wdc_redfish_command`
}

/// TaskBuilder class for wdc_redfish_command
class WdcRedfishCommand extends Playbook.TaskBuilder {
    /// Options for community.general.wdc_redfish_command
    options: WdcRedfishCommandOptions?
    /// todo doc
    function Task(): WdcRedfishCommandTask = this
        .toMap()
        .put("community.general.wdc_redfish_command", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(WdcRedfishCommandTask)
}

/// Manages WDC UltraStar Data102 Out-Of-Band controllers using Redfish APIs
/// Builds Redfish URIs locally and sends them to remote OOB controllers to get information back.
class WdcRedfishInfoOptions {
    /// Security token for authentication with OOB controller.
    auth_token: String?
    /// Base URI of OOB controller.  Must include this or O(ioms).
    baseuri: String?
    /// Category to execute on OOB controller.
    category: String
    /// List of commands to execute on OOB controller.
    command: Listing<String>
    /// List of IOM FQDNs for the enclosure.  Must include this or O(baseuri).
    ioms: Listing<String>?
    /// Password for authentication with OOB controller.
    password: String?
    /// Timeout in seconds for URL requests to OOB controller.
    timeout: Int?
    /// User for authentication with OOB controller.
    username: String?
}

/// Task class for wdc_redfish_info
class WdcRedfishInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.wdc_redfish_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.wdc_redfish_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.wdc_redfish_info`
}

/// TaskBuilder class for wdc_redfish_info
class WdcRedfishInfo extends Playbook.TaskBuilder {
    /// Options for community.general.wdc_redfish_info
    options: WdcRedfishInfoOptions?
    /// todo doc
    function Task(): WdcRedfishInfoTask = this
        .toMap()
        .put("community.general.wdc_redfish_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(WdcRedfishInfoTask)
}

/// Add or remove applications on a Webfaction host
/// Add or remove applications on a Webfaction host. Further documentation at U(https://github.com/quentinsf/ansible-webfaction).
class WebfactionAppOptions {
    /// Whether the app should restart with an C(autostart.cgi) script
    autostart: Boolean?
    /// Any extra parameters required by the app
    extra_info: String?
    /// The webfaction account to use
    login_name: String
    /// The webfaction password to use
    login_password: String
    /// The machine name to use (optional for accounts with only one machine)
    machine: String?
    /// The name of the application
    name: String
    /// IF the port should be opened
    port_open: Boolean?
    /// Whether the application should exist
    state: ("present"|"absent")?
    /// The type of application to create. See the Webfaction docs at U(https://docs.webfaction.com/xmlrpc-api/apps.html) for a list.
    type: String
}

/// Task class for webfaction_app
class WebfactionAppTask extends Playbook.Task {
    /// todo doc
    `community.general.webfaction_app`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.webfaction_app"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.webfaction_app`
}

/// TaskBuilder class for webfaction_app
class WebfactionApp extends Playbook.TaskBuilder {
    /// Options for community.general.webfaction_app
    options: WebfactionAppOptions?
    /// todo doc
    function Task(): WebfactionAppTask = this
        .toMap()
        .put("community.general.webfaction_app", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(WebfactionAppTask)
}

/// Add or remove a database on Webfaction
/// Add or remove a database on a Webfaction host. Further documentation at https://github.com/quentinsf/ansible-webfaction.
class WebfactionDbOptions {
    /// The webfaction account to use
    login_name: String
    /// The webfaction password to use
    login_password: String
    /// The machine name to use (optional for accounts with only one machine)
    machine: String?
    /// The name of the database
    name: String
    /// The password for the new database user.
    password: String?
    /// Whether the database should exist
    state: ("present"|"absent")?
    /// The type of database to create.
    type: ("mysql"|"postgresql")
}

/// Task class for webfaction_db
class WebfactionDbTask extends Playbook.Task {
    /// todo doc
    `community.general.webfaction_db`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.webfaction_db"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.webfaction_db`
}

/// TaskBuilder class for webfaction_db
class WebfactionDb extends Playbook.TaskBuilder {
    /// Options for community.general.webfaction_db
    options: WebfactionDbOptions?
    /// todo doc
    function Task(): WebfactionDbTask = this
        .toMap()
        .put("community.general.webfaction_db", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(WebfactionDbTask)
}

/// Add or remove domains and subdomains on Webfaction
/// Add or remove domains or subdomains on a Webfaction host. Further documentation at https://github.com/quentinsf/ansible-webfaction.
class WebfactionDomainOptions {
    /// The webfaction account to use
    login_name: String
    /// The webfaction password to use
    login_password: String
    /// The name of the domain
    name: String
    /// Whether the domain should exist
    state: ("present"|"absent")?
    /// Any subdomains to create.
    subdomains: Listing<String>?
}

/// Task class for webfaction_domain
class WebfactionDomainTask extends Playbook.Task {
    /// todo doc
    `community.general.webfaction_domain`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.webfaction_domain"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.webfaction_domain`
}

/// TaskBuilder class for webfaction_domain
class WebfactionDomain extends Playbook.TaskBuilder {
    /// Options for community.general.webfaction_domain
    options: WebfactionDomainOptions?
    /// todo doc
    function Task(): WebfactionDomainTask = this
        .toMap()
        .put("community.general.webfaction_domain", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(WebfactionDomainTask)
}

/// Add or remove mailboxes on Webfaction
/// Add or remove mailboxes on a Webfaction account. Further documentation at https://github.com/quentinsf/ansible-webfaction.
class WebfactionMailboxOptions {
    /// The webfaction account to use
    login_name: String
    /// The webfaction password to use
    login_password: String
    /// The name of the mailbox
    mailbox_name: String
    /// The password for the mailbox
    mailbox_password: String
    /// Whether the mailbox should exist
    state: ("present"|"absent")?
}

/// Task class for webfaction_mailbox
class WebfactionMailboxTask extends Playbook.Task {
    /// todo doc
    `community.general.webfaction_mailbox`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.webfaction_mailbox"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.webfaction_mailbox`
}

/// TaskBuilder class for webfaction_mailbox
class WebfactionMailbox extends Playbook.TaskBuilder {
    /// Options for community.general.webfaction_mailbox
    options: WebfactionMailboxOptions?
    /// todo doc
    function Task(): WebfactionMailboxTask = this
        .toMap()
        .put("community.general.webfaction_mailbox", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(WebfactionMailboxTask)
}

/// Manage user defined extended attributes
/// Manages filesystem user defined extended attributes.
/// Requires that extended attributes are enabled on the target filesystem and that the setfattr/getfattr utilities are present.
class XattrOptions {
    /// If V(true), dereferences symlinks and sets/gets attributes on symlink target, otherwise acts on symlink itself.
    follow: Boolean?
    /// The name of a specific Extended attribute key to set/retrieve.
    key: String?
    /// Namespace of the named name/key.
    namespace: String?
    /// The full path of the file/object to get the facts of.
    path: String
    /// defines which state you want to do. V(read) retrieves the current value for a O(key) (default) V(present) sets O(path) to O(value), default if value is set V(all) dumps all data V(keys) retrieves all keys V(absent) deletes the key
    state: ("absent"|"all"|"keys"|"present"|"read")?
    /// The value to set the named name/key to, it automatically sets the O(state) to V(present).
    value: String?
}

/// Task class for xattr
class XattrTask extends Playbook.Task {
    /// todo doc
    `community.general.xattr`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.xattr"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.xattr`
}

/// TaskBuilder class for xattr
class Xattr extends Playbook.TaskBuilder {
    /// Options for community.general.xattr
    options: XattrOptions?
    /// todo doc
    function Task(): XattrTask = this
        .toMap()
        .put("community.general.xattr", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(XattrTask)
}

/// Manage packages with XBPS
/// Manage packages with the XBPS package manager.
class XbpsOptions {
    /// Name of the package to install, upgrade, or remove.
    name: Listing<String>?
    /// When removing a package, also remove its dependencies, provided that they are not required by other packages and were not explicitly installed by a user.
    recurse: Boolean?
    /// Desired state of the package.
    state: ("present"|"absent"|"latest"|"installed"|"removed")?
    /// Whether or not to refresh the master package lists. This can be run as part of a package installation or as a separate step.
    update_cache: Boolean?
    /// Whether or not to upgrade whole system
    upgrade: Boolean?
    /// Whether or not to upgrade the xbps package when necessary. Before installing new packages, xbps requires the user to update the xbps package itself. Thus when this option is set to V(false), upgrades and installations will fail when xbps is not up to date.
    upgrade_xbps: Boolean?
}

/// Task class for xbps
class XbpsTask extends Playbook.Task {
    /// todo doc
    `community.general.xbps`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.xbps"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.xbps`
}

/// TaskBuilder class for xbps
class Xbps extends Playbook.TaskBuilder {
    /// Options for community.general.xbps
    options: XbpsOptions?
    /// todo doc
    function Task(): XbpsTask = this
        .toMap()
        .put("community.general.xbps", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(XbpsTask)
}

/// Manages Lenovo Out-Of-Band controllers using Redfish APIs
/// Builds Redfish URIs locally and sends them to remote OOB controllers to perform an action or get information back or update a configuration attribute.
/// Manages virtual media.
/// Supports getting information back via GET method.
/// Supports updating a configuration attribute via PATCH method.
/// Supports performing an action via POST method.
class XccRedfishCommandOptions {
    /// Security token for authentication with OOB controller
    auth_token: String?
    /// Base URI of OOB controller.
    baseuri: String
    /// Category to execute on OOB controller.
    category: String
    /// List of commands to execute on OOB controller.
    command: Listing<String>
    /// Password for authentication with OOB controller.
    password: String?
    /// The request body to patch or post.
    request_body: Any?
    /// The ID of the System, Manager or Chassis to modify.
    resource_id: String?
    /// The resource uri to get or patch or post.
    resource_uri: String?
    /// Timeout in seconds for URL requests to OOB controller.
    timeout: Int?
    /// Username for authentication with OOB controller.
    username: String?
    /// The options for VirtualMedia commands.
    virtual_media: Any?
}

/// Task class for xcc_redfish_command
class XccRedfishCommandTask extends Playbook.Task {
    /// todo doc
    `community.general.xcc_redfish_command`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.xcc_redfish_command"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.xcc_redfish_command`
}

/// TaskBuilder class for xcc_redfish_command
class XccRedfishCommand extends Playbook.TaskBuilder {
    /// Options for community.general.xcc_redfish_command
    options: XccRedfishCommandOptions?
    /// todo doc
    function Task(): XccRedfishCommandTask = this
        .toMap()
        .put("community.general.xcc_redfish_command", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(XccRedfishCommandTask)
}

/// Get facts reported on xenserver
/// Reads data out of XenAPI, can be used instead of multiple xe commands.
class XenserverFactsOptions {
}

/// Task class for xenserver_facts
class XenserverFactsTask extends Playbook.Task {
    /// todo doc
    `community.general.xenserver_facts`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.xenserver_facts"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.xenserver_facts`
}

/// TaskBuilder class for xenserver_facts
class XenserverFacts extends Playbook.TaskBuilder {
    /// Options for community.general.xenserver_facts
    options: XenserverFactsOptions?
    /// todo doc
    function Task(): XenserverFactsTask = this
        .toMap()
        .put("community.general.xenserver_facts", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(XenserverFactsTask)
}

/// Manages virtual machines running on Citrix Hypervisor/XenServer host or pool
/// This module can be used to create new virtual machines from templates or other virtual machines, modify various virtual machine components like network and disk, rename a virtual machine and remove a virtual machine with associated components.
class XenserverGuestOptions {
    /// A CD-ROM configuration for the VM.
    /// All parameters are case sensitive.
    cdrom: Any?
    /// Define a list of custom VM params to set on VM.
    /// Useful for advanced users familiar with managing VM params through xe CLI.
    /// A custom value object takes two fields O(custom_params[].key) and O(custom_params[].value) (see example below).
    custom_params: Listing<Any>?
    /// A list of disks to add to VM.
    /// All parameters are case sensitive.
    /// Removing or detaching existing disks of VM is not supported.
    /// New disks are required to have either a O(disks[].size) or one of O(ignore:disks[].size_[tb,gb,mb,kb,b]) parameters specified.
    /// VM needs to be shut down to reconfigure disk size.
    disks: Listing<Any>?
    /// Destination folder for VM.
    /// This parameter is case sensitive.
    /// Example:
    ///   folder: /folder1/folder2
    folder: String?
    /// Ignore warnings and complete the actions.
    /// This parameter is useful for removing VM in running state or reconfiguring VM params that require VM to be shut down.
    force: Boolean?
    /// Manage VM's hardware parameters. VM needs to be shut down to reconfigure these parameters.
    hardware: Any?
    /// Name of a XenServer host that will be a Home Server for the VM.
    /// This parameter is case sensitive.
    home_server: String?
    /// Convert VM to template.
    is_template: Boolean?
    /// Whether to create a Linked Clone from the template, existing VM or snapshot. If no, will create a full copy.
    /// This is equivalent to C(Use storage-level fast disk clone) option in XenCenter.
    linked_clone: Boolean?
    /// Name of the VM to work with.
    /// VMs running on XenServer do not necessarily have unique names. The module will fail if multiple VMs with same name are found.
    /// In case of multiple VMs with same name, use O(uuid) to uniquely specify VM to manage.
    /// This parameter is case sensitive.
    name: String?
    /// VM description.
    name_desc: String?
    /// A list of networks (in the order of the NICs).
    /// All parameters are case sensitive.
    /// Name is required for new NICs. Other parameters are optional in all cases.
    networks: Listing<Any>?
    /// Specify the state VM should be in.
    /// If O(state) is set to V(present) and VM exists, ensure the VM configuration conforms to given parameters.
    /// If O(state) is set to V(present) and VM does not exist, then VM is deployed with given parameters.
    /// If O(state) is set to V(absent) and VM exists, then VM is removed with its associated components.
    /// If O(state) is set to V(poweredon) and VM does not exist, then VM is deployed with given parameters and powered on automatically.
    state: ("present"|"absent"|"poweredon")?
    /// By default, module will wait indefinitely for VM to acquire an IP address if O(wait_for_ip_address=true).
    /// If this parameter is set to positive value, the module will instead wait specified number of seconds for the state change.
    /// In case of timeout, module will generate an error message.
    state_change_timeout: Int?
    /// Name of a template, an existing VM (must be shut down) or a snapshot that should be used to create VM.
    /// Templates/VMs/snapshots on XenServer do not necessarily have unique names. The module will fail if multiple templates with same name are found.
    /// In case of multiple templates/VMs/snapshots with same name, use O(template_uuid) to uniquely specify source template.
    /// If VM already exists, this setting will be ignored.
    /// This parameter is case sensitive.
    template: String?
    /// UUID of a template, an existing VM or a snapshot that should be used to create VM.
    /// It is required if template name is not unique.
    template_uuid: String?
    /// UUID of the VM to manage if known. This is XenServer's unique identifier.
    /// It is required if name is not unique.
    /// Please note that a supplied UUID will be ignored on VM creation, as XenServer creates the UUID internally.
    uuid: String?
    /// Wait until XenServer detects an IP address for the VM. If O(state) is set to V(absent), this parameter is ignored.
    /// This requires XenServer Tools to be preinstalled on the VM to work properly.
    wait_for_ip_address: Boolean?
}

/// Task class for xenserver_guest
class XenserverGuestTask extends Playbook.Task {
    /// todo doc
    `community.general.xenserver_guest`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.xenserver_guest"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.xenserver_guest`
}

/// TaskBuilder class for xenserver_guest
class XenserverGuest extends Playbook.TaskBuilder {
    /// Options for community.general.xenserver_guest
    options: XenserverGuestOptions?
    /// todo doc
    function Task(): XenserverGuestTask = this
        .toMap()
        .put("community.general.xenserver_guest", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(XenserverGuestTask)
}

/// Gathers information for virtual machines running on Citrix Hypervisor/XenServer host or pool
/// This module can be used to gather essential VM facts.
class XenserverGuestInfoOptions {
    /// Name of the VM to gather facts from.
    /// VMs running on XenServer do not necessarily have unique names. The module will fail if multiple VMs with same name are found.
    /// In case of multiple VMs with same name, use O(uuid) to uniquely specify VM to manage.
    /// This parameter is case sensitive.
    name: String?
    /// UUID of the VM to gather fact of. This is XenServer's unique identifier.
    /// It is required if name is not unique.
    uuid: String?
}

/// Task class for xenserver_guest_info
class XenserverGuestInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.xenserver_guest_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.xenserver_guest_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.xenserver_guest_info`
}

/// TaskBuilder class for xenserver_guest_info
class XenserverGuestInfo extends Playbook.TaskBuilder {
    /// Options for community.general.xenserver_guest_info
    options: XenserverGuestInfoOptions?
    /// todo doc
    function Task(): XenserverGuestInfoTask = this
        .toMap()
        .put("community.general.xenserver_guest_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(XenserverGuestInfoTask)
}

/// Manages power states of virtual machines running on Citrix Hypervisor/XenServer host or pool
/// This module can be used to power on, power off, restart or suspend virtual machine and gracefully reboot or shutdown guest OS of virtual machine.
class XenserverGuestPowerstateOptions {
    /// Name of the VM to manage.
    /// VMs running on XenServer do not necessarily have unique names. The module will fail if multiple VMs with same name are found.
    /// In case of multiple VMs with same name, use O(uuid) to uniquely specify VM to manage.
    /// This parameter is case sensitive.
    name: String?
    /// Specify the state VM should be in.
    /// If O(state) is set to value other than V(present), then VM is transitioned into required state and facts are returned.
    /// If O(state) is set to V(present), then VM is just checked for existence and facts are returned.
    state: ("powered-on"|"powered-off"|"restarted"|"shutdown-guest"|"reboot-guest"|"suspended"|"present")?
    /// By default, module will wait indefinitely for VM to change state or acquire an IP address if O(wait_for_ip_address=true).
    /// If this parameter is set to positive value, the module will instead wait specified number of seconds for the state change.
    /// In case of timeout, module will generate an error message.
    state_change_timeout: Int?
    /// UUID of the VM to manage if known. This is XenServer's unique identifier.
    /// It is required if name is not unique.
    uuid: String?
    /// Wait until XenServer detects an IP address for the VM.
    /// This requires XenServer Tools to be preinstalled on the VM to work properly.
    wait_for_ip_address: Boolean?
}

/// Task class for xenserver_guest_powerstate
class XenserverGuestPowerstateTask extends Playbook.Task {
    /// todo doc
    `community.general.xenserver_guest_powerstate`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.xenserver_guest_powerstate"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.xenserver_guest_powerstate`
}

/// TaskBuilder class for xenserver_guest_powerstate
class XenserverGuestPowerstate extends Playbook.TaskBuilder {
    /// Options for community.general.xenserver_guest_powerstate
    options: XenserverGuestPowerstateOptions?
    /// todo doc
    function Task(): XenserverGuestPowerstateTask = this
        .toMap()
        .put("community.general.xenserver_guest_powerstate", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(XenserverGuestPowerstateTask)
}

/// Edit XFCE4 Configurations
/// This module allows for the manipulation of Xfce 4 Configuration with the help of xfconf-query. Please see the xfconf-query(1) man page for more details.
class XfconfOptions {
    /// A Xfconf preference channel is a top-level tree key, inside of the Xfconf repository that corresponds to the location for which all application properties/keys are stored. See man xfconf-query(1).
    channel: String
    /// Force array even if only one element.
    force_array: Boolean?
    /// A Xfce preference key is an element in the Xfconf repository that corresponds to an application preference. See man xfconf-query(1).
    property: String
    /// The action to take upon the property/value.
    /// The state V(get) has been removed in community.general 5.0.0. Please use the module M(community.general.xfconf_info) instead.
    state: ("present"|"absent")?
    /// Preference properties typically have simple values such as strings, integers, or lists of strings and integers. See man xfconf-query(1).
    value: Listing<String>?
    /// The type of value being set.
    /// When providing more than one O(value_type), the length of the list must be equal to the length of O(value).
    /// If only one O(value_type) is provided, but O(value) contains more than on element, that O(value_type) will be applied to all elements of O(value).
    /// If the O(property) being set is an array and it can possibly have only one element in the array, then O(force_array=true) must be used to ensure that C(xfconf-query) will interpret the value as an array rather than a scalar.
    /// Support for V(uchar), V(char), V(uint64), and V(int64) has been added in community.general 4.8.0.
    value_type: Listing<("string"|"int"|"double"|"bool"|"uint"|"uchar"|"char"|"uint64"|"int64"|"float")>?
}

/// Task class for xfconf
class XfconfTask extends Playbook.Task {
    /// todo doc
    `community.general.xfconf`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.xfconf"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.xfconf`
}

/// TaskBuilder class for xfconf
class Xfconf extends Playbook.TaskBuilder {
    /// Options for community.general.xfconf
    options: XfconfOptions?
    /// todo doc
    function Task(): XfconfTask = this
        .toMap()
        .put("community.general.xfconf", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(XfconfTask)
}

/// Retrieve XFCE4 configurations
/// This module allows retrieving Xfce 4 configurations with the help of C(xfconf-query).
class XfconfInfoOptions {
    /// A Xfconf preference channel is a top-level tree key, inside of the Xfconf repository that corresponds to the location for which all application properties/keys are stored.
    /// If not provided, the module will list all available channels.
    channel: String?
    /// A Xfce preference key is an element in the Xfconf repository that corresponds to an application preference.
    /// If provided, then O(channel) is required.
    /// If not provided and a O(channel) is provided, then the module will list all available properties in that O(channel).
    property: String?
}

/// Task class for xfconf_info
class XfconfInfoTask extends Playbook.Task {
    /// todo doc
    `community.general.xfconf_info`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.xfconf_info"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.xfconf_info`
}

/// TaskBuilder class for xfconf_info
class XfconfInfo extends Playbook.TaskBuilder {
    /// Options for community.general.xfconf_info
    options: XfconfInfoOptions?
    /// todo doc
    function Task(): XfconfInfoTask = this
        .toMap()
        .put("community.general.xfconf_info", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(XfconfInfoTask)
}

/// Manage quotas on XFS filesystems
/// Configure quotas on XFS filesystems.
/// Before using this module /etc/projects and /etc/projid need to be configured.
class XfsQuotaOptions {
    /// Hard blocks quota limit.
    /// This argument supports human readable sizes.
    bhard: String?
    /// Soft blocks quota limit.
    /// This argument supports human readable sizes.
    bsoft: String?
    /// Hard inodes quota limit.
    ihard: Int?
    /// Soft inodes quota limit.
    isoft: Int?
    /// The mount point on which to apply the quotas.
    mountpoint: String
    /// The name of the user, group or project to apply the quota to, if other than default.
    name: String?
    /// Hard realtime blocks quota limit.
    /// This argument supports human readable sizes.
    rtbhard: String?
    /// Soft realtime blocks quota limit.
    /// This argument supports human readable sizes.
    rtbsoft: String?
    /// Whether to apply the limits or remove them.
    /// When removing limit, they are set to 0, and not quite removed.
    state: ("present"|"absent")?
    /// The XFS quota type.
    type: ("user"|"group"|"project")
}

/// Task class for xfs_quota
class XfsQuotaTask extends Playbook.Task {
    /// todo doc
    `community.general.xfs_quota`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.xfs_quota"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.xfs_quota`
}

/// TaskBuilder class for xfs_quota
class XfsQuota extends Playbook.TaskBuilder {
    /// Options for community.general.xfs_quota
    options: XfsQuotaOptions?
    /// todo doc
    function Task(): XfsQuotaTask = this
        .toMap()
        .put("community.general.xfs_quota", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(XfsQuotaTask)
}

/// Manage bits and pieces of XML files or strings
/// A CRUD-like interface to managing bits of XML files.
class XmlOptions {
    /// Add additional child-element(s) to a selected element for a given O(xpath).
    /// Child elements must be given in a list and each item may be either a string (for example C(children=ansible) to add an empty C(<ansible/>) child element), or a hash where the key is an element name and the value is the element value.
    /// This parameter requires O(xpath) to be set.
    add_children: Listing<String>?
    /// The attribute to select when using parameter O(value).
    /// This is a string, not prepended with V(@).
    attribute: String?
    /// Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.
    backup: Boolean?
    /// Search for a given O(xpath) and get content.
    /// This parameter requires O(xpath) to be set.
    content: ("attribute"|"text")?
    /// Search for a given O(xpath) and provide the count of any matches.
    /// This parameter requires O(xpath) to be set.
    count: Boolean?
    /// Type of input for O(add_children) and O(set_children).
    input_type: ("xml"|"yaml")?
    /// Add additional child-element(s) after the last selected element for a given O(xpath).
    /// Child elements must be given in a list and each item may be either a string (for example C(children=ansible) to add an empty C(<ansible/>) child element), or a hash where the key is an element name and the value is the element value.
    /// This parameter requires O(xpath) to be set.
    insertafter: Boolean?
    /// Add additional child-element(s) before the first selected element for a given O(xpath).
    /// Child elements must be given in a list and each item may be either a string (for example C(children=ansible) to add an empty C(<ansible/>) child element), or a hash where the key is an element name and the value is the element value.
    /// This parameter requires O(xpath) to be set.
    insertbefore: Boolean?
    /// The namespace C(prefix:uri) mapping for the XPath expression.
    /// Needs to be a C(dict), not a C(list) of items.
    namespaces: Any?
    /// Path to the file to operate on.
    /// This file must exist ahead of time.
    /// This parameter is required, unless O(xmlstring) is given.
    path: String?
    /// Pretty print XML output.
    pretty_print: Boolean?
    /// Search for a given O(xpath) and print out any matches.
    /// This parameter requires O(xpath) to be set.
    print_match: Boolean?
    /// Set the child-element(s) of a selected element for a given O(xpath).
    /// Removes any existing children.
    /// Child elements must be specified as in O(add_children).
    /// This parameter requires O(xpath) to be set.
    set_children: Listing<String>?
    /// Set or remove an xpath selection (node(s), attribute(s)).
    state: ("absent"|"present")?
    /// Remove CDATA tags surrounding text values.
    /// Note that this might break your XML file if text values contain characters that could be interpreted as XML.
    strip_cdata_tags: Boolean?
    /// Desired state of the selected attribute.
    /// Either a string, or to unset a value, the Python V(None) keyword (YAML Equivalent, V(null)).
    /// Elements default to no value (but present).
    /// Attributes default to an empty string.
    value: String?
    /// A string containing XML on which to operate.
    /// This parameter is required, unless O(path) is given.
    xmlstring: String?
    /// A valid XPath expression describing the item(s) you want to manipulate.
    /// Operates on the document root, V(/), by default.
    xpath: String?
}

/// Task class for xml
class XmlTask extends Playbook.Task {
    /// todo doc
    `community.general.xml`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.xml"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.xml`
}

/// TaskBuilder class for xml
class Xml extends Playbook.TaskBuilder {
    /// Options for community.general.xml
    options: XmlOptions?
    /// todo doc
    function Task(): XmlTask = this
        .toMap()
        .put("community.general.xml", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(XmlTask)
}

/// Manage node.js packages with Yarn
/// Manage node.js packages with the Yarn package manager (https://yarnpkg.com/)
class YarnOptions {
    /// The executable location for yarn.
    executable: String?
    /// Install the node.js library globally
    global: Boolean?
    /// Use the --ignore-scripts flag when installing.
    ignore_scripts: Boolean?
    /// The name of a node.js library to install
    /// If omitted all packages in package.json are installed.
    /// To globally install from local node.js library. Prepend "file:" to the path of the node.js library.
    name: String?
    /// The base path where Node.js libraries will be installed.
    /// This is where the node_modules folder lives.
    path: String?
    /// Install dependencies in production mode.
    /// Yarn will ignore any dependencies under devDependencies in package.json
    production: Boolean?
    /// The registry to install modules from.
    registry: String?
    /// Installation state of the named node.js library
    /// If absent is selected, a name option must be provided
    state: ("present"|"absent"|"latest")?
    /// The version of the library to be installed.
    /// Must be in semver format. If "latest" is desired, use "state" arg instead
    version: String?
}

/// Task class for yarn
class YarnTask extends Playbook.Task {
    /// todo doc
    `community.general.yarn`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.yarn"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.yarn`
}

/// TaskBuilder class for yarn
class Yarn extends Playbook.TaskBuilder {
    /// Options for community.general.yarn
    options: YarnOptions?
    /// todo doc
    function Task(): YarnTask = this
        .toMap()
        .put("community.general.yarn", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(YarnTask)
}

/// Locks / unlocks a installed package(s) from being updated by yum package manager
/// This module adds installed packages to yum versionlock to prevent the package(s) from being updated.
class YumVersionlockOptions {
    /// Package name or a list of package names with optional version or wildcards.
    /// Specifying versions is supported since community.general 7.2.0.
    name: Listing<String>
    /// If state is V(present), package(s) will be added to yum versionlock list.
    /// If state is V(absent), package(s) will be removed from yum versionlock list.
    state: ("absent"|"present")?
}

/// Task class for yum_versionlock
class YumVersionlockTask extends Playbook.Task {
    /// todo doc
    `community.general.yum_versionlock`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.yum_versionlock"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.yum_versionlock`
}

/// TaskBuilder class for yum_versionlock
class YumVersionlock extends Playbook.TaskBuilder {
    /// Options for community.general.yum_versionlock
    options: YumVersionlockOptions?
    /// todo doc
    function Task(): YumVersionlockTask = this
        .toMap()
        .put("community.general.yum_versionlock", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(YumVersionlockTask)
}

/// Manage zfs
/// Manages ZFS file systems, volumes, clones and snapshots
class ZfsOptions {
    /// A dictionary of zfs properties to be set.
    /// See the zfs(8) man page for more information.
    extra_zfs_properties: Any?
    /// File system, snapshot or volume name, for example V(rpool/myfs).
    name: String
    /// Snapshot from which to create a clone.
    origin: String?
    /// Whether to create (V(present)), or remove (V(absent)) a file system, snapshot or volume. All parents/children will be created/destroyed as needed to reach the desired state.
    state: ("absent"|"present")
}

/// Task class for zfs
class ZfsTask extends Playbook.Task {
    /// todo doc
    `community.general.zfs`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.zfs"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.zfs`
}

/// TaskBuilder class for zfs
class Zfs extends Playbook.TaskBuilder {
    /// Options for community.general.zfs
    options: ZfsOptions?
    /// todo doc
    function Task(): ZfsTask = this
        .toMap()
        .put("community.general.zfs", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ZfsTask)
}

/// Manage ZFS delegated administration (user admin privileges)
/// Manages ZFS file system delegated administration permissions, which allow unprivileged users to perform ZFS operations normally restricted to the superuser.
/// See the C(zfs allow) section of V(zfs(1M\)) for detailed explanations of options.
/// This module attempts to adhere to the behavior of the command line tool as much as possible.
class ZfsDelegateAdminOptions {
    /// Apply permissions to O(name)'s descendents (C(zfs allow -d)).
    descendents: Boolean?
    /// Apply permissions to everyone.
    everyone: Boolean?
    /// List of groups to whom permission(s) should be granted.
    groups: Listing<String>?
    /// Apply permissions to O(name) locally (C(zfs allow -l)).
    `local`: Boolean?
    /// File system or volume name, for example V(rpool/myfs).
    name: String
    /// The list of permission(s) to delegate (required if O(state=present)).
    /// Supported permissions depend on the ZFS version in use. See for example U(https://openzfs.github.io/openzfs-docs/man/8/zfs-allow.8.html) for OpenZFS.
    permissions: Listing<String>?
    /// Unallow permissions recursively (ignored when O(state=present)).
    recursive: Boolean?
    /// Whether to allow (V(present)), or unallow (V(absent)) a permission.
    /// When set to V(present), at least one "entity" param of O(users), O(groups), or O(everyone) are required.
    /// When set to V(absent), removes permissions from the specified entities, or removes all permissions if no entity params are specified.
    state: ("absent"|"present")?
    /// List of users to whom permission(s) should be granted.
    users: Listing<String>?
}

/// Task class for zfs_delegate_admin
class ZfsDelegateAdminTask extends Playbook.Task {
    /// todo doc
    `community.general.zfs_delegate_admin`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.zfs_delegate_admin"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.zfs_delegate_admin`
}

/// TaskBuilder class for zfs_delegate_admin
class ZfsDelegateAdmin extends Playbook.TaskBuilder {
    /// Options for community.general.zfs_delegate_admin
    options: ZfsDelegateAdminOptions?
    /// todo doc
    function Task(): ZfsDelegateAdminTask = this
        .toMap()
        .put("community.general.zfs_delegate_admin", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ZfsDelegateAdminTask)
}

/// Gather facts about ZFS datasets
/// Gather facts from ZFS dataset properties.
class ZfsFactsOptions {
    /// Specifies recursion depth.
    depth: Int?
    /// ZFS dataset name.
    name: String
    /// Specifies if property values should be displayed in machine friendly format.
    parsable: Boolean?
    /// Specifies which dataset properties should be queried in comma-separated format. For more information about dataset properties, check zfs(1M) man page.
    properties: String?
    /// Specifies if properties for any children should be recursively displayed.
    recurse: Boolean?
    /// Specifies which datasets types to display. Multiple values have to be provided in comma-separated form.
    type: ("all"|"filesystem"|"volume"|"snapshot"|"bookmark")?
}

/// Task class for zfs_facts
class ZfsFactsTask extends Playbook.Task {
    /// todo doc
    `community.general.zfs_facts`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.zfs_facts"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.zfs_facts`
}

/// TaskBuilder class for zfs_facts
class ZfsFacts extends Playbook.TaskBuilder {
    /// Options for community.general.zfs_facts
    options: ZfsFactsOptions?
    /// todo doc
    function Task(): ZfsFactsTask = this
        .toMap()
        .put("community.general.zfs_facts", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ZfsFactsTask)
}

/// Create, delete, retrieve, and update znodes using ZooKeeper
/// Create, delete, retrieve, and update znodes using ZooKeeper.
class ZnodeOptions {
    /// The authentication credential value. Depends on O(auth_scheme).
    /// The format for O(auth_scheme=digest) is C(user:password), and the format for O(auth_scheme=sasl) is C(user:password).
    auth_credential: String?
    /// Authentication scheme.
    auth_scheme: ("digest"|"sasl")?
    /// A list of ZooKeeper servers (format '[server]:[port]').
    hosts: String
    /// The path of the znode.
    name: String
    /// An operation to perform. Mutually exclusive with state.
    op: ("get"|"wait"|"list")?
    /// Recursively delete node and all its children.
    recursive: Boolean?
    /// The state to enforce. Mutually exclusive with op.
    state: ("present"|"absent")?
    /// The amount of time to wait for a node to appear.
    timeout: Int?
    /// Using TLS/SSL or not.
    use_tls: Boolean?
    /// The value assigned to the znode.
    value: String?
}

/// Task class for znode
class ZnodeTask extends Playbook.Task {
    /// todo doc
    `community.general.znode`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.znode"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.znode`
}

/// TaskBuilder class for znode
class Znode extends Playbook.TaskBuilder {
    /// Options for community.general.znode
    options: ZnodeOptions?
    /// todo doc
    function Task(): ZnodeTask = this
        .toMap()
        .put("community.general.znode", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ZnodeTask)
}

/// Gather facts about ZFS pools
/// Gather facts from ZFS pool properties.
class ZpoolFactsOptions {
    /// ZFS pool name.
    name: String?
    /// Specifies if property values should be displayed in machine friendly format.
    parsable: Boolean?
    /// Specifies which dataset properties should be queried in comma-separated format. For more information about dataset properties, check zpool(1M) man page.
    properties: String?
}

/// Task class for zpool_facts
class ZpoolFactsTask extends Playbook.Task {
    /// todo doc
    `community.general.zpool_facts`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.zpool_facts"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.zpool_facts`
}

/// TaskBuilder class for zpool_facts
class ZpoolFacts extends Playbook.TaskBuilder {
    /// Options for community.general.zpool_facts
    options: ZpoolFactsOptions?
    /// todo doc
    function Task(): ZpoolFactsTask = this
        .toMap()
        .put("community.general.zpool_facts", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ZpoolFactsTask)
}

/// Manage packages on SUSE and openSUSE
/// Manage packages on SUSE and openSUSE using the zypper and rpm tools.
/// Also supports transactional updates, by running zypper inside C(/sbin/transactional-update --continue --drop-if-no-change --quiet run).
class ZypperOptions {
    /// Adds C(--allow_vendor_change) option to I(zypper) dist-upgrade command.
    allow_vendor_change: Boolean?
    /// Adds C(--clean-deps) option to I(zypper) remove command.
    clean_deps: Boolean?
    /// Whether to disable to GPG signature checking of the package signature being installed. Has an effect only if O(state) is V(present) or V(latest).
    disable_gpg_check: Boolean?
    /// Corresponds to the C(--no-recommends) option for I(zypper). Default behavior (V(true)) modifies zypper's default behavior; V(false) does install recommended packages.
    disable_recommends: Boolean?
    /// Add additional options to C(zypper) command.
    /// Options should be supplied in a single line as if given in the command line.
    extra_args: String?
    /// Add additional global target options to C(zypper).
    /// Options should be supplied in a single line as if given in the command line.
    extra_args_precommand: String?
    /// Adds C(--force) option to I(zypper). Allows to downgrade packages and change vendor or architecture.
    force: Boolean?
    /// Adds C(--force-resolution) option to I(zypper). Allows to (un)install packages with conflicting requirements (resolver will choose a solution).
    force_resolution: Boolean?
    /// Package name V(name) or package specifier or a list of either.
    /// Can include a version like V(name=1.0), V(name>3.4) or V(name<=2.7). If a version is given, V(oldpackage) is implied and zypper is allowed to update the package within the version range given.
    /// You can also pass a url or a local path to a rpm file.
    /// When using O(state=latest), this can be '*', which updates all installed packages.
    name: Listing<String>
    /// Adds C(--oldpackage) option to I(zypper). Allows to downgrade packages with less side-effects than force. This is implied as soon as a version is specified as part of the package name.
    oldpackage: Boolean?
    /// Adds C(--replacefiles) option to I(zypper) install/update command.
    replacefiles: Boolean?
    /// V(present) will make sure the package is installed. V(latest)  will make sure the latest version of the package is installed. V(absent)  will make sure the specified package is not installed. V(dist-upgrade) will make sure the latest version of all installed packages from all enabled repositories is installed.
    /// When using V(dist-upgrade), O(name) should be V('*').
    state: ("present"|"latest"|"absent"|"dist-upgrade"|"installed"|"removed")?
    /// The type of package to be operated on.
    type: ("package"|"patch"|"pattern"|"product"|"srcpackage"|"application")?
    /// Run the equivalent of C(zypper refresh) before the operation. Disabled in check mode.
    update_cache: Boolean?
}

/// Task class for zypper
class ZypperTask extends Playbook.Task {
    /// todo doc
    `community.general.zypper`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.zypper"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.zypper`
}

/// TaskBuilder class for zypper
class Zypper extends Playbook.TaskBuilder {
    /// Options for community.general.zypper
    options: ZypperOptions?
    /// todo doc
    function Task(): ZypperTask = this
        .toMap()
        .put("community.general.zypper", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ZypperTask)
}

/// Add and remove Zypper repositories
/// Add or remove Zypper repositories on SUSE and openSUSE
class ZypperRepositoryOptions {
    /// Automatically import the gpg signing key of the new or changed repository.
    /// Has an effect only if O(state=present). Has no effect on existing (unchanged) repositories or in combination with O(state=absent).
    /// Implies runrefresh.
    /// Only works with C(.repo) files if `name` is given explicitly.
    auto_import_keys: Boolean?
    /// Enable autorefresh of the repository.
    autorefresh: Boolean?
    /// A description of the repository
    description: String?
    /// Whether to disable GPG signature checking of all packages. Has an effect only if O(state=present).
    /// Needs zypper version >= 1.6.2.
    disable_gpg_check: Boolean?
    /// Set repository to enabled (or disabled).
    enabled: Boolean?
    /// A name for the repository. Not required when adding repofiles.
    name: String?
    /// Overwrite multiple repository entries, if repositories with both name and URL already exist.
    overwrite_multiple: Boolean?
    /// Set priority of repository. Packages will always be installed from the repository with the smallest priority number.
    /// Needs zypper version >= 1.12.25.
    priority: Int?
    /// URI of the repository or .repo file. Required when state=present.
    repo: String?
    /// Refresh the package list of the given repository.
    /// Can be used with repo=* to refresh all repositories.
    runrefresh: Boolean?
    /// A source string state.
    state: ("absent"|"present")?
}

/// Task class for zypper_repository
class ZypperRepositoryTask extends Playbook.Task {
    /// todo doc
    `community.general.zypper_repository`: Dynamic|String
    /// todo doc
    function GetModuleName(): String = "community.general.zypper_repository"
    /// todo doc
    function GetModuleOptions(): Dynamic = this.`community.general.zypper_repository`
}

/// TaskBuilder class for zypper_repository
class ZypperRepository extends Playbook.TaskBuilder {
    /// Options for community.general.zypper_repository
    options: ZypperRepositoryOptions?
    /// todo doc
    function Task(): ZypperRepositoryTask = this
        .toMap()
        .put("community.general.zypper_repository", (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic {})
            |> (this.options_mixin ?? new Mixin {}))
        .toTyped(ZypperRepositoryTask)
}

