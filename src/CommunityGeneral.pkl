module CommunityGeneral

import "./Playbook.pkl"

/// Check or wait for migrations between nodes
class AerospikeMigrationsOptions {
    
    connect_timeout: Int?
    
    consecutive_good_checks: Int?
    
    fail_on_cluster_change: Boolean?
    
    host: String?
    
    local_only: Boolean
    
    migrate_rx_key: String?
    
    migrate_tx_key: String?
    
    min_cluster_size: Int?
    
    port: Int?
    
    sleep_between_checks: Int?
    
    target_cluster_size: Int?
    
    tries_limit: Int?
    
}

/// Task class for aerospike_migrations
class AerospikeMigrations extends Playbook.Task {

    /// todo doc
    `community.general.aerospike_migrations`: Dynamic

    /// Options for community.general.aerospike_migrations
    hidden options: AerospikeMigrationsOptions?

    /// todo doc
    function configure(): AerospikeMigrations = this
        .toMap()
        .put(
            "community.general.aerospike_migrations",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(AerospikeMigrations)

}

/// Notify airbrake about app deployments
class AirbrakeDeploymentOptions {
    
    environment: String
    
    project_id: String
    
    project_key: String
    
    repo: String?
    
    revision: String?
    
    url: String?
    
    user: String?
    
    validate_certs: Boolean?
    
    version: String?
    
}

/// Task class for airbrake_deployment
class AirbrakeDeployment extends Playbook.Task {

    /// todo doc
    `community.general.airbrake_deployment`: Dynamic

    /// Options for community.general.airbrake_deployment
    hidden options: AirbrakeDeploymentOptions?

    /// todo doc
    function configure(): AirbrakeDeployment = this
        .toMap()
        .put(
            "community.general.airbrake_deployment",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(AirbrakeDeployment)

}

/// Manages AIX devices
class AixDevicesOptions {
    
    attributes: Any?
    
    device: String?
    
    force: Boolean?
    
    recursive: Boolean?
    
    state: ("available"|"defined"|"removed")?
    
}

/// Task class for aix_devices
class AixDevices extends Playbook.Task {

    /// todo doc
    `community.general.aix_devices`: Dynamic

    /// Options for community.general.aix_devices
    hidden options: AixDevicesOptions?

    /// todo doc
    function configure(): AixDevices = this
        .toMap()
        .put(
            "community.general.aix_devices",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(AixDevices)

}

/// Configure LVM and NFS file systems for AIX
class AixFilesystemOptions {
    
    account_subsystem: Boolean?
    
    attributes: Listing<String>?
    
    auto_mount: Boolean?
    
    device: String?
    
    filesystem: String
    
    fs_type: String?
    
    mount_group: String?
    
    nfs_server: String?
    
    permissions: ("ro"|"rw")?
    
    rm_mount_point: Boolean?
    
    size: String?
    
    state: ("absent"|"mounted"|"present"|"unmounted")?
    
    vg: String?
    
}

/// Task class for aix_filesystem
class AixFilesystem extends Playbook.Task {

    /// todo doc
    `community.general.aix_filesystem`: Dynamic

    /// Options for community.general.aix_filesystem
    hidden options: AixFilesystemOptions?

    /// todo doc
    function configure(): AixFilesystem = this
        .toMap()
        .put(
            "community.general.aix_filesystem",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(AixFilesystem)

}

/// Manages the inittab on AIX
class AixInittabOptions {
    
    action: ("boot"|"bootwait"|"hold"|"initdefault"|"off"|"once"|"ondemand"|"powerfail"|"powerwait"|"respawn"|"sysinit"|"wait")?
    
    command: String
    
    insertafter: String?
    
    name: String
    
    runlevel: String
    
    state: ("absent"|"present")?
    
}

/// Task class for aix_inittab
class AixInittab extends Playbook.Task {

    /// todo doc
    `community.general.aix_inittab`: Dynamic

    /// Options for community.general.aix_inittab
    hidden options: AixInittabOptions?

    /// todo doc
    function configure(): AixInittab = this
        .toMap()
        .put(
            "community.general.aix_inittab",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(AixInittab)

}

/// Manage LVM volume groups on AIX
class AixLvgOptions {
    
    force: Boolean?
    
    pp_size: Int?
    
    pvs: Listing<String>?
    
    state: ("absent"|"present"|"varyoff"|"varyon")?
    
    vg: String
    
    vg_type: ("big"|"normal"|"scalable")?
    
}

/// Task class for aix_lvg
class AixLvg extends Playbook.Task {

    /// todo doc
    `community.general.aix_lvg`: Dynamic

    /// Options for community.general.aix_lvg
    hidden options: AixLvgOptions?

    /// todo doc
    function configure(): AixLvg = this
        .toMap()
        .put(
            "community.general.aix_lvg",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(AixLvg)

}

/// Configure AIX LVM logical volumes
class AixLvolOptions {
    
    copies: Int?
    
    lv: String
    
    lv_type: String?
    
    opts: String?
    
    policy: ("maximum"|"minimum")?
    
    pvs: Listing<String>?
    
    size: String?
    
    state: ("absent"|"present")?
    
    vg: String
    
}

/// Task class for aix_lvol
class AixLvol extends Playbook.Task {

    /// todo doc
    `community.general.aix_lvol`: Dynamic

    /// Options for community.general.aix_lvol
    hidden options: AixLvolOptions?

    /// todo doc
    function configure(): AixLvol = this
        .toMap()
        .put(
            "community.general.aix_lvol",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(AixLvol)

}

/// Manage customers in Alerta
class AlertaCustomerOptions {
    
    alerta_url: String
    
    api_key: String?
    
    api_password: String?
    
    api_username: String?
    
    customer: String
    
    match: String
    
    state: ("absent"|"present")?
    
}

/// Task class for alerta_customer
class AlertaCustomer extends Playbook.Task {

    /// todo doc
    `community.general.alerta_customer`: Dynamic

    /// Options for community.general.alerta_customer
    hidden options: AlertaCustomerOptions?

    /// todo doc
    function configure(): AlertaCustomer = this
        .toMap()
        .put(
            "community.general.alerta_customer",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(AlertaCustomer)

}

/// Create, Start, Stop, Restart or Terminate an Instance in ECS; Add or Remove Instance to/from a Security Group
class AliInstanceOptions {
    
    allocate_public_ip: Boolean?
    
    auto_renew: Boolean?
    
    auto_renew_period: Int?
    
    availability_zone: String?
    
    count: Int?
    
    count_tag: String?
    
    description: String?
    
    dry_run: Boolean?
    
    force: Boolean?
    
    host_name: String?
    
    image_id: String?
    
    include_data_disks: Boolean?
    
    instance_charge_type: ("PrePaid"|"PostPaid")?
    
    instance_ids: Listing<String>?
    
    instance_name: String?
    
    instance_type: String?
    
    internet_charge_type: ("PayByBandwidth"|"PayByTraffic")?
    
    key_name: String?
    
    max_bandwidth_in: Int?
    
    max_bandwidth_out: Int?
    
    password: String?
    
    period: Int?
    
    period_unit: ("Month"|"Week")?
    
    purge_tags: Boolean?
    
    ram_role_name: String?
    
    security_groups: Listing<String>?
    
    spot_price_limit: Any?
    
    spot_strategy: ("NoSpot"|"SpotWithPriceLimit"|"SpotAsPriceGo")?
    
    state: ("present"|"running"|"stopped"|"restarted"|"absent")?
    
    system_disk_category: ("cloud_efficiency"|"cloud_ssd")?
    
    system_disk_description: String?
    
    system_disk_name: String?
    
    system_disk_size: Int?
    
    tags: Any?
    
    unique_suffix: Boolean?
    
    user_data: String?
    
    vswitch_id: String?
    
}

/// Task class for ali_instance
class AliInstance extends Playbook.Task {

    /// todo doc
    `community.general.ali_instance`: Dynamic

    /// Options for community.general.ali_instance
    hidden options: AliInstanceOptions?

    /// todo doc
    function configure(): AliInstance = this
        .toMap()
        .put(
            "community.general.ali_instance",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(AliInstance)

}

/// Gather information on instances of Alibaba Cloud ECS
class AliInstanceInfoOptions {
    
    filters: Any?
    
    name_prefix: String?
    
    tags: Any?
    
}

/// Task class for ali_instance_info
class AliInstanceInfo extends Playbook.Task {

    /// todo doc
    `community.general.ali_instance_info`: Dynamic

    /// Options for community.general.ali_instance_info
    hidden options: AliInstanceInfoOptions?

    /// todo doc
    function configure(): AliInstanceInfo = this
        .toMap()
        .put(
            "community.general.ali_instance_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(AliInstanceInfo)

}

/// Manages alternative programs for common commands
class AlternativesOptions {
    
    link: String?
    
    name: String
    
    path: String
    
    priority: Int?
    
    state: ("present"|"selected"|"auto"|"absent")?
    
    subcommands: Listing<Any>?
    
}

/// Task class for alternatives
class Alternatives extends Playbook.Task {

    /// todo doc
    `community.general.alternatives`: Dynamic

    /// Options for community.general.alternatives
    hidden options: AlternativesOptions?

    /// todo doc
    function configure(): Alternatives = this
        .toMap()
        .put(
            "community.general.alternatives",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Alternatives)

}

/// Install Ansible roles or collections using ansible-galaxy
class AnsibleGalaxyInstallOptions {
    
    ack_ansible29: Boolean?
    
    ack_min_ansiblecore211: Boolean?
    
    dest: String?
    
    force: Boolean?
    
    name: String?
    
    no_deps: Boolean?
    
    requirements_file: String?
    
    type: ("collection"|"role"|"both")
    
}

/// Task class for ansible_galaxy_install
class AnsibleGalaxyInstall extends Playbook.Task {

    /// todo doc
    `community.general.ansible_galaxy_install`: Dynamic

    /// Options for community.general.ansible_galaxy_install
    hidden options: AnsibleGalaxyInstallOptions?

    /// todo doc
    function configure(): AnsibleGalaxyInstall = this
        .toMap()
        .put(
            "community.general.ansible_galaxy_install",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(AnsibleGalaxyInstall)

}

/// Set and/or get members' attributes of an Apache httpd 2.4 mod_proxy balancer pool
class Apache2ModProxyOptions {
    
    balancer_url_suffix: String?
    
    balancer_vhost: String
    
    member_host: String?
    
    state: String?
    
    tls: Boolean?
    
    validate_certs: Boolean?
    
}

/// Task class for apache2_mod_proxy
class Apache2ModProxy extends Playbook.Task {

    /// todo doc
    `community.general.apache2_mod_proxy`: Dynamic

    /// Options for community.general.apache2_mod_proxy
    hidden options: Apache2ModProxyOptions?

    /// todo doc
    function configure(): Apache2ModProxy = this
        .toMap()
        .put(
            "community.general.apache2_mod_proxy",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Apache2ModProxy)

}

/// Enables/disables a module of the Apache2 webserver
class Apache2ModuleOptions {
    
    force: Boolean?
    
    identifier: String?
    
    ignore_configcheck: Boolean?
    
    name: String
    
    state: ("present"|"absent")?
    
    warn_mpm_absent: Boolean?
    
}

/// Task class for apache2_module
class Apache2Module extends Playbook.Task {

    /// todo doc
    `community.general.apache2_module`: Dynamic

    /// Options for community.general.apache2_module
    hidden options: Apache2ModuleOptions?

    /// todo doc
    function configure(): Apache2Module = this
        .toMap()
        .put(
            "community.general.apache2_module",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Apache2Module)

}

/// Manages apk packages
class ApkOptions {
    
    available: Boolean?
    
    name: Listing<String>?
    
    no_cache: Boolean?
    
    repository: Listing<String>?
    
    state: ("present"|"absent"|"latest"|"installed"|"removed")?
    
    update_cache: Boolean?
    
    upgrade: Boolean?
    
    world: String?
    
}

/// Task class for apk
class Apk extends Playbook.Task {

    /// todo doc
    `community.general.apk`: Dynamic

    /// Options for community.general.apk
    hidden options: ApkOptions?

    /// todo doc
    function configure(): Apk = this
        .toMap()
        .put(
            "community.general.apk",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Apk)

}

/// Manage APT repositories via apt-repo
class AptRepoOptions {
    
    remove_others: Boolean?
    
    repo: String
    
    state: ("absent"|"present")?
    
    update: Boolean?
    
}

/// Task class for apt_repo
class AptRepo extends Playbook.Task {

    /// todo doc
    `community.general.apt_repo`: Dynamic

    /// Options for community.general.apt_repo
    hidden options: AptRepoOptions?

    /// todo doc
    function configure(): AptRepo = this
        .toMap()
        .put(
            "community.general.apt_repo",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(AptRepo)

}

/// APT-RPM package manager
class AptRpmOptions {
    
    clean: Boolean?
    
    dist_upgrade: Boolean?
    
    package: Listing<String>?
    
    state: ("absent"|"present"|"installed"|"removed")?
    
    update_cache: Boolean?
    
    update_kernel: Boolean?
    
}

/// Task class for apt_rpm
class AptRpm extends Playbook.Task {

    /// todo doc
    `community.general.apt_rpm`: Dynamic

    /// Options for community.general.apt_rpm
    hidden options: AptRpmOptions?

    /// todo doc
    function configure(): AptRpm = this
        .toMap()
        .put(
            "community.general.apt_rpm",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(AptRpm)

}

/// Creates a compressed archive of one or more files or trees
class ArchiveOptions {
    
    dest: String?
    
    exclude_path: Listing<String>?
    
    exclusion_patterns: Listing<String>?
    
    force_archive: Boolean?
    
    format: ("bz2"|"gz"|"tar"|"xz"|"zip")?
    
    path: Listing<String>
    
    remove: Boolean?
    
}

/// Task class for archive
class Archive extends Playbook.Task {

    /// todo doc
    `community.general.archive`: Dynamic

    /// Options for community.general.archive
    hidden options: ArchiveOptions?

    /// todo doc
    function configure(): Archive = this
        .toMap()
        .put(
            "community.general.archive",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Archive)

}

/// Manage the containers on the atomic host platform
class AtomicContainerOptions {
    
    backend: ("docker"|"ostree")
    
    image: String
    
    mode: ("user"|"system")?
    
    name: String
    
    rootfs: String?
    
    state: ("absent"|"latest"|"present"|"rollback")?
    
    values: Listing<String>?
    
}

/// Task class for atomic_container
class AtomicContainer extends Playbook.Task {

    /// todo doc
    `community.general.atomic_container`: Dynamic

    /// Options for community.general.atomic_container
    hidden options: AtomicContainerOptions?

    /// todo doc
    function configure(): AtomicContainer = this
        .toMap()
        .put(
            "community.general.atomic_container",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(AtomicContainer)

}

/// Manage the atomic host platform
class AtomicHostOptions {
    
    revision: String?
    
}

/// Task class for atomic_host
class AtomicHost extends Playbook.Task {

    /// todo doc
    `community.general.atomic_host`: Dynamic

    /// Options for community.general.atomic_host
    hidden options: AtomicHostOptions?

    /// todo doc
    function configure(): AtomicHost = this
        .toMap()
        .put(
            "community.general.atomic_host",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(AtomicHost)

}

/// Manage the container images on the atomic host platform
class AtomicImageOptions {
    
    backend: ("docker"|"ostree")?
    
    name: String
    
    started: Boolean?
    
    state: ("absent"|"latest"|"present")?
    
}

/// Task class for atomic_image
class AtomicImage extends Playbook.Task {

    /// todo doc
    `community.general.atomic_image`: Dynamic

    /// Options for community.general.atomic_image
    hidden options: AtomicImageOptions?

    /// todo doc
    function configure(): AtomicImage = this
        .toMap()
        .put(
            "community.general.atomic_image",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(AtomicImage)

}

/// Manage awall policies
class AwallOptions {
    
    activate: Boolean?
    
    name: Listing<String>?
    
    state: ("disabled"|"enabled")?
    
}

/// Task class for awall
class Awall extends Playbook.Task {

    /// todo doc
    `community.general.awall`: Dynamic

    /// Options for community.general.awall
    hidden options: AwallOptions?

    /// todo doc
    function configure(): Awall = this
        .toMap()
        .put(
            "community.general.awall",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Awall)

}

/// Manage ZFS boot environments on FreeBSD/Solaris/illumos systems
class BeadmOptions {
    
    description: String?
    
    force: Boolean?
    
    mountpoint: String?
    
    name: String
    
    options: String?
    
    snapshot: String?
    
    state: ("absent"|"activated"|"mounted"|"present"|"unmounted")?
    
}

/// Task class for beadm
class Beadm extends Playbook.Task {

    /// todo doc
    `community.general.beadm`: Dynamic

    /// Options for community.general.beadm
    hidden options: BeadmOptions?

    /// todo doc
    function configure(): Beadm = this
        .toMap()
        .put(
            "community.general.beadm",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Beadm)

}

/// Send BearyChat notifications
class BearychatOptions {
    
    attachments: Listing<Any>?
    
    channel: String?
    
    markdown: Boolean?
    
    text: String?
    
    url: String
    
}

/// Task class for bearychat
class Bearychat extends Playbook.Task {

    /// todo doc
    `community.general.bearychat`: Dynamic

    /// Options for community.general.bearychat
    hidden options: BearychatOptions?

    /// todo doc
    function configure(): Bearychat = this
        .toMap()
        .put(
            "community.general.bearychat",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Bearychat)

}

/// Notify BigPanda about deployments
class BigpandaOptions {
    
    component: String
    
    deployment_message: String?
    
    description: String?
    
    env: String?
    
    hosts: String?
    
    owner: String?
    
    source_system: String?
    
    state: ("started"|"finished"|"failed")
    
    token: String
    
    url: String?
    
    validate_certs: Boolean?
    
    version: String
    
}

/// Task class for bigpanda
class Bigpanda extends Playbook.Task {

    /// todo doc
    `community.general.bigpanda`: Dynamic

    /// Options for community.general.bigpanda
    hidden options: BigpandaOptions?

    /// todo doc
    function configure(): Bigpanda = this
        .toMap()
        .put(
            "community.general.bigpanda",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Bigpanda)

}

/// Manages Bitbucket repository access keys
class BitbucketAccessKeyOptions {
    
    key: String?
    
    label: String
    
    repository: String
    
    state: ("absent"|"present")
    
    workspace: String
    
}

/// Task class for bitbucket_access_key
class BitbucketAccessKey extends Playbook.Task {

    /// todo doc
    `community.general.bitbucket_access_key`: Dynamic

    /// Options for community.general.bitbucket_access_key
    hidden options: BitbucketAccessKeyOptions?

    /// todo doc
    function configure(): BitbucketAccessKey = this
        .toMap()
        .put(
            "community.general.bitbucket_access_key",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(BitbucketAccessKey)

}

/// Manages Bitbucket pipeline SSH key pair
class BitbucketPipelineKeyPairOptions {
    
    private_key: String?
    
    public_key: String?
    
    repository: String
    
    state: ("absent"|"present")
    
    workspace: String
    
}

/// Task class for bitbucket_pipeline_key_pair
class BitbucketPipelineKeyPair extends Playbook.Task {

    /// todo doc
    `community.general.bitbucket_pipeline_key_pair`: Dynamic

    /// Options for community.general.bitbucket_pipeline_key_pair
    hidden options: BitbucketPipelineKeyPairOptions?

    /// todo doc
    function configure(): BitbucketPipelineKeyPair = this
        .toMap()
        .put(
            "community.general.bitbucket_pipeline_key_pair",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(BitbucketPipelineKeyPair)

}

/// Manages Bitbucket pipeline known hosts
class BitbucketPipelineKnownHostOptions {
    
    key: String?
    
    name: String
    
    repository: String
    
    state: ("absent"|"present")
    
    workspace: String
    
}

/// Task class for bitbucket_pipeline_known_host
class BitbucketPipelineKnownHost extends Playbook.Task {

    /// todo doc
    `community.general.bitbucket_pipeline_known_host`: Dynamic

    /// Options for community.general.bitbucket_pipeline_known_host
    hidden options: BitbucketPipelineKnownHostOptions?

    /// todo doc
    function configure(): BitbucketPipelineKnownHost = this
        .toMap()
        .put(
            "community.general.bitbucket_pipeline_known_host",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(BitbucketPipelineKnownHost)

}

/// Manages Bitbucket pipeline variables
class BitbucketPipelineVariableOptions {
    
    name: String
    
    repository: String
    
    secured: Boolean?
    
    state: ("absent"|"present")
    
    value: String?
    
    workspace: String
    
}

/// Task class for bitbucket_pipeline_variable
class BitbucketPipelineVariable extends Playbook.Task {

    /// todo doc
    `community.general.bitbucket_pipeline_variable`: Dynamic

    /// Options for community.general.bitbucket_pipeline_variable
    hidden options: BitbucketPipelineVariableOptions?

    /// todo doc
    function configure(): BitbucketPipelineVariable = this
        .toMap()
        .put(
            "community.general.bitbucket_pipeline_variable",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(BitbucketPipelineVariable)

}

/// Manage bower packages with bower
class BowerOptions {
    
    name: String?
    
    offline: Boolean?
    
    path: String
    
    production: Boolean?
    
    relative_execpath: String?
    
    state: ("present"|"absent"|"latest")?
    
    version: String?
    
}

/// Task class for bower
class Bower extends Playbook.Task {

    /// todo doc
    `community.general.bower`: Dynamic

    /// Options for community.general.bower
    hidden options: BowerOptions?

    /// todo doc
    function configure(): Bower = this
        .toMap()
        .put(
            "community.general.bower",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Bower)

}

/// Query btrfs filesystem info
class BtrfsInfoOptions {
    
}

/// Task class for btrfs_info
class BtrfsInfo extends Playbook.Task {

    /// todo doc
    `community.general.btrfs_info`: Dynamic

    /// Options for community.general.btrfs_info
    hidden options: BtrfsInfoOptions?

    /// todo doc
    function configure(): BtrfsInfo = this
        .toMap()
        .put(
            "community.general.btrfs_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(BtrfsInfo)

}

/// Manage btrfs subvolumes
class BtrfsSubvolumeOptions {
    
    automount: Boolean?
    
    default: Boolean?
    
    filesystem_device: String?
    
    filesystem_label: String?
    
    filesystem_uuid: String?
    
    name: String
    
    recursive: Boolean?
    
    snapshot_conflict: ("skip"|"clobber"|"error")?
    
    snapshot_source: String?
    
    state: ("absent"|"present")?
    
}

/// Task class for btrfs_subvolume
class BtrfsSubvolume extends Playbook.Task {

    /// todo doc
    `community.general.btrfs_subvolume`: Dynamic

    /// Options for community.general.btrfs_subvolume
    hidden options: BtrfsSubvolumeOptions?

    /// todo doc
    function configure(): BtrfsSubvolume = this
        .toMap()
        .put(
            "community.general.btrfs_subvolume",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(BtrfsSubvolume)

}

/// Manage Ruby Gem dependencies with Bundler
class BundlerOptions {
    
    binstub_directory: String?
    
    chdir: String?
    
    clean: Boolean?
    
    deployment_mode: Boolean?
    
    exclude_groups: Listing<String>?
    
    executable: String?
    
    extra_args: String?
    
    gem_path: String?
    
    gemfile: String?
    
    `local`: Boolean?
    
    state: ("present"|"latest")?
    
    user_install: Boolean?
    
}

/// Task class for bundler
class Bundler extends Playbook.Task {

    /// todo doc
    `community.general.bundler`: Dynamic

    /// Options for community.general.bundler
    hidden options: BundlerOptions?

    /// todo doc
    function configure(): Bundler = this
        .toMap()
        .put(
            "community.general.bundler",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Bundler)

}

/// Deploy software (or files) from bzr branches
class BzrOptions {
    
    dest: String
    
    executable: String?
    
    force: Boolean?
    
    name: String
    
    version: String?
    
}

/// Task class for bzr
class Bzr extends Playbook.Task {

    /// todo doc
    `community.general.bzr`: Dynamic

    /// Options for community.general.bzr
    hidden options: BzrOptions?

    /// todo doc
    function configure(): Bzr = this
        .toMap()
        .put(
            "community.general.bzr",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Bzr)

}

/// Send a message to Campfire
class CampfireOptions {
    
    msg: String
    
    notify: ("56k"|"bell"|"bezos"|"bueller"|"clowntown"|"cottoneyejoe"|"crickets"|"dadgummit"|"dangerzone"|"danielsan"|"deeper"|"drama"|"greatjob"|"greyjoy"|"guarantee"|"heygirl"|"horn"|"horror"|"inconceivable"|"live"|"loggins"|"makeitso"|"noooo"|"nyan"|"ohmy"|"ohyeah"|"pushit"|"rimshot"|"rollout"|"rumble"|"sax"|"secret"|"sexyback"|"story"|"tada"|"tmyk"|"trololo"|"trombone"|"unix"|"vuvuzela"|"what"|"whoomp"|"yeah"|"yodel")?
    
    room: String
    
    subscription: String
    
    token: String
    
}

/// Task class for campfire
class Campfire extends Playbook.Task {

    /// todo doc
    `community.general.campfire`: Dynamic

    /// Options for community.general.campfire
    hidden options: CampfireOptions?

    /// todo doc
    function configure(): Campfire = this
        .toMap()
        .put(
            "community.general.campfire",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Campfire)

}

/// Manage Linux capabilities
class CapabilitiesOptions {
    
    capability: String
    
    path: String
    
    state: ("absent"|"present")?
    
}

/// Task class for capabilities
class Capabilities extends Playbook.Task {

    /// todo doc
    `community.general.capabilities`: Dynamic

    /// Options for community.general.capabilities
    hidden options: CapabilitiesOptions?

    /// todo doc
    function configure(): Capabilities = this
        .toMap()
        .put(
            "community.general.capabilities",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Capabilities)

}

/// Manage Rust packages with cargo
class CargoOptions {
    
    executable: String?
    
    locked: Boolean?
    
    name: Listing<String>
    
    path: String?
    
    state: ("present"|"absent"|"latest")?
    
    version: String?
    
}

/// Task class for cargo
class Cargo extends Playbook.Task {

    /// todo doc
    `community.general.cargo`: Dynamic

    /// Options for community.general.cargo
    hidden options: CargoOptions?

    /// todo doc
    function configure(): Cargo = this
        .toMap()
        .put(
            "community.general.cargo",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Cargo)

}

/// Send a sms / mms using the catapult bandwidth api
class CatapultOptions {
    
    api_secret: String
    
    api_token: String
    
    dest: Listing<String>
    
    media: String?
    
    msg: String
    
    src: String
    
    user_id: String
    
}

/// Task class for catapult
class Catapult extends Playbook.Task {

    /// todo doc
    `community.general.catapult`: Dynamic

    /// Options for community.general.catapult
    hidden options: CatapultOptions?

    /// todo doc
    function configure(): Catapult = this
        .toMap()
        .put(
            "community.general.catapult",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Catapult)

}

/// Create an annotation in circonus
class CirconusAnnotationOptions {
    
    api_key: String
    
    category: String
    
    description: String
    
    duration: Int?
    
    start: Int?
    
    stop: Int?
    
    title: String
    
}

/// Task class for circonus_annotation
class CirconusAnnotation extends Playbook.Task {

    /// todo doc
    `community.general.circonus_annotation`: Dynamic

    /// Options for community.general.circonus_annotation
    hidden options: CirconusAnnotationOptions?

    /// todo doc
    function configure(): CirconusAnnotation = this
        .toMap()
        .put(
            "community.general.circonus_annotation",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(CirconusAnnotation)

}

/// Send a message to a Cisco Webex Teams Room or Individual
class CiscoWebexOptions {
    
    msg: String
    
    msg_type: ("text"|"markdown")?
    
    personal_token: String
    
    recipient_id: String
    
    recipient_type: ("roomId"|"toPersonEmail"|"toPersonId")
    
}

/// Task class for cisco_webex
class CiscoWebex extends Playbook.Task {

    /// todo doc
    `community.general.cisco_webex`: Dynamic

    /// Options for community.general.cisco_webex
    hidden options: CiscoWebexOptions?

    /// todo doc
    function configure(): CiscoWebex = this
        .toMap()
        .put(
            "community.general.cisco_webex",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(CiscoWebex)

}

/// Create or Delete Anti Affinity Policies at CenturyLink Cloud
class ClcAaPolicyOptions {
    
    location: String
    
    name: String
    
    state: ("present"|"absent")?
    
}

/// Task class for clc_aa_policy
class ClcAaPolicy extends Playbook.Task {

    /// todo doc
    `community.general.clc_aa_policy`: Dynamic

    /// Options for community.general.clc_aa_policy
    hidden options: ClcAaPolicyOptions?

    /// todo doc
    function configure(): ClcAaPolicy = this
        .toMap()
        .put(
            "community.general.clc_aa_policy",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ClcAaPolicy)

}

/// Create or Delete Alert Policies at CenturyLink Cloud
class ClcAlertPolicyOptions {
    
    alert_recipients: Listing<String>?
    
    alias: String
    
    duration: String?
    
    id: String?
    
    metric: ("cpu"|"memory"|"disk")?
    
    name: String?
    
    state: ("present"|"absent")?
    
    threshold: Int?
    
}

/// Task class for clc_alert_policy
class ClcAlertPolicy extends Playbook.Task {

    /// todo doc
    `community.general.clc_alert_policy`: Dynamic

    /// Options for community.general.clc_alert_policy
    hidden options: ClcAlertPolicyOptions?

    /// todo doc
    function configure(): ClcAlertPolicy = this
        .toMap()
        .put(
            "community.general.clc_alert_policy",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ClcAlertPolicy)

}

/// Deploys a blue print package on a set of servers in CenturyLink Cloud
class ClcBlueprintPackageOptions {
    
    package_id: String
    
    package_params: Any?
    
    server_ids: Listing<String>
    
    state: ("present")?
    
    wait: String?
    
}

/// Task class for clc_blueprint_package
class ClcBlueprintPackage extends Playbook.Task {

    /// todo doc
    `community.general.clc_blueprint_package`: Dynamic

    /// Options for community.general.clc_blueprint_package
    hidden options: ClcBlueprintPackageOptions?

    /// todo doc
    function configure(): ClcBlueprintPackage = this
        .toMap()
        .put(
            "community.general.clc_blueprint_package",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ClcBlueprintPackage)

}

/// Create/delete/update firewall policies
class ClcFirewallPolicyOptions {
    
    destination: Listing<String>?
    
    destination_account_alias: String?
    
    enabled: ("True"|"False")?
    
    firewall_policy_id: String?
    
    location: String
    
    ports: Listing<String>?
    
    source: Listing<String>?
    
    source_account_alias: String
    
    state: ("present"|"absent")?
    
    wait: String?
    
}

/// Task class for clc_firewall_policy
class ClcFirewallPolicy extends Playbook.Task {

    /// todo doc
    `community.general.clc_firewall_policy`: Dynamic

    /// Options for community.general.clc_firewall_policy
    hidden options: ClcFirewallPolicyOptions?

    /// todo doc
    function configure(): ClcFirewallPolicy = this
        .toMap()
        .put(
            "community.general.clc_firewall_policy",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ClcFirewallPolicy)

}

/// Create/delete Server Groups at Centurylink Cloud
class ClcGroupOptions {
    
    description: String?
    
    location: String?
    
    name: String
    
    parent: String?
    
    state: ("present"|"absent")?
    
    wait: Boolean?
    
}

/// Task class for clc_group
class ClcGroup extends Playbook.Task {

    /// todo doc
    `community.general.clc_group`: Dynamic

    /// Options for community.general.clc_group
    hidden options: ClcGroupOptions?

    /// todo doc
    function configure(): ClcGroup = this
        .toMap()
        .put(
            "community.general.clc_group",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ClcGroup)

}

/// Create, Delete shared loadbalancers in CenturyLink Cloud
class ClcLoadbalancerOptions {
    
    alias: String
    
    description: String?
    
    location: String
    
    method: ("leastConnection"|"roundRobin")?
    
    name: String
    
    nodes: Listing<Any>?
    
    persistence: ("standard"|"sticky")?
    
    port: ("80"|"443")?
    
    state: ("present"|"absent"|"port_absent"|"nodes_present"|"nodes_absent")?
    
    status: ("enabled"|"disabled")?
    
}

/// Task class for clc_loadbalancer
class ClcLoadbalancer extends Playbook.Task {

    /// todo doc
    `community.general.clc_loadbalancer`: Dynamic

    /// Options for community.general.clc_loadbalancer
    hidden options: ClcLoadbalancerOptions?

    /// todo doc
    function configure(): ClcLoadbalancer = this
        .toMap()
        .put(
            "community.general.clc_loadbalancer",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ClcLoadbalancer)

}

/// Modify servers in CenturyLink Cloud
class ClcModifyServerOptions {
    
    alert_policy_id: String?
    
    alert_policy_name: String?
    
    anti_affinity_policy_id: String?
    
    anti_affinity_policy_name: String?
    
    cpu: String?
    
    memory: String?
    
    server_ids: Listing<String>
    
    state: ("present"|"absent")?
    
    wait: Boolean?
    
}

/// Task class for clc_modify_server
class ClcModifyServer extends Playbook.Task {

    /// todo doc
    `community.general.clc_modify_server`: Dynamic

    /// Options for community.general.clc_modify_server
    hidden options: ClcModifyServerOptions?

    /// todo doc
    function configure(): ClcModifyServer = this
        .toMap()
        .put(
            "community.general.clc_modify_server",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ClcModifyServer)

}

/// Add and Delete public ips on servers in CenturyLink Cloud
class ClcPublicipOptions {
    
    ports: Listing<Int>?
    
    protocol: ("TCP"|"UDP"|"ICMP")?
    
    server_ids: Listing<String>
    
    state: ("present"|"absent")?
    
    wait: Boolean?
    
}

/// Task class for clc_publicip
class ClcPublicip extends Playbook.Task {

    /// todo doc
    `community.general.clc_publicip`: Dynamic

    /// Options for community.general.clc_publicip
    hidden options: ClcPublicipOptions?

    /// todo doc
    function configure(): ClcPublicip = this
        .toMap()
        .put(
            "community.general.clc_publicip",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ClcPublicip)

}

/// Create, Delete, Start and Stop servers in CenturyLink Cloud
class ClcServerOptions {
    
    add_public_ip: Boolean?
    
    additional_disks: Listing<Any>?
    
    alert_policy_id: String?
    
    alert_policy_name: String?
    
    alias: String?
    
    anti_affinity_policy_id: String?
    
    anti_affinity_policy_name: String?
    
    configuration_id: String?
    
    count: Int?
    
    count_group: String?
    
    cpu: Int?
    
    cpu_autoscale_policy_id: String?
    
    custom_fields: Listing<Any>?
    
    description: String?
    
    exact_count: Int?
    
    group: String?
    
    ip_address: String?
    
    location: String?
    
    managed_os: Boolean?
    
    memory: Int?
    
    name: String?
    
    network_id: String?
    
    os_type: ("redHat6_64Bit"|"centOS6_64Bit"|"windows2012R2Standard_64Bit"|"ubuntu14_64Bit")?
    
    packages: Listing<Any>?
    
    password: String?
    
    primary_dns: String?
    
    public_ip_ports: Listing<Any>?
    
    public_ip_protocol: ("TCP"|"UDP"|"ICMP")?
    
    secondary_dns: String?
    
    server_ids: Listing<String>?
    
    source_server_password: String?
    
    state: ("present"|"absent"|"started"|"stopped")?
    
    storage_type: ("standard"|"hyperscale")?
    
    template: String?
    
    ttl: String?
    
    type: ("standard"|"hyperscale"|"bareMetal")?
    
    wait: Boolean?
    
}

/// Task class for clc_server
class ClcServer extends Playbook.Task {

    /// todo doc
    `community.general.clc_server`: Dynamic

    /// Options for community.general.clc_server
    hidden options: ClcServerOptions?

    /// todo doc
    function configure(): ClcServer = this
        .toMap()
        .put(
            "community.general.clc_server",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ClcServer)

}

/// Create, Delete and Restore server snapshots in CenturyLink Cloud
class ClcServerSnapshotOptions {
    
    expiration_days: Int?
    
    server_ids: Listing<String>
    
    state: ("present"|"absent"|"restore")?
    
    wait: String?
    
}

/// Task class for clc_server_snapshot
class ClcServerSnapshot extends Playbook.Task {

    /// todo doc
    `community.general.clc_server_snapshot`: Dynamic

    /// Options for community.general.clc_server_snapshot
    hidden options: ClcServerSnapshotOptions?

    /// todo doc
    function configure(): ClcServerSnapshot = this
        .toMap()
        .put(
            "community.general.clc_server_snapshot",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ClcServerSnapshot)

}

/// Retrieve facts of cloud-init
class CloudInitDataFactsOptions {
    
    filter: ("status"|"result")?
    
}

/// Task class for cloud_init_data_facts
class CloudInitDataFacts extends Playbook.Task {

    /// todo doc
    `community.general.cloud_init_data_facts`: Dynamic

    /// Options for community.general.cloud_init_data_facts
    hidden options: CloudInitDataFactsOptions?

    /// todo doc
    function configure(): CloudInitDataFacts = this
        .toMap()
        .put(
            "community.general.cloud_init_data_facts",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(CloudInitDataFacts)

}

/// Manage Cloudflare DNS records
class CloudflareDnsOptions {
    
    account_api_key: String?
    
    account_email: String?
    
    algorithm: Int?
    
    api_token: String?
    
    cert_usage: Int?
    
    flag: Int?
    
    hash_type: Int?
    
    key_tag: Int?
    
    port: Int?
    
    priority: Int?
    
    proto: String?
    
    proxied: Boolean?
    
    `record`: String?
    
    selector: Int?
    
    service: String?
    
    solo: Boolean?
    
    state: ("absent"|"present")?
    
    tag: ("issue"|"issuewild"|"iodef")?
    
    timeout: Int?
    
    ttl: Int?
    
    type: ("A"|"AAAA"|"CNAME"|"DS"|"MX"|"NS"|"SPF"|"SRV"|"SSHFP"|"TLSA"|"CAA"|"TXT")?
    
    value: String?
    
    weight: Int?
    
    zone: String
    
}

/// Task class for cloudflare_dns
class CloudflareDns extends Playbook.Task {

    /// todo doc
    `community.general.cloudflare_dns`: Dynamic

    /// Options for community.general.cloudflare_dns
    hidden options: CloudflareDnsOptions?

    /// todo doc
    function configure(): CloudflareDns = this
        .toMap()
        .put(
            "community.general.cloudflare_dns",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(CloudflareDns)

}

/// Sync Cobbler
class CobblerSyncOptions {
    
    host: String?
    
    password: String?
    
    port: Int?
    
    use_ssl: Boolean?
    
    username: String?
    
    validate_certs: Boolean?
    
}

/// Task class for cobbler_sync
class CobblerSync extends Playbook.Task {

    /// todo doc
    `community.general.cobbler_sync`: Dynamic

    /// Options for community.general.cobbler_sync
    hidden options: CobblerSyncOptions?

    /// todo doc
    function configure(): CobblerSync = this
        .toMap()
        .put(
            "community.general.cobbler_sync",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(CobblerSync)

}

/// Manage system objects in Cobbler
class CobblerSystemOptions {
    
    host: String?
    
    interfaces: Any?
    
    name: String?
    
    password: String?
    
    port: Int?
    
    properties: Any?
    
    state: ("absent"|"present"|"query")?
    
    sync: Boolean?
    
    use_ssl: Boolean?
    
    username: String?
    
    validate_certs: Boolean?
    
}

/// Task class for cobbler_system
class CobblerSystem extends Playbook.Task {

    /// todo doc
    `community.general.cobbler_system`: Dynamic

    /// Options for community.general.cobbler_system
    hidden options: CobblerSystemOptions?

    /// todo doc
    function configure(): CobblerSystem = this
        .toMap()
        .put(
            "community.general.cobbler_system",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(CobblerSystem)

}

/// Dependency Manager for PHP
class ComposerOptions {
    
    apcu_autoloader: Boolean?
    
    arguments: String?
    
    classmap_authoritative: Boolean?
    
    command: String?
    
    composer_executable: String?
    
    executable: String?
    
    global_command: Boolean?
    
    ignore_platform_reqs: Boolean?
    
    no_dev: Boolean?
    
    no_plugins: Boolean?
    
    no_scripts: Boolean?
    
    optimize_autoloader: Boolean?
    
    prefer_dist: Boolean?
    
    prefer_source: Boolean?
    
    working_dir: String?
    
}

/// Task class for composer
class Composer extends Playbook.Task {

    /// todo doc
    `community.general.composer`: Dynamic

    /// Options for community.general.composer
    hidden options: ComposerOptions?

    /// todo doc
    function configure(): Composer = this
        .toMap()
        .put(
            "community.general.composer",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Composer)

}

/// Add, modify & delete services within a consul cluster
class ConsulOptions {
    
    ack_params_state_absent: Boolean?
    
    check_host: String?
    
    check_id: String?
    
    check_name: String?
    
    check_node: String?
    
    host: String?
    
    http: String?
    
    interval: String?
    
    notes: String?
    
    port: Int?
    
    scheme: String?
    
    script: String?
    
    service_address: String?
    
    service_id: String?
    
    service_name: String?
    
    service_port: Int?
    
    state: ("present"|"absent")?
    
    tags: Listing<String>?
    
    tcp: String?
    
    timeout: String?
    
    token: String?
    
    ttl: String?
    
    validate_certs: Boolean?
    
}

/// Task class for consul
class Consul extends Playbook.Task {

    /// todo doc
    `community.general.consul`: Dynamic

    /// Options for community.general.consul
    hidden options: ConsulOptions?

    /// todo doc
    function configure(): Consul = this
        .toMap()
        .put(
            "community.general.consul",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Consul)

}

/// Manipulate Consul ACL keys and rules
class ConsulAclOptions {
    
    host: String?
    
    mgmt_token: String
    
    name: String?
    
    port: Int?
    
    rules: Listing<Any>?
    
    scheme: String?
    
    state: ("present"|"absent")?
    
    token: String?
    
    token_type: ("client"|"management")?
    
    validate_certs: Boolean?
    
}

/// Task class for consul_acl
class ConsulAcl extends Playbook.Task {

    /// todo doc
    `community.general.consul_acl`: Dynamic

    /// Options for community.general.consul_acl
    hidden options: ConsulAclOptions?

    /// todo doc
    function configure(): ConsulAcl = this
        .toMap()
        .put(
            "community.general.consul_acl",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ConsulAcl)

}

/// Bootstrap ACLs in Consul
class ConsulAclBootstrapOptions {
    
    bootstrap_secret: String?
    
    state: ("present"|"bootstrapped")?
    
}

/// Task class for consul_acl_bootstrap
class ConsulAclBootstrap extends Playbook.Task {

    /// todo doc
    `community.general.consul_acl_bootstrap`: Dynamic

    /// Options for community.general.consul_acl_bootstrap
    hidden options: ConsulAclBootstrapOptions?

    /// todo doc
    function configure(): ConsulAclBootstrap = this
        .toMap()
        .put(
            "community.general.consul_acl_bootstrap",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ConsulAclBootstrap)

}

/// Manipulate Consul auth methods
class ConsulAuthMethodOptions {
    
    config: Any?
    
    description: String?
    
    display_name: String?
    
    max_token_ttl: String?
    
    name: String
    
    state: ("present"|"absent")?
    
    token_locality: ("local"|"global")?
    
    type: ("kubernetes"|"jwt"|"oidc"|"aws-iam")?
    
}

/// Task class for consul_auth_method
class ConsulAuthMethod extends Playbook.Task {

    /// todo doc
    `community.general.consul_auth_method`: Dynamic

    /// Options for community.general.consul_auth_method
    hidden options: ConsulAuthMethodOptions?

    /// todo doc
    function configure(): ConsulAuthMethod = this
        .toMap()
        .put(
            "community.general.consul_auth_method",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ConsulAuthMethod)

}

/// Manipulate Consul binding rules
class ConsulBindingRuleOptions {
    
    auth_method: String
    
    bind_name: String?
    
    bind_type: ("service"|"node"|"role"|"templated-policy")?
    
    bind_vars: Any?
    
    description: String?
    
    name: String
    
    selector: String?
    
    state: ("present"|"absent")?
    
}

/// Task class for consul_binding_rule
class ConsulBindingRule extends Playbook.Task {

    /// todo doc
    `community.general.consul_binding_rule`: Dynamic

    /// Options for community.general.consul_binding_rule
    hidden options: ConsulBindingRuleOptions?

    /// todo doc
    function configure(): ConsulBindingRule = this
        .toMap()
        .put(
            "community.general.consul_binding_rule",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ConsulBindingRule)

}

/// Manipulate entries in the key/value store of a consul cluster
class ConsulKvOptions {
    
    cas: String?
    
    flags: String?
    
    host: String?
    
    key: String
    
    port: Int?
    
    recurse: Boolean?
    
    retrieve: Boolean?
    
    scheme: String?
    
    session: String?
    
    state: ("absent"|"acquire"|"present"|"release")?
    
    token: String?
    
    validate_certs: Boolean?
    
    value: String?
    
}

/// Task class for consul_kv
class ConsulKv extends Playbook.Task {

    /// todo doc
    `community.general.consul_kv`: Dynamic

    /// Options for community.general.consul_kv
    hidden options: ConsulKvOptions?

    /// todo doc
    function configure(): ConsulKv = this
        .toMap()
        .put(
            "community.general.consul_kv",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ConsulKv)

}

/// Manipulate Consul policies
class ConsulPolicyOptions {
    
    description: String?
    
    name: String
    
    rules: String?
    
    state: ("present"|"absent")?
    
    valid_datacenters: Listing<String>?
    
}

/// Task class for consul_policy
class ConsulPolicy extends Playbook.Task {

    /// todo doc
    `community.general.consul_policy`: Dynamic

    /// Options for community.general.consul_policy
    hidden options: ConsulPolicyOptions?

    /// todo doc
    function configure(): ConsulPolicy = this
        .toMap()
        .put(
            "community.general.consul_policy",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ConsulPolicy)

}

/// Manipulate Consul roles
class ConsulRoleOptions {
    
    description: String?
    
    name: String
    
    node_identities: Listing<Any>?
    
    policies: Listing<Any>?
    
    service_identities: Listing<Any>?
    
    state: ("present"|"absent")?
    
    templated_policies: Listing<Any>?
    
}

/// Task class for consul_role
class ConsulRole extends Playbook.Task {

    /// todo doc
    `community.general.consul_role`: Dynamic

    /// Options for community.general.consul_role
    hidden options: ConsulRoleOptions?

    /// todo doc
    function configure(): ConsulRole = this
        .toMap()
        .put(
            "community.general.consul_role",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ConsulRole)

}

/// Manipulate consul sessions
class ConsulSessionOptions {
    
    behavior: ("delete"|"release")?
    
    checks: Listing<String>?
    
    datacenter: String?
    
    delay: Int?
    
    id: String?
    
    name: String?
    
    node: String?
    
    state: ("absent"|"info"|"list"|"node"|"present")?
    
    token: Any?
    
    ttl: Int?
    
}

/// Task class for consul_session
class ConsulSession extends Playbook.Task {

    /// todo doc
    `community.general.consul_session`: Dynamic

    /// Options for community.general.consul_session
    hidden options: ConsulSessionOptions?

    /// todo doc
    function configure(): ConsulSession = this
        .toMap()
        .put(
            "community.general.consul_session",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ConsulSession)

}

/// Manipulate Consul tokens
class ConsulTokenOptions {
    
    accessor_id: String?
    
    description: String?
    
    expiration_ttl: String?
    
    `local`: Boolean?
    
    node_identities: Listing<Any>?
    
    policies: Listing<Any>?
    
    roles: Listing<Any>?
    
    secret_id: String?
    
    service_identities: Listing<Any>?
    
    state: ("present"|"absent")?
    
    templated_policies: Listing<Any>?
    
}

/// Task class for consul_token
class ConsulToken extends Playbook.Task {

    /// todo doc
    `community.general.consul_token`: Dynamic

    /// Options for community.general.consul_token
    hidden options: ConsulTokenOptions?

    /// todo doc
    function configure(): ConsulToken = this
        .toMap()
        .put(
            "community.general.consul_token",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ConsulToken)

}

/// Manage one of the Copr repositories
class CoprOptions {
    
    chroot: String?
    
    host: String?
    
    name: String
    
    protocol: String?
    
    state: ("absent"|"enabled"|"disabled")?
    
}

/// Task class for copr
class Copr extends Playbook.Task {

    /// todo doc
    `community.general.copr`: Dynamic

    /// Options for community.general.copr
    hidden options: CoprOptions?

    /// todo doc
    function configure(): Copr = this
        .toMap()
        .put(
            "community.general.copr",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Copr)

}

/// Manages Perl library dependencies
class CpanmOptions {
    
    executable: String?
    
    from_path: String?
    
    installdeps: Boolean?
    
    locallib: String?
    
    mirror: String?
    
    mirror_only: Boolean?
    
    mode: ("compatibility"|"new")?
    
    name: String?
    
    name_check: String?
    
    notest: Boolean?
    
    version: String?
    
}

/// Task class for cpanm
class Cpanm extends Playbook.Task {

    /// todo doc
    `community.general.cpanm`: Dynamic

    /// Options for community.general.cpanm
    hidden options: CpanmOptions?

    /// todo doc
    function configure(): Cpanm = this
        .toMap()
        .put(
            "community.general.cpanm",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Cpanm)

}

/// Manage variables in crontabs
class CronvarOptions {
    
    backup: Boolean?
    
    cron_file: String?
    
    insertafter: String?
    
    insertbefore: String?
    
    name: String
    
    state: ("absent"|"present")?
    
    user: String?
    
    value: String?
    
}

/// Task class for cronvar
class Cronvar extends Playbook.Task {

    /// todo doc
    `community.general.cronvar`: Dynamic

    /// Options for community.general.cronvar
    hidden options: CronvarOptions?

    /// todo doc
    function configure(): Cronvar = this
        .toMap()
        .put(
            "community.general.cronvar",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Cronvar)

}

/// Encrypted Linux block devices
class CrypttabOptions {
    
    backing_device: String?
    
    name: String
    
    opts: String?
    
    password: String?
    
    path: String?
    
    state: ("absent"|"opts_absent"|"opts_present"|"present")
    
}

/// Task class for crypttab
class Crypttab extends Playbook.Task {

    /// todo doc
    `community.general.crypttab`: Dynamic

    /// Options for community.general.crypttab
    hidden options: CrypttabOptions?

    /// todo doc
    function configure(): Crypttab = this
        .toMap()
        .put(
            "community.general.crypttab",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Crypttab)

}

/// Manages Datadog downtimes
class DatadogDowntimeOptions {
    
    api_host: String?
    
    api_key: String
    
    app_key: String
    
    downtime_message: String?
    
    end: Int?
    
    id: Int?
    
    monitor_id: Int?
    
    monitor_tags: Listing<String>?
    
    rrule: String?
    
    scope: Listing<String>?
    
    start: Int?
    
    state: ("present"|"absent")?
    
    timezone: String?
    
}

/// Task class for datadog_downtime
class DatadogDowntime extends Playbook.Task {

    /// todo doc
    `community.general.datadog_downtime`: Dynamic

    /// Options for community.general.datadog_downtime
    hidden options: DatadogDowntimeOptions?

    /// todo doc
    function configure(): DatadogDowntime = this
        .toMap()
        .put(
            "community.general.datadog_downtime",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(DatadogDowntime)

}

/// Posts events to Datadog  service
class DatadogEventOptions {
    
    aggregation_key: String?
    
    alert_type: ("error"|"warning"|"info"|"success")?
    
    api_host: String?
    
    api_key: String
    
    app_key: String
    
    date_happened: Int?
    
    host: String?
    
    priority: ("normal"|"low")?
    
    tags: Listing<String>?
    
    text: String
    
    title: String
    
    validate_certs: Boolean?
    
}

/// Task class for datadog_event
class DatadogEvent extends Playbook.Task {

    /// todo doc
    `community.general.datadog_event`: Dynamic

    /// Options for community.general.datadog_event
    hidden options: DatadogEventOptions?

    /// todo doc
    function configure(): DatadogEvent = this
        .toMap()
        .put(
            "community.general.datadog_event",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(DatadogEvent)

}

/// Manages Datadog monitors
class DatadogMonitorOptions {
    
    api_host: String?
    
    api_key: String
    
    app_key: String
    
    escalation_message: String?
    
    evaluation_delay: String?
    
    id: String?
    
    include_tags: Boolean?
    
    locked: Boolean?
    
    name: String
    
    new_host_delay: String?
    
    no_data_timeframe: String?
    
    notification_message: String?
    
    notification_preset_name: ("show_all"|"hide_query"|"hide_handles"|"hide_all")?
    
    notify_audit: Boolean?
    
    notify_no_data: Boolean?
    
    priority: Int?
    
    query: String?
    
    renotify_interval: String?
    
    renotify_occurrences: Int?
    
    renotify_statuses: Listing<("alert"|"warn"|"no data")>?
    
    require_full_window: Boolean?
    
    silenced: Any?
    
    state: ("present"|"absent"|"mute"|"unmute")
    
    tags: Listing<String>?
    
    thresholds: Any?
    
    timeout_h: String?
    
    type: ("metric alert"|"service check"|"event alert"|"event-v2 alert"|"process alert"|"log alert"|"query alert"|"trace-analytics alert"|"rum alert"|"composite")?
    
}

/// Task class for datadog_monitor
class DatadogMonitor extends Playbook.Task {

    /// todo doc
    `community.general.datadog_monitor`: Dynamic

    /// Options for community.general.datadog_monitor
    hidden options: DatadogMonitorOptions?

    /// todo doc
    function configure(): DatadogMonitor = this
        .toMap()
        .put(
            "community.general.datadog_monitor",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(DatadogMonitor)

}

/// Modify and read dconf database
class DconfOptions {
    
    key: String
    
    state: ("read"|"present"|"absent")?
    
    value: String?
    
}

/// Task class for dconf
class Dconf extends Playbook.Task {

    /// todo doc
    `community.general.dconf`: Dynamic

    /// Options for community.general.dconf
    hidden options: DconfOptions?

    /// todo doc
    function configure(): Dconf = this
        .toMap()
        .put(
            "community.general.dconf",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Dconf)

}

/// Manages some of the steps common in deploying projects
class DeployHelperOptions {
    
    clean: Boolean?
    
    current_path: String?
    
    keep_releases: Int?
    
    path: String
    
    release: String?
    
    releases_path: String?
    
    shared_path: String?
    
    state: ("present"|"finalize"|"absent"|"clean"|"query")?
    
    unfinished_filename: String?
    
}

/// Task class for deploy_helper
class DeployHelper extends Playbook.Task {

    /// todo doc
    `community.general.deploy_helper`: Dynamic

    /// Options for community.general.deploy_helper
    hidden options: DeployHelperOptions?

    /// todo doc
    function configure(): DeployHelper = this
        .toMap()
        .put(
            "community.general.deploy_helper",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(DeployHelper)

}

/// Create, update, and delete MCP 1.0 & 2.0 networks
class DimensiondataNetworkOptions {
    
    description: String?
    
    name: String
    
    service_plan: ("ESSENTIALS"|"ADVANCED")?
    
    state: ("present"|"absent")?
    
}

/// Task class for dimensiondata_network
class DimensiondataNetwork extends Playbook.Task {

    /// todo doc
    `community.general.dimensiondata_network`: Dynamic

    /// Options for community.general.dimensiondata_network
    hidden options: DimensiondataNetworkOptions?

    /// todo doc
    function configure(): DimensiondataNetwork = this
        .toMap()
        .put(
            "community.general.dimensiondata_network",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(DimensiondataNetwork)

}

/// Manage a VLAN in a Cloud Control network domain
class DimensiondataVlanOptions {
    
    allow_expand: Boolean?
    
    description: String?
    
    name: String
    
    network_domain: String
    
    private_ipv4_base_address: String?
    
    private_ipv4_prefix_size: Int?
    
    state: ("present"|"absent"|"readonly")?
    
}

/// Task class for dimensiondata_vlan
class DimensiondataVlan extends Playbook.Task {

    /// todo doc
    `community.general.dimensiondata_vlan`: Dynamic

    /// Options for community.general.dimensiondata_vlan
    hidden options: DimensiondataVlanOptions?

    /// todo doc
    function configure(): DimensiondataVlan = this
        .toMap()
        .put(
            "community.general.dimensiondata_vlan",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(DimensiondataVlan)

}

/// Send Discord messages
class DiscordOptions {
    
    avatar_url: String?
    
    content: String?
    
    embeds: Listing<Any>?
    
    tts: Boolean?
    
    username: String?
    
    webhook_id: String
    
    webhook_token: String
    
}

/// Task class for discord
class Discord extends Playbook.Task {

    /// todo doc
    `community.general.discord`: Dynamic

    /// Options for community.general.discord
    hidden options: DiscordOptions?

    /// todo doc
    function configure(): Discord = this
        .toMap()
        .put(
            "community.general.discord",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Discord)

}

/// Manages a Django application
class DjangoManageOptions {
    
    ack_venv_creation_deprecation: Boolean?
    
    apps: String?
    
    cache_table: String?
    
    clear: Boolean?
    
    command: String
    
    database: String?
    
    failfast: Boolean?
    
    fixtures: String?
    
    link: Boolean?
    
    merge: Boolean?
    
    project_path: String
    
    pythonpath: String?
    
    settings: String?
    
    skip: Boolean?
    
    testrunner: String?
    
    virtualenv: String?
    
}

/// Task class for django_manage
class DjangoManage extends Playbook.Task {

    /// todo doc
    `community.general.django_manage`: Dynamic

    /// Options for community.general.django_manage
    hidden options: DjangoManageOptions?

    /// todo doc
    function configure(): DjangoManage = this
        .toMap()
        .put(
            "community.general.django_manage",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(DjangoManage)

}

/// Enable or disable dnf repositories using config-manager
class DnfConfigManagerOptions {
    
    name: Listing<String>?
    
    state: ("enabled"|"disabled")?
    
}

/// Task class for dnf_config_manager
class DnfConfigManager extends Playbook.Task {

    /// todo doc
    `community.general.dnf_config_manager`: Dynamic

    /// Options for community.general.dnf_config_manager
    hidden options: DnfConfigManagerOptions?

    /// todo doc
    function configure(): DnfConfigManager = this
        .toMap()
        .put(
            "community.general.dnf_config_manager",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(DnfConfigManager)

}

/// Locks package versions in C(dnf) based systems
class DnfVersionlockOptions {
    
    name: Listing<String>?
    
    raw: Boolean?
    
    state: ("absent"|"clean"|"excluded"|"present")?
    
}

/// Task class for dnf_versionlock
class DnfVersionlock extends Playbook.Task {

    /// todo doc
    `community.general.dnf_versionlock`: Dynamic

    /// Options for community.general.dnf_versionlock
    hidden options: DnfVersionlockOptions?

    /// todo doc
    function configure(): DnfVersionlock = this
        .toMap()
        .put(
            "community.general.dnf_versionlock",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(DnfVersionlock)

}

/// Interface with dnsimple.com (a DNS hosting service)
class DnsimpleOptions {
    
    account_api_token: String?
    
    account_email: String?
    
    domain: String?
    
    priority: Int?
    
    `record`: String?
    
    record_ids: Listing<String>?
    
    sandbox: Boolean?
    
    solo: Boolean?
    
    state: ("present"|"absent")?
    
    ttl: Int?
    
    type: ("A"|"ALIAS"|"CNAME"|"MX"|"SPF"|"URL"|"TXT"|"NS"|"SRV"|"NAPTR"|"PTR"|"AAAA"|"SSHFP"|"HINFO"|"POOL"|"CAA")?
    
    value: String?
    
}

/// Task class for dnsimple
class Dnsimple extends Playbook.Task {

    /// todo doc
    `community.general.dnsimple`: Dynamic

    /// Options for community.general.dnsimple
    hidden options: DnsimpleOptions?

    /// todo doc
    function configure(): Dnsimple = this
        .toMap()
        .put(
            "community.general.dnsimple",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Dnsimple)

}

/// Pull basic info from DNSimple API
class DnsimpleInfoOptions {
    
    account_id: String
    
    api_key: String
    
    name: String?
    
    `record`: String?
    
    sandbox: Boolean?
    
}

/// Task class for dnsimple_info
class DnsimpleInfo extends Playbook.Task {

    /// todo doc
    `community.general.dnsimple_info`: Dynamic

    /// Options for community.general.dnsimple_info
    hidden options: DnsimpleInfoOptions?

    /// todo doc
    function configure(): DnsimpleInfo = this
        .toMap()
        .put(
            "community.general.dnsimple_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(DnsimpleInfo)

}

/// Interface with dnsmadeeasy.com (a DNS hosting service)
class DnsmadeeasyOptions {
    
    account_key: String
    
    account_secret: String
    
    autoFailover: Boolean?
    
    contactList: String?
    
    domain: String
    
    failover: Boolean?
    
    httpFile: String?
    
    httpFqdn: String?
    
    httpQueryString: String?
    
    ip1: String?
    
    ip2: String?
    
    ip3: String?
    
    ip4: String?
    
    ip5: String?
    
    maxEmails: Int?
    
    monitor: Boolean?
    
    port: Int?
    
    protocol: ("TCP"|"UDP"|"HTTP"|"DNS"|"SMTP"|"HTTPS")?
    
    record_name: String?
    
    record_ttl: Int?
    
    record_type: ("A"|"AAAA"|"CNAME"|"ANAME"|"HTTPRED"|"MX"|"NS"|"PTR"|"SRV"|"TXT")?
    
    record_value: String?
    
    sandbox: Boolean?
    
    sensitivity: ("Low"|"Medium"|"High")?
    
    state: ("present"|"absent")
    
    systemDescription: String?
    
    validate_certs: Boolean?
    
}

/// Task class for dnsmadeeasy
class Dnsmadeeasy extends Playbook.Task {

    /// todo doc
    `community.general.dnsmadeeasy`: Dynamic

    /// Options for community.general.dnsmadeeasy
    hidden options: DnsmadeeasyOptions?

    /// todo doc
    function configure(): Dnsmadeeasy = this
        .toMap()
        .put(
            "community.general.dnsmadeeasy",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Dnsmadeeasy)

}

/// Override a debian package's version of a file
class DpkgDivertOptions {
    
    divert: String?
    
    force: Boolean?
    
    holder: String?
    
    path: String
    
    rename: Boolean?
    
    state: ("absent"|"present")?
    
}

/// Task class for dpkg_divert
class DpkgDivert extends Playbook.Task {

    /// todo doc
    `community.general.dpkg_divert`: Dynamic

    /// Options for community.general.dpkg_divert
    hidden options: DpkgDivertOptions?

    /// todo doc
    function configure(): DpkgDivert = this
        .toMap()
        .put(
            "community.general.dpkg_divert",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(DpkgDivert)

}

/// Installs Python libraries
class EasyInstallOptions {
    
    executable: String?
    
    name: String
    
    state: ("present"|"latest")?
    
    virtualenv: String?
    
    virtualenv_command: String?
    
    virtualenv_site_packages: Boolean?
    
}

/// Task class for easy_install
class EasyInstall extends Playbook.Task {

    /// todo doc
    `community.general.easy_install`: Dynamic

    /// Options for community.general.easy_install
    hidden options: EasyInstallOptions?

    /// todo doc
    function configure(): EasyInstall = this
        .toMap()
        .put(
            "community.general.easy_install",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(EasyInstall)

}

/// Manages users for ejabberd servers
class EjabberdUserOptions {
    
    host: String
    
    logging: Boolean?
    
    password: String?
    
    state: ("present"|"absent")?
    
    username: String
    
}

/// Task class for ejabberd_user
class EjabberdUser extends Playbook.Task {

    /// todo doc
    `community.general.ejabberd_user`: Dynamic

    /// Options for community.general.ejabberd_user
    hidden options: EjabberdUserOptions?

    /// todo doc
    function configure(): EjabberdUser = this
        .toMap()
        .put(
            "community.general.ejabberd_user",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(EjabberdUser)

}

/// Manage Elasticsearch plugins
class ElasticsearchPluginOptions {
    
    force: Boolean?
    
    name: String
    
    plugin_bin: String?
    
    plugin_dir: String?
    
    proxy_host: String?
    
    proxy_port: String?
    
    src: String?
    
    state: ("present"|"absent")?
    
    timeout: String?
    
    url: String?
    
    version: String?
    
}

/// Task class for elasticsearch_plugin
class ElasticsearchPlugin extends Playbook.Task {

    /// todo doc
    `community.general.elasticsearch_plugin`: Dynamic

    /// Options for community.general.elasticsearch_plugin
    hidden options: ElasticsearchPluginOptions?

    /// todo doc
    function configure(): ElasticsearchPlugin = this
        .toMap()
        .put(
            "community.general.elasticsearch_plugin",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ElasticsearchPlugin)

}

/// Manage storage group member on EMC VNX
class EmcVnxSgMemberOptions {
    
    lunid: Int
    
    name: String
    
    state: ("present"|"absent")?
    
}

/// Task class for emc_vnx_sg_member
class EmcVnxSgMember extends Playbook.Task {

    /// todo doc
    `community.general.emc_vnx_sg_member`: Dynamic

    /// Options for community.general.emc_vnx_sg_member
    hidden options: EmcVnxSgMemberOptions?

    /// todo doc
    function configure(): EmcVnxSgMember = this
        .toMap()
        .put(
            "community.general.emc_vnx_sg_member",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(EmcVnxSgMember)

}

/// Set or delete key value pairs from an etcd3 cluster
class Etcd3Options {
    
    ca_cert: String?
    
    client_cert: String?
    
    client_key: String?
    
    host: String?
    
    key: String
    
    password: String?
    
    port: Int?
    
    state: ("present"|"absent")
    
    timeout: Int?
    
    user: String?
    
    value: String
    
}

/// Task class for etcd3
class Etcd3 extends Playbook.Task {

    /// todo doc
    `community.general.etcd3`: Dynamic

    /// Options for community.general.etcd3
    hidden options: Etcd3Options?

    /// todo doc
    function configure(): Etcd3 = this
        .toMap()
        .put(
            "community.general.etcd3",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Etcd3)

}

/// Runs the discovery program C(facter) on the remote system
class FacterOptions {
    
    arguments: Listing<String>?
    
}

/// Task class for facter
class Facter extends Playbook.Task {

    /// todo doc
    `community.general.facter`: Dynamic

    /// Options for community.general.facter
    hidden options: FacterOptions?

    /// todo doc
    function configure(): Facter = this
        .toMap()
        .put(
            "community.general.facter",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Facter)

}

/// Runs the discovery program C(facter) on the remote system and return Ansible facts
class FacterFactsOptions {
    
    arguments: Listing<String>?
    
}

/// Task class for facter_facts
class FacterFacts extends Playbook.Task {

    /// todo doc
    `community.general.facter_facts`: Dynamic

    /// Options for community.general.facter_facts
    hidden options: FacterFactsOptions?

    /// todo doc
    function configure(): FacterFacts = this
        .toMap()
        .put(
            "community.general.facter_facts",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(FacterFacts)

}

/// Create a file with a given size, or resize it if it exists
class FilesizeOptions {
    
    blocksize: String?
    
    force: Boolean?
    
    path: String
    
    size: String
    
    source: String?
    
    sparse: Boolean?
    
    unsafe_writes: Any?
    
}

/// Task class for filesize
class Filesize extends Playbook.Task {

    /// todo doc
    `community.general.filesize`: Dynamic

    /// Options for community.general.filesize
    hidden options: FilesizeOptions?

    /// todo doc
    function configure(): Filesize = this
        .toMap()
        .put(
            "community.general.filesize",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Filesize)

}

/// Makes a filesystem
class FilesystemOptions {
    
    dev: String
    
    force: Boolean?
    
    fstype: ("btrfs"|"ext2"|"ext3"|"ext4"|"ext4dev"|"f2fs"|"lvm"|"ocfs2"|"reiserfs"|"xfs"|"vfat"|"swap"|"ufs")?
    
    opts: String?
    
    resizefs: Boolean?
    
    state: ("present"|"absent")?
    
    uuid: String?
    
}

/// Task class for filesystem
class Filesystem extends Playbook.Task {

    /// todo doc
    `community.general.filesystem`: Dynamic

    /// Options for community.general.filesystem
    hidden options: FilesystemOptions?

    /// todo doc
    function configure(): Filesystem = this
        .toMap()
        .put(
            "community.general.filesystem",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Filesystem)

}

/// Manage flatpaks
class FlatpakOptions {
    
    executable: String?
    
    method: ("system"|"user")?
    
    name: Listing<String>
    
    no_dependencies: Boolean?
    
    remote: String?
    
    state: ("absent"|"present")?
    
}

/// Task class for flatpak
class Flatpak extends Playbook.Task {

    /// todo doc
    `community.general.flatpak`: Dynamic

    /// Options for community.general.flatpak
    hidden options: FlatpakOptions?

    /// todo doc
    function configure(): Flatpak = this
        .toMap()
        .put(
            "community.general.flatpak",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Flatpak)

}

/// Manage flatpak repository remotes
class FlatpakRemoteOptions {
    
    enabled: Boolean?
    
    executable: String?
    
    flatpakrepo_url: String?
    
    method: ("system"|"user")?
    
    name: String
    
    state: ("absent"|"present")?
    
}

/// Task class for flatpak_remote
class FlatpakRemote extends Playbook.Task {

    /// todo doc
    `community.general.flatpak_remote`: Dynamic

    /// Options for community.general.flatpak_remote
    hidden options: FlatpakRemoteOptions?

    /// todo doc
    function configure(): FlatpakRemote = this
        .toMap()
        .put(
            "community.general.flatpak_remote",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(FlatpakRemote)

}

/// Send a message to a flowdock
class FlowdockOptions {
    
    external_user_name: String?
    
    from_address: String?
    
    from_name: String?
    
    link: String?
    
    msg: String
    
    project: String?
    
    reply_to: String?
    
    source: String?
    
    subject: String?
    
    tags: String?
    
    token: String
    
    type: ("inbox"|"chat")
    
    validate_certs: Boolean?
    
}

/// Task class for flowdock
class Flowdock extends Playbook.Task {

    /// todo doc
    `community.general.flowdock`: Dynamic

    /// Options for community.general.flowdock
    hidden options: FlowdockOptions?

    /// todo doc
    function configure(): Flowdock = this
        .toMap()
        .put(
            "community.general.flowdock",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Flowdock)

}

/// Manage Gandi LiveDNS records
class GandiLivednsOptions {
    
    api_key: String
    
    domain: String
    
    `record`: String
    
    state: ("absent"|"present")?
    
    ttl: Int?
    
    type: String
    
    values: Listing<String>?
    
}

/// Task class for gandi_livedns
class GandiLivedns extends Playbook.Task {

    /// todo doc
    `community.general.gandi_livedns`: Dynamic

    /// Options for community.general.gandi_livedns
    hidden options: GandiLivednsOptions?

    /// todo doc
    function configure(): GandiLivedns = this
        .toMap()
        .put(
            "community.general.gandi_livedns",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GandiLivedns)

}

/// Edit GNOME Configurations
class Gconftool2Options {
    
    config_source: String?
    
    direct: Boolean?
    
    key: String
    
    state: ("absent"|"present")
    
    value: String?
    
    value_type: ("bool"|"float"|"int"|"string")?
    
}

/// Task class for gconftool2
class Gconftool2 extends Playbook.Task {

    /// todo doc
    `community.general.gconftool2`: Dynamic

    /// Options for community.general.gconftool2
    hidden options: Gconftool2Options?

    /// todo doc
    function configure(): Gconftool2 = this
        .toMap()
        .put(
            "community.general.gconftool2",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Gconftool2)

}

/// Retrieve GConf configurations
class Gconftool2InfoOptions {
    
    key: String
    
}

/// Task class for gconftool2_info
class Gconftool2Info extends Playbook.Task {

    /// todo doc
    `community.general.gconftool2_info`: Dynamic

    /// Options for community.general.gconftool2_info
    hidden options: Gconftool2InfoOptions?

    /// todo doc
    function configure(): Gconftool2Info = this
        .toMap()
        .put(
            "community.general.gconftool2_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Gconftool2Info)

}

/// Manage Ruby gems
class GemOptions {
    
    bindir: String?
    
    build_flags: String?
    
    env_shebang: Boolean?
    
    executable: String?
    
    force: Boolean?
    
    gem_source: String?
    
    include_dependencies: Boolean?
    
    include_doc: Boolean?
    
    install_dir: String?
    
    name: String
    
    norc: Boolean?
    
    pre_release: Boolean?
    
    repository: String?
    
    state: ("present"|"absent"|"latest")?
    
    user_install: Boolean?
    
    version: String?
    
}

/// Task class for gem
class Gem extends Playbook.Task {

    /// todo doc
    `community.general.gem`: Dynamic

    /// Options for community.general.gem
    hidden options: GemOptions?

    /// todo doc
    function configure(): Gem = this
        .toMap()
        .put(
            "community.general.gem",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Gem)

}

/// Set default handler for MIME type, for applications using Gnome GIO
class GioMimeOptions {
    
    handler: String
    
    mime_type: String
    
}

/// Task class for gio_mime
class GioMime extends Playbook.Task {

    /// todo doc
    `community.general.gio_mime`: Dynamic

    /// Options for community.general.gio_mime
    hidden options: GioMimeOptions?

    /// todo doc
    function configure(): GioMime = this
        .toMap()
        .put(
            "community.general.gio_mime",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GioMime)

}

/// Read and write git configuration
class GitConfigOptions {
    
    add_mode: ("add"|"replace-all")?
    
    file: String?
    
    list_all: Boolean?
    
    name: String?
    
    repo: String?
    
    scope: ("file"|"local"|"global"|"system")?
    
    state: ("present"|"absent")?
    
    value: String?
    
}

/// Task class for git_config
class GitConfig extends Playbook.Task {

    /// todo doc
    `community.general.git_config`: Dynamic

    /// Options for community.general.git_config
    hidden options: GitConfigOptions?

    /// todo doc
    function configure(): GitConfig = this
        .toMap()
        .put(
            "community.general.git_config",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GitConfig)

}

/// Read git configuration
class GitConfigInfoOptions {
    
    name: String?
    
    path: String?
    
    scope: ("global"|"system"|"local"|"file")?
    
}

/// Task class for git_config_info
class GitConfigInfo extends Playbook.Task {

    /// todo doc
    `community.general.git_config_info`: Dynamic

    /// Options for community.general.git_config_info
    hidden options: GitConfigInfoOptions?

    /// todo doc
    function configure(): GitConfigInfo = this
        .toMap()
        .put(
            "community.general.git_config_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GitConfigInfo)

}

/// Manages deploy keys for GitHub repositories
class GithubDeployKeyOptions {
    
    force: Boolean?
    
    github_url: String?
    
    key: String
    
    name: String
    
    otp: Int?
    
    owner: String
    
    password: String?
    
    read_only: Boolean?
    
    repo: String
    
    state: ("present"|"absent")?
    
    token: String?
    
    username: String?
    
}

/// Task class for github_deploy_key
class GithubDeployKey extends Playbook.Task {

    /// todo doc
    `community.general.github_deploy_key`: Dynamic

    /// Options for community.general.github_deploy_key
    hidden options: GithubDeployKeyOptions?

    /// todo doc
    function configure(): GithubDeployKey = this
        .toMap()
        .put(
            "community.general.github_deploy_key",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GithubDeployKey)

}

/// View GitHub issue
class GithubIssueOptions {
    
    action: ("get_status")?
    
    issue: Int
    
    organization: String
    
    repo: String
    
}

/// Task class for github_issue
class GithubIssue extends Playbook.Task {

    /// todo doc
    `community.general.github_issue`: Dynamic

    /// Options for community.general.github_issue
    hidden options: GithubIssueOptions?

    /// todo doc
    function configure(): GithubIssue = this
        .toMap()
        .put(
            "community.general.github_issue",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GithubIssue)

}

/// Manage GitHub access keys
class GithubKeyOptions {
    
    force: Boolean?
    
    name: String
    
    pubkey: String?
    
    state: ("present"|"absent")?
    
    token: String
    
}

/// Task class for github_key
class GithubKey extends Playbook.Task {

    /// todo doc
    `community.general.github_key`: Dynamic

    /// Options for community.general.github_key
    hidden options: GithubKeyOptions?

    /// todo doc
    function configure(): GithubKey = this
        .toMap()
        .put(
            "community.general.github_key",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GithubKey)

}

/// Interact with GitHub Releases
class GithubReleaseOptions {
    
    action: ("latest_release"|"create_release")
    
    body: String?
    
    draft: Boolean?
    
    name: String?
    
    password: String?
    
    prerelease: Boolean?
    
    repo: String
    
    tag: String?
    
    target: String?
    
    token: String?
    
    user: String
    
}

/// Task class for github_release
class GithubRelease extends Playbook.Task {

    /// todo doc
    `community.general.github_release`: Dynamic

    /// Options for community.general.github_release
    hidden options: GithubReleaseOptions?

    /// todo doc
    function configure(): GithubRelease = this
        .toMap()
        .put(
            "community.general.github_release",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GithubRelease)

}

/// Manage your repositories on Github
class GithubRepoOptions {
    
    access_token: String?
    
    api_url: String?
    
    description: String?
    
    force_defaults: Boolean?
    
    name: String
    
    organization: String?
    
    password: String?
    
    private: Boolean?
    
    state: ("absent"|"present")?
    
    username: String?
    
}

/// Task class for github_repo
class GithubRepo extends Playbook.Task {

    /// todo doc
    `community.general.github_repo`: Dynamic

    /// Options for community.general.github_repo
    hidden options: GithubRepoOptions?

    /// todo doc
    function configure(): GithubRepo = this
        .toMap()
        .put(
            "community.general.github_repo",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GithubRepo)

}

/// Manage GitHub webhooks
class GithubWebhookOptions {
    
    active: Boolean?
    
    content_type: ("form"|"json")?
    
    events: Listing<String>?
    
    github_url: String?
    
    insecure_ssl: Boolean?
    
    password: String?
    
    repository: String
    
    secret: String?
    
    state: ("absent"|"present")?
    
    token: String?
    
    url: String
    
    user: String
    
}

/// Task class for github_webhook
class GithubWebhook extends Playbook.Task {

    /// todo doc
    `community.general.github_webhook`: Dynamic

    /// Options for community.general.github_webhook
    hidden options: GithubWebhookOptions?

    /// todo doc
    function configure(): GithubWebhook = this
        .toMap()
        .put(
            "community.general.github_webhook",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GithubWebhook)

}

/// Query information about GitHub webhooks
class GithubWebhookInfoOptions {
    
    github_url: String?
    
    password: String?
    
    repository: String
    
    token: String?
    
    user: String
    
}

/// Task class for github_webhook_info
class GithubWebhookInfo extends Playbook.Task {

    /// todo doc
    `community.general.github_webhook_info`: Dynamic

    /// Options for community.general.github_webhook_info
    hidden options: GithubWebhookInfoOptions?

    /// todo doc
    function configure(): GithubWebhookInfo = this
        .toMap()
        .put(
            "community.general.github_webhook_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GithubWebhookInfo)

}

/// Create or delete a branch
class GitlabBranchOptions {
    
    branch: String
    
    project: String
    
    ref_branch: String?
    
    state: ("present"|"absent")?
    
}

/// Task class for gitlab_branch
class GitlabBranch extends Playbook.Task {

    /// todo doc
    `community.general.gitlab_branch`: Dynamic

    /// Options for community.general.gitlab_branch
    hidden options: GitlabBranchOptions?

    /// todo doc
    function configure(): GitlabBranch = this
        .toMap()
        .put(
            "community.general.gitlab_branch",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GitlabBranch)

}

/// Manages GitLab project deploy keys
class GitlabDeployKeyOptions {
    
    can_push: Boolean?
    
    key: String
    
    project: String
    
    state: ("present"|"absent")?
    
    title: String
    
}

/// Task class for gitlab_deploy_key
class GitlabDeployKey extends Playbook.Task {

    /// todo doc
    `community.general.gitlab_deploy_key`: Dynamic

    /// Options for community.general.gitlab_deploy_key
    hidden options: GitlabDeployKeyOptions?

    /// todo doc
    function configure(): GitlabDeployKey = this
        .toMap()
        .put(
            "community.general.gitlab_deploy_key",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GitlabDeployKey)

}

/// Creates/updates/deletes GitLab Groups
class GitlabGroupOptions {
    
    auto_devops_enabled: Boolean?
    
    avatar_path: String?
    
    description: String?
    
    force_delete: Boolean?
    
    name: String
    
    parent: String?
    
    path: String?
    
    project_creation_level: ("developer"|"maintainer"|"noone")?
    
    require_two_factor_authentication: Boolean?
    
    state: ("present"|"absent")?
    
    subgroup_creation_level: ("maintainer"|"owner")?
    
    visibility: ("private"|"internal"|"public")?
    
}

/// Task class for gitlab_group
class GitlabGroup extends Playbook.Task {

    /// todo doc
    `community.general.gitlab_group`: Dynamic

    /// Options for community.general.gitlab_group
    hidden options: GitlabGroupOptions?

    /// todo doc
    function configure(): GitlabGroup = this
        .toMap()
        .put(
            "community.general.gitlab_group",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GitlabGroup)

}

/// Manages GitLab group access tokens
class GitlabGroupAccessTokenOptions {
    
    access_level: ("guest"|"reporter"|"developer"|"maintainer"|"owner")?
    
    expires_at: String
    
    group: String
    
    name: String
    
    recreate: ("never"|"always"|"state_change")?
    
    scopes: Listing<("api"|"read_api"|"read_registry"|"write_registry"|"read_repository"|"write_repository"|"create_runner"|"ai_features"|"k8s_proxy")>
    
    state: ("present"|"absent")?
    
}

/// Task class for gitlab_group_access_token
class GitlabGroupAccessToken extends Playbook.Task {

    /// todo doc
    `community.general.gitlab_group_access_token`: Dynamic

    /// Options for community.general.gitlab_group_access_token
    hidden options: GitlabGroupAccessTokenOptions?

    /// todo doc
    function configure(): GitlabGroupAccessToken = this
        .toMap()
        .put(
            "community.general.gitlab_group_access_token",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GitlabGroupAccessToken)

}

/// Manage group members on GitLab Server
class GitlabGroupMembersOptions {
    
    access_level: ("guest"|"reporter"|"developer"|"maintainer"|"owner")?
    
    gitlab_group: String
    
    gitlab_user: Listing<String>?
    
    gitlab_users_access: Listing<Any>?
    
    purge_users: Listing<("guest"|"reporter"|"developer"|"maintainer"|"owner")>?
    
    state: ("present"|"absent")?
    
}

/// Task class for gitlab_group_members
class GitlabGroupMembers extends Playbook.Task {

    /// todo doc
    `community.general.gitlab_group_members`: Dynamic

    /// Options for community.general.gitlab_group_members
    hidden options: GitlabGroupMembersOptions?

    /// todo doc
    function configure(): GitlabGroupMembers = this
        .toMap()
        .put(
            "community.general.gitlab_group_members",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GitlabGroupMembers)

}

/// Creates, updates, or deletes GitLab groups variables
class GitlabGroupVariableOptions {
    
    group: String
    
    purge: Boolean?
    
    state: ("present"|"absent")?
    
    variables: Listing<Any>?
    
    vars: Any?
    
}

/// Task class for gitlab_group_variable
class GitlabGroupVariable extends Playbook.Task {

    /// todo doc
    `community.general.gitlab_group_variable`: Dynamic

    /// Options for community.general.gitlab_group_variable
    hidden options: GitlabGroupVariableOptions?

    /// todo doc
    function configure(): GitlabGroupVariable = this
        .toMap()
        .put(
            "community.general.gitlab_group_variable",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GitlabGroupVariable)

}

/// Manages GitLab project hooks
class GitlabHookOptions {
    
    hook_url: String
    
    hook_validate_certs: Boolean?
    
    issues_events: Boolean?
    
    job_events: Boolean?
    
    merge_requests_events: Boolean?
    
    note_events: Boolean?
    
    pipeline_events: Boolean?
    
    project: String
    
    push_events: Boolean?
    
    push_events_branch_filter: String?
    
    releases_events: Boolean?
    
    state: ("present"|"absent")?
    
    tag_push_events: Boolean?
    
    token: String?
    
    wiki_page_events: Boolean?
    
}

/// Task class for gitlab_hook
class GitlabHook extends Playbook.Task {

    /// todo doc
    `community.general.gitlab_hook`: Dynamic

    /// Options for community.general.gitlab_hook
    hidden options: GitlabHookOptions?

    /// todo doc
    function configure(): GitlabHook = this
        .toMap()
        .put(
            "community.general.gitlab_hook",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GitlabHook)

}

/// Creates, updates, or deletes GitLab instance variables
class GitlabInstanceVariableOptions {
    
    purge: Boolean?
    
    state: ("present"|"absent")?
    
    variables: Listing<Any>?
    
}

/// Task class for gitlab_instance_variable
class GitlabInstanceVariable extends Playbook.Task {

    /// todo doc
    `community.general.gitlab_instance_variable`: Dynamic

    /// Options for community.general.gitlab_instance_variable
    hidden options: GitlabInstanceVariableOptions?

    /// todo doc
    function configure(): GitlabInstanceVariable = this
        .toMap()
        .put(
            "community.general.gitlab_instance_variable",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GitlabInstanceVariable)

}

/// Create, update, or delete GitLab issues
class GitlabIssueOptions {
    
    assignee_ids: Listing<String>?
    
    description: String?
    
    description_path: String?
    
    issue_type: ("issue"|"incident"|"test_case")?
    
    labels: Listing<String>?
    
    milestone_group_id: String?
    
    milestone_search: String?
    
    project: String
    
    state: ("present"|"absent")?
    
    state_filter: ("opened"|"closed")?
    
    title: String
    
}

/// Task class for gitlab_issue
class GitlabIssue extends Playbook.Task {

    /// todo doc
    `community.general.gitlab_issue`: Dynamic

    /// Options for community.general.gitlab_issue
    hidden options: GitlabIssueOptions?

    /// todo doc
    function configure(): GitlabIssue = this
        .toMap()
        .put(
            "community.general.gitlab_issue",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GitlabIssue)

}

/// Creates/updates/deletes GitLab Labels belonging to project or group.
class GitlabLabelOptions {
    
    group: String?
    
    labels: Listing<Any>?
    
    project: String?
    
    purge: Boolean?
    
    state: ("present"|"absent")?
    
}

/// Task class for gitlab_label
class GitlabLabel extends Playbook.Task {

    /// todo doc
    `community.general.gitlab_label`: Dynamic

    /// Options for community.general.gitlab_label
    hidden options: GitlabLabelOptions?

    /// todo doc
    function configure(): GitlabLabel = this
        .toMap()
        .put(
            "community.general.gitlab_label",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GitlabLabel)

}

/// Create, update, or delete GitLab merge requests
class GitlabMergeRequestOptions {
    
    assignee_ids: String?
    
    description: String?
    
    description_path: String?
    
    labels: String?
    
    project: String
    
    remove_source_branch: Boolean?
    
    reviewer_ids: String?
    
    source_branch: String
    
    state: ("present"|"absent")?
    
    state_filter: ("opened"|"closed"|"locked"|"merged")?
    
    target_branch: String
    
    title: String
    
}

/// Task class for gitlab_merge_request
class GitlabMergeRequest extends Playbook.Task {

    /// todo doc
    `community.general.gitlab_merge_request`: Dynamic

    /// Options for community.general.gitlab_merge_request
    hidden options: GitlabMergeRequestOptions?

    /// todo doc
    function configure(): GitlabMergeRequest = this
        .toMap()
        .put(
            "community.general.gitlab_merge_request",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GitlabMergeRequest)

}

/// Creates/updates/deletes GitLab Milestones belonging to project or group
class GitlabMilestoneOptions {
    
    group: String?
    
    milestones: Listing<Any>?
    
    project: String?
    
    purge: Boolean?
    
    state: ("present"|"absent")?
    
}

/// Task class for gitlab_milestone
class GitlabMilestone extends Playbook.Task {

    /// todo doc
    `community.general.gitlab_milestone`: Dynamic

    /// Options for community.general.gitlab_milestone
    hidden options: GitlabMilestoneOptions?

    /// todo doc
    function configure(): GitlabMilestone = this
        .toMap()
        .put(
            "community.general.gitlab_milestone",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GitlabMilestone)

}

/// Creates/updates/deletes GitLab Projects
class GitlabProjectOptions {
    
    allow_merge_on_skipped_pipeline: Boolean?
    
    avatar_path: String?
    
    builds_access_level: ("private"|"disabled"|"enabled")?
    
    ci_config_path: String?
    
    container_registry_access_level: ("private"|"disabled"|"enabled")?
    
    default_branch: String?
    
    description: String?
    
    environments_access_level: ("private"|"disabled"|"enabled")?
    
    feature_flags_access_level: ("private"|"disabled"|"enabled")?
    
    forking_access_level: ("private"|"disabled"|"enabled")?
    
    group: String?
    
    import_url: String?
    
    infrastructure_access_level: ("private"|"disabled"|"enabled")?
    
    initialize_with_readme: Boolean?
    
    issues_enabled: Boolean?
    
    lfs_enabled: Boolean?
    
    merge_method: ("ff"|"merge"|"rebase_merge")?
    
    merge_requests_enabled: Boolean?
    
    monitor_access_level: ("private"|"disabled"|"enabled")?
    
    name: String
    
    only_allow_merge_if_all_discussions_are_resolved: Boolean?
    
    only_allow_merge_if_pipeline_succeeds: Boolean?
    
    packages_enabled: Boolean?
    
    path: String?
    
    releases_access_level: ("private"|"disabled"|"enabled")?
    
    remove_source_branch_after_merge: Boolean?
    
    security_and_compliance_access_level: ("private"|"disabled"|"enabled")?
    
    shared_runners_enabled: Boolean?
    
    snippets_enabled: Boolean?
    
    squash_option: ("never"|"always"|"default_off"|"default_on")?
    
    state: ("present"|"absent")?
    
    topics: Listing<String>?
    
    username: String?
    
    visibility: ("private"|"internal"|"public")?
    
    wiki_enabled: Boolean?
    
}

/// Task class for gitlab_project
class GitlabProject extends Playbook.Task {

    /// todo doc
    `community.general.gitlab_project`: Dynamic

    /// Options for community.general.gitlab_project
    hidden options: GitlabProjectOptions?

    /// todo doc
    function configure(): GitlabProject = this
        .toMap()
        .put(
            "community.general.gitlab_project",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GitlabProject)

}

/// Manages GitLab project access tokens
class GitlabProjectAccessTokenOptions {
    
    access_level: ("guest"|"reporter"|"developer"|"maintainer"|"owner")?
    
    expires_at: String
    
    name: String
    
    project: String
    
    recreate: ("never"|"always"|"state_change")?
    
    scopes: Listing<("api"|"read_api"|"read_registry"|"write_registry"|"read_repository"|"write_repository"|"create_runner"|"ai_features"|"k8s_proxy")>
    
    state: ("present"|"absent")?
    
}

/// Task class for gitlab_project_access_token
class GitlabProjectAccessToken extends Playbook.Task {

    /// todo doc
    `community.general.gitlab_project_access_token`: Dynamic

    /// Options for community.general.gitlab_project_access_token
    hidden options: GitlabProjectAccessTokenOptions?

    /// todo doc
    function configure(): GitlabProjectAccessToken = this
        .toMap()
        .put(
            "community.general.gitlab_project_access_token",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GitlabProjectAccessToken)

}

/// Manage project badges on GitLab Server
class GitlabProjectBadgeOptions {
    
    image_url: String
    
    link_url: String
    
    project: String
    
    state: ("present"|"absent")?
    
}

/// Task class for gitlab_project_badge
class GitlabProjectBadge extends Playbook.Task {

    /// todo doc
    `community.general.gitlab_project_badge`: Dynamic

    /// Options for community.general.gitlab_project_badge
    hidden options: GitlabProjectBadgeOptions?

    /// todo doc
    function configure(): GitlabProjectBadge = this
        .toMap()
        .put(
            "community.general.gitlab_project_badge",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GitlabProjectBadge)

}

/// Manage project members on GitLab Server
class GitlabProjectMembersOptions {
    
    access_level: ("guest"|"reporter"|"developer"|"maintainer")?
    
    gitlab_user: Listing<String>?
    
    gitlab_users_access: Listing<Any>?
    
    project: String
    
    purge_users: Listing<("guest"|"reporter"|"developer"|"maintainer")>?
    
    state: ("present"|"absent")?
    
}

/// Task class for gitlab_project_members
class GitlabProjectMembers extends Playbook.Task {

    /// todo doc
    `community.general.gitlab_project_members`: Dynamic

    /// Options for community.general.gitlab_project_members
    hidden options: GitlabProjectMembersOptions?

    /// todo doc
    function configure(): GitlabProjectMembers = this
        .toMap()
        .put(
            "community.general.gitlab_project_members",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GitlabProjectMembers)

}

/// Creates/updates/deletes GitLab Projects Variables
class GitlabProjectVariableOptions {
    
    project: String
    
    purge: Boolean?
    
    state: ("present"|"absent")?
    
    variables: Listing<Any>?
    
    vars: Any?
    
}

/// Task class for gitlab_project_variable
class GitlabProjectVariable extends Playbook.Task {

    /// todo doc
    `community.general.gitlab_project_variable`: Dynamic

    /// Options for community.general.gitlab_project_variable
    hidden options: GitlabProjectVariableOptions?

    /// todo doc
    function configure(): GitlabProjectVariable = this
        .toMap()
        .put(
            "community.general.gitlab_project_variable",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GitlabProjectVariable)

}

/// Manage protection of existing branches
class GitlabProtectedBranchOptions {
    
    merge_access_levels: ("maintainer"|"developer"|"nobody")?
    
    name: String
    
    project: String
    
    push_access_level: ("maintainer"|"developer"|"nobody")?
    
    state: ("present"|"absent")?
    
}

/// Task class for gitlab_protected_branch
class GitlabProtectedBranch extends Playbook.Task {

    /// todo doc
    `community.general.gitlab_protected_branch`: Dynamic

    /// Options for community.general.gitlab_protected_branch
    hidden options: GitlabProtectedBranchOptions?

    /// todo doc
    function configure(): GitlabProtectedBranch = this
        .toMap()
        .put(
            "community.general.gitlab_protected_branch",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GitlabProtectedBranch)

}

/// Create, modify and delete GitLab Runners
class GitlabRunnerOptions {
    
    access_level: ("not_protected"|"ref_protected")?
    
    access_level_on_creation: Boolean?
    
    active: Boolean?
    
    description: String
    
    group: String?
    
    locked: Boolean?
    
    maximum_timeout: Int?
    
    owned: Boolean?
    
    paused: Boolean?
    
    project: String?
    
    registration_token: String?
    
    run_untagged: Boolean?
    
    state: ("present"|"absent")?
    
    tag_list: Listing<String>?
    
}

/// Task class for gitlab_runner
class GitlabRunner extends Playbook.Task {

    /// todo doc
    `community.general.gitlab_runner`: Dynamic

    /// Options for community.general.gitlab_runner
    hidden options: GitlabRunnerOptions?

    /// todo doc
    function configure(): GitlabRunner = this
        .toMap()
        .put(
            "community.general.gitlab_runner",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GitlabRunner)

}

/// Creates/updates/deletes/blocks/unblocks GitLab Users
class GitlabUserOptions {
    
    access_level: ("guest"|"reporter"|"developer"|"master"|"maintainer"|"owner")?
    
    confirm: Boolean?
    
    email: String?
    
    `external`: Boolean?
    
    group: String?
    
    identities: Listing<Any>?
    
    isadmin: Boolean?
    
    name: String?
    
    overwrite_identities: Boolean?
    
    password: String?
    
    reset_password: Boolean?
    
    sshkey_expires_at: String?
    
    sshkey_file: String?
    
    sshkey_name: String?
    
    state: ("present"|"absent"|"blocked"|"unblocked")?
    
    username: String
    
}

/// Task class for gitlab_user
class GitlabUser extends Playbook.Task {

    /// todo doc
    `community.general.gitlab_user`: Dynamic

    /// Options for community.general.gitlab_user
    hidden options: GitlabUserOptions?

    /// todo doc
    function configure(): GitlabUser = this
        .toMap()
        .put(
            "community.general.gitlab_user",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GitlabUser)

}

/// Sends a notification to a grove.io channel
class GroveOptions {
    
    channel_token: String
    
    icon_url: String?
    
    message_content: String
    
    service: String?
    
    url: String?
    
    validate_certs: Boolean?
    
}

/// Task class for grove
class Grove extends Playbook.Task {

    /// todo doc
    `community.general.grove`: Dynamic

    /// Options for community.general.grove
    hidden options: GroveOptions?

    /// todo doc
    function configure(): Grove = this
        .toMap()
        .put(
            "community.general.grove",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Grove)

}

/// Run gunicorn with various settings
class GunicornOptions {
    
    app: String
    
    chdir: String?
    
    config: String?
    
    pid: String?
    
    user: String?
    
    venv: String?
    
    worker: ("sync"|"eventlet"|"gevent"|"tornado "|"gthread"|"gaiohttp")?
    
}

/// Task class for gunicorn
class Gunicorn extends Playbook.Task {

    /// todo doc
    `community.general.gunicorn`: Dynamic

    /// Options for community.general.gunicorn
    hidden options: GunicornOptions?

    /// todo doc
    function configure(): Gunicorn = this
        .toMap()
        .put(
            "community.general.gunicorn",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Gunicorn)

}

/// Enable, disable, and set weights for HAProxy backend servers using socket commands
class HaproxyOptions {
    
    agent: Boolean?
    
    backend: String?
    
    drain: Boolean?
    
    fail_on_not_found: Boolean?
    
    health: Boolean?
    
    host: String
    
    shutdown_sessions: Boolean?
    
    socket: String?
    
    state: ("disabled"|"drain"|"enabled")
    
    wait: Boolean?
    
    wait_interval: Int?
    
    wait_retries: Int?
    
    weight: String?
    
}

/// Task class for haproxy
class Haproxy extends Playbook.Task {

    /// todo doc
    `community.general.haproxy`: Dynamic

    /// Options for community.general.haproxy
    hidden options: HaproxyOptions?

    /// todo doc
    function configure(): Haproxy = this
        .toMap()
        .put(
            "community.general.haproxy",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Haproxy)

}

/// Add or delete app collaborators on Heroku
class HerokuCollaboratorOptions {
    
    api_key: String?
    
    apps: Listing<String>
    
    state: ("present"|"absent")?
    
    suppress_invitation: Boolean?
    
    user: String
    
}

/// Task class for heroku_collaborator
class HerokuCollaborator extends Playbook.Task {

    /// todo doc
    `community.general.heroku_collaborator`: Dynamic

    /// Options for community.general.heroku_collaborator
    hidden options: HerokuCollaboratorOptions?

    /// todo doc
    function configure(): HerokuCollaborator = this
        .toMap()
        .put(
            "community.general.heroku_collaborator",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(HerokuCollaborator)

}

/// Manages Mercurial (hg) repositories
class HgOptions {
    
    clone: Boolean?
    
    dest: String?
    
    executable: String?
    
    force: Boolean?
    
    purge: Boolean?
    
    repo: String
    
    revision: String?
    
    update: Boolean?
    
}

/// Task class for hg
class Hg extends Playbook.Task {

    /// todo doc
    `community.general.hg`: Dynamic

    /// Options for community.general.hg
    hidden options: HgOptions?

    /// todo doc
    function configure(): Hg = this
        .toMap()
        .put(
            "community.general.hg",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Hg)

}

/// Send a message to Hipchat
class HipchatOptions {
    
    api: String?
    
    color: ("yellow"|"red"|"green"|"purple"|"gray"|"random")?
    
    msg: String
    
    msg_format: ("text"|"html")?
    
    msg_from: String?
    
    notify: Boolean?
    
    room: String
    
    token: String
    
    validate_certs: Boolean?
    
}

/// Task class for hipchat
class Hipchat extends Playbook.Task {

    /// todo doc
    `community.general.hipchat`: Dynamic

    /// Options for community.general.hipchat
    hidden options: HipchatOptions?

    /// todo doc
    function configure(): Hipchat = this
        .toMap()
        .put(
            "community.general.hipchat",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Hipchat)

}

/// Package manager for Homebrew
class HomebrewOptions {
    
    install_options: Listing<String>?
    
    name: Listing<String>?
    
    path: String?
    
    state: ("absent"|"head"|"installed"|"latest"|"linked"|"present"|"removed"|"uninstalled"|"unlinked"|"upgraded")?
    
    update_homebrew: Boolean?
    
    upgrade_all: Boolean?
    
    upgrade_options: Listing<String>?
    
}

/// Task class for homebrew
class Homebrew extends Playbook.Task {

    /// todo doc
    `community.general.homebrew`: Dynamic

    /// Options for community.general.homebrew
    hidden options: HomebrewOptions?

    /// todo doc
    function configure(): Homebrew = this
        .toMap()
        .put(
            "community.general.homebrew",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Homebrew)

}

/// Install and uninstall homebrew casks
class HomebrewCaskOptions {
    
    accept_external_apps: Boolean?
    
    greedy: Boolean?
    
    install_options: Listing<String>?
    
    name: Listing<String>?
    
    path: String?
    
    state: ("absent"|"installed"|"latest"|"present"|"removed"|"uninstalled"|"upgraded")?
    
    sudo_password: String?
    
    update_homebrew: Boolean?
    
    upgrade_all: Boolean?
    
}

/// Task class for homebrew_cask
class HomebrewCask extends Playbook.Task {

    /// todo doc
    `community.general.homebrew_cask`: Dynamic

    /// Options for community.general.homebrew_cask
    hidden options: HomebrewCaskOptions?

    /// todo doc
    function configure(): HomebrewCask = this
        .toMap()
        .put(
            "community.general.homebrew_cask",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(HomebrewCask)

}

/// Tap a Homebrew repository
class HomebrewTapOptions {
    
    name: Listing<String>
    
    path: String?
    
    state: ("present"|"absent")?
    
    url: String?
    
}

/// Task class for homebrew_tap
class HomebrewTap extends Playbook.Task {

    /// todo doc
    `community.general.homebrew_tap`: Dynamic

    /// Options for community.general.homebrew_tap
    hidden options: HomebrewTapOptions?

    /// todo doc
    function configure(): HomebrewTap = this
        .toMap()
        .put(
            "community.general.homebrew_tap",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(HomebrewTap)

}

/// Manage user accounts with systemd-homed
class HomectlOptions {
    
    disksize: String?
    
    email: String?
    
    environment: String?
    
    gid: Int?
    
    homedir: String?
    
    iconname: String?
    
    imagepath: String?
    
    language: String?
    
    location: String?
    
    locked: Boolean?
    
    memberof: String?
    
    mountopts: String?
    
    name: String
    
    notafter: Int?
    
    notbefore: Int?
    
    password: String?
    
    passwordhint: String?
    
    realm: String?
    
    realname: String?
    
    resize: Boolean?
    
    shell: String?
    
    skeleton: String?
    
    sshkeys: String?
    
    state: ("absent"|"present")?
    
    storage: ("classic"|"luks"|"directory"|"subvolume"|"fscrypt"|"cifs")?
    
    timezone: String?
    
    uid: Int?
    
    umask: Int?
    
}

/// Task class for homectl
class Homectl extends Playbook.Task {

    /// todo doc
    `community.general.homectl`: Dynamic

    /// Options for community.general.homectl
    hidden options: HomectlOptions?

    /// todo doc
    function configure(): Homectl = this
        .toMap()
        .put(
            "community.general.homectl",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Homectl)

}

/// Notify Honeybadger.io about app deployments
class HoneybadgerDeploymentOptions {
    
    environment: String
    
    repo: String?
    
    revision: String?
    
    token: String
    
    url: String?
    
    user: String?
    
    validate_certs: Boolean?
    
}

/// Task class for honeybadger_deployment
class HoneybadgerDeployment extends Playbook.Task {

    /// todo doc
    `community.general.honeybadger_deployment`: Dynamic

    /// Options for community.general.honeybadger_deployment
    hidden options: HoneybadgerDeploymentOptions?

    /// todo doc
    function configure(): HoneybadgerDeployment = this
        .toMap()
        .put(
            "community.general.honeybadger_deployment",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(HoneybadgerDeployment)

}

/// Boot system using specific media through HP iLO interface
class HpiloBootOptions {
    
    force: Boolean?
    
    host: String
    
    image: String?
    
    login: String?
    
    media: ("cdrom"|"floppy"|"rbsu"|"hdd"|"network"|"normal"|"usb")?
    
    password: String?
    
    ssl_version: ("SSLv3"|"SSLv23"|"TLSv1"|"TLSv1_1"|"TLSv1_2")?
    
    state: ("boot_always"|"boot_once"|"connect"|"disconnect"|"no_boot"|"poweroff")?
    
}

/// Task class for hpilo_boot
class HpiloBoot extends Playbook.Task {

    /// todo doc
    `community.general.hpilo_boot`: Dynamic

    /// Options for community.general.hpilo_boot
    hidden options: HpiloBootOptions?

    /// todo doc
    function configure(): HpiloBoot = this
        .toMap()
        .put(
            "community.general.hpilo_boot",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(HpiloBoot)

}

/// Gather information through an HP iLO interface
class HpiloInfoOptions {
    
    host: String
    
    login: String?
    
    password: String?
    
    ssl_version: ("SSLv3"|"SSLv23"|"TLSv1"|"TLSv1_1"|"TLSv1_2")?
    
}

/// Task class for hpilo_info
class HpiloInfo extends Playbook.Task {

    /// todo doc
    `community.general.hpilo_info`: Dynamic

    /// Options for community.general.hpilo_info
    hidden options: HpiloInfoOptions?

    /// todo doc
    function configure(): HpiloInfo = this
        .toMap()
        .put(
            "community.general.hpilo_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(HpiloInfo)

}

/// Configure HP iLO interface using hponcfg
class HponcfgOptions {
    
    executable: String?
    
    minfw: String?
    
    path: String
    
    verbose: Boolean?
    
}

/// Task class for hponcfg
class Hponcfg extends Playbook.Task {

    /// todo doc
    `community.general.hponcfg`: Dynamic

    /// Options for community.general.hponcfg
    hidden options: HponcfgOptions?

    /// todo doc
    function configure(): Hponcfg = this
        .toMap()
        .put(
            "community.general.hponcfg",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Hponcfg)

}

/// Manage user files for basic authentication
class HtpasswdOptions {
    
    create: Boolean?
    
    hash_scheme: String?
    
    name: String
    
    password: String?
    
    path: String
    
    state: ("present"|"absent")?
    
}

/// Task class for htpasswd
class Htpasswd extends Playbook.Task {

    /// todo doc
    `community.general.htpasswd`: Dynamic

    /// Options for community.general.htpasswd
    hidden options: HtpasswdOptions?

    /// todo doc
    function configure(): Htpasswd = this
        .toMap()
        .put(
            "community.general.htpasswd",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Htpasswd)

}

/// Creates a resource of Ecs/Instance in Huawei Cloud
class HwcEcsInstanceOptions {
    
    admin_pass: String?
    
    availability_zone: String
    
    data_volumes: Listing<Any>?
    
    description: String?
    
    eip_id: String?
    
    enable_auto_recovery: Boolean?
    
    enterprise_project_id: String?
    
    flavor_name: String
    
    image_id: String
    
    name: String
    
    nics: Listing<Any>
    
    root_volume: Any
    
    security_groups: Listing<String>?
    
    server_metadata: Any?
    
    server_tags: Any?
    
    ssh_key_name: String?
    
    state: ("present"|"absent")?
    
    timeouts: Any?
    
    user_data: String?
    
    vpc_id: String
    
}

/// Task class for hwc_ecs_instance
class HwcEcsInstance extends Playbook.Task {

    /// todo doc
    `community.general.hwc_ecs_instance`: Dynamic

    /// Options for community.general.hwc_ecs_instance
    hidden options: HwcEcsInstanceOptions?

    /// todo doc
    function configure(): HwcEcsInstance = this
        .toMap()
        .put(
            "community.general.hwc_ecs_instance",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(HwcEcsInstance)

}

/// Creates a resource of Evs/Disk in Huawei Cloud
class HwcEvsDiskOptions {
    
    availability_zone: String
    
    backup_id: String?
    
    description: String?
    
    enable_full_clone: Boolean?
    
    enable_scsi: Boolean?
    
    enable_share: Boolean?
    
    encryption_id: String?
    
    enterprise_project_id: String?
    
    image_id: String?
    
    name: String
    
    size: Int?
    
    snapshot_id: String?
    
    state: ("present"|"absent")?
    
    timeouts: Any?
    
    volume_type: String
    
}

/// Task class for hwc_evs_disk
class HwcEvsDisk extends Playbook.Task {

    /// todo doc
    `community.general.hwc_evs_disk`: Dynamic

    /// Options for community.general.hwc_evs_disk
    hidden options: HwcEvsDiskOptions?

    /// todo doc
    function configure(): HwcEvsDisk = this
        .toMap()
        .put(
            "community.general.hwc_evs_disk",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(HwcEvsDisk)

}

/// Creates a Huawei Cloud VPC
class HwcNetworkVpcOptions {
    
    cidr: String
    
    name: String
    
    state: ("present"|"absent")?
    
    timeouts: Any?
    
}

/// Task class for hwc_network_vpc
class HwcNetworkVpc extends Playbook.Task {

    /// todo doc
    `community.general.hwc_network_vpc`: Dynamic

    /// Options for community.general.hwc_network_vpc
    hidden options: HwcNetworkVpcOptions?

    /// todo doc
    function configure(): HwcNetworkVpc = this
        .toMap()
        .put(
            "community.general.hwc_network_vpc",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(HwcNetworkVpc)

}

/// Creates a resource of SMNTopic in Huaweicloud Cloud
class HwcSmnTopicOptions {
    
    display_name: String?
    
    name: String
    
    state: ("present"|"absent")?
    
}

/// Task class for hwc_smn_topic
class HwcSmnTopic extends Playbook.Task {

    /// todo doc
    `community.general.hwc_smn_topic`: Dynamic

    /// Options for community.general.hwc_smn_topic
    hidden options: HwcSmnTopicOptions?

    /// todo doc
    function configure(): HwcSmnTopic = this
        .toMap()
        .put(
            "community.general.hwc_smn_topic",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(HwcSmnTopic)

}

/// Creates a resource of Vpc/EIP in Huawei Cloud
class HwcVpcEipOptions {
    
    dedicated_bandwidth: Any?
    
    enterprise_project_id: String?
    
    ip_version: Int?
    
    ipv4_address: String?
    
    port_id: String?
    
    shared_bandwidth_id: String?
    
    state: ("present"|"absent")?
    
    timeouts: Any?
    
    type: String
    
}

/// Task class for hwc_vpc_eip
class HwcVpcEip extends Playbook.Task {

    /// todo doc
    `community.general.hwc_vpc_eip`: Dynamic

    /// Options for community.general.hwc_vpc_eip
    hidden options: HwcVpcEipOptions?

    /// todo doc
    function configure(): HwcVpcEip = this
        .toMap()
        .put(
            "community.general.hwc_vpc_eip",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(HwcVpcEip)

}

/// Creates a resource of Vpc/PeeringConnect in Huawei Cloud
class HwcVpcPeeringConnectOptions {
    
    description: String?
    
    local_vpc_id: String
    
    name: String
    
    peering_vpc: Any
    
    state: ("present"|"absent")?
    
    timeouts: Any?
    
}

/// Task class for hwc_vpc_peering_connect
class HwcVpcPeeringConnect extends Playbook.Task {

    /// todo doc
    `community.general.hwc_vpc_peering_connect`: Dynamic

    /// Options for community.general.hwc_vpc_peering_connect
    hidden options: HwcVpcPeeringConnectOptions?

    /// todo doc
    function configure(): HwcVpcPeeringConnect = this
        .toMap()
        .put(
            "community.general.hwc_vpc_peering_connect",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(HwcVpcPeeringConnect)

}

/// Creates a resource of Vpc/Port in Huawei Cloud
class HwcVpcPortOptions {
    
    admin_state_up: Boolean?
    
    allowed_address_pairs: Listing<Any>?
    
    extra_dhcp_opts: Listing<Any>?
    
    ip_address: String?
    
    name: String?
    
    security_groups: Listing<String>?
    
    state: ("present"|"absent")?
    
    subnet_id: String
    
    timeouts: Any?
    
}

/// Task class for hwc_vpc_port
class HwcVpcPort extends Playbook.Task {

    /// todo doc
    `community.general.hwc_vpc_port`: Dynamic

    /// Options for community.general.hwc_vpc_port
    hidden options: HwcVpcPortOptions?

    /// todo doc
    function configure(): HwcVpcPort = this
        .toMap()
        .put(
            "community.general.hwc_vpc_port",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(HwcVpcPort)

}

/// Creates a resource of Vpc/PrivateIP in Huawei Cloud
class HwcVpcPrivateIpOptions {
    
    ip_address: String?
    
    state: ("present"|"absent")?
    
    subnet_id: String
    
}

/// Task class for hwc_vpc_private_ip
class HwcVpcPrivateIp extends Playbook.Task {

    /// todo doc
    `community.general.hwc_vpc_private_ip`: Dynamic

    /// Options for community.general.hwc_vpc_private_ip
    hidden options: HwcVpcPrivateIpOptions?

    /// todo doc
    function configure(): HwcVpcPrivateIp = this
        .toMap()
        .put(
            "community.general.hwc_vpc_private_ip",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(HwcVpcPrivateIp)

}

/// Creates a resource of Vpc/Route in Huawei Cloud
class HwcVpcRouteOptions {
    
    destination: String
    
    next_hop: String
    
    state: ("present"|"absent")?
    
    type: String?
    
    vpc_id: String
    
}

/// Task class for hwc_vpc_route
class HwcVpcRoute extends Playbook.Task {

    /// todo doc
    `community.general.hwc_vpc_route`: Dynamic

    /// Options for community.general.hwc_vpc_route
    hidden options: HwcVpcRouteOptions?

    /// todo doc
    function configure(): HwcVpcRoute = this
        .toMap()
        .put(
            "community.general.hwc_vpc_route",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(HwcVpcRoute)

}

/// Creates a resource of Vpc/SecurityGroup in Huawei Cloud
class HwcVpcSecurityGroupOptions {
    
    enterprise_project_id: String?
    
    name: String
    
    state: ("present"|"absent")?
    
    vpc_id: String?
    
}

/// Task class for hwc_vpc_security_group
class HwcVpcSecurityGroup extends Playbook.Task {

    /// todo doc
    `community.general.hwc_vpc_security_group`: Dynamic

    /// Options for community.general.hwc_vpc_security_group
    hidden options: HwcVpcSecurityGroupOptions?

    /// todo doc
    function configure(): HwcVpcSecurityGroup = this
        .toMap()
        .put(
            "community.general.hwc_vpc_security_group",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(HwcVpcSecurityGroup)

}

/// Creates a resource of Vpc/SecurityGroupRule in Huawei Cloud
class HwcVpcSecurityGroupRuleOptions {
    
    description: String?
    
    direction: String
    
    ethertype: String?
    
    port_range_max: Int?
    
    port_range_min: Int?
    
    protocol: String?
    
    remote_group_id: String?
    
    remote_ip_prefix: String?
    
    security_group_id: String
    
    state: ("present"|"absent")?
    
}

/// Task class for hwc_vpc_security_group_rule
class HwcVpcSecurityGroupRule extends Playbook.Task {

    /// todo doc
    `community.general.hwc_vpc_security_group_rule`: Dynamic

    /// Options for community.general.hwc_vpc_security_group_rule
    hidden options: HwcVpcSecurityGroupRuleOptions?

    /// todo doc
    function configure(): HwcVpcSecurityGroupRule = this
        .toMap()
        .put(
            "community.general.hwc_vpc_security_group_rule",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(HwcVpcSecurityGroupRule)

}

/// Creates a resource of Vpc/Subnet in Huawei Cloud
class HwcVpcSubnetOptions {
    
    availability_zone: String?
    
    cidr: String
    
    dhcp_enable: Boolean?
    
    dns_address: Listing<String>?
    
    gateway_ip: String
    
    name: String
    
    state: ("present"|"absent")?
    
    timeouts: Any?
    
    vpc_id: String
    
}

/// Task class for hwc_vpc_subnet
class HwcVpcSubnet extends Playbook.Task {

    /// todo doc
    `community.general.hwc_vpc_subnet`: Dynamic

    /// Options for community.general.hwc_vpc_subnet
    hidden options: HwcVpcSubnetOptions?

    /// todo doc
    function configure(): HwcVpcSubnet = this
        .toMap()
        .put(
            "community.general.hwc_vpc_subnet",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(HwcVpcSubnet)

}

/// Manages domains on IBM Spectrum Accelerate Family storage systems
class IbmSaDomainOptions {
    
    domain: String
    
    hard_capacity: String?
    
    ldap_id: String?
    
    max_cgs: String?
    
    max_dms: String?
    
    max_mirrors: String?
    
    max_pools: String?
    
    max_volumes: String?
    
    perf_class: String?
    
    size: String?
    
    soft_capacity: String?
    
    state: ("present"|"absent")?
    
}

/// Task class for ibm_sa_domain
class IbmSaDomain extends Playbook.Task {

    /// todo doc
    `community.general.ibm_sa_domain`: Dynamic

    /// Options for community.general.ibm_sa_domain
    hidden options: IbmSaDomainOptions?

    /// todo doc
    function configure(): IbmSaDomain = this
        .toMap()
        .put(
            "community.general.ibm_sa_domain",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IbmSaDomain)

}

/// Adds hosts to or removes them from IBM Spectrum Accelerate Family storage systems
class IbmSaHostOptions {
    
    cluster: String?
    
    domain: String?
    
    host: String
    
    iscsi_chap_name: String?
    
    iscsi_chap_secret: String?
    
    state: ("present"|"absent")?
    
}

/// Task class for ibm_sa_host
class IbmSaHost extends Playbook.Task {

    /// todo doc
    `community.general.ibm_sa_host`: Dynamic

    /// Options for community.general.ibm_sa_host
    hidden options: IbmSaHostOptions?

    /// todo doc
    function configure(): IbmSaHost = this
        .toMap()
        .put(
            "community.general.ibm_sa_host",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IbmSaHost)

}

/// Add host ports on IBM Spectrum Accelerate Family storage systems
class IbmSaHostPortsOptions {
    
    fcaddress: String?
    
    host: String
    
    iscsi_name: String?
    
    num_of_visible_targets: String?
    
    state: ("present"|"absent")?
    
}

/// Task class for ibm_sa_host_ports
class IbmSaHostPorts extends Playbook.Task {

    /// todo doc
    `community.general.ibm_sa_host_ports`: Dynamic

    /// Options for community.general.ibm_sa_host_ports
    hidden options: IbmSaHostPortsOptions?

    /// todo doc
    function configure(): IbmSaHostPorts = this
        .toMap()
        .put(
            "community.general.ibm_sa_host_ports",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IbmSaHostPorts)

}

/// Handles pools on IBM Spectrum Accelerate Family storage systems
class IbmSaPoolOptions {
    
    domain: String?
    
    perf_class: String?
    
    pool: String
    
    size: String?
    
    snapshot_size: String?
    
    state: ("present"|"absent")?
    
}

/// Task class for ibm_sa_pool
class IbmSaPool extends Playbook.Task {

    /// todo doc
    `community.general.ibm_sa_pool`: Dynamic

    /// Options for community.general.ibm_sa_pool
    hidden options: IbmSaPoolOptions?

    /// todo doc
    function configure(): IbmSaPool = this
        .toMap()
        .put(
            "community.general.ibm_sa_pool",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IbmSaPool)

}

/// Handle volumes on IBM Spectrum Accelerate Family storage systems
class IbmSaVolOptions {
    
    pool: String?
    
    size: String?
    
    state: ("present"|"absent")?
    
    vol: String
    
}

/// Task class for ibm_sa_vol
class IbmSaVol extends Playbook.Task {

    /// todo doc
    `community.general.ibm_sa_vol`: Dynamic

    /// Options for community.general.ibm_sa_vol
    hidden options: IbmSaVolOptions?

    /// todo doc
    function configure(): IbmSaVol = this
        .toMap()
        .put(
            "community.general.ibm_sa_vol",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IbmSaVol)

}

/// Handles volume mapping on IBM Spectrum Accelerate Family storage systems
class IbmSaVolMapOptions {
    
    cluster: String?
    
    host: String?
    
    lun: String?
    
    `override`: String?
    
    state: ("present"|"absent")?
    
    vol: String
    
}

/// Task class for ibm_sa_vol_map
class IbmSaVolMap extends Playbook.Task {

    /// todo doc
    `community.general.ibm_sa_vol_map`: Dynamic

    /// Options for community.general.ibm_sa_vol_map
    hidden options: IbmSaVolMapOptions?

    /// todo doc
    function configure(): IbmSaVolMap = this
        .toMap()
        .put(
            "community.general.ibm_sa_vol_map",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IbmSaVolMap)

}

/// Manage Icinga2 feature
class Icinga2FeatureOptions {
    
    name: String
    
    state: ("present"|"absent")?
    
}

/// Task class for icinga2_feature
class Icinga2Feature extends Playbook.Task {

    /// todo doc
    `community.general.icinga2_feature`: Dynamic

    /// Options for community.general.icinga2_feature
    hidden options: Icinga2FeatureOptions?

    /// todo doc
    function configure(): Icinga2Feature = this
        .toMap()
        .put(
            "community.general.icinga2_feature",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Icinga2Feature)

}

/// Manage a host in Icinga2
class Icinga2HostOptions {
    
    check_command: String?
    
    client_cert: String?
    
    client_key: String?
    
    display_name: String?
    
    force_basic_auth: Boolean?
    
    ip: String?
    
    name: String
    
    state: ("present"|"absent")?
    
    template: String?
    
    url: String?
    
    url_password: String?
    
    url_username: String?
    
    use_proxy: Boolean?
    
    validate_certs: Boolean?
    
    variables: Any?
    
    zone: String?
    
}

/// Task class for icinga2_host
class Icinga2Host extends Playbook.Task {

    /// todo doc
    `community.general.icinga2_host`: Dynamic

    /// Options for community.general.icinga2_host
    hidden options: Icinga2HostOptions?

    /// todo doc
    function configure(): Icinga2Host = this
        .toMap()
        .put(
            "community.general.icinga2_host",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Icinga2Host)

}

/// Manages Out-Of-Band controllers using iDRAC OEM Redfish APIs
class IdracRedfishCommandOptions {
    
    auth_token: String?
    
    baseuri: String
    
    category: String
    
    command: Listing<String>
    
    password: String?
    
    resource_id: String?
    
    timeout: Int?
    
    username: String?
    
}

/// Task class for idrac_redfish_command
class IdracRedfishCommand extends Playbook.Task {

    /// todo doc
    `community.general.idrac_redfish_command`: Dynamic

    /// Options for community.general.idrac_redfish_command
    hidden options: IdracRedfishCommandOptions?

    /// todo doc
    function configure(): IdracRedfishCommand = this
        .toMap()
        .put(
            "community.general.idrac_redfish_command",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IdracRedfishCommand)

}

/// Manages servers through iDRAC using Dell Redfish APIs
class IdracRedfishConfigOptions {
    
    auth_token: String?
    
    baseuri: String
    
    category: String
    
    command: Listing<String>
    
    manager_attributes: Any?
    
    password: String?
    
    resource_id: String?
    
    timeout: Int?
    
    username: String?
    
}

/// Task class for idrac_redfish_config
class IdracRedfishConfig extends Playbook.Task {

    /// todo doc
    `community.general.idrac_redfish_config`: Dynamic

    /// Options for community.general.idrac_redfish_config
    hidden options: IdracRedfishConfigOptions?

    /// todo doc
    function configure(): IdracRedfishConfig = this
        .toMap()
        .put(
            "community.general.idrac_redfish_config",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IdracRedfishConfig)

}

/// Gather PowerEdge server information through iDRAC using Redfish APIs
class IdracRedfishInfoOptions {
    
    auth_token: String?
    
    baseuri: String
    
    category: String
    
    command: Listing<String>
    
    password: String?
    
    timeout: Int?
    
    username: String?
    
}

/// Task class for idrac_redfish_info
class IdracRedfishInfo extends Playbook.Task {

    /// todo doc
    `community.general.idrac_redfish_info`: Dynamic

    /// Options for community.general.idrac_redfish_info
    hidden options: IdracRedfishInfoOptions?

    /// todo doc
    function configure(): IdracRedfishInfo = this
        .toMap()
        .put(
            "community.general.idrac_redfish_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IdracRedfishInfo)

}

/// Manages Out-Of-Band controllers using Redfish APIs
class IloRedfishCommandOptions {
    
    auth_token: String?
    
    baseuri: String
    
    category: ("Systems")
    
    command: Listing<String>
    
    password: String?
    
    timeout: Int?
    
    username: String?
    
}

/// Task class for ilo_redfish_command
class IloRedfishCommand extends Playbook.Task {

    /// todo doc
    `community.general.ilo_redfish_command`: Dynamic

    /// Options for community.general.ilo_redfish_command
    hidden options: IloRedfishCommandOptions?

    /// todo doc
    function configure(): IloRedfishCommand = this
        .toMap()
        .put(
            "community.general.ilo_redfish_command",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IloRedfishCommand)

}

/// Sets or updates configuration attributes on HPE iLO with Redfish OEM extensions
class IloRedfishConfigOptions {
    
    attribute_name: String
    
    attribute_value: String?
    
    auth_token: String?
    
    baseuri: String
    
    category: ("Manager")
    
    command: Listing<String>
    
    password: String?
    
    timeout: Int?
    
    username: String?
    
}

/// Task class for ilo_redfish_config
class IloRedfishConfig extends Playbook.Task {

    /// todo doc
    `community.general.ilo_redfish_config`: Dynamic

    /// Options for community.general.ilo_redfish_config
    hidden options: IloRedfishConfigOptions?

    /// todo doc
    function configure(): IloRedfishConfig = this
        .toMap()
        .put(
            "community.general.ilo_redfish_config",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IloRedfishConfig)

}

/// Gathers server information through iLO using Redfish APIs
class IloRedfishInfoOptions {
    
    auth_token: String?
    
    baseuri: String
    
    category: Listing<String>
    
    command: Listing<String>
    
    password: String?
    
    timeout: Int?
    
    username: String?
    
}

/// Task class for ilo_redfish_info
class IloRedfishInfo extends Playbook.Task {

    /// todo doc
    `community.general.ilo_redfish_info`: Dynamic

    /// Options for community.general.ilo_redfish_info
    hidden options: IloRedfishInfoOptions?

    /// todo doc
    function configure(): IloRedfishInfo = this
        .toMap()
        .put(
            "community.general.ilo_redfish_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IloRedfishInfo)

}

/// Manage Cisco IMC hardware through its REST API
class ImcRestOptions {
    
    content: String?
    
    hostname: String
    
    password: String?
    
    path: String?
    
    protocol: ("http"|"https")?
    
    timeout: Int?
    
    username: String?
    
    validate_certs: Boolean?
    
}

/// Task class for imc_rest
class ImcRest extends Playbook.Task {

    /// todo doc
    `community.general.imc_rest`: Dynamic

    /// Options for community.general.imc_rest
    hidden options: ImcRestOptions?

    /// todo doc
    function configure(): ImcRest = this
        .toMap()
        .put(
            "community.general.imc_rest",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ImcRest)

}

/// Manage SmartOS images
class ImgadmOptions {
    
    force: Boolean?
    
    pool: String?
    
    source: String?
    
    state: ("present"|"absent"|"deleted"|"imported"|"updated"|"vacuumed")
    
    type: ("imgapi"|"docker"|"dsapi")?
    
    uuid: String?
    
}

/// Task class for imgadm
class Imgadm extends Playbook.Task {

    /// todo doc
    `community.general.imgadm`: Dynamic

    /// Options for community.general.imgadm
    hidden options: ImgadmOptions?

    /// todo doc
    function configure(): Imgadm = this
        .toMap()
        .put(
            "community.general.imgadm",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Imgadm)

}

/// Manage Infinity IPAM using Rest API
class InfinityOptions {
    
    action: ("add_network"|"delete_network"|"get_network"|"get_network_id"|"release_ip"|"release_network"|"reserve_network"|"reserve_next_available_ip")
    
    ip_address: String?
    
    network_address: String?
    
    network_family: ("4"|"6"|"dual")?
    
    network_id: String?
    
    network_location: Int?
    
    network_name: String?
    
    network_size: String?
    
    network_type: ("lan"|"shared_lan"|"supernet")?
    
    password: String
    
    server_ip: String
    
    username: String
    
}

/// Task class for infinity
class Infinity extends Playbook.Task {

    /// todo doc
    `community.general.infinity`: Dynamic

    /// Options for community.general.infinity
    hidden options: InfinityOptions?

    /// todo doc
    function configure(): Infinity = this
        .toMap()
        .put(
            "community.general.infinity",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Infinity)

}

/// Manage InfluxDB databases
class InfluxdbDatabaseOptions {
    
    database_name: String
    
    state: ("absent"|"present")?
    
}

/// Task class for influxdb_database
class InfluxdbDatabase extends Playbook.Task {

    /// todo doc
    `community.general.influxdb_database`: Dynamic

    /// Options for community.general.influxdb_database
    hidden options: InfluxdbDatabaseOptions?

    /// todo doc
    function configure(): InfluxdbDatabase = this
        .toMap()
        .put(
            "community.general.influxdb_database",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(InfluxdbDatabase)

}

/// Query data points from InfluxDB
class InfluxdbQueryOptions {
    
    database_name: String
    
    query: String
    
}

/// Task class for influxdb_query
class InfluxdbQuery extends Playbook.Task {

    /// todo doc
    `community.general.influxdb_query`: Dynamic

    /// Options for community.general.influxdb_query
    hidden options: InfluxdbQueryOptions?

    /// todo doc
    function configure(): InfluxdbQuery = this
        .toMap()
        .put(
            "community.general.influxdb_query",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(InfluxdbQuery)

}

/// Manage InfluxDB retention policies
class InfluxdbRetentionPolicyOptions {
    
    database_name: String
    
    default: Boolean?
    
    duration: String?
    
    policy_name: String
    
    replication: Int?
    
    shard_group_duration: String?
    
    state: ("absent"|"present")?
    
}

/// Task class for influxdb_retention_policy
class InfluxdbRetentionPolicy extends Playbook.Task {

    /// todo doc
    `community.general.influxdb_retention_policy`: Dynamic

    /// Options for community.general.influxdb_retention_policy
    hidden options: InfluxdbRetentionPolicyOptions?

    /// todo doc
    function configure(): InfluxdbRetentionPolicy = this
        .toMap()
        .put(
            "community.general.influxdb_retention_policy",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(InfluxdbRetentionPolicy)

}

/// Manage InfluxDB users
class InfluxdbUserOptions {
    
    admin: Boolean?
    
    grants: Listing<Any>?
    
    state: ("absent"|"present")?
    
    user_name: String
    
    user_password: String?
    
}

/// Task class for influxdb_user
class InfluxdbUser extends Playbook.Task {

    /// todo doc
    `community.general.influxdb_user`: Dynamic

    /// Options for community.general.influxdb_user
    hidden options: InfluxdbUserOptions?

    /// todo doc
    function configure(): InfluxdbUser = this
        .toMap()
        .put(
            "community.general.influxdb_user",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(InfluxdbUser)

}

/// Write data points into InfluxDB
class InfluxdbWriteOptions {
    
    data_points: Listing<Any>
    
    database_name: String
    
}

/// Task class for influxdb_write
class InfluxdbWrite extends Playbook.Task {

    /// todo doc
    `community.general.influxdb_write`: Dynamic

    /// Options for community.general.influxdb_write
    hidden options: InfluxdbWriteOptions?

    /// todo doc
    function configure(): InfluxdbWrite = this
        .toMap()
        .put(
            "community.general.influxdb_write",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(InfluxdbWrite)

}

/// Tweak settings in INI files
class IniFileOptions {
    
    allow_no_value: Boolean?
    
    backup: Boolean?
    
    create: Boolean?
    
    exclusive: Boolean?
    
    follow: Boolean?
    
    ignore_spaces: Boolean?
    
    modify_inactive_option: Boolean?
    
    no_extra_spaces: Boolean?
    
    option: String?
    
    path: String
    
    section: String?
    
    state: ("absent"|"present")?
    
    value: String?
    
    values: Listing<String>?
    
}

/// Task class for ini_file
class IniFile extends Playbook.Task {

    /// todo doc
    `community.general.ini_file`: Dynamic

    /// Options for community.general.ini_file
    hidden options: IniFileOptions?

    /// todo doc
    function configure(): IniFile = this
        .toMap()
        .put(
            "community.general.ini_file",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IniFile)

}

/// Manage packages on AIX
class InstallpOptions {
    
    accept_license: Boolean?
    
    name: Listing<String>
    
    repository_path: String?
    
    state: ("absent"|"present")?
    
}

/// Task class for installp
class Installp extends Playbook.Task {

    /// todo doc
    `community.general.installp`: Dynamic

    /// Options for community.general.installp
    hidden options: InstallpOptions?

    /// todo doc
    function configure(): Installp = this
        .toMap()
        .put(
            "community.general.installp",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Installp)

}

/// Tweak settings in C(/etc/network/interfaces) files
class InterfacesFileOptions {
    
    address_family: String?
    
    backup: Boolean?
    
    dest: String?
    
    iface: String?
    
    option: String?
    
    state: ("present"|"absent")?
    
    value: String?
    
}

/// Task class for interfaces_file
class InterfacesFile extends Playbook.Task {

    /// todo doc
    `community.general.interfaces_file`: Dynamic

    /// Options for community.general.interfaces_file
    hidden options: InterfacesFileOptions?

    /// todo doc
    function configure(): InterfacesFile = this
        .toMap()
        .put(
            "community.general.interfaces_file",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(InterfacesFile)

}

/// Manage network namespaces
class IpNetnsOptions {
    
    name: String?
    
    state: ("present"|"absent")?
    
}

/// Task class for ip_netns
class IpNetns extends Playbook.Task {

    /// todo doc
    `community.general.ip_netns`: Dynamic

    /// Options for community.general.ip_netns
    hidden options: IpNetnsOptions?

    /// todo doc
    function configure(): IpNetns = this
        .toMap()
        .put(
            "community.general.ip_netns",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IpNetns)

}

/// Manage Global FreeIPA Configuration Settings
class IpaConfigOptions {
    
    ipaconfigstring: Listing<("AllowNThash"|"KDC:Disable Last Success"|"KDC:Disable Lockout"|"KDC:Disable Default Preauth for SPNs")>?
    
    ipadefaultemaildomain: String?
    
    ipadefaultloginshell: String?
    
    ipadefaultprimarygroup: String?
    
    ipagroupobjectclasses: Listing<String>?
    
    ipagroupsearchfields: Listing<String>?
    
    ipahomesrootdir: String?
    
    ipakrbauthzdata: Listing<("MS-PAC"|"PAD"|"nfs:NONE")>?
    
    ipamaxusernamelength: Int?
    
    ipapwdexpadvnotify: Int?
    
    ipasearchrecordslimit: Int?
    
    ipasearchtimelimit: Int?
    
    ipaselinuxusermaporder: Listing<String>?
    
    ipauserauthtype: Listing<("password"|"radius"|"otp"|"pkinit"|"hardened"|"idp"|"passkey"|"disabled")>?
    
    ipauserobjectclasses: Listing<String>?
    
    ipausersearchfields: Listing<String>?
    
}

/// Task class for ipa_config
class IpaConfig extends Playbook.Task {

    /// todo doc
    `community.general.ipa_config`: Dynamic

    /// Options for community.general.ipa_config
    hidden options: IpaConfigOptions?

    /// todo doc
    function configure(): IpaConfig = this
        .toMap()
        .put(
            "community.general.ipa_config",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IpaConfig)

}

/// Manage FreeIPA DNS records
class IpaDnsrecordOptions {
    
    record_name: String
    
    record_ttl: Int?
    
    record_type: ("A"|"AAAA"|"A6"|"CNAME"|"DNAME"|"MX"|"NS"|"PTR"|"SRV"|"TXT")?
    
    record_value: String?
    
    record_values: Listing<String>?
    
    state: ("absent"|"present")?
    
    zone_name: String
    
}

/// Task class for ipa_dnsrecord
class IpaDnsrecord extends Playbook.Task {

    /// todo doc
    `community.general.ipa_dnsrecord`: Dynamic

    /// Options for community.general.ipa_dnsrecord
    hidden options: IpaDnsrecordOptions?

    /// todo doc
    function configure(): IpaDnsrecord = this
        .toMap()
        .put(
            "community.general.ipa_dnsrecord",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IpaDnsrecord)

}

/// Manage FreeIPA DNS Zones
class IpaDnszoneOptions {
    
    allowsyncptr: Boolean?
    
    dynamicupdate: Boolean?
    
    state: ("absent"|"present")?
    
    zone_name: String
    
}

/// Task class for ipa_dnszone
class IpaDnszone extends Playbook.Task {

    /// todo doc
    `community.general.ipa_dnszone`: Dynamic

    /// Options for community.general.ipa_dnszone
    hidden options: IpaDnszoneOptions?

    /// todo doc
    function configure(): IpaDnszone = this
        .toMap()
        .put(
            "community.general.ipa_dnszone",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IpaDnszone)

}

/// Manage FreeIPA group
class IpaGroupOptions {
    
    append: Boolean?
    
    cn: String
    
    description: String?
    
    `external`: Boolean?
    
    external_user: Listing<String>?
    
    gidnumber: String?
    
    group: Listing<String>?
    
    nonposix: Boolean?
    
    state: ("absent"|"present")?
    
    user: Listing<String>?
    
}

/// Task class for ipa_group
class IpaGroup extends Playbook.Task {

    /// todo doc
    `community.general.ipa_group`: Dynamic

    /// Options for community.general.ipa_group
    hidden options: IpaGroupOptions?

    /// todo doc
    function configure(): IpaGroup = this
        .toMap()
        .put(
            "community.general.ipa_group",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IpaGroup)

}

/// Manage FreeIPA HBAC rule
class IpaHbacruleOptions {
    
    cn: String
    
    description: String?
    
    host: Listing<String>?
    
    hostcategory: ("all")?
    
    hostgroup: Listing<String>?
    
    service: Listing<String>?
    
    servicecategory: ("all")?
    
    servicegroup: Listing<String>?
    
    sourcehost: Listing<String>?
    
    sourcehostcategory: ("all")?
    
    sourcehostgroup: Listing<String>?
    
    state: ("absent"|"disabled"|"enabled"|"present")?
    
    user: Listing<String>?
    
    usercategory: ("all")?
    
    usergroup: Listing<String>?
    
}

/// Task class for ipa_hbacrule
class IpaHbacrule extends Playbook.Task {

    /// todo doc
    `community.general.ipa_hbacrule`: Dynamic

    /// Options for community.general.ipa_hbacrule
    hidden options: IpaHbacruleOptions?

    /// todo doc
    function configure(): IpaHbacrule = this
        .toMap()
        .put(
            "community.general.ipa_hbacrule",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IpaHbacrule)

}

/// Manage FreeIPA host
class IpaHostOptions {
    
    description: String?
    
    force: Boolean?
    
    fqdn: String
    
    ip_address: String?
    
    mac_address: Listing<String>?
    
    ns_hardware_platform: String?
    
    ns_host_location: String?
    
    ns_os_version: String?
    
    random_password: Boolean?
    
    state: ("absent"|"disabled"|"enabled"|"present")?
    
    update_dns: Boolean?
    
    user_certificate: Listing<String>?
    
}

/// Task class for ipa_host
class IpaHost extends Playbook.Task {

    /// todo doc
    `community.general.ipa_host`: Dynamic

    /// Options for community.general.ipa_host
    hidden options: IpaHostOptions?

    /// todo doc
    function configure(): IpaHost = this
        .toMap()
        .put(
            "community.general.ipa_host",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IpaHost)

}

/// Manage FreeIPA host-group
class IpaHostgroupOptions {
    
    append: Boolean?
    
    cn: String
    
    description: String?
    
    host: Listing<String>?
    
    hostgroup: Listing<String>?
    
    state: ("absent"|"disabled"|"enabled"|"present")?
    
}

/// Task class for ipa_hostgroup
class IpaHostgroup extends Playbook.Task {

    /// todo doc
    `community.general.ipa_hostgroup`: Dynamic

    /// Options for community.general.ipa_hostgroup
    hidden options: IpaHostgroupOptions?

    /// todo doc
    function configure(): IpaHostgroup = this
        .toMap()
        .put(
            "community.general.ipa_hostgroup",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IpaHostgroup)

}

/// Manage FreeIPA OTP Configuration Settings
class IpaOtpconfigOptions {
    
    ipatokenhotpauthwindow: Int?
    
    ipatokenhotpsyncwindow: Int?
    
    ipatokentotpauthwindow: Int?
    
    ipatokentotpsyncwindow: Int?
    
}

/// Task class for ipa_otpconfig
class IpaOtpconfig extends Playbook.Task {

    /// todo doc
    `community.general.ipa_otpconfig`: Dynamic

    /// Options for community.general.ipa_otpconfig
    hidden options: IpaOtpconfigOptions?

    /// todo doc
    function configure(): IpaOtpconfig = this
        .toMap()
        .put(
            "community.general.ipa_otpconfig",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IpaOtpconfig)

}

/// Manage FreeIPA OTPs
class IpaOtptokenOptions {
    
    algorithm: ("sha1"|"sha256"|"sha384"|"sha512")?
    
    counter: Int?
    
    description: String?
    
    digits: Int?
    
    enabled: Boolean?
    
    interval: Int?
    
    model: String?
    
    newuniqueid: String?
    
    notafter: String?
    
    notbefore: String?
    
    offset: Int?
    
    otptype: ("totp"|"hotp")?
    
    owner: String?
    
    secretkey: String?
    
    serial: String?
    
    state: ("present"|"absent")?
    
    uniqueid: String
    
    vendor: String?
    
}

/// Task class for ipa_otptoken
class IpaOtptoken extends Playbook.Task {

    /// todo doc
    `community.general.ipa_otptoken`: Dynamic

    /// Options for community.general.ipa_otptoken
    hidden options: IpaOtptokenOptions?

    /// todo doc
    function configure(): IpaOtptoken = this
        .toMap()
        .put(
            "community.general.ipa_otptoken",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IpaOtptoken)

}

/// Manage FreeIPA password policies
class IpaPwpolicyOptions {
    
    dictcheck: Boolean?
    
    failinterval: String?
    
    gracelimit: Int?
    
    group: String?
    
    historylength: String?
    
    lockouttime: String?
    
    maxfailcount: String?
    
    maxpwdlife: String?
    
    maxrepeat: Int?
    
    maxsequence: Int?
    
    minclasses: String?
    
    minlength: String?
    
    minpwdlife: String?
    
    priority: String?
    
    state: ("absent"|"present")?
    
    usercheck: Boolean?
    
}

/// Task class for ipa_pwpolicy
class IpaPwpolicy extends Playbook.Task {

    /// todo doc
    `community.general.ipa_pwpolicy`: Dynamic

    /// Options for community.general.ipa_pwpolicy
    hidden options: IpaPwpolicyOptions?

    /// todo doc
    function configure(): IpaPwpolicy = this
        .toMap()
        .put(
            "community.general.ipa_pwpolicy",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IpaPwpolicy)

}

/// Manage FreeIPA role
class IpaRoleOptions {
    
    cn: String
    
    description: String?
    
    group: Listing<String>?
    
    host: Listing<String>?
    
    hostgroup: Listing<String>?
    
    privilege: Listing<String>?
    
    service: Listing<String>?
    
    state: ("absent"|"present")?
    
    user: Listing<String>?
    
}

/// Task class for ipa_role
class IpaRole extends Playbook.Task {

    /// todo doc
    `community.general.ipa_role`: Dynamic

    /// Options for community.general.ipa_role
    hidden options: IpaRoleOptions?

    /// todo doc
    function configure(): IpaRole = this
        .toMap()
        .put(
            "community.general.ipa_role",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IpaRole)

}

/// Manage FreeIPA service
class IpaServiceOptions {
    
    force: Boolean?
    
    hosts: Listing<String>?
    
    krbcanonicalname: String
    
    skip_host_check: Boolean?
    
    state: ("absent"|"present")?
    
}

/// Task class for ipa_service
class IpaService extends Playbook.Task {

    /// todo doc
    `community.general.ipa_service`: Dynamic

    /// Options for community.general.ipa_service
    hidden options: IpaServiceOptions?

    /// todo doc
    function configure(): IpaService = this
        .toMap()
        .put(
            "community.general.ipa_service",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IpaService)

}

/// Manage FreeIPA Lightweight Sub Certificate Authorities
class IpaSubcaOptions {
    
    state: ("absent"|"disabled"|"enabled"|"present")?
    
    subca_desc: String?
    
    subca_name: String
    
    subca_subject: String
    
}

/// Task class for ipa_subca
class IpaSubca extends Playbook.Task {

    /// todo doc
    `community.general.ipa_subca`: Dynamic

    /// Options for community.general.ipa_subca
    hidden options: IpaSubcaOptions?

    /// todo doc
    function configure(): IpaSubca = this
        .toMap()
        .put(
            "community.general.ipa_subca",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IpaSubca)

}

/// Manage FreeIPA sudo command
class IpaSudocmdOptions {
    
    description: String?
    
    state: ("absent"|"disabled"|"enabled"|"present")?
    
    sudocmd: String
    
}

/// Task class for ipa_sudocmd
class IpaSudocmd extends Playbook.Task {

    /// todo doc
    `community.general.ipa_sudocmd`: Dynamic

    /// Options for community.general.ipa_sudocmd
    hidden options: IpaSudocmdOptions?

    /// todo doc
    function configure(): IpaSudocmd = this
        .toMap()
        .put(
            "community.general.ipa_sudocmd",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IpaSudocmd)

}

/// Manage FreeIPA sudo command group
class IpaSudocmdgroupOptions {
    
    cn: String
    
    description: String?
    
    state: ("absent"|"disabled"|"enabled"|"present")?
    
    sudocmd: Listing<String>?
    
}

/// Task class for ipa_sudocmdgroup
class IpaSudocmdgroup extends Playbook.Task {

    /// todo doc
    `community.general.ipa_sudocmdgroup`: Dynamic

    /// Options for community.general.ipa_sudocmdgroup
    hidden options: IpaSudocmdgroupOptions?

    /// todo doc
    function configure(): IpaSudocmdgroup = this
        .toMap()
        .put(
            "community.general.ipa_sudocmdgroup",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IpaSudocmdgroup)

}

/// Manage FreeIPA sudo rule
class IpaSudoruleOptions {
    
    cmd: Listing<String>?
    
    cmdcategory: ("all")?
    
    cmdgroup: Listing<String>?
    
    cn: String
    
    deny_cmd: Listing<String>?
    
    deny_cmdgroup: Listing<String>?
    
    description: String?
    
    host: Listing<String>?
    
    hostcategory: ("all")?
    
    hostgroup: Listing<String>?
    
    runasextusers: Listing<String>?
    
    runasgroupcategory: ("all")?
    
    runasusercategory: ("all")?
    
    state: ("absent"|"disabled"|"enabled"|"present")?
    
    sudoopt: Listing<String>?
    
    user: Listing<String>?
    
    usercategory: ("all")?
    
    usergroup: Listing<String>?
    
}

/// Task class for ipa_sudorule
class IpaSudorule extends Playbook.Task {

    /// todo doc
    `community.general.ipa_sudorule`: Dynamic

    /// Options for community.general.ipa_sudorule
    hidden options: IpaSudoruleOptions?

    /// todo doc
    function configure(): IpaSudorule = this
        .toMap()
        .put(
            "community.general.ipa_sudorule",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IpaSudorule)

}

/// Manage FreeIPA users
class IpaUserOptions {
    
    displayname: String?
    
    gidnumber: String?
    
    givenname: String?
    
    homedirectory: String?
    
    krbpasswordexpiration: String?
    
    loginshell: String?
    
    mail: Listing<String>?
    
    password: String?
    
    sn: String?
    
    sshpubkey: Listing<String>?
    
    state: ("absent"|"disabled"|"enabled"|"present")?
    
    telephonenumber: Listing<String>?
    
    title: String?
    
    uid: String
    
    uidnumber: String?
    
    update_password: ("always"|"on_create")?
    
    userauthtype: Listing<("password"|"radius"|"otp"|"pkinit"|"hardened"|"idp"|"passkey")>?
    
}

/// Task class for ipa_user
class IpaUser extends Playbook.Task {

    /// todo doc
    `community.general.ipa_user`: Dynamic

    /// Options for community.general.ipa_user
    hidden options: IpaUserOptions?

    /// todo doc
    function configure(): IpaUser = this
        .toMap()
        .put(
            "community.general.ipa_user",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IpaUser)

}

/// Manage FreeIPA vaults
class IpaVaultOptions {
    
    cn: String
    
    description: String?
    
    ipavaultpublickey: String?
    
    ipavaultsalt: String?
    
    ipavaulttype: ("asymmetric"|"standard"|"symmetric")?
    
    replace: Boolean?
    
    service: String?
    
    state: ("absent"|"present")?
    
    username: Listing<String>?
    
    validate_certs: Boolean?
    
}

/// Task class for ipa_vault
class IpaVault extends Playbook.Task {

    /// todo doc
    `community.general.ipa_vault`: Dynamic

    /// Options for community.general.ipa_vault
    hidden options: IpaVaultOptions?

    /// todo doc
    function configure(): IpaVault = this
        .toMap()
        .put(
            "community.general.ipa_vault",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IpaVault)

}

/// Retrieve IP geolocation and other facts of a host's IP address using the ipbase.com API
class IpbaseInfoOptions {
    
    apikey: String?
    
    hostname: Boolean?
    
    ip: String?
    
    language: String?
    
}

/// Task class for ipbase_info
class IpbaseInfo extends Playbook.Task {

    /// todo doc
    `community.general.ipbase_info`: Dynamic

    /// Options for community.general.ipbase_info
    hidden options: IpbaseInfoOptions?

    /// todo doc
    function configure(): IpbaseInfo = this
        .toMap()
        .put(
            "community.general.ipbase_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IpbaseInfo)

}

/// Retrieve the public IP of your internet gateway
class IpifyFactsOptions {
    
    api_url: String?
    
    timeout: Int?
    
    validate_certs: Boolean?
    
}

/// Task class for ipify_facts
class IpifyFacts extends Playbook.Task {

    /// todo doc
    `community.general.ipify_facts`: Dynamic

    /// Options for community.general.ipify_facts
    hidden options: IpifyFactsOptions?

    /// todo doc
    function configure(): IpifyFacts = this
        .toMap()
        .put(
            "community.general.ipify_facts",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IpifyFacts)

}

/// Retrieve IP geolocation facts of a host's IP address
class IpinfoioFactsOptions {
    
    http_agent: String?
    
    timeout: Int?
    
}

/// Task class for ipinfoio_facts
class IpinfoioFacts extends Playbook.Task {

    /// todo doc
    `community.general.ipinfoio_facts`: Dynamic

    /// Options for community.general.ipinfoio_facts
    hidden options: IpinfoioFactsOptions?

    /// todo doc
    function configure(): IpinfoioFacts = this
        .toMap()
        .put(
            "community.general.ipinfoio_facts",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IpinfoioFacts)

}

/// Management of order of boot devices
class IpmiBootOptions {
    
    bootdev: ("network"|"floppy"|"hd"|"safe"|"optical"|"setup"|"default")
    
    key: String?
    
    name: String
    
    password: String
    
    persistent: Boolean?
    
    port: Int?
    
    state: ("present"|"absent")?
    
    uefiboot: Boolean?
    
    user: String
    
}

/// Task class for ipmi_boot
class IpmiBoot extends Playbook.Task {

    /// todo doc
    `community.general.ipmi_boot`: Dynamic

    /// Options for community.general.ipmi_boot
    hidden options: IpmiBootOptions?

    /// todo doc
    function configure(): IpmiBoot = this
        .toMap()
        .put(
            "community.general.ipmi_boot",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IpmiBoot)

}

/// Power management for machine
class IpmiPowerOptions {
    
    key: String?
    
    machine: Listing<Any>?
    
    name: String
    
    password: String
    
    port: Int?
    
    state: ("on"|"off"|"shutdown"|"reset"|"boot")?
    
    timeout: Int?
    
    user: String
    
}

/// Task class for ipmi_power
class IpmiPower extends Playbook.Task {

    /// todo doc
    `community.general.ipmi_power`: Dynamic

    /// Options for community.general.ipmi_power
    hidden options: IpmiPowerOptions?

    /// todo doc
    function configure(): IpmiPower = this
        .toMap()
        .put(
            "community.general.ipmi_power",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IpmiPower)

}

/// Save iptables state into a file or restore it from a file
class IptablesStateOptions {
    
    counters: Boolean?
    
    ip_version: ("ipv4"|"ipv6")?
    
    modprobe: String?
    
    noflush: Boolean?
    
    path: String
    
    state: ("saved"|"restored")
    
    table: ("filter"|"nat"|"mangle"|"raw"|"security")?
    
    wait: Int?
    
}

/// Task class for iptables_state
class IptablesState extends Playbook.Task {

    /// todo doc
    `community.general.iptables_state`: Dynamic

    /// Options for community.general.iptables_state
    hidden options: IptablesStateOptions?

    /// todo doc
    function configure(): IptablesState = this
        .toMap()
        .put(
            "community.general.iptables_state",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IptablesState)

}

/// Manage DNS Records for Ericsson IPWorks via ipwcli
class IpwcliDnsOptions {
    
    address: String?
    
    container: String
    
    dnsname: String
    
    flags: ("S"|"A"|"U"|"P")?
    
    order: Int?
    
    password: String
    
    port: Int?
    
    preference: Int?
    
    priority: Int?
    
    replacement: String?
    
    service: String?
    
    state: ("absent"|"present")?
    
    target: String?
    
    ttl: Int?
    
    type: ("NAPTR"|"SRV"|"A"|"AAAA")
    
    username: String
    
    weight: Int?
    
}

/// Task class for ipwcli_dns
class IpwcliDns extends Playbook.Task {

    /// todo doc
    `community.general.ipwcli_dns`: Dynamic

    /// Options for community.general.ipwcli_dns
    hidden options: IpwcliDnsOptions?

    /// todo doc
    function configure(): IpwcliDns = this
        .toMap()
        .put(
            "community.general.ipwcli_dns",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IpwcliDns)

}

/// Send a message to an IRC channel or a nick
class IrcOptions {
    
    channel: String?
    
    color: ("none"|"white"|"black"|"blue"|"green"|"red"|"brown"|"purple"|"orange"|"yellow"|"light_green"|"teal"|"light_cyan"|"light_blue"|"pink"|"gray"|"light_gray")?
    
    key: String?
    
    msg: String
    
    nick: String?
    
    nick_to: Listing<String>?
    
    part: Boolean?
    
    passwd: String?
    
    port: Int?
    
    server: String?
    
    style: ("bold"|"underline"|"reverse"|"italic"|"none")?
    
    timeout: Int?
    
    topic: String?
    
    use_tls: Boolean?
    
    validate_certs: Boolean?
    
}

/// Task class for irc
class Irc extends Playbook.Task {

    /// todo doc
    `community.general.irc`: Dynamic

    /// Options for community.general.irc
    hidden options: IrcOptions?

    /// todo doc
    function configure(): Irc = this
        .toMap()
        .put(
            "community.general.irc",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Irc)

}

/// Generate ISO file with specified files or folders
class IsoCreateOptions {
    
    dest_iso: String
    
    interchange_level: Int?
    
    joliet: Int?
    
    rock_ridge: ("1.09"|"1.10"|"1.12")?
    
    src_files: Listing<String>
    
    udf: Boolean?
    
    vol_ident: String?
    
}

/// Task class for iso_create
class IsoCreate extends Playbook.Task {

    /// todo doc
    `community.general.iso_create`: Dynamic

    /// Options for community.general.iso_create
    hidden options: IsoCreateOptions?

    /// todo doc
    function configure(): IsoCreate = this
        .toMap()
        .put(
            "community.general.iso_create",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IsoCreate)

}

/// Add/remove/change files in ISO file
class IsoCustomizeOptions {
    
    add_files: Listing<Any>?
    
    delete_files: Listing<String>?
    
    dest_iso: String
    
    src_iso: String
    
}

/// Task class for iso_customize
class IsoCustomize extends Playbook.Task {

    /// todo doc
    `community.general.iso_customize`: Dynamic

    /// Options for community.general.iso_customize
    hidden options: IsoCustomizeOptions?

    /// todo doc
    function configure(): IsoCustomize = this
        .toMap()
        .put(
            "community.general.iso_customize",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IsoCustomize)

}

/// Extract files from an ISO image
class IsoExtractOptions {
    
    dest: String
    
    executable: String?
    
    files: Listing<String>
    
    force: Boolean?
    
    image: String
    
}

/// Task class for iso_extract
class IsoExtract extends Playbook.Task {

    /// todo doc
    `community.general.iso_extract`: Dynamic

    /// Options for community.general.iso_extract
    hidden options: IsoExtractOptions?

    /// todo doc
    function configure(): IsoExtract = this
        .toMap()
        .put(
            "community.general.iso_extract",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IsoExtract)

}

/// Send a message to jabber user or chat room
class JabberOptions {
    
    encoding: String?
    
    host: String?
    
    msg: String
    
    password: String
    
    port: Int?
    
    to: String
    
    user: String
    
}

/// Task class for jabber
class Jabber extends Playbook.Task {

    /// todo doc
    `community.general.jabber`: Dynamic

    /// Options for community.general.jabber
    hidden options: JabberOptions?

    /// todo doc
    function configure(): Jabber = this
        .toMap()
        .put(
            "community.general.jabber",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Jabber)

}

/// Uses keytool to import/remove certificate to/from java keystore (cacerts)
class JavaCertOptions {
    
    cert_alias: String?
    
    cert_path: String?
    
    cert_port: Int?
    
    cert_url: String?
    
    executable: String?
    
    keystore_create: Boolean?
    
    keystore_pass: String
    
    keystore_path: String?
    
    keystore_type: String?
    
    pkcs12_alias: String?
    
    pkcs12_password: String?
    
    pkcs12_path: String?
    
    state: ("absent"|"present")?
    
    trust_cacert: Boolean?
    
}

/// Task class for java_cert
class JavaCert extends Playbook.Task {

    /// todo doc
    `community.general.java_cert`: Dynamic

    /// Options for community.general.java_cert
    hidden options: JavaCertOptions?

    /// todo doc
    function configure(): JavaCert = this
        .toMap()
        .put(
            "community.general.java_cert",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(JavaCert)

}

/// Create a Java keystore in JKS format
class JavaKeystoreOptions {
    
    certificate: String?
    
    certificate_path: String?
    
    dest: String
    
    force: Boolean?
    
    group: Any?
    
    keystore_type: ("jks"|"pkcs12")?
    
    mode: Any?
    
    name: String
    
    owner: Any?
    
    password: String
    
    private_key: String?
    
    private_key_passphrase: String?
    
    private_key_path: String?
    
    ssl_backend: ("openssl"|"cryptography")?
    
}

/// Task class for java_keystore
class JavaKeystore extends Playbook.Task {

    /// todo doc
    `community.general.java_keystore`: Dynamic

    /// Options for community.general.java_keystore
    hidden options: JavaKeystoreOptions?

    /// todo doc
    function configure(): JavaKeystore = this
        .toMap()
        .put(
            "community.general.java_keystore",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(JavaKeystore)

}

/// Deploy applications to JBoss
class JbossOptions {
    
    deploy_path: String?
    
    deployment: String
    
    src: String?
    
    state: ("present"|"absent")?
    
}

/// Task class for jboss
class Jboss extends Playbook.Task {

    /// todo doc
    `community.general.jboss`: Dynamic

    /// Options for community.general.jboss
    hidden options: JbossOptions?

    /// todo doc
    function configure(): Jboss = this
        .toMap()
        .put(
            "community.general.jboss",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Jboss)

}

/// Manage jenkins builds
class JenkinsBuildOptions {
    
    args: Any?
    
    build_number: Int?
    
    detach: Boolean?
    
    name: String
    
    password: String?
    
    state: ("present"|"absent"|"stopped")?
    
    time_between_checks: Int?
    
    token: String?
    
    url: String?
    
    user: String?
    
}

/// Task class for jenkins_build
class JenkinsBuild extends Playbook.Task {

    /// todo doc
    `community.general.jenkins_build`: Dynamic

    /// Options for community.general.jenkins_build
    hidden options: JenkinsBuildOptions?

    /// todo doc
    function configure(): JenkinsBuild = this
        .toMap()
        .put(
            "community.general.jenkins_build",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(JenkinsBuild)

}

/// Get information about Jenkins builds
class JenkinsBuildInfoOptions {
    
    build_number: Int?
    
    name: String
    
    password: String?
    
    token: String?
    
    url: String?
    
    user: String?
    
}

/// Task class for jenkins_build_info
class JenkinsBuildInfo extends Playbook.Task {

    /// todo doc
    `community.general.jenkins_build_info`: Dynamic

    /// Options for community.general.jenkins_build_info
    hidden options: JenkinsBuildInfoOptions?

    /// todo doc
    function configure(): JenkinsBuildInfo = this
        .toMap()
        .put(
            "community.general.jenkins_build_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(JenkinsBuildInfo)

}

/// Manage jenkins jobs
class JenkinsJobOptions {
    
    config: String?
    
    enabled: Boolean?
    
    name: String
    
    password: String?
    
    state: ("present"|"absent")?
    
    token: String?
    
    url: String?
    
    user: String?
    
    validate_certs: Boolean?
    
}

/// Task class for jenkins_job
class JenkinsJob extends Playbook.Task {

    /// todo doc
    `community.general.jenkins_job`: Dynamic

    /// Options for community.general.jenkins_job
    hidden options: JenkinsJobOptions?

    /// todo doc
    function configure(): JenkinsJob = this
        .toMap()
        .put(
            "community.general.jenkins_job",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(JenkinsJob)

}

/// Get information about Jenkins jobs
class JenkinsJobInfoOptions {
    
    color: String?
    
    glob: String?
    
    name: String?
    
    password: String?
    
    token: String?
    
    url: String?
    
    user: String?
    
    validate_certs: Boolean?
    
}

/// Task class for jenkins_job_info
class JenkinsJobInfo extends Playbook.Task {

    /// todo doc
    `community.general.jenkins_job_info`: Dynamic

    /// Options for community.general.jenkins_job_info
    hidden options: JenkinsJobInfoOptions?

    /// todo doc
    function configure(): JenkinsJobInfo = this
        .toMap()
        .put(
            "community.general.jenkins_job_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(JenkinsJobInfo)

}

/// Add or remove Jenkins plugin
class JenkinsPluginOptions {
    
    group: String?
    
    jenkins_home: String?
    
    latest_plugins_url_segments: Listing<String>?
    
    mode: String?
    
    name: String
    
    owner: String?
    
    state: ("absent"|"present"|"pinned"|"unpinned"|"enabled"|"disabled"|"latest")?
    
    timeout: Int?
    
    update_json_url_segment: Listing<String>?
    
    updates_expiration: Int?
    
    updates_url: Listing<String>?
    
    url: String?
    
    version: String?
    
    versioned_plugins_url_segments: Listing<String>?
    
    with_dependencies: Boolean?
    
}

/// Task class for jenkins_plugin
class JenkinsPlugin extends Playbook.Task {

    /// todo doc
    `community.general.jenkins_plugin`: Dynamic

    /// Options for community.general.jenkins_plugin
    hidden options: JenkinsPluginOptions?

    /// todo doc
    function configure(): JenkinsPlugin = this
        .toMap()
        .put(
            "community.general.jenkins_plugin",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(JenkinsPlugin)

}

/// Executes a groovy script in the jenkins instance
class JenkinsScriptOptions {
    
    args: Any?
    
    password: String?
    
    script: String
    
    timeout: Int?
    
    url: String?
    
    user: String?
    
    validate_certs: Boolean?
    
}

/// Task class for jenkins_script
class JenkinsScript extends Playbook.Task {

    /// todo doc
    `community.general.jenkins_script`: Dynamic

    /// Options for community.general.jenkins_script
    hidden options: JenkinsScriptOptions?

    /// todo doc
    function configure(): JenkinsScript = this
        .toMap()
        .put(
            "community.general.jenkins_script",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(JenkinsScript)

}

/// Create and modify issues in a JIRA instance
class JiraOptions {
    
    account_id: String?
    
    assignee: String?
    
    attachment: Any?
    
    comment: String?
    
    comment_visibility: Any?
    
    description: String?
    
    fields: Any?
    
    inwardissue: String?
    
    issue: String?
    
    issuetype: String?
    
    jql: String?
    
    linktype: String?
    
    maxresults: Int?
    
    operation: ("attach"|"comment"|"create"|"edit"|"fetch"|"link"|"search"|"transition"|"update"|"worklog")
    
    outwardissue: String?
    
    password: String?
    
    project: String?
    
    status: String?
    
    summary: String?
    
    timeout: Any?
    
    token: String?
    
    uri: String
    
    username: String?
    
    validate_certs: Boolean?
    
}

/// Task class for jira
class Jira extends Playbook.Task {

    /// todo doc
    `community.general.jira`: Dynamic

    /// Options for community.general.jira
    hidden options: JiraOptions?

    /// todo doc
    function configure(): Jira = this
        .toMap()
        .put(
            "community.general.jira",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Jira)

}

/// Manage KDE configuration files
class KdeconfigOptions {
    
    backup: Boolean?
    
    kwriteconfig_path: String?
    
    path: String
    
    values: Listing<Any>
    
}

/// Task class for kdeconfig
class Kdeconfig extends Playbook.Task {

    /// todo doc
    `community.general.kdeconfig`: Dynamic

    /// Options for community.general.kdeconfig
    hidden options: KdeconfigOptions?

    /// todo doc
    function configure(): Kdeconfig = this
        .toMap()
        .put(
            "community.general.kdeconfig",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Kdeconfig)

}

/// Blacklist kernel modules
class KernelBlacklistOptions {
    
    blacklist_file: String?
    
    name: String
    
    state: ("absent"|"present")?
    
}

/// Task class for kernel_blacklist
class KernelBlacklist extends Playbook.Task {

    /// todo doc
    `community.general.kernel_blacklist`: Dynamic

    /// Options for community.general.kernel_blacklist
    hidden options: KernelBlacklistOptions?

    /// todo doc
    function configure(): KernelBlacklist = this
        .toMap()
        .put(
            "community.general.kernel_blacklist",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(KernelBlacklist)

}

/// Configure authentication in Keycloak
class KeycloakAuthenticationOptions {
    
    alias: String
    
    authenticationExecutions: Listing<Any>?
    
    copyFrom: String?
    
    description: String?
    
    force: Boolean?
    
    providerId: ("basic-flow"|"client-flow")?
    
    realm: String
    
    state: ("present"|"absent")?
    
}

/// Task class for keycloak_authentication
class KeycloakAuthentication extends Playbook.Task {

    /// todo doc
    `community.general.keycloak_authentication`: Dynamic

    /// Options for community.general.keycloak_authentication
    hidden options: KeycloakAuthenticationOptions?

    /// todo doc
    function configure(): KeycloakAuthentication = this
        .toMap()
        .put(
            "community.general.keycloak_authentication",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(KeycloakAuthentication)

}

/// Allows administration of Keycloak authentication required actions
class KeycloakAuthenticationRequiredActionsOptions {
    
    realm: String
    
    required_actions: Listing<Any>?
    
    state: ("absent"|"present")
    
}

/// Task class for keycloak_authentication_required_actions
class KeycloakAuthenticationRequiredActions extends Playbook.Task {

    /// todo doc
    `community.general.keycloak_authentication_required_actions`: Dynamic

    /// Options for community.general.keycloak_authentication_required_actions
    hidden options: KeycloakAuthenticationRequiredActionsOptions?

    /// todo doc
    function configure(): KeycloakAuthenticationRequiredActions = this
        .toMap()
        .put(
            "community.general.keycloak_authentication_required_actions",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(KeycloakAuthenticationRequiredActions)

}

/// Allows administration of Keycloak client authorization scopes via Keycloak API
class KeycloakAuthzAuthorizationScopeOptions {
    
    client_id: String
    
    display_name: String?
    
    icon_uri: String?
    
    name: String
    
    realm: String
    
    state: ("present"|"absent")?
    
}

/// Task class for keycloak_authz_authorization_scope
class KeycloakAuthzAuthorizationScope extends Playbook.Task {

    /// todo doc
    `community.general.keycloak_authz_authorization_scope`: Dynamic

    /// Options for community.general.keycloak_authz_authorization_scope
    hidden options: KeycloakAuthzAuthorizationScopeOptions?

    /// todo doc
    function configure(): KeycloakAuthzAuthorizationScope = this
        .toMap()
        .put(
            "community.general.keycloak_authz_authorization_scope",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(KeycloakAuthzAuthorizationScope)

}

/// Allows administration of Keycloak client custom Javascript policies via Keycloak API
class KeycloakAuthzCustomPolicyOptions {
    
    client_id: String
    
    name: String
    
    policy_type: String
    
    realm: String
    
    state: ("present"|"absent")?
    
}

/// Task class for keycloak_authz_custom_policy
class KeycloakAuthzCustomPolicy extends Playbook.Task {

    /// todo doc
    `community.general.keycloak_authz_custom_policy`: Dynamic

    /// Options for community.general.keycloak_authz_custom_policy
    hidden options: KeycloakAuthzCustomPolicyOptions?

    /// todo doc
    function configure(): KeycloakAuthzCustomPolicy = this
        .toMap()
        .put(
            "community.general.keycloak_authz_custom_policy",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(KeycloakAuthzCustomPolicy)

}

/// Allows administration of Keycloak client authorization permissions via Keycloak API
class KeycloakAuthzPermissionOptions {
    
    client_id: String
    
    decision_strategy: ("UNANIMOUS"|"AFFIRMATIVE"|"CONSENSUS")?
    
    description: String?
    
    name: String
    
    permission_type: ("resource"|"scope")
    
    policies: Listing<String>?
    
    realm: String
    
    resources: Listing<String>?
    
    scopes: Listing<String>?
    
    state: ("present"|"absent")?
    
}

/// Task class for keycloak_authz_permission
class KeycloakAuthzPermission extends Playbook.Task {

    /// todo doc
    `community.general.keycloak_authz_permission`: Dynamic

    /// Options for community.general.keycloak_authz_permission
    hidden options: KeycloakAuthzPermissionOptions?

    /// todo doc
    function configure(): KeycloakAuthzPermission = this
        .toMap()
        .put(
            "community.general.keycloak_authz_permission",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(KeycloakAuthzPermission)

}

/// Query Keycloak client authorization permissions information
class KeycloakAuthzPermissionInfoOptions {
    
    client_id: String
    
    name: String
    
    realm: String
    
}

/// Task class for keycloak_authz_permission_info
class KeycloakAuthzPermissionInfo extends Playbook.Task {

    /// todo doc
    `community.general.keycloak_authz_permission_info`: Dynamic

    /// Options for community.general.keycloak_authz_permission_info
    hidden options: KeycloakAuthzPermissionInfoOptions?

    /// todo doc
    function configure(): KeycloakAuthzPermissionInfo = this
        .toMap()
        .put(
            "community.general.keycloak_authz_permission_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(KeycloakAuthzPermissionInfo)

}

/// Allows administration of Keycloak clients via Keycloak API
class KeycloakClientOptions {
    
    admin_url: String?
    
    always_display_in_console: Boolean?
    
    attributes: Any?
    
    authentication_flow_binding_overrides: Any?
    
    authorization_services_enabled: Boolean?
    
    authorization_settings: Any?
    
    base_url: String?
    
    bearer_only: Boolean?
    
    client_authenticator_type: ("client-secret"|"client-jwt")?
    
    client_id: String?
    
    client_template: String?
    
    consent_required: Boolean?
    
    default_client_scopes: Listing<String>?
    
    default_roles: Listing<String>?
    
    description: String?
    
    direct_access_grants_enabled: Boolean?
    
    enabled: Boolean?
    
    frontchannel_logout: Boolean?
    
    full_scope_allowed: Boolean?
    
    id: String?
    
    implicit_flow_enabled: Boolean?
    
    name: String?
    
    node_re_registration_timeout: Int?
    
    not_before: Int?
    
    optional_client_scopes: Listing<String>?
    
    protocol: ("openid-connect"|"saml")?
    
    protocol_mappers: Listing<Any>?
    
    public_client: Boolean?
    
    realm: String?
    
    redirect_uris: Listing<String>?
    
    registered_nodes: Any?
    
    registration_access_token: String?
    
    root_url: String?
    
    secret: String?
    
    service_accounts_enabled: Boolean?
    
    standard_flow_enabled: Boolean?
    
    state: ("present"|"absent")?
    
    surrogate_auth_required: Boolean?
    
    use_template_config: Boolean?
    
    use_template_mappers: Boolean?
    
    use_template_scope: Boolean?
    
    web_origins: Listing<String>?
    
}

/// Task class for keycloak_client
class KeycloakClient extends Playbook.Task {

    /// todo doc
    `community.general.keycloak_client`: Dynamic

    /// Options for community.general.keycloak_client
    hidden options: KeycloakClientOptions?

    /// todo doc
    function configure(): KeycloakClient = this
        .toMap()
        .put(
            "community.general.keycloak_client",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(KeycloakClient)

}

/// Allows administration of Keycloak client_rolemapping with the Keycloak API
class KeycloakClientRolemappingOptions {
    
    cid: String?
    
    client_id: String?
    
    gid: String?
    
    group_name: String?
    
    parents: Listing<Any>?
    
    realm: String?
    
    roles: Listing<Any>?
    
    state: ("present"|"absent")?
    
}

/// Task class for keycloak_client_rolemapping
class KeycloakClientRolemapping extends Playbook.Task {

    /// todo doc
    `community.general.keycloak_client_rolemapping`: Dynamic

    /// Options for community.general.keycloak_client_rolemapping
    hidden options: KeycloakClientRolemappingOptions?

    /// todo doc
    function configure(): KeycloakClientRolemapping = this
        .toMap()
        .put(
            "community.general.keycloak_client_rolemapping",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(KeycloakClientRolemapping)

}

/// Allows administration of Keycloak client_scopes via Keycloak API
class KeycloakClientscopeOptions {
    
    attributes: Any?
    
    description: String?
    
    id: String?
    
    name: String?
    
    protocol: ("openid-connect"|"saml"|"wsfed")?
    
    protocol_mappers: Listing<Any>?
    
    realm: String?
    
    state: ("present"|"absent")?
    
}

/// Task class for keycloak_clientscope
class KeycloakClientscope extends Playbook.Task {

    /// todo doc
    `community.general.keycloak_clientscope`: Dynamic

    /// Options for community.general.keycloak_clientscope
    hidden options: KeycloakClientscopeOptions?

    /// todo doc
    function configure(): KeycloakClientscope = this
        .toMap()
        .put(
            "community.general.keycloak_clientscope",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(KeycloakClientscope)

}

/// Set the type of aclientscope in realm or client via Keycloak API
class KeycloakClientscopeTypeOptions {
    
    client_id: String?
    
    default_clientscopes: Listing<String>?
    
    optional_clientscopes: Listing<String>?
    
    realm: String?
    
}

/// Task class for keycloak_clientscope_type
class KeycloakClientscopeType extends Playbook.Task {

    /// todo doc
    `community.general.keycloak_clientscope_type`: Dynamic

    /// Options for community.general.keycloak_clientscope_type
    hidden options: KeycloakClientscopeTypeOptions?

    /// todo doc
    function configure(): KeycloakClientscopeType = this
        .toMap()
        .put(
            "community.general.keycloak_clientscope_type",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(KeycloakClientscopeType)

}

/// Retrieve client secret via Keycloak API
class KeycloakClientsecretInfoOptions {
    
    client_id: String?
    
    id: String?
    
    realm: String?
    
}

/// Task class for keycloak_clientsecret_info
class KeycloakClientsecretInfo extends Playbook.Task {

    /// todo doc
    `community.general.keycloak_clientsecret_info`: Dynamic

    /// Options for community.general.keycloak_clientsecret_info
    hidden options: KeycloakClientsecretInfoOptions?

    /// todo doc
    function configure(): KeycloakClientsecretInfo = this
        .toMap()
        .put(
            "community.general.keycloak_clientsecret_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(KeycloakClientsecretInfo)

}

/// Regenerate Keycloak client secret via Keycloak API
class KeycloakClientsecretRegenerateOptions {
    
    client_id: String?
    
    id: String?
    
    realm: String?
    
}

/// Task class for keycloak_clientsecret_regenerate
class KeycloakClientsecretRegenerate extends Playbook.Task {

    /// todo doc
    `community.general.keycloak_clientsecret_regenerate`: Dynamic

    /// Options for community.general.keycloak_clientsecret_regenerate
    hidden options: KeycloakClientsecretRegenerateOptions?

    /// todo doc
    function configure(): KeycloakClientsecretRegenerate = this
        .toMap()
        .put(
            "community.general.keycloak_clientsecret_regenerate",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(KeycloakClientsecretRegenerate)

}

/// Allows administration of Keycloak client templates via Keycloak API
class KeycloakClienttemplateOptions {
    
    attributes: Any?
    
    description: String?
    
    full_scope_allowed: Boolean?
    
    id: String?
    
    name: String?
    
    protocol: ("openid-connect"|"saml")?
    
    protocol_mappers: Listing<Any>?
    
    realm: String?
    
    state: ("present"|"absent")?
    
}

/// Task class for keycloak_clienttemplate
class KeycloakClienttemplate extends Playbook.Task {

    /// todo doc
    `community.general.keycloak_clienttemplate`: Dynamic

    /// Options for community.general.keycloak_clienttemplate
    hidden options: KeycloakClienttemplateOptions?

    /// todo doc
    function configure(): KeycloakClienttemplate = this
        .toMap()
        .put(
            "community.general.keycloak_clienttemplate",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(KeycloakClienttemplate)

}

/// Retrive component info in Keycloak
class KeycloakComponentInfoOptions {
    
    name: String?
    
    parent_id: String?
    
    provider_type: String?
    
    realm: String
    
}

/// Task class for keycloak_component_info
class KeycloakComponentInfo extends Playbook.Task {

    /// todo doc
    `community.general.keycloak_component_info`: Dynamic

    /// Options for community.general.keycloak_component_info
    hidden options: KeycloakComponentInfoOptions?

    /// todo doc
    function configure(): KeycloakComponentInfo = this
        .toMap()
        .put(
            "community.general.keycloak_component_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(KeycloakComponentInfo)

}

/// Allows administration of Keycloak groups via Keycloak API
class KeycloakGroupOptions {
    
    attributes: Any?
    
    id: String?
    
    name: String?
    
    parents: Listing<Any>?
    
    realm: String?
    
    state: ("present"|"absent")?
    
}

/// Task class for keycloak_group
class KeycloakGroup extends Playbook.Task {

    /// todo doc
    `community.general.keycloak_group`: Dynamic

    /// Options for community.general.keycloak_group
    hidden options: KeycloakGroupOptions?

    /// todo doc
    function configure(): KeycloakGroup = this
        .toMap()
        .put(
            "community.general.keycloak_group",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(KeycloakGroup)

}

/// Allows administration of Keycloak identity providers via Keycloak API
class KeycloakIdentityProviderOptions {
    
    add_read_token_role_on_create: Boolean?
    
    alias: String
    
    authenticate_by_default: Boolean?
    
    config: Any?
    
    display_name: String?
    
    enabled: Boolean?
    
    first_broker_login_flow_alias: String?
    
    link_only: Boolean?
    
    mappers: Listing<Any>?
    
    post_broker_login_flow_alias: String?
    
    provider_id: String?
    
    realm: String?
    
    state: ("present"|"absent")?
    
    store_token: Boolean?
    
    trust_email: Boolean?
    
}

/// Task class for keycloak_identity_provider
class KeycloakIdentityProvider extends Playbook.Task {

    /// todo doc
    `community.general.keycloak_identity_provider`: Dynamic

    /// Options for community.general.keycloak_identity_provider
    hidden options: KeycloakIdentityProviderOptions?

    /// todo doc
    function configure(): KeycloakIdentityProvider = this
        .toMap()
        .put(
            "community.general.keycloak_identity_provider",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(KeycloakIdentityProvider)

}

/// Allows administration of Keycloak realm via Keycloak API
class KeycloakRealmOptions {
    
    access_code_lifespan: Int?
    
    access_code_lifespan_login: Int?
    
    access_code_lifespan_user_action: Int?
    
    access_token_lifespan: Int?
    
    access_token_lifespan_for_implicit_flow: Int?
    
    account_theme: String?
    
    action_token_generated_by_admin_lifespan: Int?
    
    action_token_generated_by_user_lifespan: Int?
    
    admin_events_details_enabled: Boolean?
    
    admin_events_enabled: Boolean?
    
    admin_theme: String?
    
    attributes: Any?
    
    browser_flow: String?
    
    browser_security_headers: Any?
    
    brute_force_protected: Boolean?
    
    client_authentication_flow: String?
    
    client_scope_mappings: Any?
    
    default_default_client_scopes: Listing<String>?
    
    default_groups: Listing<String>?
    
    default_locale: String?
    
    default_optional_client_scopes: Listing<String>?
    
    default_roles: Listing<String>?
    
    default_signature_algorithm: String?
    
    direct_grant_flow: String?
    
    display_name: String?
    
    display_name_html: String?
    
    docker_authentication_flow: String?
    
    duplicate_emails_allowed: Boolean?
    
    edit_username_allowed: Boolean?
    
    email_theme: String?
    
    enabled: Boolean?
    
    enabled_event_types: Listing<String>?
    
    events_enabled: Boolean?
    
    events_expiration: Int?
    
    events_listeners: Listing<String>?
    
    failure_factor: Int?
    
    id: String?
    
    internationalization_enabled: Boolean?
    
    login_theme: String?
    
    login_with_email_allowed: Boolean?
    
    max_delta_time_seconds: Int?
    
    max_failure_wait_seconds: Int?
    
    minimum_quick_login_wait_seconds: Int?
    
    not_before: Int?
    
    offline_session_idle_timeout: Int?
    
    offline_session_max_lifespan: Int?
    
    offline_session_max_lifespan_enabled: Boolean?
    
    otp_policy_algorithm: String?
    
    otp_policy_digits: Int?
    
    otp_policy_initial_counter: Int?
    
    otp_policy_look_ahead_window: Int?
    
    otp_policy_period: Int?
    
    otp_policy_type: String?
    
    otp_supported_applications: Listing<String>?
    
    password_policy: String?
    
    permanent_lockout: Boolean?
    
    quick_login_check_milli_seconds: Int?
    
    realm: String?
    
    refresh_token_max_reuse: Int?
    
    registration_allowed: Boolean?
    
    registration_email_as_username: Boolean?
    
    registration_flow: String?
    
    remember_me: Boolean?
    
    reset_credentials_flow: String?
    
    reset_password_allowed: Boolean?
    
    revoke_refresh_token: Boolean?
    
    smtp_server: Any?
    
    ssl_required: ("all"|"external"|"none")?
    
    sso_session_idle_timeout: Int?
    
    sso_session_idle_timeout_remember_me: Int?
    
    sso_session_max_lifespan: Int?
    
    sso_session_max_lifespan_remember_me: Int?
    
    state: ("present"|"absent")?
    
    supported_locales: Listing<String>?
    
    user_managed_access_allowed: Boolean?
    
    verify_email: Boolean?
    
    wait_increment_seconds: Int?
    
}

/// Task class for keycloak_realm
class KeycloakRealm extends Playbook.Task {

    /// todo doc
    `community.general.keycloak_realm`: Dynamic

    /// Options for community.general.keycloak_realm
    hidden options: KeycloakRealmOptions?

    /// todo doc
    function configure(): KeycloakRealm = this
        .toMap()
        .put(
            "community.general.keycloak_realm",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(KeycloakRealm)

}

/// Allows obtaining Keycloak realm public information via Keycloak API
class KeycloakRealmInfoOptions {
    
    auth_keycloak_url: String
    
    realm: String?
    
    validate_certs: Boolean?
    
}

/// Task class for keycloak_realm_info
class KeycloakRealmInfo extends Playbook.Task {

    /// todo doc
    `community.general.keycloak_realm_info`: Dynamic

    /// Options for community.general.keycloak_realm_info
    hidden options: KeycloakRealmInfoOptions?

    /// todo doc
    function configure(): KeycloakRealmInfo = this
        .toMap()
        .put(
            "community.general.keycloak_realm_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(KeycloakRealmInfo)

}

/// Allows administration of Keycloak realm keys via Keycloak API
class KeycloakRealmKeyOptions {
    
    config: Any?
    
    force: Boolean?
    
    name: String
    
    parent_id: String
    
    provider_id: ("rsa"|"rsa-enc")?
    
    state: ("present"|"absent")?
    
}

/// Task class for keycloak_realm_key
class KeycloakRealmKey extends Playbook.Task {

    /// todo doc
    `community.general.keycloak_realm_key`: Dynamic

    /// Options for community.general.keycloak_realm_key
    hidden options: KeycloakRealmKeyOptions?

    /// todo doc
    function configure(): KeycloakRealmKey = this
        .toMap()
        .put(
            "community.general.keycloak_realm_key",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(KeycloakRealmKey)

}

/// Allows administration of Keycloak realm role mappings into groups with the Keycloak API
class KeycloakRealmRolemappingOptions {
    
    gid: String?
    
    group_name: String?
    
    parents: Listing<Any>?
    
    realm: String?
    
    roles: Listing<Any>?
    
    state: ("present"|"absent")?
    
}

/// Task class for keycloak_realm_rolemapping
class KeycloakRealmRolemapping extends Playbook.Task {

    /// todo doc
    `community.general.keycloak_realm_rolemapping`: Dynamic

    /// Options for community.general.keycloak_realm_rolemapping
    hidden options: KeycloakRealmRolemappingOptions?

    /// todo doc
    function configure(): KeycloakRealmRolemapping = this
        .toMap()
        .put(
            "community.general.keycloak_realm_rolemapping",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(KeycloakRealmRolemapping)

}

/// Allows administration of Keycloak roles via Keycloak API
class KeycloakRoleOptions {
    
    attributes: Any?
    
    client_id: String?
    
    composite: Boolean?
    
    composites: Listing<Any>?
    
    description: String?
    
    name: String
    
    realm: String?
    
    state: ("present"|"absent")?
    
}

/// Task class for keycloak_role
class KeycloakRole extends Playbook.Task {

    /// todo doc
    `community.general.keycloak_role`: Dynamic

    /// Options for community.general.keycloak_role
    hidden options: KeycloakRoleOptions?

    /// todo doc
    function configure(): KeycloakRole = this
        .toMap()
        .put(
            "community.general.keycloak_role",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(KeycloakRole)

}

/// Create and configure a user in Keycloak
class KeycloakUserOptions {
    
    access: Any?
    
    attributes: Listing<Any>?
    
    auth_username: Any?
    
    client_consents: Listing<Any>?
    
    credentials: Listing<Any>?
    
    disableable_credential_types: Listing<String>?
    
    email: String?
    
    email_verified: Boolean?
    
    enabled: Boolean?
    
    federated_identities: Listing<String>?
    
    federation_link: String?
    
    first_name: String?
    
    force: Boolean?
    
    groups: Listing<Any>?
    
    id: String?
    
    last_name: String?
    
    origin: String?
    
    realm: String?
    
    required_actions: Listing<String>?
    
    self: String?
    
    service_account_client_id: String?
    
    state: ("present"|"absent")?
    
    username: String
    
}

/// Task class for keycloak_user
class KeycloakUser extends Playbook.Task {

    /// todo doc
    `community.general.keycloak_user`: Dynamic

    /// Options for community.general.keycloak_user
    hidden options: KeycloakUserOptions?

    /// todo doc
    function configure(): KeycloakUser = this
        .toMap()
        .put(
            "community.general.keycloak_user",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(KeycloakUser)

}

/// Allows administration of Keycloak user federations via Keycloak API
class KeycloakUserFederationOptions {
    
    config: Any?
    
    id: String?
    
    mappers: Listing<Any>?
    
    name: String?
    
    parent_id: String?
    
    provider_id: String?
    
    provider_type: String?
    
    realm: String?
    
    state: ("present"|"absent")?
    
}

/// Task class for keycloak_user_federation
class KeycloakUserFederation extends Playbook.Task {

    /// todo doc
    `community.general.keycloak_user_federation`: Dynamic

    /// Options for community.general.keycloak_user_federation
    hidden options: KeycloakUserFederationOptions?

    /// todo doc
    function configure(): KeycloakUserFederation = this
        .toMap()
        .put(
            "community.general.keycloak_user_federation",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(KeycloakUserFederation)

}

/// Allows administration of Keycloak user_rolemapping with the Keycloak API
class KeycloakUserRolemappingOptions {
    
    cid: String?
    
    client_id: String?
    
    realm: String?
    
    roles: Listing<Any>?
    
    service_account_user_client_id: String?
    
    state: ("present"|"absent")?
    
    target_username: String?
    
    uid: String?
    
}

/// Task class for keycloak_user_rolemapping
class KeycloakUserRolemapping extends Playbook.Task {

    /// todo doc
    `community.general.keycloak_user_rolemapping`: Dynamic

    /// Options for community.general.keycloak_user_rolemapping
    hidden options: KeycloakUserRolemappingOptions?

    /// todo doc
    function configure(): KeycloakUserRolemapping = this
        .toMap()
        .put(
            "community.general.keycloak_user_rolemapping",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(KeycloakUserRolemapping)

}

/// Set or delete a passphrase using the Operating System's native keyring
class KeyringOptions {
    
    keyring_password: String
    
    service: String
    
    state: ("present"|"absent")?
    
    user_password: String?
    
    username: String
    
}

/// Task class for keyring
class Keyring extends Playbook.Task {

    /// todo doc
    `community.general.keyring`: Dynamic

    /// Options for community.general.keyring
    hidden options: KeyringOptions?

    /// todo doc
    function configure(): Keyring = this
        .toMap()
        .put(
            "community.general.keyring",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Keyring)

}

/// Get a passphrase using the Operating System's native keyring
class KeyringInfoOptions {
    
    keyring_password: String
    
    service: String
    
    username: String
    
}

/// Task class for keyring_info
class KeyringInfo extends Playbook.Task {

    /// todo doc
    `community.general.keyring_info`: Dynamic

    /// Options for community.general.keyring_info
    hidden options: KeyringInfoOptions?

    /// todo doc
    function configure(): KeyringInfo = this
        .toMap()
        .put(
            "community.general.keyring_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(KeyringInfo)

}

/// Manage Kibana plugins
class KibanaPluginOptions {
    
    allow_root: Boolean?
    
    force: Boolean?
    
    name: String
    
    plugin_bin: String?
    
    plugin_dir: String?
    
    state: ("present"|"absent")?
    
    timeout: String?
    
    url: String?
    
    version: String?
    
}

/// Task class for kibana_plugin
class KibanaPlugin extends Playbook.Task {

    /// todo doc
    `community.general.kibana_plugin`: Dynamic

    /// Options for community.general.kibana_plugin
    hidden options: KibanaPluginOptions?

    /// todo doc
    function configure(): KibanaPlugin = this
        .toMap()
        .put(
            "community.general.kibana_plugin",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(KibanaPlugin)

}

/// Manage macOS services
class LaunchdOptions {
    
    enabled: Boolean?
    
    force_stop: Boolean?
    
    name: String
    
    state: ("reloaded"|"restarted"|"started"|"stopped"|"unloaded")?
    
}

/// Task class for launchd
class Launchd extends Playbook.Task {

    /// todo doc
    `community.general.launchd`: Dynamic

    /// Options for community.general.launchd
    hidden options: LaunchdOptions?

    /// todo doc
    function configure(): Launchd = this
        .toMap()
        .put(
            "community.general.launchd",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Launchd)

}

/// Manage Gentoo overlays
class LaymanOptions {
    
    list_url: String?
    
    name: String
    
    state: ("present"|"absent"|"updated")?
    
    validate_certs: Boolean?
    
}

/// Task class for layman
class Layman extends Playbook.Task {

    /// todo doc
    `community.general.layman`: Dynamic

    /// Options for community.general.layman
    hidden options: LaymanOptions?

    /// todo doc
    function configure(): Layman = this
        .toMap()
        .put(
            "community.general.layman",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Layman)

}

/// Local Backup Utility for Alpine Linux
class LbuOptions {
    
    commit: Boolean?
    
    exclude: Listing<String>?
    
    include: Listing<String>?
    
}

/// Task class for lbu
class Lbu extends Playbook.Task {

    /// todo doc
    `community.general.lbu`: Dynamic

    /// Options for community.general.lbu
    hidden options: LbuOptions?

    /// todo doc
    function configure(): Lbu = this
        .toMap()
        .put(
            "community.general.lbu",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Lbu)

}

/// Add or remove multiple LDAP attribute values
class LdapAttrsOptions {
    
    attributes: Any
    
    ordered: Boolean?
    
    state: ("present"|"absent"|"exact")?
    
}

/// Task class for ldap_attrs
class LdapAttrs extends Playbook.Task {

    /// todo doc
    `community.general.ldap_attrs`: Dynamic

    /// Options for community.general.ldap_attrs
    hidden options: LdapAttrsOptions?

    /// todo doc
    function configure(): LdapAttrs = this
        .toMap()
        .put(
            "community.general.ldap_attrs",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(LdapAttrs)

}

/// Add or remove LDAP entries
class LdapEntryOptions {
    
    attributes: Any?
    
    objectClass: Listing<String>?
    
    recursive: Boolean?
    
    state: ("present"|"absent")?
    
}

/// Task class for ldap_entry
class LdapEntry extends Playbook.Task {

    /// todo doc
    `community.general.ldap_entry`: Dynamic

    /// Options for community.general.ldap_entry
    hidden options: LdapEntryOptions?

    /// todo doc
    function configure(): LdapEntry = this
        .toMap()
        .put(
            "community.general.ldap_entry",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(LdapEntry)

}

/// Set passwords in LDAP
class LdapPasswdOptions {
    
    passwd: String?
    
}

/// Task class for ldap_passwd
class LdapPasswd extends Playbook.Task {

    /// todo doc
    `community.general.ldap_passwd`: Dynamic

    /// Options for community.general.ldap_passwd
    hidden options: LdapPasswdOptions?

    /// todo doc
    function configure(): LdapPasswd = this
        .toMap()
        .put(
            "community.general.ldap_passwd",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(LdapPasswd)

}

/// Search for entries in a LDAP server
class LdapSearchOptions {
    
    attrs: Listing<String>?
    
    base64_attributes: Listing<String>?
    
    dn: String
    
    filter: String?
    
    page_size: Int?
    
    schema: Boolean?
    
    scope: ("base"|"onelevel"|"subordinate"|"children")?
    
}

/// Task class for ldap_search
class LdapSearch extends Playbook.Task {

    /// todo doc
    `community.general.ldap_search`: Dynamic

    /// Options for community.general.ldap_search
    hidden options: LdapSearchOptions?

    /// todo doc
    function configure(): LdapSearch = this
        .toMap()
        .put(
            "community.general.ldap_search",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(LdapSearch)

}

/// Create an annotation in librato
class LibratoAnnotationOptions {
    
    api_key: String
    
    description: String?
    
    end_time: Int?
    
    links: Listing<Any>?
    
    name: String?
    
    source: String?
    
    start_time: Int?
    
    title: String
    
    user: String
    
}

/// Task class for librato_annotation
class LibratoAnnotation extends Playbook.Task {

    /// todo doc
    `community.general.librato_annotation`: Dynamic

    /// Options for community.general.librato_annotation
    hidden options: LibratoAnnotationOptions?

    /// todo doc
    function configure(): LibratoAnnotation = this
        .toMap()
        .put(
            "community.general.librato_annotation",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(LibratoAnnotation)

}

/// Manage instances on the Linode Public Cloud
class LinodeOptions {
    
    additional_disks: Listing<Any>?
    
    alert_bwin_enabled: Boolean?
    
    alert_bwin_threshold: Int?
    
    alert_bwout_enabled: Boolean?
    
    alert_bwout_threshold: Int?
    
    alert_bwquota_enabled: Boolean?
    
    alert_bwquota_threshold: Int?
    
    alert_cpu_enabled: Boolean?
    
    alert_cpu_threshold: Int?
    
    alert_diskio_enabled: Boolean?
    
    alert_diskio_threshold: Int?
    
    api_key: String
    
    backupweeklyday: Int?
    
    backupwindow: Int?
    
    datacenter: Int?
    
    displaygroup: String?
    
    distribution: Int?
    
    kernel_id: Int?
    
    linode_id: Int?
    
    name: String
    
    password: String?
    
    payment_term: Int?
    
    plan: Int?
    
    private_ip: Boolean?
    
    ssh_pub_key: String?
    
    state: ("absent"|"active"|"deleted"|"present"|"restarted"|"started"|"stopped")?
    
    swap: Int?
    
    wait: Boolean?
    
    wait_timeout: Int?
    
    watchdog: Boolean?
    
}

/// Task class for linode
class Linode extends Playbook.Task {

    /// todo doc
    `community.general.linode`: Dynamic

    /// Options for community.general.linode
    hidden options: LinodeOptions?

    /// todo doc
    function configure(): Linode = this
        .toMap()
        .put(
            "community.general.linode",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Linode)

}

/// Manage instances on the Linode cloud
class LinodeV4Options {
    
    access_token: String
    
    authorized_keys: Listing<String>?
    
    group: String?
    
    image: String?
    
    label: String
    
    private_ip: Boolean?
    
    region: String?
    
    root_pass: String?
    
    stackscript_data: Any?
    
    stackscript_id: Int?
    
    state: ("present"|"absent")
    
    tags: Listing<String>?
    
    type: String?
    
}

/// Task class for linode_v4
class LinodeV4 extends Playbook.Task {

    /// todo doc
    `community.general.linode_v4`: Dynamic

    /// Options for community.general.linode_v4
    hidden options: LinodeV4Options?

    /// todo doc
    function configure(): LinodeV4 = this
        .toMap()
        .put(
            "community.general.linode_v4",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(LinodeV4)

}

/// Gather facts on processes listening on TCP and UDP ports
class ListenPortsFactsOptions {
    
    command: ("netstat"|"ss")?
    
    include_non_listening: Boolean?
    
}

/// Task class for listen_ports_facts
class ListenPortsFacts extends Playbook.Task {

    /// todo doc
    `community.general.listen_ports_facts`: Dynamic

    /// Options for community.general.listen_ports_facts
    hidden options: ListenPortsFactsOptions?

    /// todo doc
    function configure(): ListenPortsFacts = this
        .toMap()
        .put(
            "community.general.listen_ports_facts",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ListenPortsFacts)

}

/// Get details reported by lldp
class LldpOptions {
    
}

/// Task class for lldp
class Lldp extends Playbook.Task {

    /// todo doc
    `community.general.lldp`: Dynamic

    /// Options for community.general.lldp
    hidden options: LldpOptions?

    /// todo doc
    function configure(): Lldp = this
        .toMap()
        .put(
            "community.general.lldp",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Lldp)

}

/// Creates or removes locales
class LocaleGenOptions {
    
    name: String
    
    state: ("absent"|"present")?
    
}

/// Task class for locale_gen
class LocaleGen extends Playbook.Task {

    /// todo doc
    `community.general.locale_gen`: Dynamic

    /// Options for community.general.locale_gen
    hidden options: LocaleGenOptions?

    /// todo doc
    function configure(): LocaleGen = this
        .toMap()
        .put(
            "community.general.locale_gen",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(LocaleGen)

}

/// Module for tracking logs via logentries.com
class LogentriesOptions {
    
    logtype: String?
    
    name: String?
    
    path: String
    
    state: ("present"|"absent"|"followed"|"unfollowed")?
    
}

/// Task class for logentries
class Logentries extends Playbook.Task {

    /// todo doc
    `community.general.logentries`: Dynamic

    /// Options for community.general.logentries
    hidden options: LogentriesOptions?

    /// todo doc
    function configure(): Logentries = this
        .toMap()
        .put(
            "community.general.logentries",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Logentries)

}

/// Send a message to logentries
class LogentriesMsgOptions {
    
    api: String?
    
    msg: String
    
    port: Int?
    
    token: String
    
}

/// Task class for logentries_msg
class LogentriesMsg extends Playbook.Task {

    /// todo doc
    `community.general.logentries_msg`: Dynamic

    /// Options for community.general.logentries_msg
    hidden options: LogentriesMsgOptions?

    /// todo doc
    function configure(): LogentriesMsg = this
        .toMap()
        .put(
            "community.general.logentries_msg",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(LogentriesMsg)

}

/// Manage Logstash plugins
class LogstashPluginOptions {
    
    name: String
    
    plugin_bin: String?
    
    proxy_host: String?
    
    proxy_port: String?
    
    state: ("present"|"absent")?
    
    version: String?
    
}

/// Task class for logstash_plugin
class LogstashPlugin extends Playbook.Task {

    /// todo doc
    `community.general.logstash_plugin`: Dynamic

    /// Options for community.general.logstash_plugin
    hidden options: LogstashPluginOptions?

    /// todo doc
    function configure(): LogstashPlugin = this
        .toMap()
        .put(
            "community.general.logstash_plugin",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(LogstashPlugin)

}

/// Configure LVM volume groups
class LvgOptions {
    
    force: Boolean?
    
    pesize: String?
    
    pv_options: String?
    
    pvresize: Boolean?
    
    pvs: Listing<String>?
    
    reset_pv_uuid: Boolean?
    
    reset_vg_uuid: Boolean?
    
    state: ("absent"|"present"|"active"|"inactive")?
    
    vg: String
    
    vg_options: String?
    
}

/// Task class for lvg
class Lvg extends Playbook.Task {

    /// todo doc
    `community.general.lvg`: Dynamic

    /// Options for community.general.lvg
    hidden options: LvgOptions?

    /// todo doc
    function configure(): Lvg = this
        .toMap()
        .put(
            "community.general.lvg",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Lvg)

}

/// Renames LVM volume groups
class LvgRenameOptions {
    
    vg: String
    
    vg_new: String
    
}

/// Task class for lvg_rename
class LvgRename extends Playbook.Task {

    /// todo doc
    `community.general.lvg_rename`: Dynamic

    /// Options for community.general.lvg_rename
    hidden options: LvgRenameOptions?

    /// todo doc
    function configure(): LvgRename = this
        .toMap()
        .put(
            "community.general.lvg_rename",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(LvgRename)

}

/// Configure LVM logical volumes
class LvolOptions {
    
    active: Boolean?
    
    force: Boolean?
    
    lv: String?
    
    opts: String?
    
    pvs: Listing<String>?
    
    resizefs: Boolean?
    
    shrink: Boolean?
    
    size: String?
    
    snapshot: String?
    
    state: ("absent"|"present")?
    
    thinpool: String?
    
    vg: String
    
}

/// Task class for lvol
class Lvol extends Playbook.Task {

    /// todo doc
    `community.general.lvol`: Dynamic

    /// Options for community.general.lvol
    hidden options: LvolOptions?

    /// todo doc
    function configure(): Lvol = this
        .toMap()
        .put(
            "community.general.lvol",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Lvol)

}

/// Manage LXC Containers
class LxcContainerOptions {
    
    archive: Boolean?
    
    archive_compression: ("gzip"|"bzip2"|"none")?
    
    archive_path: String?
    
    backing_store: ("dir"|"lvm"|"loop"|"btrfs"|"overlayfs"|"zfs")?
    
    clone_name: String?
    
    clone_snapshot: Boolean?
    
    config: String?
    
    container_command: String?
    
    container_config: Listing<String>?
    
    container_log: Boolean?
    
    container_log_level: ("Info"|"info"|"INFO"|"Error"|"error"|"ERROR"|"Debug"|"debug"|"DEBUG")?
    
    directory: String?
    
    fs_size: String?
    
    fs_type: String?
    
    lv_name: String?
    
    lxc_path: String?
    
    name: String
    
    state: ("started"|"stopped"|"restarted"|"absent"|"frozen"|"clone")?
    
    template: String?
    
    template_options: String?
    
    thinpool: String?
    
    vg_name: String?
    
    zfs_root: String?
    
}

/// Task class for lxc_container
class LxcContainer extends Playbook.Task {

    /// todo doc
    `community.general.lxc_container`: Dynamic

    /// Options for community.general.lxc_container
    hidden options: LxcContainerOptions?

    /// todo doc
    function configure(): LxcContainer = this
        .toMap()
        .put(
            "community.general.lxc_container",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(LxcContainer)

}

/// Custom module for lxca cmms inventory utility
class LxcaCmmsOptions {
    
    chassis: String?
    
    command_options: ("cmms"|"cmms_by_uuid"|"cmms_by_chassis_uuid")?
    
    uuid: String?
    
}

/// Task class for lxca_cmms
class LxcaCmms extends Playbook.Task {

    /// todo doc
    `community.general.lxca_cmms`: Dynamic

    /// Options for community.general.lxca_cmms
    hidden options: LxcaCmmsOptions?

    /// todo doc
    function configure(): LxcaCmms = this
        .toMap()
        .put(
            "community.general.lxca_cmms",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(LxcaCmms)

}

/// Custom module for lxca nodes inventory utility
class LxcaNodesOptions {
    
    chassis: String?
    
    command_options: ("nodes"|"nodes_by_uuid"|"nodes_by_chassis_uuid"|"nodes_status_managed"|"nodes_status_unmanaged")?
    
    uuid: String?
    
}

/// Task class for lxca_nodes
class LxcaNodes extends Playbook.Task {

    /// todo doc
    `community.general.lxca_nodes`: Dynamic

    /// Options for community.general.lxca_nodes
    hidden options: LxcaNodesOptions?

    /// todo doc
    function configure(): LxcaNodes = this
        .toMap()
        .put(
            "community.general.lxca_nodes",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(LxcaNodes)

}

/// Manage LXD instances
class LxdContainerOptions {
    
    architecture: String?
    
    client_cert: String?
    
    client_key: String?
    
    config: Any?
    
    devices: Any?
    
    ephemeral: Boolean?
    
    force_stop: Boolean?
    
    ignore_volatile_options: Boolean?
    
    name: String
    
    profiles: Listing<String>?
    
    project: String?
    
    snap_url: String?
    
    source: Any?
    
    state: ("started"|"stopped"|"restarted"|"absent"|"frozen")?
    
    target: String?
    
    timeout: Int?
    
    trust_password: String?
    
    type: ("container"|"virtual-machine")?
    
    url: String?
    
    wait_for_container: Boolean?
    
    wait_for_ipv4_addresses: Boolean?
    
}

/// Task class for lxd_container
class LxdContainer extends Playbook.Task {

    /// todo doc
    `community.general.lxd_container`: Dynamic

    /// Options for community.general.lxd_container
    hidden options: LxdContainerOptions?

    /// todo doc
    function configure(): LxdContainer = this
        .toMap()
        .put(
            "community.general.lxd_container",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(LxdContainer)

}

/// Manage LXD profiles
class LxdProfileOptions {
    
    client_cert: String?
    
    client_key: String?
    
    config: Any?
    
    description: String?
    
    devices: Any?
    
    merge_profile: Boolean?
    
    name: String
    
    new_name: String?
    
    project: String?
    
    snap_url: String?
    
    state: ("present"|"absent")?
    
    trust_password: String?
    
    url: String?
    
}

/// Task class for lxd_profile
class LxdProfile extends Playbook.Task {

    /// todo doc
    `community.general.lxd_profile`: Dynamic

    /// Options for community.general.lxd_profile
    hidden options: LxdProfileOptions?

    /// todo doc
    function configure(): LxdProfile = this
        .toMap()
        .put(
            "community.general.lxd_profile",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(LxdProfile)

}

/// Manage LXD projects
class LxdProjectOptions {
    
    client_cert: String?
    
    client_key: String?
    
    config: Any?
    
    description: String?
    
    merge_project: Boolean?
    
    name: String
    
    new_name: String?
    
    snap_url: String?
    
    state: ("present"|"absent")?
    
    trust_password: String?
    
    url: String?
    
}

/// Task class for lxd_project
class LxdProject extends Playbook.Task {

    /// todo doc
    `community.general.lxd_project`: Dynamic

    /// Options for community.general.lxd_project
    hidden options: LxdProjectOptions?

    /// todo doc
    function configure(): LxdProject = this
        .toMap()
        .put(
            "community.general.lxd_project",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(LxdProject)

}

/// Package manager for MacPorts
class MacportsOptions {
    
    name: Listing<String>?
    
    selfupdate: Boolean?
    
    state: ("present"|"absent"|"active"|"inactive"|"installed"|"removed")?
    
    upgrade: Boolean?
    
    variant: String?
    
}

/// Task class for macports
class Macports extends Playbook.Task {

    /// todo doc
    `community.general.macports`: Dynamic

    /// Options for community.general.macports
    hidden options: MacportsOptions?

    /// todo doc
    function configure(): Macports = this
        .toMap()
        .put(
            "community.general.macports",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Macports)

}

/// Send an email
class MailOptions {
    
    attach: Listing<String>?
    
    bcc: Listing<String>?
    
    body: String?
    
    cc: Listing<String>?
    
    charset: String?
    
    ehlohost: String?
    
    headers: Listing<String>?
    
    host: String?
    
    message_id_domain: String?
    
    password: String?
    
    port: Int?
    
    secure: ("always"|"never"|"starttls"|"try")?
    
    sender: String?
    
    subject: String
    
    subtype: ("html"|"plain")?
    
    timeout: Int?
    
    to: Listing<String>?
    
    username: String?
    
}

/// Task class for mail
class Mail extends Playbook.Task {

    /// todo doc
    `community.general.mail`: Dynamic

    /// Options for community.general.mail
    hidden options: MailOptions?

    /// todo doc
    function configure(): Mail = this
        .toMap()
        .put(
            "community.general.mail",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Mail)

}

/// Run targets in a Makefile
class MakeOptions {
    
    chdir: String
    
    file: String?
    
    jobs: Int?
    
    make: String?
    
    params: Any?
    
    target: String?
    
    targets: Listing<String>?
    
}

/// Task class for make
class Make extends Playbook.Task {

    /// todo doc
    `community.general.make`: Dynamic

    /// Options for community.general.make
    hidden options: MakeOptions?

    /// todo doc
    function configure(): Make = this
        .toMap()
        .put(
            "community.general.make",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Make)

}

/// Configuration of alert profiles for ManageIQ
class ManageiqAlertProfilesOptions {
    
    alerts: Listing<String>?
    
    name: String?
    
    notes: String?
    
    resource_type: ("Vm"|"ContainerNode"|"MiqServer"|"Host"|"Storage"|"EmsCluster"|"ExtManagementSystem"|"MiddlewareServer")?
    
    state: ("absent"|"present")?
    
}

/// Task class for manageiq_alert_profiles
class ManageiqAlertProfiles extends Playbook.Task {

    /// todo doc
    `community.general.manageiq_alert_profiles`: Dynamic

    /// Options for community.general.manageiq_alert_profiles
    hidden options: ManageiqAlertProfilesOptions?

    /// todo doc
    function configure(): ManageiqAlertProfiles = this
        .toMap()
        .put(
            "community.general.manageiq_alert_profiles",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ManageiqAlertProfiles)

}

/// Configuration of alerts in ManageIQ
class ManageiqAlertsOptions {
    
    description: String?
    
    enabled: Boolean?
    
    expression: Any?
    
    expression_type: ("hash"|"miq")?
    
    options: Any?
    
    resource_type: ("Vm"|"ContainerNode"|"MiqServer"|"Host"|"Storage"|"EmsCluster"|"ExtManagementSystem"|"MiddlewareServer")?
    
    state: ("absent"|"present")?
    
}

/// Task class for manageiq_alerts
class ManageiqAlerts extends Playbook.Task {

    /// todo doc
    `community.general.manageiq_alerts`: Dynamic

    /// Options for community.general.manageiq_alerts
    hidden options: ManageiqAlertsOptions?

    /// todo doc
    function configure(): ManageiqAlerts = this
        .toMap()
        .put(
            "community.general.manageiq_alerts",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ManageiqAlerts)

}

/// Management of groups in ManageIQ
class ManageiqGroupOptions {
    
    belongsto_filters: Listing<String>?
    
    belongsto_filters_merge_mode: ("merge"|"replace")?
    
    description: String
    
    managed_filters: Any?
    
    managed_filters_merge_mode: ("merge"|"replace")?
    
    role: String?
    
    role_id: Int?
    
    state: ("absent"|"present")?
    
    tenant: String?
    
    tenant_id: Int?
    
}

/// Task class for manageiq_group
class ManageiqGroup extends Playbook.Task {

    /// todo doc
    `community.general.manageiq_group`: Dynamic

    /// Options for community.general.manageiq_group
    hidden options: ManageiqGroupOptions?

    /// todo doc
    function configure(): ManageiqGroup = this
        .toMap()
        .put(
            "community.general.manageiq_group",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ManageiqGroup)

}

/// Management of resource policy_profiles in ManageIQ
class ManageiqPoliciesOptions {
    
    policy_profiles: Listing<Any>?
    
    resource_id: Int?
    
    resource_name: String?
    
    resource_type: ("provider"|"host"|"vm"|"blueprint"|"category"|"cluster"|"data store"|"group"|"resource pool"|"service"|"service template"|"template"|"tenant"|"user")
    
    state: ("absent"|"present")?
    
}

/// Task class for manageiq_policies
class ManageiqPolicies extends Playbook.Task {

    /// todo doc
    `community.general.manageiq_policies`: Dynamic

    /// Options for community.general.manageiq_policies
    hidden options: ManageiqPoliciesOptions?

    /// todo doc
    function configure(): ManageiqPolicies = this
        .toMap()
        .put(
            "community.general.manageiq_policies",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ManageiqPolicies)

}

/// Listing of resource policy_profiles in ManageIQ
class ManageiqPoliciesInfoOptions {
    
    resource_id: Int?
    
    resource_name: String?
    
    resource_type: ("provider"|"host"|"vm"|"blueprint"|"category"|"cluster"|"data store"|"group"|"resource pool"|"service"|"service template"|"template"|"tenant"|"user")
    
}

/// Task class for manageiq_policies_info
class ManageiqPoliciesInfo extends Playbook.Task {

    /// todo doc
    `community.general.manageiq_policies_info`: Dynamic

    /// Options for community.general.manageiq_policies_info
    hidden options: ManageiqPoliciesInfoOptions?

    /// todo doc
    function configure(): ManageiqPoliciesInfo = this
        .toMap()
        .put(
            "community.general.manageiq_policies_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ManageiqPoliciesInfo)

}

/// Management of provider in ManageIQ
class ManageiqProviderOptions {
    
    alerts: Any?
    
    api_version: ("v2"|"v3")?
    
    azure_tenant_id: String?
    
    host_default_vnc_port_end: String?
    
    host_default_vnc_port_start: String?
    
    metrics: Any?
    
    name: String
    
    project: String?
    
    provider: Any?
    
    provider_region: String?
    
    ssh_keypair: Any?
    
    state: ("absent"|"present"|"refresh")?
    
    subscription: String?
    
    tenant_mapping_enabled: Boolean?
    
    type: ("Openshift"|"Amazon"|"oVirt"|"VMware"|"Azure"|"Director"|"OpenStack"|"GCE")?
    
    zone: String?
    
}

/// Task class for manageiq_provider
class ManageiqProvider extends Playbook.Task {

    /// todo doc
    `community.general.manageiq_provider`: Dynamic

    /// Options for community.general.manageiq_provider
    hidden options: ManageiqProviderOptions?

    /// todo doc
    function configure(): ManageiqProvider = this
        .toMap()
        .put(
            "community.general.manageiq_provider",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ManageiqProvider)

}

/// Management of resource tags in ManageIQ
class ManageiqTagsOptions {
    
    resource_id: Int?
    
    resource_name: String?
    
    resource_type: ("provider"|"host"|"vm"|"blueprint"|"category"|"cluster"|"data store"|"group"|"resource pool"|"service"|"service template"|"template"|"tenant"|"user")
    
    state: ("absent"|"present")?
    
    tags: Listing<Any>?
    
}

/// Task class for manageiq_tags
class ManageiqTags extends Playbook.Task {

    /// todo doc
    `community.general.manageiq_tags`: Dynamic

    /// Options for community.general.manageiq_tags
    hidden options: ManageiqTagsOptions?

    /// todo doc
    function configure(): ManageiqTags = this
        .toMap()
        .put(
            "community.general.manageiq_tags",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ManageiqTags)

}

/// Retrieve resource tags in ManageIQ
class ManageiqTagsInfoOptions {
    
    resource_id: Int?
    
    resource_name: String?
    
    resource_type: ("provider"|"host"|"vm"|"blueprint"|"category"|"cluster"|"data store"|"group"|"resource pool"|"service"|"service template"|"template"|"tenant"|"user")
    
}

/// Task class for manageiq_tags_info
class ManageiqTagsInfo extends Playbook.Task {

    /// todo doc
    `community.general.manageiq_tags_info`: Dynamic

    /// Options for community.general.manageiq_tags_info
    hidden options: ManageiqTagsInfoOptions?

    /// todo doc
    function configure(): ManageiqTagsInfo = this
        .toMap()
        .put(
            "community.general.manageiq_tags_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ManageiqTagsInfo)

}

/// Management of tenants in ManageIQ
class ManageiqTenantOptions {
    
    description: String
    
    name: String
    
    parent: String?
    
    parent_id: Int?
    
    quotas: Any?
    
    state: ("absent"|"present")?
    
}

/// Task class for manageiq_tenant
class ManageiqTenant extends Playbook.Task {

    /// todo doc
    `community.general.manageiq_tenant`: Dynamic

    /// Options for community.general.manageiq_tenant
    hidden options: ManageiqTenantOptions?

    /// todo doc
    function configure(): ManageiqTenant = this
        .toMap()
        .put(
            "community.general.manageiq_tenant",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ManageiqTenant)

}

/// Management of users in ManageIQ
class ManageiqUserOptions {
    
    email: String?
    
    group: String?
    
    name: String?
    
    password: String?
    
    state: ("absent"|"present")?
    
    update_password: ("always"|"on_create")?
    
    userid: String
    
}

/// Task class for manageiq_user
class ManageiqUser extends Playbook.Task {

    /// todo doc
    `community.general.manageiq_user`: Dynamic

    /// Options for community.general.manageiq_user
    hidden options: ManageiqUserOptions?

    /// todo doc
    function configure(): ManageiqUser = this
        .toMap()
        .put(
            "community.general.manageiq_user",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ManageiqUser)

}

/// Manage Mac App Store applications with mas-cli
class MasOptions {
    
    id: Listing<Int>?
    
    state: ("absent"|"latest"|"present")?
    
    upgrade_all: Boolean?
    
}

/// Task class for mas
class Mas extends Playbook.Task {

    /// todo doc
    `community.general.mas`: Dynamic

    /// Options for community.general.mas
    hidden options: MasOptions?

    /// todo doc
    function configure(): Mas = this
        .toMap()
        .put(
            "community.general.mas",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Mas)

}

/// Send notifications to matrix
class MatrixOptions {
    
    hs_url: String
    
    msg_html: String
    
    msg_plain: String
    
    password: String?
    
    room_id: String
    
    token: String?
    
    user_id: String?
    
}

/// Task class for matrix
class Matrix extends Playbook.Task {

    /// todo doc
    `community.general.matrix`: Dynamic

    /// Options for community.general.matrix
    hidden options: MatrixOptions?

    /// todo doc
    function configure(): Matrix = this
        .toMap()
        .put(
            "community.general.matrix",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Matrix)

}

/// Send Mattermost notifications
class MattermostOptions {
    
    api_key: String
    
    attachments: Listing<Any>?
    
    channel: String?
    
    icon_url: String?
    
    text: String?
    
    url: String
    
    username: String?
    
    validate_certs: Boolean?
    
}

/// Task class for mattermost
class Mattermost extends Playbook.Task {

    /// todo doc
    `community.general.mattermost`: Dynamic

    /// Options for community.general.mattermost
    hidden options: MattermostOptions?

    /// todo doc
    function configure(): Mattermost = this
        .toMap()
        .put(
            "community.general.mattermost",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Mattermost)

}

/// Downloads an Artifact from a Maven Repository
class MavenArtifactOptions {
    
    artifact_id: String
    
    checksum_alg: ("md5"|"sha1")?
    
    classifier: String?
    
    client_cert: String?
    
    client_key: String?
    
    dest: String
    
    directory_mode: String?
    
    extension: String?
    
    force_basic_auth: Boolean?
    
    group_id: String
    
    headers: Any?
    
    keep_name: Boolean?
    
    password: String?
    
    repository_url: String?
    
    state: ("present"|"absent")?
    
    timeout: Int?
    
    unredirected_headers: Listing<String>?
    
    username: String?
    
    validate_certs: Boolean?
    
    verify_checksum: ("never"|"download"|"change"|"always")?
    
    version: String?
    
    version_by_spec: String?
    
}

/// Task class for maven_artifact
class MavenArtifact extends Playbook.Task {

    /// todo doc
    `community.general.maven_artifact`: Dynamic

    /// Options for community.general.maven_artifact
    hidden options: MavenArtifactOptions?

    /// todo doc
    function configure(): MavenArtifact = this
        .toMap()
        .put(
            "community.general.maven_artifact",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(MavenArtifact)

}

/// Request reload of Memset's DNS infrastructure,
class MemsetDnsReloadOptions {
    
    api_key: String
    
    poll: Boolean?
    
}

/// Task class for memset_dns_reload
class MemsetDnsReload extends Playbook.Task {

    /// todo doc
    `community.general.memset_dns_reload`: Dynamic

    /// Options for community.general.memset_dns_reload
    hidden options: MemsetDnsReloadOptions?

    /// todo doc
    function configure(): MemsetDnsReload = this
        .toMap()
        .put(
            "community.general.memset_dns_reload",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(MemsetDnsReload)

}

/// Retrieve Memstore product usage information
class MemsetMemstoreInfoOptions {
    
    api_key: String
    
    name: String
    
}

/// Task class for memset_memstore_info
class MemsetMemstoreInfo extends Playbook.Task {

    /// todo doc
    `community.general.memset_memstore_info`: Dynamic

    /// Options for community.general.memset_memstore_info
    hidden options: MemsetMemstoreInfoOptions?

    /// todo doc
    function configure(): MemsetMemstoreInfo = this
        .toMap()
        .put(
            "community.general.memset_memstore_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(MemsetMemstoreInfo)

}

/// Retrieve server information
class MemsetServerInfoOptions {
    
    api_key: String
    
    name: String
    
}

/// Task class for memset_server_info
class MemsetServerInfo extends Playbook.Task {

    /// todo doc
    `community.general.memset_server_info`: Dynamic

    /// Options for community.general.memset_server_info
    hidden options: MemsetServerInfoOptions?

    /// todo doc
    function configure(): MemsetServerInfo = this
        .toMap()
        .put(
            "community.general.memset_server_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(MemsetServerInfo)

}

/// Creates and deletes Memset DNS zones
class MemsetZoneOptions {
    
    api_key: String
    
    force: Boolean?
    
    name: String
    
    state: ("absent"|"present")
    
    ttl: Int?
    
}

/// Task class for memset_zone
class MemsetZone extends Playbook.Task {

    /// todo doc
    `community.general.memset_zone`: Dynamic

    /// Options for community.general.memset_zone
    hidden options: MemsetZoneOptions?

    /// todo doc
    function configure(): MemsetZone = this
        .toMap()
        .put(
            "community.general.memset_zone",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(MemsetZone)

}

/// Create and delete domains in Memset DNS zones
class MemsetZoneDomainOptions {
    
    api_key: String
    
    domain: String
    
    state: ("absent"|"present")?
    
    zone: String
    
}

/// Task class for memset_zone_domain
class MemsetZoneDomain extends Playbook.Task {

    /// todo doc
    `community.general.memset_zone_domain`: Dynamic

    /// Options for community.general.memset_zone_domain
    hidden options: MemsetZoneDomainOptions?

    /// todo doc
    function configure(): MemsetZoneDomain = this
        .toMap()
        .put(
            "community.general.memset_zone_domain",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(MemsetZoneDomain)

}

/// Create and delete records in Memset DNS zones
class MemsetZoneRecordOptions {
    
    address: String
    
    api_key: String
    
    priority: Int?
    
    `record`: String?
    
    relative: Boolean?
    
    state: ("absent"|"present")?
    
    ttl: Int?
    
    type: ("A"|"AAAA"|"CNAME"|"MX"|"NS"|"SRV"|"TXT")
    
    zone: String
    
}

/// Task class for memset_zone_record
class MemsetZoneRecord extends Playbook.Task {

    /// todo doc
    `community.general.memset_zone_record`: Dynamic

    /// Options for community.general.memset_zone_record
    hidden options: MemsetZoneRecordOptions?

    /// todo doc
    function configure(): MemsetZoneRecord = this
        .toMap()
        .put(
            "community.general.memset_zone_record",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(MemsetZoneRecord)

}

/// Generates AIX mksysb rootvg backups
class MksysbOptions {
    
    backup_crypt_files: Boolean?
    
    backup_dmapi_fs: Boolean?
    
    create_map_files: Boolean?
    
    exclude_files: Boolean?
    
    exclude_wpar_files: Boolean?
    
    extended_attrs: Boolean?
    
    name: String
    
    new_image_data: Boolean?
    
    software_packing: Boolean?
    
    storage_path: String
    
    use_snapshot: Boolean?
    
}

/// Task class for mksysb
class Mksysb extends Playbook.Task {

    /// todo doc
    `community.general.mksysb`: Dynamic

    /// Options for community.general.mksysb
    hidden options: MksysbOptions?

    /// todo doc
    function configure(): Mksysb = this
        .toMap()
        .put(
            "community.general.mksysb",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Mksysb)

}

/// Load or unload kernel modules
class ModprobeOptions {
    
    name: String
    
    params: String?
    
    persistent: ("disabled"|"absent"|"present")?
    
    state: ("absent"|"present")?
    
}

/// Task class for modprobe
class Modprobe extends Playbook.Task {

    /// todo doc
    `community.general.modprobe`: Dynamic

    /// Options for community.general.modprobe
    hidden options: ModprobeOptions?

    /// todo doc
    function configure(): Modprobe = this
        .toMap()
        .put(
            "community.general.modprobe",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Modprobe)

}

/// Manage the state of a program monitored via Monit
class MonitOptions {
    
    name: String
    
    state: ("present"|"started"|"stopped"|"restarted"|"monitored"|"unmonitored"|"reloaded")
    
    timeout: Int?
    
}

/// Task class for monit
class Monit extends Playbook.Task {

    /// todo doc
    `community.general.monit`: Dynamic

    /// Options for community.general.monit
    hidden options: MonitOptions?

    /// todo doc
    function configure(): Monit = this
        .toMap()
        .put(
            "community.general.monit",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Monit)

}

/// Publish a message on an MQTT topic for the IoT
class MqttOptions {
    
    ca_cert: String?
    
    client_cert: String?
    
    client_id: String?
    
    client_key: String?
    
    password: String?
    
    payload: String
    
    port: Int?
    
    qos: ("0"|"1"|"2")?
    
    retain: Boolean?
    
    server: String?
    
    tls_version: ("tlsv1.1"|"tlsv1.2")?
    
    topic: String
    
    username: String?
    
}

/// Task class for mqtt
class Mqtt extends Playbook.Task {

    /// todo doc
    `community.general.mqtt`: Dynamic

    /// Options for community.general.mqtt
    hidden options: MqttOptions?

    /// todo doc
    function configure(): Mqtt = this
        .toMap()
        .put(
            "community.general.mqtt",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Mqtt)

}

/// Add or remove MSSQL databases from a remote host
class MssqlDbOptions {
    
    autocommit: Boolean?
    
    login_host: String
    
    login_password: String?
    
    login_port: String?
    
    login_user: String?
    
    name: String
    
    state: ("present"|"absent"|"import")?
    
    target: String?
    
}

/// Task class for mssql_db
class MssqlDb extends Playbook.Task {

    /// todo doc
    `community.general.mssql_db`: Dynamic

    /// Options for community.general.mssql_db
    hidden options: MssqlDbOptions?

    /// todo doc
    function configure(): MssqlDb = this
        .toMap()
        .put(
            "community.general.mssql_db",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(MssqlDb)

}

/// Execute SQL scripts on a MSSQL database
class MssqlScriptOptions {
    
    login_host: String
    
    login_password: String?
    
    login_port: Int?
    
    login_user: String?
    
    name: String?
    
    output: ("dict"|"default")?
    
    params: Any?
    
    script: String
    
    transaction: Boolean?
    
}

/// Task class for mssql_script
class MssqlScript extends Playbook.Task {

    /// todo doc
    `community.general.mssql_script`: Dynamic

    /// Options for community.general.mssql_script
    hidden options: MssqlScriptOptions?

    /// todo doc
    function configure(): MssqlScript = this
        .toMap()
        .put(
            "community.general.mssql_script",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(MssqlScript)

}

/// Perform common tasks in Nagios related to downtime and notifications
class NagiosOptions {
    
    action: ("downtime"|"delete_downtime"|"enable_alerts"|"disable_alerts"|"silence"|"unsilence"|"silence_nagios"|"unsilence_nagios"|"command"|"servicegroup_service_downtime"|"servicegroup_host_downtime"|"acknowledge"|"forced_check")
    
    author: String?
    
    cmdfile: String?
    
    command: String?
    
    comment: String?
    
    host: String?
    
    minutes: Int?
    
    servicegroup: String?
    
    services: String?
    
    start: String?
    
}

/// Task class for nagios
class Nagios extends Playbook.Task {

    /// todo doc
    `community.general.nagios`: Dynamic

    /// Options for community.general.nagios
    hidden options: NagiosOptions?

    /// todo doc
    function configure(): Nagios = this
        .toMap()
        .put(
            "community.general.nagios",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Nagios)

}

/// Manage Netcup DNS records
class NetcupDnsOptions {
    
    api_key: String
    
    api_password: String
    
    customer_id: Int
    
    domain: String
    
    priority: Int?
    
    `record`: String?
    
    solo: Boolean?
    
    state: ("present"|"absent")?
    
    timeout: Int?
    
    type: ("A"|"AAAA"|"MX"|"CNAME"|"CAA"|"SRV"|"TXT"|"TLSA"|"NS"|"DS"|"OPENPGPKEY"|"SMIMEA"|"SSHFP")
    
    value: String
    
}

/// Task class for netcup_dns
class NetcupDns extends Playbook.Task {

    /// todo doc
    `community.general.netcup_dns`: Dynamic

    /// Options for community.general.netcup_dns
    hidden options: NetcupDnsOptions?

    /// todo doc
    function configure(): NetcupDns = this
        .toMap()
        .put(
            "community.general.netcup_dns",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(NetcupDns)

}

/// Notify New Relic about app deployments
class NewrelicDeploymentOptions {
    
    app_name: String?
    
    app_name_exact_match: Boolean?
    
    application_id: String?
    
    changelog: String?
    
    description: String?
    
    revision: String
    
    token: String
    
    user: String?
    
    validate_certs: Boolean?
    
}

/// Task class for newrelic_deployment
class NewrelicDeployment extends Playbook.Task {

    /// todo doc
    `community.general.newrelic_deployment`: Dynamic

    /// Options for community.general.newrelic_deployment
    hidden options: NewrelicDeploymentOptions?

    /// todo doc
    function configure(): NewrelicDeployment = this
        .toMap()
        .put(
            "community.general.newrelic_deployment",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(NewrelicDeployment)

}

/// Send a SMS via nexmo
class NexmoOptions {
    
    api_key: String
    
    api_secret: String
    
    dest: Listing<Int>
    
    msg: String
    
    src: Int
    
    validate_certs: Boolean?
    
}

/// Task class for nexmo
class Nexmo extends Playbook.Task {

    /// todo doc
    `community.general.nexmo`: Dynamic

    /// Options for community.general.nexmo
    hidden options: NexmoOptions?

    /// todo doc
    function configure(): Nexmo = this
        .toMap()
        .put(
            "community.general.nexmo",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Nexmo)

}

/// Retrieve information on nginx status
class NginxStatusInfoOptions {
    
    timeout: Int?
    
    url: String
    
}

/// Task class for nginx_status_info
class NginxStatusInfo extends Playbook.Task {

    /// todo doc
    `community.general.nginx_status_info`: Dynamic

    /// Options for community.general.nginx_status_info
    hidden options: NginxStatusInfoOptions?

    /// todo doc
    function configure(): NginxStatusInfo = this
        .toMap()
        .put(
            "community.general.nginx_status_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(NginxStatusInfo)

}

/// Manage nic tags on SmartOS systems
class NictagadmOptions {
    
    etherstub: Boolean?
    
    force: Boolean?
    
    mac: String?
    
    mtu: Int?
    
    name: String
    
    state: ("absent"|"present")?
    
}

/// Task class for nictagadm
class Nictagadm extends Playbook.Task {

    /// todo doc
    `community.general.nictagadm`: Dynamic

    /// Options for community.general.nictagadm
    hidden options: NictagadmOptions?

    /// todo doc
    function configure(): Nictagadm = this
        .toMap()
        .put(
            "community.general.nictagadm",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Nictagadm)

}

/// Manage Networking
class NmcliOptions {
    
    addr_gen_mode6: ("default"|"default-or-eui64"|"eui64"|"stable-privacy")?
    
    ageingtime: Int?
    
    arp_interval: Int?
    
    arp_ip_target: String?
    
    autoconnect: Boolean?
    
    conn_name: String
    
    dhcp_client_id: String?
    
    dns4: Listing<String>?
    
    dns4_ignore_auto: Boolean?
    
    dns4_options: Listing<String>?
    
    dns4_search: Listing<String>?
    
    dns6: Listing<String>?
    
    dns6_ignore_auto: Boolean?
    
    dns6_options: Listing<String>?
    
    dns6_search: Listing<String>?
    
    downdelay: Int?
    
    egress: String?
    
    flags: String?
    
    forwarddelay: Int?
    
    gsm: Any?
    
    gw4: String?
    
    gw4_ignore_auto: Boolean?
    
    gw6: String?
    
    gw6_ignore_auto: Boolean?
    
    hairpin: Boolean?
    
    hellotime: Int?
    
    ifname: String?
    
    ignore_unsupported_suboptions: Boolean?
    
    ingress: String?
    
    ip4: Listing<String>?
    
    ip6: Listing<String>?
    
    ip_privacy6: ("disabled"|"prefer-public-addr"|"prefer-temp-addr"|"unknown")?
    
    ip_tunnel_dev: String?
    
    ip_tunnel_input_key: String?
    
    ip_tunnel_local: String?
    
    ip_tunnel_output_key: String?
    
    ip_tunnel_remote: String?
    
    mac: String?
    
    macvlan: Any?
    
    master: String?
    
    maxage: Int?
    
    may_fail4: Boolean?
    
    method4: ("auto"|"link-local"|"manual"|"shared"|"disabled")?
    
    method6: ("ignore"|"auto"|"dhcp"|"link-local"|"manual"|"shared"|"disabled")?
    
    miimon: Int?
    
    mode: ("802.3ad"|"active-backup"|"balance-alb"|"balance-rr"|"balance-tlb"|"balance-xor"|"broadcast")?
    
    mtu: Int?
    
    never_default4: Boolean?
    
    path_cost: Int?
    
    primary: String?
    
    priority: Int?
    
    route_metric4: Int?
    
    route_metric6: Int?
    
    routes4: Listing<String>?
    
    routes4_extended: Listing<Any>?
    
    routes6: Listing<String>?
    
    routes6_extended: Listing<Any>?
    
    routing_rules4: Listing<String>?
    
    runner: ("broadcast"|"roundrobin"|"activebackup"|"loadbalance"|"lacp")?
    
    runner_fast_rate: Boolean?
    
    runner_hwaddr_policy: ("same_all"|"by_active"|"only_active")?
    
    slave_type: ("bond"|"bridge"|"team")?
    
    slavepriority: Int?
    
    ssid: String?
    
    state: ("absent"|"present")
    
    stp: Boolean?
    
    transport_mode: ("datagram"|"connected")?
    
    type: ("bond"|"bond-slave"|"bridge"|"bridge-slave"|"dummy"|"ethernet"|"generic"|"gre"|"infiniband"|"ipip"|"macvlan"|"sit"|"team"|"team-slave"|"vlan"|"vxlan"|"wifi"|"gsm"|"wireguard"|"vpn"|"loopback")?
    
    updelay: Int?
    
    vlandev: String?
    
    vlanid: Int?
    
    vpn: Any?
    
    vxlan_id: Int?
    
    vxlan_local: String?
    
    vxlan_remote: String?
    
    wifi: Any?
    
    wifi_sec: Any?
    
    wireguard: Any?
    
    xmit_hash_policy: String?
    
    zone: String?
    
}

/// Task class for nmcli
class Nmcli extends Playbook.Task {

    /// todo doc
    `community.general.nmcli`: Dynamic

    /// Options for community.general.nmcli
    hidden options: NmcliOptions?

    /// todo doc
    function configure(): Nmcli = this
        .toMap()
        .put(
            "community.general.nmcli",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Nmcli)

}

/// Launch a Nomad Job
class NomadJobOptions {
    
    content: String?
    
    content_format: ("hcl"|"json")?
    
    force_start: Boolean?
    
    name: String?
    
    state: ("present"|"absent")
    
}

/// Task class for nomad_job
class NomadJob extends Playbook.Task {

    /// todo doc
    `community.general.nomad_job`: Dynamic

    /// Options for community.general.nomad_job
    hidden options: NomadJobOptions?

    /// todo doc
    function configure(): NomadJob = this
        .toMap()
        .put(
            "community.general.nomad_job",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(NomadJob)

}

/// Get Nomad Jobs info
class NomadJobInfoOptions {
    
    name: String?
    
}

/// Task class for nomad_job_info
class NomadJobInfo extends Playbook.Task {

    /// todo doc
    `community.general.nomad_job_info`: Dynamic

    /// Options for community.general.nomad_job_info
    hidden options: NomadJobInfoOptions?

    /// todo doc
    function configure(): NomadJobInfo = this
        .toMap()
        .put(
            "community.general.nomad_job_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(NomadJobInfo)

}

/// Manage Nomad ACL tokens
class NomadTokenOptions {
    
    global_replicated: Boolean?
    
    name: String?
    
    policies: Listing<String>?
    
    state: ("present"|"absent")
    
    token_type: ("client"|"management"|"bootstrap")?
    
}

/// Task class for nomad_token
class NomadToken extends Playbook.Task {

    /// todo doc
    `community.general.nomad_token`: Dynamic

    /// Options for community.general.nomad_token
    hidden options: NomadTokenOptions?

    /// todo doc
    function configure(): NomadToken = this
        .toMap()
        .put(
            "community.general.nomad_token",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(NomadToken)

}

/// Manage services with nosh
class NoshOptions {
    
    enabled: Boolean?
    
    name: String
    
    preset: Boolean?
    
    state: ("started"|"stopped"|"reset"|"restarted"|"reloaded")?
    
    user: Boolean?
    
}

/// Task class for nosh
class Nosh extends Playbook.Task {

    /// todo doc
    `community.general.nosh`: Dynamic

    /// Options for community.general.nosh
    hidden options: NoshOptions?

    /// todo doc
    function configure(): Nosh = this
        .toMap()
        .put(
            "community.general.nosh",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Nosh)

}

/// Manage node.js packages with npm
class NpmOptions {
    
    ci: Boolean?
    
    executable: String?
    
    global: Boolean?
    
    ignore_scripts: Boolean?
    
    name: String?
    
    no_bin_links: Boolean?
    
    no_optional: Boolean?
    
    path: String?
    
    production: Boolean?
    
    registry: String?
    
    state: ("present"|"absent"|"latest")?
    
    unsafe_perm: Boolean?
    
    version: String?
    
}

/// Task class for npm
class Npm extends Playbook.Task {

    /// todo doc
    `community.general.npm`: Dynamic

    /// Options for community.general.npm
    hidden options: NpmOptions?

    /// todo doc
    function configure(): Npm = this
        .toMap()
        .put(
            "community.general.npm",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Npm)

}

/// Manage DNS records
class NsupdateOptions {
    
    key_algorithm: ("HMAC-MD5.SIG-ALG.REG.INT"|"hmac-md5"|"hmac-sha1"|"hmac-sha224"|"hmac-sha256"|"hmac-sha384"|"hmac-sha512")?
    
    key_name: String?
    
    key_secret: String?
    
    port: Int?
    
    protocol: ("tcp"|"udp")?
    
    `record`: String
    
    server: String
    
    state: ("present"|"absent")?
    
    ttl: Int?
    
    type: String?
    
    value: Listing<String>?
    
    zone: String?
    
}

/// Task class for nsupdate
class Nsupdate extends Playbook.Task {

    /// todo doc
    `community.general.nsupdate`: Dynamic

    /// Options for community.general.nsupdate
    hidden options: NsupdateOptions?

    /// todo doc
    function configure(): Nsupdate = this
        .toMap()
        .put(
            "community.general.nsupdate",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Nsupdate)

}

/// Manages Out-Of-Band controllers using Open Composable API (OCAPI)
class OcapiCommandOptions {
    
    baseuri: String
    
    category: String
    
    command: String
    
    job_name: String?
    
    password: String
    
    proxy_slot_number: Int?
    
    timeout: Int?
    
    update_image_path: String?
    
    username: String
    
}

/// Task class for ocapi_command
class OcapiCommand extends Playbook.Task {

    /// todo doc
    `community.general.ocapi_command`: Dynamic

    /// Options for community.general.ocapi_command
    hidden options: OcapiCommandOptions?

    /// todo doc
    function configure(): OcapiCommand = this
        .toMap()
        .put(
            "community.general.ocapi_command",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OcapiCommand)

}

/// Manages Out-Of-Band controllers using Open Composable API (OCAPI)
class OcapiInfoOptions {
    
    baseuri: String
    
    category: String
    
    command: String
    
    job_name: String?
    
    password: String
    
    proxy_slot_number: Int?
    
    timeout: Int?
    
    username: String
    
}

/// Task class for ocapi_info
class OcapiInfo extends Playbook.Task {

    /// todo doc
    `community.general.ocapi_info`: Dynamic

    /// Options for community.general.ocapi_info
    hidden options: OcapiInfoOptions?

    /// todo doc
    function configure(): OcapiInfo = this
        .toMap()
        .put(
            "community.general.ocapi_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OcapiInfo)

}

/// Manage Virtual Cloud Networks(VCN) in OCI
class OciVcnOptions {
    
    cidr_block: String?
    
    compartment_id: String?
    
    display_name: String?
    
    dns_label: String?
    
    state: ("present"|"absent")?
    
    vcn_id: String?
    
}

/// Task class for oci_vcn
class OciVcn extends Playbook.Task {

    /// todo doc
    `community.general.oci_vcn`: Dynamic

    /// Options for community.general.oci_vcn
    hidden options: OciVcnOptions?

    /// todo doc
    function configure(): OciVcn = this
        .toMap()
        .put(
            "community.general.oci_vcn",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OciVcn)

}

/// Execute SQL via ODBC
class OdbcOptions {
    
    commit: Boolean?
    
    dsn: String
    
    params: Listing<String>?
    
    query: String
    
}

/// Task class for odbc
class Odbc extends Playbook.Task {

    /// todo doc
    `community.general.odbc`: Dynamic

    /// Options for community.general.odbc
    hidden options: OdbcOptions?

    /// todo doc
    function configure(): Odbc = this
        .toMap()
        .put(
            "community.general.odbc",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Odbc)

}

/// Use webhooks to create Connector Card messages within an Office 365 group
class Office365ConnectorCardOptions {
    
    actions: Listing<Any>?
    
    color: String?
    
    sections: Listing<Any>?
    
    summary: String?
    
    text: String?
    
    title: String?
    
    webhook: String
    
}

/// Task class for office_365_connector_card
class Office365ConnectorCard extends Playbook.Task {

    /// todo doc
    `community.general.office_365_connector_card`: Dynamic

    /// Options for community.general.office_365_connector_card
    hidden options: Office365ConnectorCardOptions?

    /// todo doc
    function configure(): Office365ConnectorCard = this
        .toMap()
        .put(
            "community.general.office_365_connector_card",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Office365ConnectorCard)

}

/// Returns inventory data from I(Ohai)
class OhaiOptions {
    
}

/// Task class for ohai
class Ohai extends Playbook.Task {

    /// todo doc
    `community.general.ohai`: Dynamic

    /// Options for community.general.ohai
    hidden options: OhaiOptions?

    /// todo doc
    function configure(): Ohai = this
        .toMap()
        .put(
            "community.general.ohai",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Ohai)

}

/// Setup OMAPI hosts
class OmapiHostOptions {
    
    ddns: Boolean?
    
    host: String?
    
    hostname: String?
    
    ip: String?
    
    key: String
    
    key_name: String
    
    macaddr: String
    
    port: Int?
    
    state: ("absent"|"present")
    
    statements: Listing<String>?
    
}

/// Task class for omapi_host
class OmapiHost extends Playbook.Task {

    /// todo doc
    `community.general.omapi_host`: Dynamic

    /// Options for community.general.omapi_host
    hidden options: OmapiHostOptions?

    /// todo doc
    function configure(): OmapiHost = this
        .toMap()
        .put(
            "community.general.omapi_host",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OmapiHost)

}

/// Manages OpenNebula Hosts
class OneHostOptions {
    
    cluster_id: Int?
    
    cluster_name: String?
    
    im_mad_name: String?
    
    labels: Listing<String>?
    
    name: String
    
    state: ("absent"|"present"|"enabled"|"disabled"|"offline")?
    
    template: Any?
    
    vmm_mad_name: String?
    
}

/// Task class for one_host
class OneHost extends Playbook.Task {

    /// todo doc
    `community.general.one_host`: Dynamic

    /// Options for community.general.one_host
    hidden options: OneHostOptions?

    /// todo doc
    function configure(): OneHost = this
        .toMap()
        .put(
            "community.general.one_host",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OneHost)

}

/// Manages OpenNebula images
class OneImageOptions {
    
    api_password: String?
    
    api_url: String?
    
    api_username: String?
    
    enabled: Boolean?
    
    id: Int?
    
    name: String?
    
    new_name: String?
    
    state: ("present"|"absent"|"cloned"|"renamed")?
    
}

/// Task class for one_image
class OneImage extends Playbook.Task {

    /// todo doc
    `community.general.one_image`: Dynamic

    /// Options for community.general.one_image
    hidden options: OneImageOptions?

    /// todo doc
    function configure(): OneImage = this
        .toMap()
        .put(
            "community.general.one_image",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OneImage)

}

/// Gather information on OpenNebula images
class OneImageInfoOptions {
    
    api_password: String?
    
    api_url: String?
    
    api_username: String?
    
    ids: Listing<String>?
    
    name: String?
    
}

/// Task class for one_image_info
class OneImageInfo extends Playbook.Task {

    /// todo doc
    `community.general.one_image_info`: Dynamic

    /// Options for community.general.one_image_info
    hidden options: OneImageInfoOptions?

    /// todo doc
    function configure(): OneImageInfo = this
        .toMap()
        .put(
            "community.general.one_image_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OneImageInfo)

}

/// Deploy and manage OpenNebula services
class OneServiceOptions {
    
    api_password: String?
    
    api_url: String?
    
    api_username: String?
    
    cardinality: Int?
    
    custom_attrs: Any?
    
    force: Boolean?
    
    group_id: Int?
    
    mode: String?
    
    owner_id: Int?
    
    role: String?
    
    service_id: Int?
    
    service_name: String?
    
    state: ("present"|"absent")?
    
    template_id: Int?
    
    template_name: String?
    
    unique: Boolean?
    
    wait: Boolean?
    
    wait_timeout: Int?
    
}

/// Task class for one_service
class OneService extends Playbook.Task {

    /// todo doc
    `community.general.one_service`: Dynamic

    /// Options for community.general.one_service
    hidden options: OneServiceOptions?

    /// todo doc
    function configure(): OneService = this
        .toMap()
        .put(
            "community.general.one_service",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OneService)

}

/// Manages OpenNebula templates
class OneTemplateOptions {
    
    id: Int?
    
    name: String?
    
    state: ("present"|"absent")?
    
    template: String?
    
}

/// Task class for one_template
class OneTemplate extends Playbook.Task {

    /// todo doc
    `community.general.one_template`: Dynamic

    /// Options for community.general.one_template
    hidden options: OneTemplateOptions?

    /// todo doc
    function configure(): OneTemplate = this
        .toMap()
        .put(
            "community.general.one_template",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OneTemplate)

}

/// Creates or terminates OpenNebula instances
class OneVmOptions {
    
    api_password: String?
    
    api_url: String?
    
    api_username: String?
    
    attributes: Any?
    
    count: Int?
    
    count_attributes: Any?
    
    count_labels: Listing<String>?
    
    cpu: Any?
    
    datastore_id: Int?
    
    datastore_name: String?
    
    disk_saveas: Any?
    
    disk_size: Listing<String>?
    
    exact_count: Int?
    
    group_id: Int?
    
    hard: Boolean?
    
    instance_ids: Listing<Int>?
    
    labels: Listing<String>?
    
    memory: String?
    
    mode: String?
    
    networks: Listing<Any>?
    
    owner_id: Int?
    
    persistent: Boolean?
    
    state: ("present"|"absent"|"running"|"rebooted"|"poweredoff")?
    
    template_id: Int?
    
    template_name: String?
    
    updateconf: Any?
    
    vcpu: Int?
    
    vm_start_on_hold: Boolean?
    
    wait: Boolean?
    
    wait_timeout: Int?
    
}

/// Task class for one_vm
class OneVm extends Playbook.Task {

    /// todo doc
    `community.general.one_vm`: Dynamic

    /// Options for community.general.one_vm
    hidden options: OneVmOptions?

    /// todo doc
    function configure(): OneVm = this
        .toMap()
        .put(
            "community.general.one_vm",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OneVm)

}

/// Configure 1&1 firewall policy
class OneandoneFirewallPolicyOptions {
    
    add_rules: Listing<Any>?
    
    add_server_ips: Listing<String>?
    
    api_url: String?
    
    auth_token: String?
    
    description: String?
    
    firewall_policy: String?
    
    name: String?
    
    remove_rules: Listing<String>?
    
    remove_server_ips: Listing<String>?
    
    rules: Listing<Any>?
    
    state: ("present"|"absent"|"update")?
    
    wait: Boolean?
    
    wait_interval: Int?
    
    wait_timeout: Int?
    
}

/// Task class for oneandone_firewall_policy
class OneandoneFirewallPolicy extends Playbook.Task {

    /// todo doc
    `community.general.oneandone_firewall_policy`: Dynamic

    /// Options for community.general.oneandone_firewall_policy
    hidden options: OneandoneFirewallPolicyOptions?

    /// todo doc
    function configure(): OneandoneFirewallPolicy = this
        .toMap()
        .put(
            "community.general.oneandone_firewall_policy",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OneandoneFirewallPolicy)

}

/// Configure 1&1 load balancer
class OneandoneLoadBalancerOptions {
    
    add_rules: Listing<Any>?
    
    add_server_ips: Listing<String>?
    
    api_url: String?
    
    auth_token: String?
    
    datacenter: ("US"|"ES"|"DE"|"GB")?
    
    description: String?
    
    health_check_interval: String?
    
    health_check_parse: String?
    
    health_check_path: String?
    
    health_check_test: ("NONE"|"TCP"|"HTTP"|"ICMP")?
    
    load_balancer: String?
    
    method: ("ROUND_ROBIN"|"LEAST_CONNECTIONS")?
    
    name: String?
    
    persistence: Boolean?
    
    persistence_time: String?
    
    remove_rules: Listing<String>?
    
    remove_server_ips: Listing<String>?
    
    rules: Listing<Any>?
    
    state: ("present"|"absent"|"update")?
    
    wait: Boolean?
    
    wait_interval: Int?
    
    wait_timeout: Int?
    
}

/// Task class for oneandone_load_balancer
class OneandoneLoadBalancer extends Playbook.Task {

    /// todo doc
    `community.general.oneandone_load_balancer`: Dynamic

    /// Options for community.general.oneandone_load_balancer
    hidden options: OneandoneLoadBalancerOptions?

    /// todo doc
    function configure(): OneandoneLoadBalancer = this
        .toMap()
        .put(
            "community.general.oneandone_load_balancer",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OneandoneLoadBalancer)

}

/// Configure 1&1 monitoring policy
class OneandoneMonitoringPolicyOptions {
    
    add_ports: Listing<Any>?
    
    add_processes: Listing<Any>?
    
    add_servers: Listing<String>?
    
    agent: String?
    
    api_url: String?
    
    auth_token: String?
    
    description: String?
    
    email: String?
    
    monitoring_policy: String?
    
    name: String?
    
    ports: Listing<Any>?
    
    processes: Listing<Any>?
    
    remove_ports: Listing<String>?
    
    remove_processes: Listing<String>?
    
    remove_servers: Listing<String>?
    
    state: ("present"|"absent"|"update")?
    
    thresholds: Listing<Any>?
    
    update_ports: Listing<Any>?
    
    update_processes: Listing<Any>?
    
    wait: Boolean?
    
    wait_interval: Int?
    
    wait_timeout: Int?
    
}

/// Task class for oneandone_monitoring_policy
class OneandoneMonitoringPolicy extends Playbook.Task {

    /// todo doc
    `community.general.oneandone_monitoring_policy`: Dynamic

    /// Options for community.general.oneandone_monitoring_policy
    hidden options: OneandoneMonitoringPolicyOptions?

    /// todo doc
    function configure(): OneandoneMonitoringPolicy = this
        .toMap()
        .put(
            "community.general.oneandone_monitoring_policy",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OneandoneMonitoringPolicy)

}

/// Configure 1&1 private networking
class OneandonePrivateNetworkOptions {
    
    add_members: Listing<String>?
    
    api_url: String?
    
    auth_token: String?
    
    datacenter: ("US"|"ES"|"DE"|"GB")?
    
    description: String?
    
    name: String?
    
    network_address: String?
    
    private_network: String?
    
    remove_members: Listing<String>?
    
    state: ("present"|"absent"|"update")?
    
    subnet_mask: String?
    
    wait: Boolean?
    
    wait_interval: Int?
    
    wait_timeout: Int?
    
}

/// Task class for oneandone_private_network
class OneandonePrivateNetwork extends Playbook.Task {

    /// todo doc
    `community.general.oneandone_private_network`: Dynamic

    /// Options for community.general.oneandone_private_network
    hidden options: OneandonePrivateNetworkOptions?

    /// todo doc
    function configure(): OneandonePrivateNetwork = this
        .toMap()
        .put(
            "community.general.oneandone_private_network",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OneandonePrivateNetwork)

}

/// Configure 1&1 public IPs
class OneandonePublicIpOptions {
    
    api_url: String?
    
    auth_token: String?
    
    datacenter: ("US"|"ES"|"DE"|"GB")?
    
    public_ip_id: String?
    
    reverse_dns: String?
    
    state: ("present"|"absent"|"update")?
    
    type: ("IPV4"|"IPV6")?
    
    wait: Boolean?
    
    wait_interval: Int?
    
    wait_timeout: Int?
    
}

/// Task class for oneandone_public_ip
class OneandonePublicIp extends Playbook.Task {

    /// todo doc
    `community.general.oneandone_public_ip`: Dynamic

    /// Options for community.general.oneandone_public_ip
    hidden options: OneandonePublicIpOptions?

    /// todo doc
    function configure(): OneandonePublicIp = this
        .toMap()
        .put(
            "community.general.oneandone_public_ip",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OneandonePublicIp)

}

/// Create, destroy, start, stop, and reboot a 1&1 Host server
class OneandoneServerOptions {
    
    api_url: String?
    
    appliance: String?
    
    auth_token: String?
    
    auto_increment: Boolean?
    
    cores_per_processor: Int?
    
    count: Int?
    
    datacenter: ("US"|"ES"|"DE"|"GB")?
    
    description: String?
    
    firewall_policy: String?
    
    fixed_instance_size: String?
    
    hdds: Listing<Any>?
    
    hostname: String?
    
    load_balancer: String?
    
    monitoring_policy: String?
    
    private_network: String?
    
    ram: Any?
    
    server: String?
    
    server_type: ("cloud"|"baremetal"|"k8s_node")?
    
    ssh_key: String?
    
    state: ("present"|"absent"|"running"|"stopped")?
    
    vcore: Int?
    
    wait: Boolean?
    
    wait_interval: Int?
    
    wait_timeout: Int?
    
}

/// Task class for oneandone_server
class OneandoneServer extends Playbook.Task {

    /// todo doc
    `community.general.oneandone_server`: Dynamic

    /// Options for community.general.oneandone_server
    hidden options: OneandoneServerOptions?

    /// todo doc
    function configure(): OneandoneServer = this
        .toMap()
        .put(
            "community.general.oneandone_server",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OneandoneServer)

}

/// Gather items from 1Password
class OnepasswordInfoOptions {
    
    auto_login: Any?
    
    cli_path: String?
    
    search_terms: Listing<Any>
    
}

/// Task class for onepassword_info
class OnepasswordInfo extends Playbook.Task {

    /// todo doc
    `community.general.onepassword_info`: Dynamic

    /// Options for community.general.onepassword_info
    hidden options: OnepasswordInfoOptions?

    /// todo doc
    function configure(): OnepasswordInfo = this
        .toMap()
        .put(
            "community.general.onepassword_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OnepasswordInfo)

}

/// Retrieve information about the OneView Data Centers
class OneviewDatacenterInfoOptions {
    
    name: String?
    
    options: Listing<String>?
    
}

/// Task class for oneview_datacenter_info
class OneviewDatacenterInfo extends Playbook.Task {

    /// todo doc
    `community.general.oneview_datacenter_info`: Dynamic

    /// Options for community.general.oneview_datacenter_info
    hidden options: OneviewDatacenterInfoOptions?

    /// todo doc
    function configure(): OneviewDatacenterInfo = this
        .toMap()
        .put(
            "community.general.oneview_datacenter_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OneviewDatacenterInfo)

}

/// Retrieve information about one or more Enclosures
class OneviewEnclosureInfoOptions {
    
    name: String?
    
    options: Listing<String>?
    
}

/// Task class for oneview_enclosure_info
class OneviewEnclosureInfo extends Playbook.Task {

    /// todo doc
    `community.general.oneview_enclosure_info`: Dynamic

    /// Options for community.general.oneview_enclosure_info
    hidden options: OneviewEnclosureInfoOptions?

    /// todo doc
    function configure(): OneviewEnclosureInfo = this
        .toMap()
        .put(
            "community.general.oneview_enclosure_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OneviewEnclosureInfo)

}

/// Manage OneView Ethernet Network resources
class OneviewEthernetNetworkOptions {
    
    data: Any
    
    state: ("present"|"absent"|"default_bandwidth_reset")?
    
}

/// Task class for oneview_ethernet_network
class OneviewEthernetNetwork extends Playbook.Task {

    /// todo doc
    `community.general.oneview_ethernet_network`: Dynamic

    /// Options for community.general.oneview_ethernet_network
    hidden options: OneviewEthernetNetworkOptions?

    /// todo doc
    function configure(): OneviewEthernetNetwork = this
        .toMap()
        .put(
            "community.general.oneview_ethernet_network",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OneviewEthernetNetwork)

}

/// Retrieve the information about one or more of the OneView Ethernet Networks
class OneviewEthernetNetworkInfoOptions {
    
    name: String?
    
    options: Listing<String>?
    
}

/// Task class for oneview_ethernet_network_info
class OneviewEthernetNetworkInfo extends Playbook.Task {

    /// todo doc
    `community.general.oneview_ethernet_network_info`: Dynamic

    /// Options for community.general.oneview_ethernet_network_info
    hidden options: OneviewEthernetNetworkInfoOptions?

    /// todo doc
    function configure(): OneviewEthernetNetworkInfo = this
        .toMap()
        .put(
            "community.general.oneview_ethernet_network_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OneviewEthernetNetworkInfo)

}

/// Manage OneView Fibre Channel Network resources
class OneviewFcNetworkOptions {
    
    data: Any
    
    state: ("present"|"absent")
    
}

/// Task class for oneview_fc_network
class OneviewFcNetwork extends Playbook.Task {

    /// todo doc
    `community.general.oneview_fc_network`: Dynamic

    /// Options for community.general.oneview_fc_network
    hidden options: OneviewFcNetworkOptions?

    /// todo doc
    function configure(): OneviewFcNetwork = this
        .toMap()
        .put(
            "community.general.oneview_fc_network",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OneviewFcNetwork)

}

/// Retrieve the information about one or more of the OneView Fibre Channel Networks
class OneviewFcNetworkInfoOptions {
    
    name: String?
    
}

/// Task class for oneview_fc_network_info
class OneviewFcNetworkInfo extends Playbook.Task {

    /// todo doc
    `community.general.oneview_fc_network_info`: Dynamic

    /// Options for community.general.oneview_fc_network_info
    hidden options: OneviewFcNetworkInfoOptions?

    /// todo doc
    function configure(): OneviewFcNetworkInfo = this
        .toMap()
        .put(
            "community.general.oneview_fc_network_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OneviewFcNetworkInfo)

}

/// Manage OneView FCoE Network resources
class OneviewFcoeNetworkOptions {
    
    data: Any
    
    state: ("present"|"absent")?
    
}

/// Task class for oneview_fcoe_network
class OneviewFcoeNetwork extends Playbook.Task {

    /// todo doc
    `community.general.oneview_fcoe_network`: Dynamic

    /// Options for community.general.oneview_fcoe_network
    hidden options: OneviewFcoeNetworkOptions?

    /// todo doc
    function configure(): OneviewFcoeNetwork = this
        .toMap()
        .put(
            "community.general.oneview_fcoe_network",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OneviewFcoeNetwork)

}

/// Retrieve the information about one or more of the OneView FCoE Networks
class OneviewFcoeNetworkInfoOptions {
    
    name: String?
    
}

/// Task class for oneview_fcoe_network_info
class OneviewFcoeNetworkInfo extends Playbook.Task {

    /// todo doc
    `community.general.oneview_fcoe_network_info`: Dynamic

    /// Options for community.general.oneview_fcoe_network_info
    hidden options: OneviewFcoeNetworkInfoOptions?

    /// todo doc
    function configure(): OneviewFcoeNetworkInfo = this
        .toMap()
        .put(
            "community.general.oneview_fcoe_network_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OneviewFcoeNetworkInfo)

}

/// Manage OneView Logical Interconnect Group resources
class OneviewLogicalInterconnectGroupOptions {
    
    data: Any
    
    state: ("absent"|"present")?
    
}

/// Task class for oneview_logical_interconnect_group
class OneviewLogicalInterconnectGroup extends Playbook.Task {

    /// todo doc
    `community.general.oneview_logical_interconnect_group`: Dynamic

    /// Options for community.general.oneview_logical_interconnect_group
    hidden options: OneviewLogicalInterconnectGroupOptions?

    /// todo doc
    function configure(): OneviewLogicalInterconnectGroup = this
        .toMap()
        .put(
            "community.general.oneview_logical_interconnect_group",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OneviewLogicalInterconnectGroup)

}

/// Retrieve information about one or more of the OneView Logical Interconnect Groups
class OneviewLogicalInterconnectGroupInfoOptions {
    
    name: String?
    
}

/// Task class for oneview_logical_interconnect_group_info
class OneviewLogicalInterconnectGroupInfo extends Playbook.Task {

    /// todo doc
    `community.general.oneview_logical_interconnect_group_info`: Dynamic

    /// Options for community.general.oneview_logical_interconnect_group_info
    hidden options: OneviewLogicalInterconnectGroupInfoOptions?

    /// todo doc
    function configure(): OneviewLogicalInterconnectGroupInfo = this
        .toMap()
        .put(
            "community.general.oneview_logical_interconnect_group_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OneviewLogicalInterconnectGroupInfo)

}

/// Manage HPE OneView Network Set resources
class OneviewNetworkSetOptions {
    
    data: Any
    
    state: ("present"|"absent")?
    
}

/// Task class for oneview_network_set
class OneviewNetworkSet extends Playbook.Task {

    /// todo doc
    `community.general.oneview_network_set`: Dynamic

    /// Options for community.general.oneview_network_set
    hidden options: OneviewNetworkSetOptions?

    /// todo doc
    function configure(): OneviewNetworkSet = this
        .toMap()
        .put(
            "community.general.oneview_network_set",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OneviewNetworkSet)

}

/// Retrieve information about the OneView Network Sets
class OneviewNetworkSetInfoOptions {
    
    name: String?
    
    options: Listing<String>?
    
}

/// Task class for oneview_network_set_info
class OneviewNetworkSetInfo extends Playbook.Task {

    /// todo doc
    `community.general.oneview_network_set_info`: Dynamic

    /// Options for community.general.oneview_network_set_info
    hidden options: OneviewNetworkSetInfoOptions?

    /// todo doc
    function configure(): OneviewNetworkSetInfo = this
        .toMap()
        .put(
            "community.general.oneview_network_set_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OneviewNetworkSetInfo)

}

/// Manage OneView SAN Manager resources
class OneviewSanManagerOptions {
    
    data: Any
    
    state: ("present"|"absent"|"connection_information_set")?
    
}

/// Task class for oneview_san_manager
class OneviewSanManager extends Playbook.Task {

    /// todo doc
    `community.general.oneview_san_manager`: Dynamic

    /// Options for community.general.oneview_san_manager
    hidden options: OneviewSanManagerOptions?

    /// todo doc
    function configure(): OneviewSanManager = this
        .toMap()
        .put(
            "community.general.oneview_san_manager",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OneviewSanManager)

}

/// Retrieve information about one or more of the OneView SAN Managers
class OneviewSanManagerInfoOptions {
    
    params: Any?
    
    provider_display_name: String?
    
}

/// Task class for oneview_san_manager_info
class OneviewSanManagerInfo extends Playbook.Task {

    /// todo doc
    `community.general.oneview_san_manager_info`: Dynamic

    /// Options for community.general.oneview_san_manager_info
    hidden options: OneviewSanManagerInfoOptions?

    /// todo doc
    function configure(): OneviewSanManagerInfo = this
        .toMap()
        .put(
            "community.general.oneview_san_manager_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OneviewSanManagerInfo)

}

/// Gather information about Online servers
class OnlineServerInfoOptions {
    
}

/// Task class for online_server_info
class OnlineServerInfo extends Playbook.Task {

    /// todo doc
    `community.general.online_server_info`: Dynamic

    /// Options for community.general.online_server_info
    hidden options: OnlineServerInfoOptions?

    /// todo doc
    function configure(): OnlineServerInfo = this
        .toMap()
        .put(
            "community.general.online_server_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OnlineServerInfo)

}

/// Gather information about Online user
class OnlineUserInfoOptions {
    
}

/// Task class for online_user_info
class OnlineUserInfo extends Playbook.Task {

    /// todo doc
    `community.general.online_user_info`: Dynamic

    /// Options for community.general.online_user_info
    hidden options: OnlineUserInfoOptions?

    /// todo doc
    function configure(): OnlineUserInfo = this
        .toMap()
        .put(
            "community.general.online_user_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OnlineUserInfo)

}

/// Manage iSCSI targets with Open-iSCSI
class OpenIscsiOptions {
    
    auto_node_startup: Boolean?
    
    auto_portal_startup: Boolean?
    
    discover: Boolean?
    
    login: Boolean?
    
    node_auth: String?
    
    node_pass: String?
    
    node_pass_in: String?
    
    node_user: String?
    
    node_user_in: String?
    
    port: String?
    
    portal: String?
    
    rescan: Boolean?
    
    show_nodes: Boolean?
    
    target: String?
    
}

/// Task class for open_iscsi
class OpenIscsi extends Playbook.Task {

    /// todo doc
    `community.general.open_iscsi`: Dynamic

    /// Options for community.general.open_iscsi
    hidden options: OpenIscsiOptions?

    /// todo doc
    function configure(): OpenIscsi = this
        .toMap()
        .put(
            "community.general.open_iscsi",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OpenIscsi)

}

/// Manage packages on OpenBSD
class OpenbsdPkgOptions {
    
    build: Boolean?
    
    clean: Boolean?
    
    name: Listing<String>
    
    ports_dir: String?
    
    quick: Boolean?
    
    snapshot: Boolean?
    
    state: ("absent"|"latest"|"present"|"installed"|"removed")?
    
}

/// Task class for openbsd_pkg
class OpenbsdPkg extends Playbook.Task {

    /// todo doc
    `community.general.openbsd_pkg`: Dynamic

    /// Options for community.general.openbsd_pkg
    hidden options: OpenbsdPkgOptions?

    /// todo doc
    function configure(): OpenbsdPkg = this
        .toMap()
        .put(
            "community.general.openbsd_pkg",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OpenbsdPkg)

}

/// Will update the backend configuration of OpenDJ via the dsconfig set-backend-prop command
class OpendjBackendpropOptions {
    
    backend: String
    
    hostname: String
    
    name: String
    
    opendj_bindir: String?
    
    password: String?
    
    passwordfile: String?
    
    port: String
    
    state: String?
    
    username: String?
    
    value: String
    
}

/// Task class for opendj_backendprop
class OpendjBackendprop extends Playbook.Task {

    /// todo doc
    `community.general.opendj_backendprop`: Dynamic

    /// Options for community.general.opendj_backendprop
    hidden options: OpendjBackendpropOptions?

    /// todo doc
    function configure(): OpendjBackendprop = this
        .toMap()
        .put(
            "community.general.opendj_backendprop",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OpendjBackendprop)

}

/// Manage services on OpenWrt
class OpenwrtInitOptions {
    
    enabled: Boolean?
    
    name: String
    
    pattern: String?
    
    state: ("started"|"stopped"|"restarted"|"reloaded")?
    
}

/// Task class for openwrt_init
class OpenwrtInit extends Playbook.Task {

    /// todo doc
    `community.general.openwrt_init`: Dynamic

    /// Options for community.general.openwrt_init
    hidden options: OpenwrtInitOptions?

    /// todo doc
    function configure(): OpenwrtInit = this
        .toMap()
        .put(
            "community.general.openwrt_init",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OpenwrtInit)

}

/// Package manager for OpenWrt and Openembedded/Yocto based Linux distributions
class OpkgOptions {
    
    executable: String?
    
    force: (""|"depends"|"maintainer"|"reinstall"|"overwrite"|"downgrade"|"space"|"postinstall"|"remove"|"checksum"|"removal-of-dependent-packages")?
    
    name: Listing<String>
    
    state: ("present"|"absent"|"installed"|"removed")?
    
    update_cache: Boolean?
    
}

/// Task class for opkg
class Opkg extends Playbook.Task {

    /// todo doc
    `community.general.opkg`: Dynamic

    /// Options for community.general.opkg
    hidden options: OpkgOptions?

    /// todo doc
    function configure(): Opkg = this
        .toMap()
        .put(
            "community.general.opkg",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Opkg)

}

/// Manage macOS user defaults
class OsxDefaultsOptions {
    
    array_add: Boolean?
    
    domain: String?
    
    host: String?
    
    key: String?
    
    path: String?
    
    state: ("absent"|"list"|"present")?
    
    type: ("array"|"bool"|"boolean"|"date"|"float"|"int"|"integer"|"string")?
    
    value: String?
    
}

/// Task class for osx_defaults
class OsxDefaults extends Playbook.Task {

    /// todo doc
    `community.general.osx_defaults`: Dynamic

    /// Options for community.general.osx_defaults
    hidden options: OsxDefaultsOptions?

    /// todo doc
    function configure(): OsxDefaults = this
        .toMap()
        .put(
            "community.general.osx_defaults",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OsxDefaults)

}

/// Manage OVH IP failover address
class OvhIpFailoverOptions {
    
    application_key: String
    
    application_secret: String
    
    consumer_key: String
    
    endpoint: String
    
    name: String
    
    service: String
    
    timeout: Int?
    
    wait_completion: Boolean?
    
    wait_task_completion: Int?
    
}

/// Task class for ovh_ip_failover
class OvhIpFailover extends Playbook.Task {

    /// todo doc
    `community.general.ovh_ip_failover`: Dynamic

    /// Options for community.general.ovh_ip_failover
    hidden options: OvhIpFailoverOptions?

    /// todo doc
    function configure(): OvhIpFailover = this
        .toMap()
        .put(
            "community.general.ovh_ip_failover",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OvhIpFailover)

}

/// Manage OVH IP LoadBalancing backends
class OvhIpLoadbalancingBackendOptions {
    
    application_key: String
    
    application_secret: String
    
    backend: String
    
    consumer_key: String
    
    endpoint: String
    
    name: String
    
    probe: ("none"|"http"|"icmp"|"oco")?
    
    state: ("present"|"absent")?
    
    timeout: Int?
    
    weight: Int?
    
}

/// Task class for ovh_ip_loadbalancing_backend
class OvhIpLoadbalancingBackend extends Playbook.Task {

    /// todo doc
    `community.general.ovh_ip_loadbalancing_backend`: Dynamic

    /// Options for community.general.ovh_ip_loadbalancing_backend
    hidden options: OvhIpLoadbalancingBackendOptions?

    /// todo doc
    function configure(): OvhIpLoadbalancingBackend = this
        .toMap()
        .put(
            "community.general.ovh_ip_loadbalancing_backend",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OvhIpLoadbalancingBackend)

}

/// Manage OVH monthly billing
class OvhMonthlyBillingOptions {
    
    application_key: String?
    
    application_secret: String?
    
    consumer_key: String?
    
    endpoint: String?
    
    instance_id: String
    
    project_id: String
    
}

/// Task class for ovh_monthly_billing
class OvhMonthlyBilling extends Playbook.Task {

    /// todo doc
    `community.general.ovh_monthly_billing`: Dynamic

    /// Options for community.general.ovh_monthly_billing
    hidden options: OvhMonthlyBillingOptions?

    /// todo doc
    function configure(): OvhMonthlyBilling = this
        .toMap()
        .put(
            "community.general.ovh_monthly_billing",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(OvhMonthlyBilling)

}

/// Manage pacemaker clusters
class PacemakerClusterOptions {
    
    force: Boolean?
    
    node: String?
    
    state: ("cleanup"|"offline"|"online"|"restart")?
    
    timeout: Int?
    
}

/// Task class for pacemaker_cluster
class PacemakerCluster extends Playbook.Task {

    /// todo doc
    `community.general.pacemaker_cluster`: Dynamic

    /// Options for community.general.pacemaker_cluster
    hidden options: PacemakerClusterOptions?

    /// todo doc
    function configure(): PacemakerCluster = this
        .toMap()
        .put(
            "community.general.pacemaker_cluster",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(PacemakerCluster)

}

/// Manage a bare metal server in the Packet Host
class PacketDeviceOptions {
    
    always_pxe: Boolean?
    
    auth_token: String?
    
    count: Int?
    
    count_offset: Int?
    
    device_ids: Listing<String>?
    
    facility: String?
    
    features: Any?
    
    hostnames: Listing<String>?
    
    ipxe_script_url: String?
    
    locked: Boolean?
    
    operating_system: String?
    
    plan: String?
    
    project_id: String
    
    state: ("present"|"absent"|"active"|"inactive"|"rebooted")?
    
    tags: Listing<String>?
    
    user_data: String?
    
    wait_for_public_IPv: Int?
    
    wait_timeout: Int?
    
}

/// Task class for packet_device
class PacketDevice extends Playbook.Task {

    /// todo doc
    `community.general.packet_device`: Dynamic

    /// Options for community.general.packet_device
    hidden options: PacketDeviceOptions?

    /// todo doc
    function configure(): PacketDevice = this
        .toMap()
        .put(
            "community.general.packet_device",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(PacketDevice)

}

/// Assign IP subnet to a bare metal server
class PacketIpSubnetOptions {
    
    auth_token: String?
    
    cidr: String
    
    device_count: Int?
    
    device_id: String?
    
    hostname: String?
    
    project_id: String?
    
    state: ("present"|"absent")?
    
}

/// Task class for packet_ip_subnet
class PacketIpSubnet extends Playbook.Task {

    /// todo doc
    `community.general.packet_ip_subnet`: Dynamic

    /// Options for community.general.packet_ip_subnet
    hidden options: PacketIpSubnetOptions?

    /// todo doc
    function configure(): PacketIpSubnet = this
        .toMap()
        .put(
            "community.general.packet_ip_subnet",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(PacketIpSubnet)

}

/// Create/delete a project in Packet host
class PacketProjectOptions {
    
    auth_token: String?
    
    custom_data: String?
    
    id: String?
    
    name: String?
    
    org_id: String?
    
    payment_method: String?
    
    state: ("present"|"absent")?
    
}

/// Task class for packet_project
class PacketProject extends Playbook.Task {

    /// todo doc
    `community.general.packet_project`: Dynamic

    /// Options for community.general.packet_project
    hidden options: PacketProjectOptions?

    /// todo doc
    function configure(): PacketProject = this
        .toMap()
        .put(
            "community.general.packet_project",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(PacketProject)

}

/// Create/delete an SSH key in Packet host
class PacketSshkeyOptions {
    
    auth_token: String?
    
    fingerprint: String?
    
    id: String?
    
    key: String?
    
    key_file: String?
    
    label: String?
    
    state: ("present"|"absent")?
    
}

/// Task class for packet_sshkey
class PacketSshkey extends Playbook.Task {

    /// todo doc
    `community.general.packet_sshkey`: Dynamic

    /// Options for community.general.packet_sshkey
    hidden options: PacketSshkeyOptions?

    /// todo doc
    function configure(): PacketSshkey = this
        .toMap()
        .put(
            "community.general.packet_sshkey",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(PacketSshkey)

}

/// Create/delete a volume in Packet host
class PacketVolumeOptions {
    
    auth_token: String?
    
    billing_cycle: ("hourly"|"monthly")?
    
    description: String?
    
    facility: String?
    
    id: String?
    
    locked: Boolean?
    
    name: String?
    
    plan: ("storage_1"|"storage_2")?
    
    project_id: String
    
    size: Int?
    
    snapshot_policy: Any?
    
    state: ("present"|"absent")?
    
}

/// Task class for packet_volume
class PacketVolume extends Playbook.Task {

    /// todo doc
    `community.general.packet_volume`: Dynamic

    /// Options for community.general.packet_volume
    hidden options: PacketVolumeOptions?

    /// todo doc
    function configure(): PacketVolume = this
        .toMap()
        .put(
            "community.general.packet_volume",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(PacketVolume)

}

/// Attach/detach a volume to a device in the Packet host
class PacketVolumeAttachmentOptions {
    
    auth_token: String?
    
    device: String?
    
    project_id: String
    
    state: ("present"|"absent")?
    
    volume: String
    
}

/// Task class for packet_volume_attachment
class PacketVolumeAttachment extends Playbook.Task {

    /// todo doc
    `community.general.packet_volume_attachment`: Dynamic

    /// Options for community.general.packet_volume_attachment
    hidden options: PacketVolumeAttachmentOptions?

    /// todo doc
    function configure(): PacketVolumeAttachment = this
        .toMap()
        .put(
            "community.general.packet_volume_attachment",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(PacketVolumeAttachment)

}

/// Manage packages with I(pacman)
class PacmanOptions {
    
    executable: String?
    
    extra_args: String?
    
    force: Boolean?
    
    name: Listing<String>?
    
    reason: ("dependency"|"explicit")?
    
    reason_for: ("all"|"new")?
    
    remove_nosave: Boolean?
    
    state: ("absent"|"installed"|"latest"|"present"|"removed")?
    
    update_cache: Boolean?
    
    update_cache_extra_args: String?
    
    upgrade: Boolean?
    
    upgrade_extra_args: String?
    
}

/// Task class for pacman
class Pacman extends Playbook.Task {

    /// todo doc
    `community.general.pacman`: Dynamic

    /// Options for community.general.pacman
    hidden options: PacmanOptions?

    /// todo doc
    function configure(): Pacman = this
        .toMap()
        .put(
            "community.general.pacman",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Pacman)

}

/// Manage pacman's list of trusted keys
class PacmanKeyOptions {
    
    data: String?
    
    file: String?
    
    force_update: Boolean?
    
    id: String
    
    keyring: String?
    
    keyserver: String?
    
    state: ("absent"|"present")?
    
    url: String?
    
    verify: Boolean?
    
}

/// Task class for pacman_key
class PacmanKey extends Playbook.Task {

    /// todo doc
    `community.general.pacman_key`: Dynamic

    /// Options for community.general.pacman_key
    hidden options: PacmanKeyOptions?

    /// todo doc
    function configure(): PacmanKey = this
        .toMap()
        .put(
            "community.general.pacman_key",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(PacmanKey)

}

/// Create PagerDuty maintenance windows
class PagerdutyOptions {
    
    desc: String?
    
    hours: String?
    
    minutes: String?
    
    name: String?
    
    requester_id: String?
    
    service: Listing<String>?
    
    state: ("running"|"started"|"ongoing"|"absent")
    
    token: String
    
    user: String?
    
    validate_certs: Boolean?
    
    window_id: String?
    
}

/// Task class for pagerduty
class Pagerduty extends Playbook.Task {

    /// todo doc
    `community.general.pagerduty`: Dynamic

    /// Options for community.general.pagerduty
    hidden options: PagerdutyOptions?

    /// todo doc
    function configure(): Pagerduty = this
        .toMap()
        .put(
            "community.general.pagerduty",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Pagerduty)

}

/// Trigger, acknowledge or resolve PagerDuty incidents
class PagerdutyAlertOptions {
    
    api_key: String?
    
    api_version: ("v1"|"v2")?
    
    client: String?
    
    client_url: String?
    
    component: String?
    
    custom_details: Any?
    
    desc: String?
    
    incident_class: String?
    
    incident_key: String?
    
    integration_key: String?
    
    link_text: String?
    
    link_url: String?
    
    name: String?
    
    service_id: String?
    
    service_key: String?
    
    severity: ("critical"|"warning"|"error"|"info")?
    
    source: String?
    
    state: ("triggered"|"acknowledged"|"resolved")
    
}

/// Task class for pagerduty_alert
class PagerdutyAlert extends Playbook.Task {

    /// todo doc
    `community.general.pagerduty_alert`: Dynamic

    /// Options for community.general.pagerduty_alert
    hidden options: PagerdutyAlertOptions?

    /// todo doc
    function configure(): PagerdutyAlert = this
        .toMap()
        .put(
            "community.general.pagerduty_alert",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(PagerdutyAlert)

}

/// Track a code or infrastructure change as a PagerDuty change event
class PagerdutyChangeOptions {
    
    environment: String?
    
    integration_key: String
    
    link_text: String?
    
    link_url: String?
    
    repo: String?
    
    revision: String?
    
    source: String?
    
    summary: String
    
    url: String?
    
    user: String?
    
    validate_certs: Boolean?
    
}

/// Task class for pagerduty_change
class PagerdutyChange extends Playbook.Task {

    /// todo doc
    `community.general.pagerduty_change`: Dynamic

    /// Options for community.general.pagerduty_change
    hidden options: PagerdutyChangeOptions?

    /// todo doc
    function configure(): PagerdutyChange = this
        .toMap()
        .put(
            "community.general.pagerduty_change",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(PagerdutyChange)

}

/// Manage a user account on PagerDuty
class PagerdutyUserOptions {
    
    access_token: String
    
    pd_email: String
    
    pd_role: ("global_admin"|"manager"|"responder"|"observer"|"stakeholder"|"limited_stakeholder"|"restricted_access")?
    
    pd_teams: Listing<String>?
    
    pd_user: String
    
    state: ("present"|"absent")?
    
}

/// Task class for pagerduty_user
class PagerdutyUser extends Playbook.Task {

    /// todo doc
    `community.general.pagerduty_user`: Dynamic

    /// Options for community.general.pagerduty_user
    hidden options: PagerdutyUserOptions?

    /// todo doc
    function configure(): PagerdutyUser = this
        .toMap()
        .put(
            "community.general.pagerduty_user",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(PagerdutyUser)

}

/// Modify Linux PAM limits
class PamLimitsOptions {
    
    backup: Boolean?
    
    comment: String?
    
    dest: String?
    
    domain: String
    
    limit_item: ("core"|"data"|"fsize"|"memlock"|"nofile"|"rss"|"stack"|"cpu"|"nproc"|"as"|"maxlogins"|"maxsyslogins"|"priority"|"locks"|"sigpending"|"msgqueue"|"nice"|"rtprio"|"chroot")
    
    limit_type: ("hard"|"soft"|"-")
    
    use_max: Boolean?
    
    use_min: Boolean?
    
    value: String
    
}

/// Task class for pam_limits
class PamLimits extends Playbook.Task {

    /// todo doc
    `community.general.pam_limits`: Dynamic

    /// Options for community.general.pam_limits
    hidden options: PamLimitsOptions?

    /// todo doc
    function configure(): PamLimits = this
        .toMap()
        .put(
            "community.general.pam_limits",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(PamLimits)

}

/// Manage PAM Modules
class PamdOptions {
    
    backup: Boolean?
    
    control: String
    
    module_arguments: Listing<String>?
    
    module_path: String
    
    name: String
    
    new_control: String?
    
    new_module_path: String?
    
    new_type: ("account"|"-account"|"auth"|"-auth"|"password"|"-password"|"session"|"-session")?
    
    path: String?
    
    state: ("absent"|"before"|"after"|"args_absent"|"args_present"|"updated")?
    
    type: ("account"|"-account"|"auth"|"-auth"|"password"|"-password"|"session"|"-session")
    
}

/// Task class for pamd
class Pamd extends Playbook.Task {

    /// todo doc
    `community.general.pamd`: Dynamic

    /// Options for community.general.pamd
    hidden options: PamdOptions?

    /// todo doc
    function configure(): Pamd = this
        .toMap()
        .put(
            "community.general.pamd",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Pamd)

}

/// Configure block device partitions
class PartedOptions {
    
    align: ("cylinder"|"minimal"|"none"|"optimal"|"undefined")?
    
    device: String
    
    flags: Listing<String>?
    
    fs_type: String?
    
    label: ("aix"|"amiga"|"bsd"|"dvh"|"gpt"|"loop"|"mac"|"msdos"|"pc98"|"sun")?
    
    name: String?
    
    number: Int?
    
    part_end: String?
    
    part_start: String?
    
    part_type: ("extended"|"logical"|"primary")?
    
    resize: Boolean?
    
    state: ("absent"|"present"|"info")?
    
    unit: ("s"|"B"|"KB"|"KiB"|"MB"|"MiB"|"GB"|"GiB"|"TB"|"TiB"|"%"|"cyl"|"chs"|"compact")?
    
}

/// Task class for parted
class Parted extends Playbook.Task {

    /// todo doc
    `community.general.parted`: Dynamic

    /// Options for community.general.parted
    hidden options: PartedOptions?

    /// todo doc
    function configure(): Parted = this
        .toMap()
        .put(
            "community.general.parted",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Parted)

}

/// Manage pear/pecl packages
class PearOptions {
    
    executable: String?
    
    name: String
    
    prompts: Listing<String>?
    
    state: ("present"|"installed"|"latest"|"absent"|"removed")?
    
}

/// Task class for pear
class Pear extends Playbook.Task {

    /// todo doc
    `community.general.pear`: Dynamic

    /// Options for community.general.pear
    hidden options: PearOptions?

    /// todo doc
    function configure(): Pear = this
        .toMap()
        .put(
            "community.general.pear",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Pear)

}

/// Retrieves process IDs list if the process is running otherwise return empty list
class PidsOptions {
    
    ignore_case: Boolean?
    
    name: String?
    
    pattern: String?
    
}

/// Task class for pids
class Pids extends Playbook.Task {

    /// todo doc
    `community.general.pids`: Dynamic

    /// Options for community.general.pids
    hidden options: PidsOptions?

    /// todo doc
    function configure(): Pids = this
        .toMap()
        .put(
            "community.general.pids",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Pids)

}

/// Pause/unpause Pingdom alerts
class PingdomOptions {
    
    checkid: String
    
    key: String
    
    passwd: String
    
    state: ("running"|"paused"|"started"|"stopped")
    
    uid: String
    
}

/// Task class for pingdom
class Pingdom extends Playbook.Task {

    /// todo doc
    `community.general.pingdom`: Dynamic

    /// Options for community.general.pingdom
    hidden options: PingdomOptions?

    /// todo doc
    function configure(): Pingdom = this
        .toMap()
        .put(
            "community.general.pingdom",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Pingdom)

}

/// Pip package information
class PipPackageInfoOptions {
    
    clients: Listing<String>?
    
}

/// Task class for pip_package_info
class PipPackageInfo extends Playbook.Task {

    /// todo doc
    `community.general.pip_package_info`: Dynamic

    /// Options for community.general.pip_package_info
    hidden options: PipPackageInfoOptions?

    /// todo doc
    function configure(): PipPackageInfo = this
        .toMap()
        .put(
            "community.general.pip_package_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(PipPackageInfo)

}

/// Manages applications installed with pipx
class PipxOptions {
    
    editable: Boolean?
    
    executable: String?
    
    force: Boolean?
    
    include_injected: Boolean?
    
    index_url: String?
    
    inject_packages: Listing<String>?
    
    install_apps: Boolean?
    
    install_deps: Boolean?
    
    name: String?
    
    pip_args: String?
    
    python: String?
    
    source: String?
    
    state: ("present"|"absent"|"install"|"uninstall"|"uninstall_all"|"inject"|"upgrade"|"upgrade_all"|"reinstall"|"reinstall_all"|"latest")?
    
    system_site_packages: Boolean?
    
}

/// Task class for pipx
class Pipx extends Playbook.Task {

    /// todo doc
    `community.general.pipx`: Dynamic

    /// Options for community.general.pipx
    hidden options: PipxOptions?

    /// todo doc
    function configure(): Pipx = this
        .toMap()
        .put(
            "community.general.pipx",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Pipx)

}

/// Rretrieves information about applications installed with pipx
class PipxInfoOptions {
    
    executable: String?
    
    include_deps: Boolean?
    
    include_injected: Boolean?
    
    include_raw: Boolean?
    
    name: String?
    
}

/// Task class for pipx_info
class PipxInfo extends Playbook.Task {

    /// todo doc
    `community.general.pipx_info`: Dynamic

    /// Options for community.general.pipx_info
    hidden options: PipxInfoOptions?

    /// todo doc
    function configure(): PipxInfo = this
        .toMap()
        .put(
            "community.general.pipx_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(PipxInfo)

}

/// Manages packages with the Solaris 11 Image Packaging System
class Pkg5Options {
    
    accept_licenses: Boolean?
    
    be_name: String?
    
    name: Listing<String>
    
    refresh: Boolean?
    
    state: ("absent"|"latest"|"present"|"installed"|"removed"|"uninstalled")?
    
}

/// Task class for pkg5
class Pkg5 extends Playbook.Task {

    /// todo doc
    `community.general.pkg5`: Dynamic

    /// Options for community.general.pkg5
    hidden options: Pkg5Options?

    /// todo doc
    function configure(): Pkg5 = this
        .toMap()
        .put(
            "community.general.pkg5",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Pkg5)

}

/// Manages Solaris 11 Image Packaging System publishers
class Pkg5PublisherOptions {
    
    enabled: Boolean?
    
    mirror: Listing<String>?
    
    name: String
    
    origin: Listing<String>?
    
    state: ("present"|"absent")?
    
    sticky: Boolean?
    
}

/// Task class for pkg5_publisher
class Pkg5Publisher extends Playbook.Task {

    /// todo doc
    `community.general.pkg5_publisher`: Dynamic

    /// Options for community.general.pkg5_publisher
    hidden options: Pkg5PublisherOptions?

    /// todo doc
    function configure(): Pkg5Publisher = this
        .toMap()
        .put(
            "community.general.pkg5_publisher",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Pkg5Publisher)

}

/// Package manager for SmartOS, NetBSD, et al
class PkginOptions {
    
    clean: Boolean?
    
    force: Boolean?
    
    full_upgrade: Boolean?
    
    name: Listing<String>?
    
    state: ("present"|"absent")?
    
    update_cache: Boolean?
    
    upgrade: Boolean?
    
}

/// Task class for pkgin
class Pkgin extends Playbook.Task {

    /// todo doc
    `community.general.pkgin`: Dynamic

    /// Options for community.general.pkgin
    hidden options: PkginOptions?

    /// todo doc
    function configure(): Pkgin = this
        .toMap()
        .put(
            "community.general.pkgin",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Pkgin)

}

/// Package manager for FreeBSD >= 9.0
class PkgngOptions {
    
    annotation: Listing<String>?
    
    autoremove: Boolean?
    
    cached: Boolean?
    
    chroot: String?
    
    ignore_osver: Boolean?
    
    jail: String?
    
    name: Listing<String>
    
    pkgsite: String?
    
    rootdir: String?
    
    state: ("present"|"latest"|"absent")?
    
}

/// Task class for pkgng
class Pkgng extends Playbook.Task {

    /// todo doc
    `community.general.pkgng`: Dynamic

    /// Options for community.general.pkgng
    hidden options: PkgngOptions?

    /// todo doc
    function configure(): Pkgng = this
        .toMap()
        .put(
            "community.general.pkgng",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Pkgng)

}

/// OpenCSW package management on Solaris
class PkgutilOptions {
    
    force: Boolean?
    
    name: Listing<String>
    
    site: String?
    
    state: ("absent"|"installed"|"latest"|"present"|"removed")
    
    update_catalog: Boolean?
    
}

/// Task class for pkgutil
class Pkgutil extends Playbook.Task {

    /// todo doc
    `community.general.pkgutil`: Dynamic

    /// Options for community.general.pkgutil
    hidden options: PkgutilOptions?

    /// todo doc
    function configure(): Pkgutil = this
        .toMap()
        .put(
            "community.general.pkgutil",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Pkgutil)

}

/// Configure Intel Optane Persistent Memory modules
class PmemOptions {
    
    appdirect: Int?
    
    appdirect_interleaved: Boolean?
    
    memorymode: Int?
    
    namespace: Listing<Any>?
    
    namespace_append: Boolean?
    
    reserved: Int?
    
    socket: Listing<Any>?
    
}

/// Task class for pmem
class Pmem extends Playbook.Task {

    /// todo doc
    `community.general.pmem`: Dynamic

    /// Options for community.general.pmem
    hidden options: PmemOptions?

    /// todo doc
    function configure(): Pmem = this
        .toMap()
        .put(
            "community.general.pmem",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Pmem)

}

/// Manage node.js packages with pnpm
class PnpmOptions {
    
    alias: String?
    
    dev: Boolean?
    
    executable: String?
    
    global: Boolean?
    
    ignore_scripts: Boolean?
    
    name: String?
    
    no_optional: Boolean?
    
    optional: Boolean?
    
    path: String?
    
    production: Boolean?
    
    state: ("present"|"absent"|"latest")?
    
    version: String?
    
}

/// Task class for pnpm
class Pnpm extends Playbook.Task {

    /// todo doc
    `community.general.pnpm`: Dynamic

    /// Options for community.general.pnpm
    hidden options: PnpmOptions?

    /// todo doc
    function configure(): Pnpm = this
        .toMap()
        .put(
            "community.general.pnpm",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Pnpm)

}

/// Package manager for Gentoo
class PortageOptions {
    
    backtrack: Int?
    
    changed_use: Boolean?
    
    deep: Boolean?
    
    depclean: Boolean?
    
    getbinpkg: Boolean?
    
    getbinpkgonly: Boolean?
    
    jobs: Int?
    
    keepgoing: Boolean?
    
    loadavg: Any?
    
    newuse: Boolean?
    
    nodeps: Boolean?
    
    noreplace: Boolean?
    
    oneshot: Boolean?
    
    onlydeps: Boolean?
    
    package: Listing<String>?
    
    quiet: Boolean?
    
    quietbuild: Boolean?
    
    quietfail: Boolean?
    
    state: ("present"|"installed"|"emerged"|"absent"|"removed"|"unmerged"|"latest")?
    
    sync: ("web"|"yes"|"no")?
    
    update: Boolean?
    
    usepkg: Boolean?
    
    usepkgonly: Boolean?
    
    verbose: Boolean?
    
    withbdeps: Boolean?
    
}

/// Task class for portage
class Portage extends Playbook.Task {

    /// todo doc
    `community.general.portage`: Dynamic

    /// Options for community.general.portage
    hidden options: PortageOptions?

    /// todo doc
    function configure(): Portage = this
        .toMap()
        .put(
            "community.general.portage",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Portage)

}

/// Installing packages from FreeBSD's ports system
class PortinstallOptions {
    
    name: String
    
    state: ("present"|"absent")?
    
    use_packages: Boolean?
    
}

/// Task class for portinstall
class Portinstall extends Playbook.Task {

    /// todo doc
    `community.general.portinstall`: Dynamic

    /// Options for community.general.portinstall
    hidden options: PortinstallOptions?

    /// todo doc
    function configure(): Portinstall = this
        .toMap()
        .put(
            "community.general.portinstall",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Portinstall)

}

/// Manages Pritunl Organizations using the Pritunl API
class PritunlOrgOptions {
    
    force: Boolean?
    
    name: String
    
    state: ("present"|"absent")?
    
}

/// Task class for pritunl_org
class PritunlOrg extends Playbook.Task {

    /// todo doc
    `community.general.pritunl_org`: Dynamic

    /// Options for community.general.pritunl_org
    hidden options: PritunlOrgOptions?

    /// todo doc
    function configure(): PritunlOrg = this
        .toMap()
        .put(
            "community.general.pritunl_org",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(PritunlOrg)

}

/// List Pritunl Organizations using the Pritunl API
class PritunlOrgInfoOptions {
    
    organization: String?
    
}

/// Task class for pritunl_org_info
class PritunlOrgInfo extends Playbook.Task {

    /// todo doc
    `community.general.pritunl_org_info`: Dynamic

    /// Options for community.general.pritunl_org_info
    hidden options: PritunlOrgInfoOptions?

    /// todo doc
    function configure(): PritunlOrgInfo = this
        .toMap()
        .put(
            "community.general.pritunl_org_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(PritunlOrgInfo)

}

/// Manage Pritunl Users using the Pritunl API
class PritunlUserOptions {
    
    organization: String
    
    state: ("present"|"absent")?
    
    user_disabled: Boolean?
    
    user_email: String?
    
    user_gravatar: Boolean?
    
    user_groups: Listing<String>?
    
    user_mac_addresses: Listing<String>?
    
    user_name: String
    
    user_type: ("client"|"server")?
    
}

/// Task class for pritunl_user
class PritunlUser extends Playbook.Task {

    /// todo doc
    `community.general.pritunl_user`: Dynamic

    /// Options for community.general.pritunl_user
    hidden options: PritunlUserOptions?

    /// todo doc
    function configure(): PritunlUser = this
        .toMap()
        .put(
            "community.general.pritunl_user",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(PritunlUser)

}

/// List Pritunl Users using the Pritunl API
class PritunlUserInfoOptions {
    
    organization: String
    
    user_name: String?
    
    user_type: ("client"|"server")?
    
}

/// Task class for pritunl_user_info
class PritunlUserInfo extends Playbook.Task {

    /// todo doc
    `community.general.pritunl_user_info`: Dynamic

    /// Options for community.general.pritunl_user_info
    hidden options: PritunlUserInfoOptions?

    /// todo doc
    function configure(): PritunlUserInfo = this
        .toMap()
        .put(
            "community.general.pritunl_user_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(PritunlUserInfo)

}

/// Create, destroy, start, stop, and reboot a ProfitBricks virtual machine
class ProfitbricksOptions {
    
    assign_public_ip: Boolean?
    
    auto_increment: Boolean?
    
    bus: ("IDE"|"VIRTIO")?
    
    cores: Int?
    
    count: Int?
    
    cpu_family: ("AMD_OPTERON"|"INTEL_XEON")?
    
    datacenter: String?
    
    disk_type: ("SSD"|"HDD")?
    
    image: String?
    
    image_password: String?
    
    instance_ids: Listing<String>?
    
    lan: Int?
    
    location: ("us/las"|"de/fra"|"de/fkb")?
    
    name: String?
    
    ram: Int?
    
    remove_boot_volume: Boolean?
    
    ssh_keys: Listing<String>?
    
    state: String?
    
    subscription_password: String?
    
    subscription_user: String?
    
    volume_size: Int?
    
    wait: Boolean?
    
    wait_timeout: Int?
    
}

/// Task class for profitbricks
class Profitbricks extends Playbook.Task {

    /// todo doc
    `community.general.profitbricks`: Dynamic

    /// Options for community.general.profitbricks
    hidden options: ProfitbricksOptions?

    /// todo doc
    function configure(): Profitbricks = this
        .toMap()
        .put(
            "community.general.profitbricks",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Profitbricks)

}

/// Create or destroy a ProfitBricks Virtual Datacenter
class ProfitbricksDatacenterOptions {
    
    description: String?
    
    location: ("us/las"|"de/fra"|"de/fkb")?
    
    name: String?
    
    state: String?
    
    subscription_password: String?
    
    subscription_user: String?
    
    wait: Boolean?
    
    wait_timeout: Int?
    
}

/// Task class for profitbricks_datacenter
class ProfitbricksDatacenter extends Playbook.Task {

    /// todo doc
    `community.general.profitbricks_datacenter`: Dynamic

    /// Options for community.general.profitbricks_datacenter
    hidden options: ProfitbricksDatacenterOptions?

    /// todo doc
    function configure(): ProfitbricksDatacenter = this
        .toMap()
        .put(
            "community.general.profitbricks_datacenter",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ProfitbricksDatacenter)

}

/// Create or Remove a NIC
class ProfitbricksNicOptions {
    
    datacenter: String
    
    lan: String?
    
    name: String?
    
    server: String
    
    state: String?
    
    subscription_password: String
    
    subscription_user: String
    
    wait: Boolean?
    
    wait_timeout: Int?
    
}

/// Task class for profitbricks_nic
class ProfitbricksNic extends Playbook.Task {

    /// todo doc
    `community.general.profitbricks_nic`: Dynamic

    /// Options for community.general.profitbricks_nic
    hidden options: ProfitbricksNicOptions?

    /// todo doc
    function configure(): ProfitbricksNic = this
        .toMap()
        .put(
            "community.general.profitbricks_nic",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ProfitbricksNic)

}

/// Create or destroy a volume
class ProfitbricksVolumeOptions {
    
    auto_increment: Boolean?
    
    bus: ("IDE"|"VIRTIO")?
    
    count: Int?
    
    datacenter: String?
    
    disk_type: ("HDD"|"SSD")?
    
    image: String?
    
    image_password: String?
    
    instance_ids: Listing<String>?
    
    licence_type: String?
    
    name: String?
    
    server: String?
    
    size: Int?
    
    ssh_keys: Listing<String>?
    
    state: String?
    
    subscription_password: String?
    
    subscription_user: String?
    
    wait: Boolean?
    
    wait_timeout: Int?
    
}

/// Task class for profitbricks_volume
class ProfitbricksVolume extends Playbook.Task {

    /// todo doc
    `community.general.profitbricks_volume`: Dynamic

    /// Options for community.general.profitbricks_volume
    hidden options: ProfitbricksVolumeOptions?

    /// todo doc
    function configure(): ProfitbricksVolume = this
        .toMap()
        .put(
            "community.general.profitbricks_volume",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ProfitbricksVolume)

}

/// Attach or detach a volume
class ProfitbricksVolumeAttachmentsOptions {
    
    datacenter: String?
    
    server: String?
    
    state: String?
    
    subscription_password: String?
    
    subscription_user: String?
    
    volume: String?
    
    wait: Boolean?
    
    wait_timeout: Int?
    
}

/// Task class for profitbricks_volume_attachments
class ProfitbricksVolumeAttachments extends Playbook.Task {

    /// todo doc
    `community.general.profitbricks_volume_attachments`: Dynamic

    /// Options for community.general.profitbricks_volume_attachments
    hidden options: ProfitbricksVolumeAttachmentsOptions?

    /// todo doc
    function configure(): ProfitbricksVolumeAttachments = this
        .toMap()
        .put(
            "community.general.profitbricks_volume_attachments",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ProfitbricksVolumeAttachments)

}

/// Management of instances in Proxmox VE cluster
class ProxmoxOptions {
    
    clone: Int?
    
    clone_type: ("full"|"linked"|"opportunistic")?
    
    cores: Int?
    
    cpus: Int?
    
    cpuunits: Int?
    
    description: String?
    
    disk: String?
    
    features: Listing<String>?
    
    force: Boolean?
    
    hookscript: String?
    
    hostname: String?
    
    ip_address: String?
    
    memory: Int?
    
    mounts: Any?
    
    nameserver: String?
    
    netif: Any?
    
    onboot: Boolean?
    
    ostemplate: String?
    
    ostype: ("auto"|"debian"|"devuan"|"ubuntu"|"centos"|"fedora"|"opensuse"|"archlinux"|"alpine"|"gentoo"|"nixos"|"unmanaged")?
    
    password: String?
    
    proxmox_default_behavior: ("compatibility"|"no_defaults")?
    
    pubkey: String?
    
    purge: Boolean?
    
    searchdomain: String?
    
    state: ("present"|"started"|"absent"|"stopped"|"restarted"|"template")?
    
    storage: String?
    
    swap: Int?
    
    tags: Listing<String>?
    
    timeout: Int?
    
    timezone: String?
    
    unprivileged: Boolean?
    
    update: Boolean?
    
}

/// Task class for proxmox
class Proxmox extends Playbook.Task {

    /// todo doc
    `community.general.proxmox`: Dynamic

    /// Options for community.general.proxmox
    hidden options: ProxmoxOptions?

    /// todo doc
    function configure(): Proxmox = this
        .toMap()
        .put(
            "community.general.proxmox",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Proxmox)

}

/// Management of a disk of a Qemu(KVM) VM in a Proxmox VE cluster
class ProxmoxDiskOptions {
    
    aio: ("native"|"threads"|"io_uring")?
    
    backup: Boolean?
    
    bps_max_length: Int?
    
    bps_rd_max_length: Int?
    
    bps_wr_max_length: Int?
    
    bwlimit: Int?
    
    cache: ("none"|"writethrough"|"writeback"|"unsafe"|"directsync")?
    
    create: ("disabled"|"regular"|"forced")?
    
    cyls: Int?
    
    delete_moved: Boolean?
    
    detect_zeroes: Boolean?
    
    discard: ("ignore"|"on")?
    
    disk: String
    
    format: ("raw"|"cow"|"qcow"|"qed"|"qcow2"|"vmdk"|"cloop")?
    
    heads: Int?
    
    import_from: String?
    
    iops: Int?
    
    iops_max: Int?
    
    iops_max_length: Int?
    
    iops_rd: Int?
    
    iops_rd_max: Int?
    
    iops_rd_max_length: Int?
    
    iops_wr: Int?
    
    iops_wr_max: Int?
    
    iops_wr_max_length: Int?
    
    iothread: Boolean?
    
    iso_image: String?
    
    mbps: Any?
    
    mbps_max: Any?
    
    mbps_rd: Any?
    
    mbps_rd_max: Any?
    
    mbps_wr: Any?
    
    mbps_wr_max: Any?
    
    media: ("cdrom"|"disk")?
    
    name: String?
    
    queues: Int?
    
    replicate: Boolean?
    
    rerror: ("ignore"|"report"|"stop")?
    
    ro: Boolean?
    
    scsiblock: Boolean?
    
    secs: Int?
    
    serial: String?
    
    shared: Boolean?
    
    size: String?
    
    snapshot: Boolean?
    
    ssd: Boolean?
    
    state: ("present"|"resized"|"detached"|"moved"|"absent")?
    
    storage: String?
    
    target_disk: String?
    
    target_storage: String?
    
    target_vmid: Int?
    
    timeout: Int?
    
    trans: ("auto"|"lba"|"none")?
    
    vmid: Int?
    
    werror: ("enospc"|"ignore"|"report"|"stop")?
    
    wwn: String?
    
}

/// Task class for proxmox_disk
class ProxmoxDisk extends Playbook.Task {

    /// todo doc
    `community.general.proxmox_disk`: Dynamic

    /// Options for community.general.proxmox_disk
    hidden options: ProxmoxDiskOptions?

    /// todo doc
    function configure(): ProxmoxDisk = this
        .toMap()
        .put(
            "community.general.proxmox_disk",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ProxmoxDisk)

}

/// Retrieve information about one or more Proxmox VE domains
class ProxmoxDomainInfoOptions {
    
    domain: String?
    
}

/// Task class for proxmox_domain_info
class ProxmoxDomainInfo extends Playbook.Task {

    /// todo doc
    `community.general.proxmox_domain_info`: Dynamic

    /// Options for community.general.proxmox_domain_info
    hidden options: ProxmoxDomainInfoOptions?

    /// todo doc
    function configure(): ProxmoxDomainInfo = this
        .toMap()
        .put(
            "community.general.proxmox_domain_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ProxmoxDomainInfo)

}

/// Retrieve information about one or more Proxmox VE groups
class ProxmoxGroupInfoOptions {
    
    group: String?
    
}

/// Task class for proxmox_group_info
class ProxmoxGroupInfo extends Playbook.Task {

    /// todo doc
    `community.general.proxmox_group_info`: Dynamic

    /// Options for community.general.proxmox_group_info
    hidden options: ProxmoxGroupInfoOptions?

    /// todo doc
    function configure(): ProxmoxGroupInfo = this
        .toMap()
        .put(
            "community.general.proxmox_group_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ProxmoxGroupInfo)

}

/// Management of Qemu(KVM) Virtual Machines in Proxmox VE cluster
class ProxmoxKvmOptions {
    
    acpi: Boolean?
    
    agent: String?
    
    archive: String?
    
    args: String?
    
    autostart: Boolean?
    
    balloon: Int?
    
    bios: ("seabios"|"ovmf")?
    
    boot: String?
    
    bootdisk: String?
    
    cicustom: String?
    
    cipassword: String?
    
    citype: ("nocloud"|"configdrive2")?
    
    ciuser: String?
    
    clone: String?
    
    cores: Int?
    
    cpu: String?
    
    cpulimit: Int?
    
    cpuunits: Int?
    
    `delete`: String?
    
    description: String?
    
    digest: String?
    
    efidisk0: Any?
    
    force: Boolean?
    
    format: ("cloop"|"cow"|"qcow"|"qcow2"|"qed"|"raw"|"vmdk"|"unspecified")?
    
    freeze: Boolean?
    
    full: Boolean?
    
    hookscript: String?
    
    hostpci: Any?
    
    hotplug: String?
    
    hugepages: ("any"|"2"|"1024")?
    
    ide: Any?
    
    ipconfig: Any?
    
    keyboard: String?
    
    kvm: Boolean?
    
    localtime: Boolean?
    
    lock: ("migrate"|"backup"|"snapshot"|"rollback")?
    
    machine: String?
    
    memory: Int?
    
    migrate: Boolean?
    
    migrate_downtime: Int?
    
    migrate_speed: Int?
    
    name: String?
    
    nameservers: Listing<String>?
    
    net: Any?
    
    newid: Int?
    
    numa: Any?
    
    numa_enabled: Boolean?
    
    onboot: Boolean?
    
    ostype: ("other"|"wxp"|"w2k"|"w2k3"|"w2k8"|"wvista"|"win7"|"win8"|"win10"|"win11"|"l24"|"l26"|"solaris")?
    
    parallel: Any?
    
    protection: Boolean?
    
    proxmox_default_behavior: ("compatibility"|"no_defaults")?
    
    reboot: Boolean?
    
    revert: String?
    
    sata: Any?
    
    scsi: Any?
    
    scsihw: ("lsi"|"lsi53c810"|"virtio-scsi-pci"|"virtio-scsi-single"|"megasas"|"pvscsi")?
    
    searchdomains: Listing<String>?
    
    serial: Any?
    
    shares: Int?
    
    skiplock: Boolean?
    
    smbios: String?
    
    snapname: String?
    
    sockets: Int?
    
    sshkeys: String?
    
    startdate: String?
    
    startup: String?
    
    state: ("present"|"started"|"absent"|"stopped"|"restarted"|"current"|"template")?
    
    storage: String?
    
    tablet: Boolean?
    
    tags: Listing<String>?
    
    target: String?
    
    tdf: Boolean?
    
    template: Boolean?
    
    timeout: Int?
    
    tpmstate0: Any?
    
    update: Boolean?
    
    update_unsafe: Boolean?
    
    vcpus: Int?
    
    vga: ("std"|"cirrus"|"vmware"|"qxl"|"serial0"|"serial1"|"serial2"|"serial3"|"qxl2"|"qxl3"|"qxl4")?
    
    virtio: Any?
    
    watchdog: String?
    
}

/// Task class for proxmox_kvm
class ProxmoxKvm extends Playbook.Task {

    /// todo doc
    `community.general.proxmox_kvm`: Dynamic

    /// Options for community.general.proxmox_kvm
    hidden options: ProxmoxKvmOptions?

    /// todo doc
    function configure(): ProxmoxKvm = this
        .toMap()
        .put(
            "community.general.proxmox_kvm",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ProxmoxKvm)

}

/// Management of a NIC of a Qemu(KVM) VM in a Proxmox VE cluster
class ProxmoxNicOptions {
    
    bridge: String?
    
    firewall: Boolean?
    
    interface: String
    
    link_down: Boolean?
    
    mac: String?
    
    model: ("e1000"|"e1000-82540em"|"e1000-82544gc"|"e1000-82545em"|"i82551"|"i82557b"|"i82559er"|"ne2k_isa"|"ne2k_pci"|"pcnet"|"rtl8139"|"virtio"|"vmxnet3")?
    
    mtu: Int?
    
    name: String?
    
    queues: Int?
    
    rate: Any?
    
    state: ("present"|"absent")?
    
    tag: Int?
    
    trunks: Listing<Int>?
    
    vmid: Int?
    
}

/// Task class for proxmox_nic
class ProxmoxNic extends Playbook.Task {

    /// todo doc
    `community.general.proxmox_nic`: Dynamic

    /// Options for community.general.proxmox_nic
    hidden options: ProxmoxNicOptions?

    /// todo doc
    function configure(): ProxmoxNic = this
        .toMap()
        .put(
            "community.general.proxmox_nic",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ProxmoxNic)

}

/// Retrieve information about one or more Proxmox VE nodes
class ProxmoxNodeInfoOptions {
    
}

/// Task class for proxmox_node_info
class ProxmoxNodeInfo extends Playbook.Task {

    /// todo doc
    `community.general.proxmox_node_info`: Dynamic

    /// Options for community.general.proxmox_node_info
    hidden options: ProxmoxNodeInfoOptions?

    /// todo doc
    function configure(): ProxmoxNodeInfo = this
        .toMap()
        .put(
            "community.general.proxmox_node_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ProxmoxNodeInfo)

}

/// Pool management for Proxmox VE cluster
class ProxmoxPoolOptions {
    
    comment: String?
    
    poolid: String
    
    state: ("present"|"absent")?
    
}

/// Task class for proxmox_pool
class ProxmoxPool extends Playbook.Task {

    /// todo doc
    `community.general.proxmox_pool`: Dynamic

    /// Options for community.general.proxmox_pool
    hidden options: ProxmoxPoolOptions?

    /// todo doc
    function configure(): ProxmoxPool = this
        .toMap()
        .put(
            "community.general.proxmox_pool",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ProxmoxPool)

}

/// Add or delete members from Proxmox VE cluster pools
class ProxmoxPoolMemberOptions {
    
    member: String
    
    poolid: String
    
    state: ("present"|"absent")?
    
    type: ("vm"|"storage")?
    
}

/// Task class for proxmox_pool_member
class ProxmoxPoolMember extends Playbook.Task {

    /// todo doc
    `community.general.proxmox_pool_member`: Dynamic

    /// Options for community.general.proxmox_pool_member
    hidden options: ProxmoxPoolMemberOptions?

    /// todo doc
    function configure(): ProxmoxPoolMember = this
        .toMap()
        .put(
            "community.general.proxmox_pool_member",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ProxmoxPoolMember)

}

/// Snapshot management of instances in Proxmox VE cluster
class ProxmoxSnapOptions {
    
    description: String?
    
    force: Boolean?
    
    hostname: String?
    
    retention: Int?
    
    snapname: String?
    
    state: ("present"|"absent"|"rollback")?
    
    timeout: Int?
    
    unbind: Boolean?
    
    vmid: String?
    
    vmstate: Boolean?
    
}

/// Task class for proxmox_snap
class ProxmoxSnap extends Playbook.Task {

    /// todo doc
    `community.general.proxmox_snap`: Dynamic

    /// Options for community.general.proxmox_snap
    hidden options: ProxmoxSnapOptions?

    /// todo doc
    function configure(): ProxmoxSnap = this
        .toMap()
        .put(
            "community.general.proxmox_snap",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ProxmoxSnap)

}

/// List content from a Proxmox VE storage
class ProxmoxStorageContentsInfoOptions {
    
    content: ("all"|"backup"|"rootdir"|"images"|"iso")?
    
    node: String
    
    storage: String
    
    vmid: Int?
    
}

/// Task class for proxmox_storage_contents_info
class ProxmoxStorageContentsInfo extends Playbook.Task {

    /// todo doc
    `community.general.proxmox_storage_contents_info`: Dynamic

    /// Options for community.general.proxmox_storage_contents_info
    hidden options: ProxmoxStorageContentsInfoOptions?

    /// todo doc
    function configure(): ProxmoxStorageContentsInfo = this
        .toMap()
        .put(
            "community.general.proxmox_storage_contents_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ProxmoxStorageContentsInfo)

}

/// Retrieve information about one or more Proxmox VE storages
class ProxmoxStorageInfoOptions {
    
    storage: String?
    
    type: String?
    
}

/// Task class for proxmox_storage_info
class ProxmoxStorageInfo extends Playbook.Task {

    /// todo doc
    `community.general.proxmox_storage_info`: Dynamic

    /// Options for community.general.proxmox_storage_info
    hidden options: ProxmoxStorageInfoOptions?

    /// todo doc
    function configure(): ProxmoxStorageInfo = this
        .toMap()
        .put(
            "community.general.proxmox_storage_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ProxmoxStorageInfo)

}

/// Retrieve information about one or more Proxmox VE tasks
class ProxmoxTasksInfoOptions {
    
    node: String
    
    task: String?
    
}

/// Task class for proxmox_tasks_info
class ProxmoxTasksInfo extends Playbook.Task {

    /// todo doc
    `community.general.proxmox_tasks_info`: Dynamic

    /// Options for community.general.proxmox_tasks_info
    hidden options: ProxmoxTasksInfoOptions?

    /// todo doc
    function configure(): ProxmoxTasksInfo = this
        .toMap()
        .put(
            "community.general.proxmox_tasks_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ProxmoxTasksInfo)

}

/// Management of OS templates in Proxmox VE cluster
class ProxmoxTemplateOptions {
    
    content_type: ("vztmpl"|"iso")?
    
    force: Boolean?
    
    node: String?
    
    src: String?
    
    state: ("present"|"absent")?
    
    storage: String?
    
    template: String?
    
    timeout: Int?
    
}

/// Task class for proxmox_template
class ProxmoxTemplate extends Playbook.Task {

    /// todo doc
    `community.general.proxmox_template`: Dynamic

    /// Options for community.general.proxmox_template
    hidden options: ProxmoxTemplateOptions?

    /// todo doc
    function configure(): ProxmoxTemplate = this
        .toMap()
        .put(
            "community.general.proxmox_template",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ProxmoxTemplate)

}

/// Retrieve information about one or more Proxmox VE users
class ProxmoxUserInfoOptions {
    
    domain: String?
    
    user: String?
    
    userid: String?
    
}

/// Task class for proxmox_user_info
class ProxmoxUserInfo extends Playbook.Task {

    /// todo doc
    `community.general.proxmox_user_info`: Dynamic

    /// Options for community.general.proxmox_user_info
    hidden options: ProxmoxUserInfoOptions?

    /// todo doc
    function configure(): ProxmoxUserInfo = this
        .toMap()
        .put(
            "community.general.proxmox_user_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ProxmoxUserInfo)

}

/// Retrieve information about one or more Proxmox VE virtual machines
class ProxmoxVmInfoOptions {
    
    config: ("none"|"current"|"pending")?
    
    name: String?
    
    node: String?
    
    type: ("all"|"qemu"|"lxc")?
    
    vmid: Int?
    
}

/// Task class for proxmox_vm_info
class ProxmoxVmInfo extends Playbook.Task {

    /// todo doc
    `community.general.proxmox_vm_info`: Dynamic

    /// Options for community.general.proxmox_vm_info
    hidden options: ProxmoxVmInfoOptions?

    /// todo doc
    function configure(): ProxmoxVmInfo = this
        .toMap()
        .put(
            "community.general.proxmox_vm_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ProxmoxVmInfo)

}

/// PubNub blocks management module
class PubnubBlocksOptions {
    
    account: String?
    
    application: String
    
    cache: Any?
    
    changes: Any?
    
    description: String?
    
    email: String?
    
    event_handlers: Listing<Any>?
    
    keyset: String
    
    name: String
    
    password: String?
    
    state: ("started"|"stopped"|"present"|"absent")?
    
    validate_certs: Boolean?
    
}

/// Task class for pubnub_blocks
class PubnubBlocks extends Playbook.Task {

    /// todo doc
    `community.general.pubnub_blocks`: Dynamic

    /// Options for community.general.pubnub_blocks
    hidden options: PubnubBlocksOptions?

    /// todo doc
    function configure(): PubnubBlocks = this
        .toMap()
        .put(
            "community.general.pubnub_blocks",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(PubnubBlocks)

}

/// Add or remove Pulp repos from a remote host
class PulpRepoOptions {
    
    add_export_distributor: Boolean?
    
    feed: String?
    
    feed_ca_cert: String?
    
    feed_client_cert: String?
    
    feed_client_key: String?
    
    force_basic_auth: Boolean?
    
    generate_sqlite: Boolean?
    
    name: String
    
    proxy_host: String?
    
    proxy_password: String?
    
    proxy_port: String?
    
    proxy_username: String?
    
    publish_distributor: String?
    
    pulp_host: String?
    
    relative_url: String?
    
    repo_type: String?
    
    repoview: Boolean?
    
    serve_http: Boolean?
    
    serve_https: Boolean?
    
    state: ("present"|"absent"|"sync"|"publish")?
    
    url_password: Any?
    
    url_username: Any?
    
    validate_certs: Boolean?
    
    wait_for_completion: Boolean?
    
}

/// Task class for pulp_repo
class PulpRepo extends Playbook.Task {

    /// todo doc
    `community.general.pulp_repo`: Dynamic

    /// Options for community.general.pulp_repo
    hidden options: PulpRepoOptions?

    /// todo doc
    function configure(): PulpRepo = this
        .toMap()
        .put(
            "community.general.pulp_repo",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(PulpRepo)

}

/// Runs puppet
class PuppetOptions {
    
    certname: String?
    
    confdir: String?
    
    debug: Boolean?
    
    environment: String?
    
    execute: String?
    
    facter_basename: String?
    
    facts: Any?
    
    logdest: ("all"|"stdout"|"syslog")?
    
    manifest: String?
    
    modulepath: String?
    
    noop: Boolean?
    
    puppetmaster: String?
    
    show_diff: Boolean?
    
    skip_tags: Listing<String>?
    
    summarize: Boolean?
    
    tags: Listing<String>?
    
    timeout: String?
    
    use_srv_records: Boolean?
    
    verbose: Boolean?
    
}

/// Task class for puppet
class Puppet extends Playbook.Task {

    /// todo doc
    `community.general.puppet`: Dynamic

    /// Options for community.general.puppet
    hidden options: PuppetOptions?

    /// todo doc
    function configure(): Puppet = this
        .toMap()
        .put(
            "community.general.puppet",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Puppet)

}

/// Sends notifications to Pushbullet
class PushbulletOptions {
    
    api_key: String
    
    body: String?
    
    channel: String?
    
    device: String?
    
    push_type: ("note"|"link")?
    
    title: String
    
    url: String?
    
}

/// Task class for pushbullet
class Pushbullet extends Playbook.Task {

    /// todo doc
    `community.general.pushbullet`: Dynamic

    /// Options for community.general.pushbullet
    hidden options: PushbulletOptions?

    /// todo doc
    function configure(): Pushbullet = this
        .toMap()
        .put(
            "community.general.pushbullet",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Pushbullet)

}

/// Send notifications via U(https://pushover.net)
class PushoverOptions {
    
    app_token: String
    
    device: String?
    
    msg: String
    
    pri: ("-2"|"-1"|"0"|"1"|"2")?
    
    title: String?
    
    user_key: String
    
}

/// Task class for pushover
class Pushover extends Playbook.Task {

    /// todo doc
    `community.general.pushover`: Dynamic

    /// Options for community.general.pushover
    hidden options: PushoverOptions?

    /// todo doc
    function configure(): Pushover = this
        .toMap()
        .put(
            "community.general.pushover",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Pushover)

}

/// Show python path and assert dependency versions
class PythonRequirementsInfoOptions {
    
    dependencies: Listing<String>?
    
}

/// Task class for python_requirements_info
class PythonRequirementsInfo extends Playbook.Task {

    /// todo doc
    `community.general.python_requirements_info`: Dynamic

    /// Options for community.general.python_requirements_info
    hidden options: PythonRequirementsInfoOptions?

    /// todo doc
    function configure(): PythonRequirementsInfo = this
        .toMap()
        .put(
            "community.general.python_requirements_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(PythonRequirementsInfo)

}

/// Create / delete an instance in Rackspace Public Cloud
class RaxOptions {
    
    auto_increment: Boolean?
    
    boot_from_volume: Boolean?
    
    boot_volume: String?
    
    boot_volume_size: Int?
    
    boot_volume_terminate: Boolean?
    
    config_drive: Boolean?
    
    count: Int?
    
    count_offset: Int?
    
    disk_config: ("auto"|"manual")?
    
    exact_count: Boolean?
    
    extra_client_args: Any?
    
    extra_create_args: Any?
    
    files: Any?
    
    flavor: String?
    
    group: String?
    
    image: String?
    
    instance_ids: Listing<String>?
    
    key_name: String?
    
    meta: Any?
    
    name: String?
    
    networks: Listing<String>?
    
    state: ("present"|"absent")?
    
    user_data: String?
    
    wait: Boolean?
    
    wait_timeout: Int?
    
}

/// Task class for rax
class Rax extends Playbook.Task {

    /// todo doc
    `community.general.rax`: Dynamic

    /// Options for community.general.rax
    hidden options: RaxOptions?

    /// todo doc
    function configure(): Rax = this
        .toMap()
        .put(
            "community.general.rax",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Rax)

}

/// Manipulate Rackspace Cloud Block Storage Volumes
class RaxCbsOptions {
    
    description: String?
    
    image: String?
    
    meta: Any?
    
    name: String
    
    size: Int?
    
    snapshot_id: String?
    
    state: ("present"|"absent")?
    
    volume_type: ("SATA"|"SSD")?
    
    wait: Boolean?
    
    wait_timeout: Int?
    
}

/// Task class for rax_cbs
class RaxCbs extends Playbook.Task {

    /// todo doc
    `community.general.rax_cbs`: Dynamic

    /// Options for community.general.rax_cbs
    hidden options: RaxCbsOptions?

    /// todo doc
    function configure(): RaxCbs = this
        .toMap()
        .put(
            "community.general.rax_cbs",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RaxCbs)

}

/// Manipulate Rackspace Cloud Block Storage Volume Attachments
class RaxCbsAttachmentsOptions {
    
    device: String?
    
    server: String
    
    state: ("present"|"absent")?
    
    volume: String
    
    wait: Boolean?
    
    wait_timeout: Int?
    
}

/// Task class for rax_cbs_attachments
class RaxCbsAttachments extends Playbook.Task {

    /// todo doc
    `community.general.rax_cbs_attachments`: Dynamic

    /// Options for community.general.rax_cbs_attachments
    hidden options: RaxCbsAttachmentsOptions?

    /// todo doc
    function configure(): RaxCbsAttachments = this
        .toMap()
        .put(
            "community.general.rax_cbs_attachments",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RaxCbsAttachments)

}

/// Create/delete or resize a Rackspace Cloud Databases instance
class RaxCdbOptions {
    
    cdb_type: String?
    
    cdb_version: String?
    
    flavor: Int?
    
    name: String
    
    state: ("present"|"absent")?
    
    volume: Int?
    
    wait: Boolean?
    
    wait_timeout: Int?
    
}

/// Task class for rax_cdb
class RaxCdb extends Playbook.Task {

    /// todo doc
    `community.general.rax_cdb`: Dynamic

    /// Options for community.general.rax_cdb
    hidden options: RaxCdbOptions?

    /// todo doc
    function configure(): RaxCdb = this
        .toMap()
        .put(
            "community.general.rax_cdb",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RaxCdb)

}

/// Create / delete a database in the Cloud Databases
class RaxCdbDatabaseOptions {
    
    cdb_id: String
    
    character_set: String?
    
    collate: String?
    
    name: String
    
    state: ("present"|"absent")?
    
}

/// Task class for rax_cdb_database
class RaxCdbDatabase extends Playbook.Task {

    /// todo doc
    `community.general.rax_cdb_database`: Dynamic

    /// Options for community.general.rax_cdb_database
    hidden options: RaxCdbDatabaseOptions?

    /// todo doc
    function configure(): RaxCdbDatabase = this
        .toMap()
        .put(
            "community.general.rax_cdb_database",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RaxCdbDatabase)

}

/// Create / delete a Rackspace Cloud Database
class RaxCdbUserOptions {
    
    cdb_id: String
    
    databases: Listing<String>?
    
    db_password: String
    
    db_username: String
    
    host: String?
    
    state: ("present"|"absent")?
    
}

/// Task class for rax_cdb_user
class RaxCdbUser extends Playbook.Task {

    /// todo doc
    `community.general.rax_cdb_user`: Dynamic

    /// Options for community.general.rax_cdb_user
    hidden options: RaxCdbUserOptions?

    /// todo doc
    function configure(): RaxCdbUser = this
        .toMap()
        .put(
            "community.general.rax_cdb_user",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RaxCdbUser)

}

/// Create / delete a load balancer in Rackspace Public Cloud
class RaxClbOptions {
    
    algorithm: ("RANDOM"|"LEAST_CONNECTIONS"|"ROUND_ROBIN"|"WEIGHTED_LEAST_CONNECTIONS"|"WEIGHTED_ROUND_ROBIN")?
    
    meta: Any?
    
    name: String
    
    port: Int?
    
    protocol: ("DNS_TCP"|"DNS_UDP"|"FTP"|"HTTP"|"HTTPS"|"IMAPS"|"IMAPv4"|"LDAP"|"LDAPS"|"MYSQL"|"POP3"|"POP3S"|"SMTP"|"TCP"|"TCP_CLIENT_FIRST"|"UDP"|"UDP_STREAM"|"SFTP")?
    
    state: ("present"|"absent")?
    
    timeout: Int?
    
    type: ("PUBLIC"|"SERVICENET")?
    
    vip_id: String?
    
    wait: Boolean?
    
    wait_timeout: Int?
    
}

/// Task class for rax_clb
class RaxClb extends Playbook.Task {

    /// todo doc
    `community.general.rax_clb`: Dynamic

    /// Options for community.general.rax_clb
    hidden options: RaxClbOptions?

    /// todo doc
    function configure(): RaxClb = this
        .toMap()
        .put(
            "community.general.rax_clb",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RaxClb)

}

/// Add, modify and remove nodes from a Rackspace Cloud Load Balancer
class RaxClbNodesOptions {
    
    address: String?
    
    condition: ("enabled"|"disabled"|"draining")?
    
    load_balancer_id: Int
    
    node_id: Int?
    
    port: Int?
    
    state: ("present"|"absent")?
    
    type: ("primary"|"secondary")?
    
    virtualenv: String?
    
    wait: Boolean?
    
    wait_timeout: Int?
    
    weight: Int?
    
}

/// Task class for rax_clb_nodes
class RaxClbNodes extends Playbook.Task {

    /// todo doc
    `community.general.rax_clb_nodes`: Dynamic

    /// Options for community.general.rax_clb_nodes
    hidden options: RaxClbNodesOptions?

    /// todo doc
    function configure(): RaxClbNodes = this
        .toMap()
        .put(
            "community.general.rax_clb_nodes",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RaxClbNodes)

}

/// Manage SSL termination for a Rackspace Cloud Load Balancer
class RaxClbSslOptions {
    
    certificate: String?
    
    enabled: Boolean?
    
    https_redirect: Boolean?
    
    intermediate_certificate: String?
    
    loadbalancer: String
    
    private_key: String?
    
    secure_port: Int?
    
    secure_traffic_only: Boolean?
    
    state: ("present"|"absent")?
    
    wait: Boolean?
    
    wait_timeout: Int?
    
}

/// Task class for rax_clb_ssl
class RaxClbSsl extends Playbook.Task {

    /// todo doc
    `community.general.rax_clb_ssl`: Dynamic

    /// Options for community.general.rax_clb_ssl
    hidden options: RaxClbSslOptions?

    /// todo doc
    function configure(): RaxClbSsl = this
        .toMap()
        .put(
            "community.general.rax_clb_ssl",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RaxClbSsl)

}

/// Manage domains on Rackspace Cloud DNS
class RaxDnsOptions {
    
    comment: String?
    
    email: String?
    
    name: String?
    
    state: ("present"|"absent")?
    
    ttl: Int?
    
}

/// Task class for rax_dns
class RaxDns extends Playbook.Task {

    /// todo doc
    `community.general.rax_dns`: Dynamic

    /// Options for community.general.rax_dns
    hidden options: RaxDnsOptions?

    /// todo doc
    function configure(): RaxDns = this
        .toMap()
        .put(
            "community.general.rax_dns",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RaxDns)

}

/// Manage DNS records on Rackspace Cloud DNS
class RaxDnsRecordOptions {
    
    comment: String?
    
    data: String
    
    domain: String?
    
    loadbalancer: String?
    
    name: String
    
    overwrite: Boolean?
    
    priority: Int?
    
    server: String?
    
    state: ("present"|"absent")?
    
    ttl: Int?
    
    type: ("A"|"AAAA"|"CNAME"|"MX"|"NS"|"SRV"|"TXT"|"PTR")
    
}

/// Task class for rax_dns_record
class RaxDnsRecord extends Playbook.Task {

    /// todo doc
    `community.general.rax_dns_record`: Dynamic

    /// Options for community.general.rax_dns_record
    hidden options: RaxDnsRecordOptions?

    /// todo doc
    function configure(): RaxDnsRecord = this
        .toMap()
        .put(
            "community.general.rax_dns_record",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RaxDnsRecord)

}

/// Gather facts for Rackspace Cloud Servers
class RaxFactsOptions {
    
    address: String?
    
    id: String?
    
    name: String?
    
}

/// Task class for rax_facts
class RaxFacts extends Playbook.Task {

    /// todo doc
    `community.general.rax_facts`: Dynamic

    /// Options for community.general.rax_facts
    hidden options: RaxFactsOptions?

    /// todo doc
    function configure(): RaxFacts = this
        .toMap()
        .put(
            "community.general.rax_facts",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RaxFacts)

}

/// Manipulate Rackspace Cloud Files Containers
class RaxFilesOptions {
    
    clear_meta: Boolean?
    
    container: String?
    
    meta: Any?
    
    private: Boolean?
    
    public: Boolean?
    
    region: String?
    
    state: ("present"|"absent"|"list")?
    
    ttl: Int?
    
    type: ("container"|"meta")?
    
    web_error: String?
    
    web_index: String?
    
}

/// Task class for rax_files
class RaxFiles extends Playbook.Task {

    /// todo doc
    `community.general.rax_files`: Dynamic

    /// Options for community.general.rax_files
    hidden options: RaxFilesOptions?

    /// todo doc
    function configure(): RaxFiles = this
        .toMap()
        .put(
            "community.general.rax_files",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RaxFiles)

}

/// Upload, download, and delete objects in Rackspace Cloud Files
class RaxFilesObjectsOptions {
    
    clear_meta: Boolean?
    
    container: String
    
    dest: String?
    
    expires: Int?
    
    meta: Any?
    
    method: ("get"|"put"|"delete")?
    
    src: String?
    
    structure: Boolean?
    
    type: ("file"|"meta")?
    
}

/// Task class for rax_files_objects
class RaxFilesObjects extends Playbook.Task {

    /// todo doc
    `community.general.rax_files_objects`: Dynamic

    /// Options for community.general.rax_files_objects
    hidden options: RaxFilesObjectsOptions?

    /// todo doc
    function configure(): RaxFilesObjects = this
        .toMap()
        .put(
            "community.general.rax_files_objects",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RaxFilesObjects)

}

/// Load Rackspace Cloud Identity
class RaxIdentityOptions {
    
    state: ("present")?
    
}

/// Task class for rax_identity
class RaxIdentity extends Playbook.Task {

    /// todo doc
    `community.general.rax_identity`: Dynamic

    /// Options for community.general.rax_identity
    hidden options: RaxIdentityOptions?

    /// todo doc
    function configure(): RaxIdentity = this
        .toMap()
        .put(
            "community.general.rax_identity",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RaxIdentity)

}

/// Create a keypair for use with Rackspace Cloud Servers
class RaxKeypairOptions {
    
    name: String
    
    public_key: String?
    
    state: ("present"|"absent")?
    
}

/// Task class for rax_keypair
class RaxKeypair extends Playbook.Task {

    /// todo doc
    `community.general.rax_keypair`: Dynamic

    /// Options for community.general.rax_keypair
    hidden options: RaxKeypairOptions?

    /// todo doc
    function configure(): RaxKeypair = this
        .toMap()
        .put(
            "community.general.rax_keypair",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RaxKeypair)

}

/// Manipulate metadata for Rackspace Cloud Servers
class RaxMetaOptions {
    
    address: String?
    
    id: String?
    
    meta: Any?
    
    name: String?
    
}

/// Task class for rax_meta
class RaxMeta extends Playbook.Task {

    /// todo doc
    `community.general.rax_meta`: Dynamic

    /// Options for community.general.rax_meta
    hidden options: RaxMetaOptions?

    /// todo doc
    function configure(): RaxMeta = this
        .toMap()
        .put(
            "community.general.rax_meta",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RaxMeta)

}

/// Create or delete a Rackspace Cloud Monitoring alarm
class RaxMonAlarmOptions {
    
    check_id: String
    
    criteria: String?
    
    disabled: Boolean?
    
    entity_id: String
    
    label: String
    
    metadata: Any?
    
    notification_plan_id: String
    
    state: ("present"|"absent")?
    
}

/// Task class for rax_mon_alarm
class RaxMonAlarm extends Playbook.Task {

    /// todo doc
    `community.general.rax_mon_alarm`: Dynamic

    /// Options for community.general.rax_mon_alarm
    hidden options: RaxMonAlarmOptions?

    /// todo doc
    function configure(): RaxMonAlarm = this
        .toMap()
        .put(
            "community.general.rax_mon_alarm",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RaxMonAlarm)

}

/// Create or delete a Rackspace Cloud Monitoring check for an existing entity.
class RaxMonCheckOptions {
    
    check_type: String
    
    details: Any?
    
    disabled: Boolean?
    
    entity_id: String
    
    label: String
    
    metadata: Any?
    
    monitoring_zones_poll: String?
    
    period: Int?
    
    state: ("present"|"absent")?
    
    target_alias: String?
    
    target_hostname: String?
    
    timeout: Int?
    
}

/// Task class for rax_mon_check
class RaxMonCheck extends Playbook.Task {

    /// todo doc
    `community.general.rax_mon_check`: Dynamic

    /// Options for community.general.rax_mon_check
    hidden options: RaxMonCheckOptions?

    /// todo doc
    function configure(): RaxMonCheck = this
        .toMap()
        .put(
            "community.general.rax_mon_check",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RaxMonCheck)

}

/// Create or delete a Rackspace Cloud Monitoring entity
class RaxMonEntityOptions {
    
    agent_id: String?
    
    label: String
    
    metadata: Any?
    
    named_ip_addresses: Any?
    
    state: ("present"|"absent")?
    
}

/// Task class for rax_mon_entity
class RaxMonEntity extends Playbook.Task {

    /// todo doc
    `community.general.rax_mon_entity`: Dynamic

    /// Options for community.general.rax_mon_entity
    hidden options: RaxMonEntityOptions?

    /// todo doc
    function configure(): RaxMonEntity = this
        .toMap()
        .put(
            "community.general.rax_mon_entity",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RaxMonEntity)

}

/// Create or delete a Rackspace Cloud Monitoring notification
class RaxMonNotificationOptions {
    
    details: Any
    
    label: String
    
    notification_type: ("webhook"|"email"|"pagerduty")
    
    state: ("present"|"absent")?
    
}

/// Task class for rax_mon_notification
class RaxMonNotification extends Playbook.Task {

    /// todo doc
    `community.general.rax_mon_notification`: Dynamic

    /// Options for community.general.rax_mon_notification
    hidden options: RaxMonNotificationOptions?

    /// todo doc
    function configure(): RaxMonNotification = this
        .toMap()
        .put(
            "community.general.rax_mon_notification",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RaxMonNotification)

}

/// Create or delete a Rackspace Cloud Monitoring notification plan.
class RaxMonNotificationPlanOptions {
    
    critical_state: Listing<String>?
    
    label: String
    
    ok_state: Listing<String>?
    
    state: ("present"|"absent")?
    
    warning_state: Listing<String>?
    
}

/// Task class for rax_mon_notification_plan
class RaxMonNotificationPlan extends Playbook.Task {

    /// todo doc
    `community.general.rax_mon_notification_plan`: Dynamic

    /// Options for community.general.rax_mon_notification_plan
    hidden options: RaxMonNotificationPlanOptions?

    /// todo doc
    function configure(): RaxMonNotificationPlan = this
        .toMap()
        .put(
            "community.general.rax_mon_notification_plan",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RaxMonNotificationPlan)

}

/// Create / delete an isolated network in Rackspace Public Cloud
class RaxNetworkOptions {
    
    cidr: String?
    
    label: String
    
    state: ("present"|"absent")?
    
}

/// Task class for rax_network
class RaxNetwork extends Playbook.Task {

    /// todo doc
    `community.general.rax_network`: Dynamic

    /// Options for community.general.rax_network
    hidden options: RaxNetworkOptions?

    /// todo doc
    function configure(): RaxNetwork = this
        .toMap()
        .put(
            "community.general.rax_network",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RaxNetwork)

}

/// Create / delete a queue in Rackspace Public Cloud
class RaxQueueOptions {
    
    name: String?
    
    state: ("present"|"absent")?
    
}

/// Task class for rax_queue
class RaxQueue extends Playbook.Task {

    /// todo doc
    `community.general.rax_queue`: Dynamic

    /// Options for community.general.rax_queue
    hidden options: RaxQueueOptions?

    /// todo doc
    function configure(): RaxQueue = this
        .toMap()
        .put(
            "community.general.rax_queue",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RaxQueue)

}

/// Manipulate Rackspace Cloud Autoscale Groups
class RaxScalingGroupOptions {
    
    config_drive: Boolean?
    
    cooldown: Int?
    
    disk_config: ("auto"|"manual")?
    
    files: Any?
    
    flavor: String
    
    image: String
    
    key_name: String?
    
    loadbalancers: Listing<Any>?
    
    max_entities: Int
    
    meta: Any?
    
    min_entities: Int
    
    name: String
    
    networks: Listing<String>?
    
    server_name: String
    
    state: ("present"|"absent")?
    
    user_data: String?
    
    wait: Boolean?
    
    wait_timeout: Int?
    
}

/// Task class for rax_scaling_group
class RaxScalingGroup extends Playbook.Task {

    /// todo doc
    `community.general.rax_scaling_group`: Dynamic

    /// Options for community.general.rax_scaling_group
    hidden options: RaxScalingGroupOptions?

    /// todo doc
    function configure(): RaxScalingGroup = this
        .toMap()
        .put(
            "community.general.rax_scaling_group",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RaxScalingGroup)

}

/// Manipulate Rackspace Cloud Autoscale Scaling Policy
class RaxScalingPolicyOptions {
    
    at: String?
    
    change: Int?
    
    cooldown: Int?
    
    cron: String?
    
    desired_capacity: Int?
    
    is_percent: Boolean?
    
    name: String
    
    policy_type: ("webhook"|"schedule")
    
    scaling_group: String
    
    state: ("present"|"absent")?
    
}

/// Task class for rax_scaling_policy
class RaxScalingPolicy extends Playbook.Task {

    /// todo doc
    `community.general.rax_scaling_policy`: Dynamic

    /// Options for community.general.rax_scaling_policy
    hidden options: RaxScalingPolicyOptions?

    /// todo doc
    function configure(): RaxScalingPolicy = this
        .toMap()
        .put(
            "community.general.rax_scaling_policy",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RaxScalingPolicy)

}

/// Read a CSV file
class ReadCsvOptions {
    
    delimiter: String?
    
    dialect: String?
    
    fieldnames: Listing<String>?
    
    key: String?
    
    path: String
    
    skipinitialspace: Boolean?
    
    strict: Boolean?
    
    unique: Boolean?
    
}

/// Task class for read_csv
class ReadCsv extends Playbook.Task {

    /// todo doc
    `community.general.read_csv`: Dynamic

    /// Options for community.general.read_csv
    hidden options: ReadCsvOptions?

    /// todo doc
    function configure(): ReadCsv = this
        .toMap()
        .put(
            "community.general.read_csv",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ReadCsv)

}

/// Manages Out-Of-Band controllers using Redfish APIs
class RedfishCommandOptions {
    
    account_properties: Any?
    
    account_types: Listing<String>?
    
    auth_token: String?
    
    baseuri: String
    
    bios_attributes: Any?
    
    boot_next: String?
    
    boot_override_mode: ("Legacy"|"UEFI")?
    
    bootdevice: String?
    
    category: String
    
    command: Listing<String>
    
    id: String?
    
    new_password: String?
    
    new_username: String?
    
    oem_account_types: Listing<String>?
    
    password: String?
    
    resource_id: String?
    
    roleid: String?
    
    session_uri: String?
    
    strip_etag_quotes: Boolean?
    
    timeout: Int?
    
    uefi_target: String?
    
    update_apply_time: ("Immediate"|"OnReset"|"AtMaintenanceWindowStart"|"InMaintenanceWindowOnReset"|"OnStartUpdateRequest")?
    
    update_creds: Any?
    
    update_handle: String?
    
    update_image_file: String?
    
    update_image_uri: String?
    
    update_oem_params: Any?
    
    update_protocol: String?
    
    update_targets: Listing<String>?
    
    update_username: String?
    
    username: String?
    
    virtual_media: Any?
    
}

/// Task class for redfish_command
class RedfishCommand extends Playbook.Task {

    /// todo doc
    `community.general.redfish_command`: Dynamic

    /// Options for community.general.redfish_command
    hidden options: RedfishCommandOptions?

    /// todo doc
    function configure(): RedfishCommand = this
        .toMap()
        .put(
            "community.general.redfish_command",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RedfishCommand)

}

/// Manages Out-Of-Band controllers using Redfish APIs
class RedfishConfigOptions {
    
    auth_token: String?
    
    baseuri: String
    
    bios_attributes: Any?
    
    boot_order: Listing<String>?
    
    category: String
    
    command: Listing<String>
    
    hostinterface_config: Any?
    
    hostinterface_id: String?
    
    network_protocols: Any?
    
    nic_addr: String?
    
    nic_config: Any?
    
    password: String?
    
    resource_id: String?
    
    secure_boot_enable: Boolean?
    
    service_id: String?
    
    sessions_config: Any?
    
    storage_subsystem_id: String?
    
    strip_etag_quotes: Boolean?
    
    timeout: Int?
    
    username: String?
    
    volume_details: Any?
    
    volume_ids: Listing<String>?
    
}

/// Task class for redfish_config
class RedfishConfig extends Playbook.Task {

    /// todo doc
    `community.general.redfish_config`: Dynamic

    /// Options for community.general.redfish_config
    hidden options: RedfishConfigOptions?

    /// todo doc
    function configure(): RedfishConfig = this
        .toMap()
        .put(
            "community.general.redfish_config",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RedfishConfig)

}

/// Manages Out-Of-Band controllers using Redfish APIs
class RedfishInfoOptions {
    
    auth_token: String?
    
    baseuri: String
    
    category: Listing<String>?
    
    command: Listing<String>?
    
    manager: String?
    
    password: String?
    
    timeout: Int?
    
    update_handle: String?
    
    username: String?
    
}

/// Task class for redfish_info
class RedfishInfo extends Playbook.Task {

    /// todo doc
    `community.general.redfish_info`: Dynamic

    /// Options for community.general.redfish_info
    hidden options: RedfishInfoOptions?

    /// todo doc
    function configure(): RedfishInfo = this
        .toMap()
        .put(
            "community.general.redfish_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RedfishInfo)

}

/// Manage registration and subscriptions to RHSM using C(subscription-manager)
class RedhatSubscriptionOptions {
    
    activationkey: String?
    
    auto_attach: Boolean?
    
    consumer_id: String?
    
    consumer_name: String?
    
    consumer_type: String?
    
    environment: String?
    
    force_register: Boolean?
    
    org_id: String?
    
    password: String?
    
    pool: String?
    
    pool_ids: Listing<String>?
    
    release: String?
    
    rhsm_baseurl: String?
    
    rhsm_repo_ca_cert: String?
    
    server_hostname: String?
    
    server_insecure: String?
    
    server_port: String?
    
    server_prefix: String?
    
    server_proxy_hostname: String?
    
    server_proxy_password: String?
    
    server_proxy_port: String?
    
    server_proxy_scheme: String?
    
    server_proxy_user: String?
    
    state: ("present"|"absent")?
    
    syspurpose: Any?
    
    token: String?
    
    username: String?
    
}

/// Task class for redhat_subscription
class RedhatSubscription extends Playbook.Task {

    /// todo doc
    `community.general.redhat_subscription`: Dynamic

    /// Options for community.general.redhat_subscription
    hidden options: RedhatSubscriptionOptions?

    /// todo doc
    function configure(): RedhatSubscription = this
        .toMap()
        .put(
            "community.general.redhat_subscription",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RedhatSubscription)

}

/// Various redis commands, replica and flush
class RedisOptions {
    
    ca_certs: Any?
    
    command: ("config"|"flush"|"replica"|"slave")?
    
    db: Int?
    
    flush_mode: ("all"|"db")?
    
    login_user: Any?
    
    master_host: String?
    
    master_port: Int?
    
    name: String?
    
    replica_mode: ("master"|"replica"|"slave")?
    
    tls: Any?
    
    validate_certs: Any?
    
    value: String?
    
}

/// Task class for redis
class Redis extends Playbook.Task {

    /// todo doc
    `community.general.redis`: Dynamic

    /// Options for community.general.redis
    hidden options: RedisOptions?

    /// todo doc
    function configure(): Redis = this
        .toMap()
        .put(
            "community.general.redis",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Redis)

}

/// Set key value pairs in Redis
class RedisDataOptions {
    
    existing: Boolean?
    
    expiration: Int?
    
    keep_ttl: Boolean?
    
    key: String
    
    non_existing: Boolean?
    
    state: ("present"|"absent")?
    
    value: String?
    
}

/// Task class for redis_data
class RedisData extends Playbook.Task {

    /// todo doc
    `community.general.redis_data`: Dynamic

    /// Options for community.general.redis_data
    hidden options: RedisDataOptions?

    /// todo doc
    function configure(): RedisData = this
        .toMap()
        .put(
            "community.general.redis_data",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RedisData)

}

/// Increment keys in Redis
class RedisDataIncrOptions {
    
    increment_float: Any?
    
    increment_int: Int?
    
    key: String
    
}

/// Task class for redis_data_incr
class RedisDataIncr extends Playbook.Task {

    /// todo doc
    `community.general.redis_data_incr`: Dynamic

    /// Options for community.general.redis_data_incr
    hidden options: RedisDataIncrOptions?

    /// todo doc
    function configure(): RedisDataIncr = this
        .toMap()
        .put(
            "community.general.redis_data_incr",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RedisDataIncr)

}

/// Get value of key in Redis database
class RedisDataInfoOptions {
    
    key: String
    
}

/// Task class for redis_data_info
class RedisDataInfo extends Playbook.Task {

    /// todo doc
    `community.general.redis_data_info`: Dynamic

    /// Options for community.general.redis_data_info
    hidden options: RedisDataInfoOptions?

    /// todo doc
    function configure(): RedisDataInfo = this
        .toMap()
        .put(
            "community.general.redis_data_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RedisDataInfo)

}

/// Gather information about Redis servers
class RedisInfoOptions {
    
    ca_certs: Any?
    
    login_user: Any?
    
    tls: Any?
    
    validate_certs: Any?
    
}

/// Task class for redis_info
class RedisInfo extends Playbook.Task {

    /// todo doc
    `community.general.redis_info`: Dynamic

    /// Options for community.general.redis_info
    hidden options: RedisInfoOptions?

    /// todo doc
    function configure(): RedisInfo = this
        .toMap()
        .put(
            "community.general.redis_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RedisInfo)

}

/// RHEV/oVirt automation
class RhevmOptions {
    
    boot_order: Listing<String>?
    
    cd_drive: String?
    
    cluster: String?
    
    cpu_share: Int?
    
    datacenter: String?
    
    del_prot: Boolean?
    
    disks: Listing<String>?
    
    ifaces: Listing<String>?
    
    image: String?
    
    insecure_api: Boolean?
    
    mempol: Int?
    
    name: String?
    
    osver: String?
    
    password: String
    
    port: Int?
    
    server: String?
    
    state: ("absent"|"cd"|"down"|"info"|"ping"|"present"|"restarted"|"up")?
    
    timeout: Int?
    
    type: ("desktop"|"host"|"server")?
    
    user: String?
    
    vm_ha: Boolean?
    
    vmcpu: Int?
    
    vmhost: String?
    
    vmmem: Int?
    
}

/// Task class for rhevm
class Rhevm extends Playbook.Task {

    /// todo doc
    `community.general.rhevm`: Dynamic

    /// Options for community.general.rhevm
    hidden options: RhevmOptions?

    /// todo doc
    function configure(): Rhevm = this
        .toMap()
        .put(
            "community.general.rhevm",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Rhevm)

}

/// Adds or removes Red Hat software channels
class RhnChannelOptions {
    
    name: String
    
    password: String
    
    state: ("present"|"absent")?
    
    sysname: String
    
    url: String
    
    user: String
    
    validate_certs: Boolean?
    
}

/// Task class for rhn_channel
class RhnChannel extends Playbook.Task {

    /// todo doc
    `community.general.rhn_channel`: Dynamic

    /// Options for community.general.rhn_channel
    hidden options: RhnChannelOptions?

    /// todo doc
    function configure(): RhnChannel = this
        .toMap()
        .put(
            "community.general.rhn_channel",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RhnChannel)

}

/// Manage Red Hat Network registration using the C(rhnreg_ks) command
class RhnRegisterOptions {
    
    activationkey: String?
    
    ca_cert: String?
    
    channels: Listing<String>?
    
    enable_eus: Boolean?
    
    force: Boolean?
    
    nopackages: Boolean?
    
    password: String?
    
    profilename: String?
    
    server_url: String?
    
    state: ("absent"|"present")?
    
    systemorgid: String?
    
    username: String?
    
}

/// Task class for rhn_register
class RhnRegister extends Playbook.Task {

    /// todo doc
    `community.general.rhn_register`: Dynamic

    /// Options for community.general.rhn_register
    hidden options: RhnRegisterOptions?

    /// todo doc
    function configure(): RhnRegister = this
        .toMap()
        .put(
            "community.general.rhn_register",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RhnRegister)

}

/// Set or Unset RHSM Release version
class RhsmReleaseOptions {
    
    release: String?
    
}

/// Task class for rhsm_release
class RhsmRelease extends Playbook.Task {

    /// todo doc
    `community.general.rhsm_release`: Dynamic

    /// Options for community.general.rhsm_release
    hidden options: RhsmReleaseOptions?

    /// todo doc
    function configure(): RhsmRelease = this
        .toMap()
        .put(
            "community.general.rhsm_release",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RhsmRelease)

}

/// Manage RHSM repositories using the subscription-manager command
class RhsmRepositoryOptions {
    
    name: Listing<String>
    
    purge: Boolean?
    
    state: ("present"|"enabled"|"absent"|"disabled")?
    
}

/// Task class for rhsm_repository
class RhsmRepository extends Playbook.Task {

    /// todo doc
    `community.general.rhsm_repository`: Dynamic

    /// Options for community.general.rhsm_repository
    hidden options: RhsmRepositoryOptions?

    /// todo doc
    function configure(): RhsmRepository = this
        .toMap()
        .put(
            "community.general.rhsm_repository",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RhsmRepository)

}

/// This module handles some common Riak operations
class RiakOptions {
    
    command: ("ping"|"kv_test"|"join"|"plan"|"commit")?
    
    config_dir: String?
    
    http_conn: String?
    
    target_node: String?
    
    validate_certs: Boolean?
    
    wait_for_handoffs: Int?
    
    wait_for_ring: Int?
    
    wait_for_service: ("kv")?
    
}

/// Task class for riak
class Riak extends Playbook.Task {

    /// todo doc
    `community.general.riak`: Dynamic

    /// Options for community.general.riak
    hidden options: RiakOptions?

    /// todo doc
    function configure(): Riak = this
        .toMap()
        .put(
            "community.general.riak",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Riak)

}

/// Send notifications to Rocket Chat
class RocketchatOptions {
    
    attachments: Listing<Any>?
    
    channel: String?
    
    color: ("normal"|"good"|"warning"|"danger")?
    
    domain: String
    
    icon_emoji: String?
    
    icon_url: String?
    
    link_names: Int?
    
    msg: String?
    
    protocol: ("http"|"https")?
    
    token: String
    
    username: String?
    
    validate_certs: Boolean?
    
}

/// Task class for rocketchat
class Rocketchat extends Playbook.Task {

    /// todo doc
    `community.general.rocketchat`: Dynamic

    /// Options for community.general.rocketchat
    hidden options: RocketchatOptions?

    /// todo doc
    function configure(): Rocketchat = this
        .toMap()
        .put(
            "community.general.rocketchat",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Rocketchat)

}

/// Notify Rollbar about app deployments
class RollbarDeploymentOptions {
    
    comment: String?
    
    environment: String
    
    revision: String
    
    rollbar_user: String?
    
    token: String
    
    url: String?
    
    user: String?
    
    validate_certs: Boolean?
    
}

/// Task class for rollbar_deployment
class RollbarDeployment extends Playbook.Task {

    /// todo doc
    `community.general.rollbar_deployment`: Dynamic

    /// Options for community.general.rollbar_deployment
    hidden options: RollbarDeploymentOptions?

    /// todo doc
    function configure(): RollbarDeployment = this
        .toMap()
        .put(
            "community.general.rollbar_deployment",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RollbarDeployment)

}

/// Install or uninstall overlay additional packages
class RpmOstreePkgOptions {
    
    name: Listing<String>
    
    state: ("absent"|"present")?
    
}

/// Task class for rpm_ostree_pkg
class RpmOstreePkg extends Playbook.Task {

    /// todo doc
    `community.general.rpm_ostree_pkg`: Dynamic

    /// Options for community.general.rpm_ostree_pkg
    hidden options: RpmOstreePkgOptions?

    /// todo doc
    function configure(): RpmOstreePkg = this
        .toMap()
        .put(
            "community.general.rpm_ostree_pkg",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RpmOstreePkg)

}

/// Manage Rundeck ACL policies
class RundeckAclPolicyOptions {
    
    api_token: Any?
    
    client_cert: Any?
    
    client_key: Any?
    
    force: Any?
    
    force_basic_auth: Any?
    
    http_agent: Any?
    
    name: String
    
    policy: String?
    
    project: String?
    
    state: ("present"|"absent")?
    
    url_password: Any?
    
    url_username: Any?
    
    use_proxy: Any?
    
    validate_certs: Any?
    
}

/// Task class for rundeck_acl_policy
class RundeckAclPolicy extends Playbook.Task {

    /// todo doc
    `community.general.rundeck_acl_policy`: Dynamic

    /// Options for community.general.rundeck_acl_policy
    hidden options: RundeckAclPolicyOptions?

    /// todo doc
    function configure(): RundeckAclPolicy = this
        .toMap()
        .put(
            "community.general.rundeck_acl_policy",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RundeckAclPolicy)

}

/// Query executions for a Rundeck job
class RundeckJobExecutionsInfoOptions {
    
    job_id: String
    
    max: Int?
    
    offset: Int?
    
    status: ("succeeded"|"failed"|"aborted"|"running")?
    
}

/// Task class for rundeck_job_executions_info
class RundeckJobExecutionsInfo extends Playbook.Task {

    /// todo doc
    `community.general.rundeck_job_executions_info`: Dynamic

    /// Options for community.general.rundeck_job_executions_info
    hidden options: RundeckJobExecutionsInfoOptions?

    /// todo doc
    function configure(): RundeckJobExecutionsInfo = this
        .toMap()
        .put(
            "community.general.rundeck_job_executions_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RundeckJobExecutionsInfo)

}

/// Run a Rundeck job
class RundeckJobRunOptions {
    
    abort_on_timeout: Boolean?
    
    filter_nodes: String?
    
    job_id: String
    
    job_options: Any?
    
    loglevel: ("debug"|"verbose"|"info"|"warn"|"error")?
    
    run_at_time: String?
    
    wait_execution: Boolean?
    
    wait_execution_delay: Int?
    
    wait_execution_timeout: Int?
    
}

/// Task class for rundeck_job_run
class RundeckJobRun extends Playbook.Task {

    /// todo doc
    `community.general.rundeck_job_run`: Dynamic

    /// Options for community.general.rundeck_job_run
    hidden options: RundeckJobRunOptions?

    /// todo doc
    function configure(): RundeckJobRun = this
        .toMap()
        .put(
            "community.general.rundeck_job_run",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RundeckJobRun)

}

/// Manage Rundeck projects
class RundeckProjectOptions {
    
    api_token: Any?
    
    client_cert: Any?
    
    client_key: Any?
    
    force: Any?
    
    force_basic_auth: Any?
    
    http_agent: Any?
    
    name: String
    
    state: ("present"|"absent")?
    
    url_password: Any?
    
    url_username: Any?
    
    use_proxy: Any?
    
    validate_certs: Any?
    
}

/// Task class for rundeck_project
class RundeckProject extends Playbook.Task {

    /// todo doc
    `community.general.rundeck_project`: Dynamic

    /// Options for community.general.rundeck_project
    hidden options: RundeckProjectOptions?

    /// todo doc
    function configure(): RundeckProject = this
        .toMap()
        .put(
            "community.general.rundeck_project",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RundeckProject)

}

/// Manage runit services
class RunitOptions {
    
    enabled: Boolean?
    
    name: String
    
    service_dir: String?
    
    service_src: String?
    
    state: ("killed"|"once"|"reloaded"|"restarted"|"started"|"stopped")?
    
}

/// Task class for runit
class Runit extends Playbook.Task {

    /// todo doc
    `community.general.runit`: Dynamic

    /// Options for community.general.runit
    hidden options: RunitOptions?

    /// todo doc
    function configure(): Runit = this
        .toMap()
        .put(
            "community.general.runit",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Runit)

}

/// Makes a computer to speak
class SayOptions {
    
    msg: String
    
    voice: String?
    
}

/// Task class for say
class Say extends Playbook.Task {

    /// todo doc
    `community.general.say`: Dynamic

    /// Options for community.general.say
    hidden options: SayOptions?

    /// todo doc
    function configure(): Say = this
        .toMap()
        .put(
            "community.general.say",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Say)

}

/// Scaleway compute management module
class ScalewayComputeOptions {
    
    commercial_type: String
    
    enable_ipv6: Boolean?
    
    image: String
    
    name: String?
    
    organization: String?
    
    project: String?
    
    public_ip: String?
    
    region: ("ams1"|"EMEA-NL-EVS"|"par1"|"EMEA-FR-PAR1"|"par2"|"EMEA-FR-PAR2"|"waw1"|"EMEA-PL-WAW1")
    
    security_group: String?
    
    state: ("present"|"absent"|"running"|"restarted"|"stopped")?
    
    tags: Listing<String>?
    
    wait: Boolean?
    
    wait_sleep_time: Int?
    
    wait_timeout: Int?
    
}

/// Task class for scaleway_compute
class ScalewayCompute extends Playbook.Task {

    /// todo doc
    `community.general.scaleway_compute`: Dynamic

    /// Options for community.general.scaleway_compute
    hidden options: ScalewayComputeOptions?

    /// todo doc
    function configure(): ScalewayCompute = this
        .toMap()
        .put(
            "community.general.scaleway_compute",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ScalewayCompute)

}

/// Scaleway compute - private network management
class ScalewayComputePrivateNetworkOptions {
    
    compute_id: String
    
    private_network_id: String
    
    project: String
    
    region: ("ams1"|"EMEA-NL-EVS"|"par1"|"EMEA-FR-PAR1"|"par2"|"EMEA-FR-PAR2"|"waw1"|"EMEA-PL-WAW1")
    
    state: ("present"|"absent")?
    
}

/// Task class for scaleway_compute_private_network
class ScalewayComputePrivateNetwork extends Playbook.Task {

    /// todo doc
    `community.general.scaleway_compute_private_network`: Dynamic

    /// Options for community.general.scaleway_compute_private_network
    hidden options: ScalewayComputePrivateNetworkOptions?

    /// todo doc
    function configure(): ScalewayComputePrivateNetwork = this
        .toMap()
        .put(
            "community.general.scaleway_compute_private_network",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ScalewayComputePrivateNetwork)

}

/// Scaleway Container management
class ScalewayContainerOptions {
    
    container_timeout: String?
    
    description: String?
    
    environment_variables: Any?
    
    max_concurrency: Int?
    
    max_scale: Int?
    
    memory_limit: Int?
    
    min_scale: Int?
    
    name: String
    
    namespace_id: String
    
    port: Int?
    
    privacy: ("public"|"private")?
    
    protocol: ("http1"|"h2c")?
    
    redeploy: Boolean?
    
    region: ("fr-par"|"nl-ams"|"pl-waw")
    
    registry_image: String
    
    secret_environment_variables: Any?
    
    state: ("present"|"absent")?
    
}

/// Task class for scaleway_container
class ScalewayContainer extends Playbook.Task {

    /// todo doc
    `community.general.scaleway_container`: Dynamic

    /// Options for community.general.scaleway_container
    hidden options: ScalewayContainerOptions?

    /// todo doc
    function configure(): ScalewayContainer = this
        .toMap()
        .put(
            "community.general.scaleway_container",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ScalewayContainer)

}

/// Retrieve information on Scaleway Container
class ScalewayContainerInfoOptions {
    
    name: String
    
    namespace_id: String
    
    region: ("fr-par"|"nl-ams"|"pl-waw")
    
}

/// Task class for scaleway_container_info
class ScalewayContainerInfo extends Playbook.Task {

    /// todo doc
    `community.general.scaleway_container_info`: Dynamic

    /// Options for community.general.scaleway_container_info
    hidden options: ScalewayContainerInfoOptions?

    /// todo doc
    function configure(): ScalewayContainerInfo = this
        .toMap()
        .put(
            "community.general.scaleway_container_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ScalewayContainerInfo)

}

/// Scaleway Container namespace management
class ScalewayContainerNamespaceOptions {
    
    description: String?
    
    environment_variables: Any?
    
    name: String
    
    project_id: String
    
    region: ("fr-par"|"nl-ams"|"pl-waw")
    
    secret_environment_variables: Any?
    
    state: ("present"|"absent")?
    
}

/// Task class for scaleway_container_namespace
class ScalewayContainerNamespace extends Playbook.Task {

    /// todo doc
    `community.general.scaleway_container_namespace`: Dynamic

    /// Options for community.general.scaleway_container_namespace
    hidden options: ScalewayContainerNamespaceOptions?

    /// todo doc
    function configure(): ScalewayContainerNamespace = this
        .toMap()
        .put(
            "community.general.scaleway_container_namespace",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ScalewayContainerNamespace)

}

/// Retrieve information on Scaleway Container namespace
class ScalewayContainerNamespaceInfoOptions {
    
    name: String
    
    project_id: String
    
    region: ("fr-par"|"nl-ams"|"pl-waw")
    
}

/// Task class for scaleway_container_namespace_info
class ScalewayContainerNamespaceInfo extends Playbook.Task {

    /// todo doc
    `community.general.scaleway_container_namespace_info`: Dynamic

    /// Options for community.general.scaleway_container_namespace_info
    hidden options: ScalewayContainerNamespaceInfoOptions?

    /// todo doc
    function configure(): ScalewayContainerNamespaceInfo = this
        .toMap()
        .put(
            "community.general.scaleway_container_namespace_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ScalewayContainerNamespaceInfo)

}

/// Scaleway Container registry management module
class ScalewayContainerRegistryOptions {
    
    description: String?
    
    name: String
    
    privacy_policy: ("public"|"private")?
    
    project_id: String
    
    region: ("fr-par"|"nl-ams"|"pl-waw")
    
    state: ("present"|"absent")?
    
}

/// Task class for scaleway_container_registry
class ScalewayContainerRegistry extends Playbook.Task {

    /// todo doc
    `community.general.scaleway_container_registry`: Dynamic

    /// Options for community.general.scaleway_container_registry
    hidden options: ScalewayContainerRegistryOptions?

    /// todo doc
    function configure(): ScalewayContainerRegistry = this
        .toMap()
        .put(
            "community.general.scaleway_container_registry",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ScalewayContainerRegistry)

}

/// Scaleway Container registry info module
class ScalewayContainerRegistryInfoOptions {
    
    name: String
    
    project_id: String
    
    region: ("fr-par"|"nl-ams"|"pl-waw")
    
}

/// Task class for scaleway_container_registry_info
class ScalewayContainerRegistryInfo extends Playbook.Task {

    /// todo doc
    `community.general.scaleway_container_registry_info`: Dynamic

    /// Options for community.general.scaleway_container_registry_info
    hidden options: ScalewayContainerRegistryInfoOptions?

    /// todo doc
    function configure(): ScalewayContainerRegistryInfo = this
        .toMap()
        .put(
            "community.general.scaleway_container_registry_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ScalewayContainerRegistryInfo)

}

/// Scaleway database backups management module
class ScalewayDatabaseBackupOptions {
    
    database_name: String?
    
    expires_at: String?
    
    id: String?
    
    instance_id: String?
    
    name: String?
    
    region: ("fr-par"|"nl-ams"|"pl-waw")
    
    state: ("present"|"absent"|"exported"|"restored")?
    
    wait: Boolean?
    
    wait_sleep_time: Int?
    
    wait_timeout: Int?
    
}

/// Task class for scaleway_database_backup
class ScalewayDatabaseBackup extends Playbook.Task {

    /// todo doc
    `community.general.scaleway_database_backup`: Dynamic

    /// Options for community.general.scaleway_database_backup
    hidden options: ScalewayDatabaseBackupOptions?

    /// todo doc
    function configure(): ScalewayDatabaseBackup = this
        .toMap()
        .put(
            "community.general.scaleway_database_backup",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ScalewayDatabaseBackup)

}

/// Scaleway Function management
class ScalewayFunctionOptions {
    
    description: String?
    
    environment_variables: Any?
    
    function_timeout: String?
    
    handler: String?
    
    max_scale: Int?
    
    memory_limit: Int?
    
    min_scale: Int?
    
    name: String
    
    namespace_id: String
    
    privacy: ("public"|"private")?
    
    redeploy: Boolean?
    
    region: ("fr-par"|"nl-ams"|"pl-waw")
    
    runtime: String
    
    secret_environment_variables: Any?
    
    state: ("present"|"absent")?
    
}

/// Task class for scaleway_function
class ScalewayFunction extends Playbook.Task {

    /// todo doc
    `community.general.scaleway_function`: Dynamic

    /// Options for community.general.scaleway_function
    hidden options: ScalewayFunctionOptions?

    /// todo doc
    function configure(): ScalewayFunction = this
        .toMap()
        .put(
            "community.general.scaleway_function",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ScalewayFunction)

}

/// Retrieve information on Scaleway Function
class ScalewayFunctionInfoOptions {
    
    name: String
    
    namespace_id: String
    
    region: ("fr-par"|"nl-ams"|"pl-waw")
    
}

/// Task class for scaleway_function_info
class ScalewayFunctionInfo extends Playbook.Task {

    /// todo doc
    `community.general.scaleway_function_info`: Dynamic

    /// Options for community.general.scaleway_function_info
    hidden options: ScalewayFunctionInfoOptions?

    /// todo doc
    function configure(): ScalewayFunctionInfo = this
        .toMap()
        .put(
            "community.general.scaleway_function_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ScalewayFunctionInfo)

}

/// Scaleway Function namespace management
class ScalewayFunctionNamespaceOptions {
    
    description: String?
    
    environment_variables: Any?
    
    name: String
    
    project_id: String
    
    region: ("fr-par"|"nl-ams"|"pl-waw")
    
    secret_environment_variables: Any?
    
    state: ("present"|"absent")?
    
}

/// Task class for scaleway_function_namespace
class ScalewayFunctionNamespace extends Playbook.Task {

    /// todo doc
    `community.general.scaleway_function_namespace`: Dynamic

    /// Options for community.general.scaleway_function_namespace
    hidden options: ScalewayFunctionNamespaceOptions?

    /// todo doc
    function configure(): ScalewayFunctionNamespace = this
        .toMap()
        .put(
            "community.general.scaleway_function_namespace",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ScalewayFunctionNamespace)

}

/// Retrieve information on Scaleway Function namespace
class ScalewayFunctionNamespaceInfoOptions {
    
    name: String
    
    project_id: String
    
    region: ("fr-par"|"nl-ams"|"pl-waw")
    
}

/// Task class for scaleway_function_namespace_info
class ScalewayFunctionNamespaceInfo extends Playbook.Task {

    /// todo doc
    `community.general.scaleway_function_namespace_info`: Dynamic

    /// Options for community.general.scaleway_function_namespace_info
    hidden options: ScalewayFunctionNamespaceInfoOptions?

    /// todo doc
    function configure(): ScalewayFunctionNamespaceInfo = this
        .toMap()
        .put(
            "community.general.scaleway_function_namespace_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ScalewayFunctionNamespaceInfo)

}

/// Gather information about the Scaleway images available
class ScalewayImageInfoOptions {
    
    region: ("ams1"|"EMEA-NL-EVS"|"par1"|"EMEA-FR-PAR1"|"par2"|"EMEA-FR-PAR2"|"waw1"|"EMEA-PL-WAW1")
    
}

/// Task class for scaleway_image_info
class ScalewayImageInfo extends Playbook.Task {

    /// todo doc
    `community.general.scaleway_image_info`: Dynamic

    /// Options for community.general.scaleway_image_info
    hidden options: ScalewayImageInfoOptions?

    /// todo doc
    function configure(): ScalewayImageInfo = this
        .toMap()
        .put(
            "community.general.scaleway_image_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ScalewayImageInfo)

}

/// Scaleway IP management module
class ScalewayIpOptions {
    
    id: String?
    
    organization: String
    
    region: ("ams1"|"EMEA-NL-EVS"|"par1"|"EMEA-FR-PAR1"|"par2"|"EMEA-FR-PAR2"|"waw1"|"EMEA-PL-WAW1")
    
    reverse: String?
    
    server: String?
    
    state: ("present"|"absent")?
    
}

/// Task class for scaleway_ip
class ScalewayIp extends Playbook.Task {

    /// todo doc
    `community.general.scaleway_ip`: Dynamic

    /// Options for community.general.scaleway_ip
    hidden options: ScalewayIpOptions?

    /// todo doc
    function configure(): ScalewayIp = this
        .toMap()
        .put(
            "community.general.scaleway_ip",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ScalewayIp)

}

/// Gather information about the Scaleway ips available
class ScalewayIpInfoOptions {
    
    region: ("ams1"|"EMEA-NL-EVS"|"par1"|"EMEA-FR-PAR1"|"par2"|"EMEA-FR-PAR2"|"waw1"|"EMEA-PL-WAW1")
    
}

/// Task class for scaleway_ip_info
class ScalewayIpInfo extends Playbook.Task {

    /// todo doc
    `community.general.scaleway_ip_info`: Dynamic

    /// Options for community.general.scaleway_ip_info
    hidden options: ScalewayIpInfoOptions?

    /// todo doc
    function configure(): ScalewayIpInfo = this
        .toMap()
        .put(
            "community.general.scaleway_ip_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ScalewayIpInfo)

}

/// Scaleway load-balancer management module
class ScalewayLbOptions {
    
    description: String
    
    name: String
    
    organization_id: String
    
    region: ("nl-ams"|"fr-par"|"pl-waw")
    
    state: ("present"|"absent")?
    
    tags: Listing<String>?
    
    wait: Boolean?
    
    wait_sleep_time: Int?
    
    wait_timeout: Int?
    
}

/// Task class for scaleway_lb
class ScalewayLb extends Playbook.Task {

    /// todo doc
    `community.general.scaleway_lb`: Dynamic

    /// Options for community.general.scaleway_lb
    hidden options: ScalewayLbOptions?

    /// todo doc
    function configure(): ScalewayLb = this
        .toMap()
        .put(
            "community.general.scaleway_lb",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ScalewayLb)

}

/// Gather information about the Scaleway organizations available
class ScalewayOrganizationInfoOptions {
    
    api_url: Any?
    
}

/// Task class for scaleway_organization_info
class ScalewayOrganizationInfo extends Playbook.Task {

    /// todo doc
    `community.general.scaleway_organization_info`: Dynamic

    /// Options for community.general.scaleway_organization_info
    hidden options: ScalewayOrganizationInfoOptions?

    /// todo doc
    function configure(): ScalewayOrganizationInfo = this
        .toMap()
        .put(
            "community.general.scaleway_organization_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ScalewayOrganizationInfo)

}

/// Scaleway private network management
class ScalewayPrivateNetworkOptions {
    
    name: String?
    
    project: String
    
    region: ("ams1"|"EMEA-NL-EVS"|"par1"|"EMEA-FR-PAR1"|"par2"|"EMEA-FR-PAR2"|"waw1"|"EMEA-PL-WAW1")
    
    state: ("present"|"absent")?
    
    tags: Listing<String>?
    
}

/// Task class for scaleway_private_network
class ScalewayPrivateNetwork extends Playbook.Task {

    /// todo doc
    `community.general.scaleway_private_network`: Dynamic

    /// Options for community.general.scaleway_private_network
    hidden options: ScalewayPrivateNetworkOptions?

    /// todo doc
    function configure(): ScalewayPrivateNetwork = this
        .toMap()
        .put(
            "community.general.scaleway_private_network",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ScalewayPrivateNetwork)

}

/// Scaleway Security Group management module
class ScalewaySecurityGroupOptions {
    
    description: String?
    
    inbound_default_policy: ("accept"|"drop")?
    
    name: String
    
    organization: String
    
    organization_default: Boolean?
    
    outbound_default_policy: ("accept"|"drop")?
    
    region: ("ams1"|"EMEA-NL-EVS"|"par1"|"EMEA-FR-PAR1"|"par2"|"EMEA-FR-PAR2"|"waw1"|"EMEA-PL-WAW1")
    
    state: ("absent"|"present")?
    
    stateful: Boolean
    
}

/// Task class for scaleway_security_group
class ScalewaySecurityGroup extends Playbook.Task {

    /// todo doc
    `community.general.scaleway_security_group`: Dynamic

    /// Options for community.general.scaleway_security_group
    hidden options: ScalewaySecurityGroupOptions?

    /// todo doc
    function configure(): ScalewaySecurityGroup = this
        .toMap()
        .put(
            "community.general.scaleway_security_group",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ScalewaySecurityGroup)

}

/// Gather information about the Scaleway security groups available
class ScalewaySecurityGroupInfoOptions {
    
    region: ("ams1"|"EMEA-NL-EVS"|"par1"|"EMEA-FR-PAR1"|"par2"|"EMEA-FR-PAR2"|"waw1"|"EMEA-PL-WAW1")
    
}

/// Task class for scaleway_security_group_info
class ScalewaySecurityGroupInfo extends Playbook.Task {

    /// todo doc
    `community.general.scaleway_security_group_info`: Dynamic

    /// Options for community.general.scaleway_security_group_info
    hidden options: ScalewaySecurityGroupInfoOptions?

    /// todo doc
    function configure(): ScalewaySecurityGroupInfo = this
        .toMap()
        .put(
            "community.general.scaleway_security_group_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ScalewaySecurityGroupInfo)

}

/// Scaleway Security Group Rule management module
class ScalewaySecurityGroupRuleOptions {
    
    action: ("accept"|"drop")
    
    direction: ("inbound"|"outbound")
    
    ip_range: String?
    
    port: Int
    
    protocol: ("TCP"|"UDP"|"ICMP")
    
    region: ("ams1"|"EMEA-NL-EVS"|"par1"|"EMEA-FR-PAR1"|"par2"|"EMEA-FR-PAR2"|"waw1"|"EMEA-PL-WAW1")
    
    security_group: String
    
    state: ("present"|"absent")?
    
}

/// Task class for scaleway_security_group_rule
class ScalewaySecurityGroupRule extends Playbook.Task {

    /// todo doc
    `community.general.scaleway_security_group_rule`: Dynamic

    /// Options for community.general.scaleway_security_group_rule
    hidden options: ScalewaySecurityGroupRuleOptions?

    /// todo doc
    function configure(): ScalewaySecurityGroupRule = this
        .toMap()
        .put(
            "community.general.scaleway_security_group_rule",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ScalewaySecurityGroupRule)

}

/// Gather information about the Scaleway servers available
class ScalewayServerInfoOptions {
    
    region: ("ams1"|"EMEA-NL-EVS"|"par1"|"EMEA-FR-PAR1"|"par2"|"EMEA-FR-PAR2"|"waw1"|"EMEA-PL-WAW1")
    
}

/// Task class for scaleway_server_info
class ScalewayServerInfo extends Playbook.Task {

    /// todo doc
    `community.general.scaleway_server_info`: Dynamic

    /// Options for community.general.scaleway_server_info
    hidden options: ScalewayServerInfoOptions?

    /// todo doc
    function configure(): ScalewayServerInfo = this
        .toMap()
        .put(
            "community.general.scaleway_server_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ScalewayServerInfo)

}

/// Gather information about the Scaleway snapshots available
class ScalewaySnapshotInfoOptions {
    
    region: ("ams1"|"EMEA-NL-EVS"|"par1"|"EMEA-FR-PAR1"|"par2"|"EMEA-FR-PAR2"|"waw1"|"EMEA-PL-WAW1")
    
}

/// Task class for scaleway_snapshot_info
class ScalewaySnapshotInfo extends Playbook.Task {

    /// todo doc
    `community.general.scaleway_snapshot_info`: Dynamic

    /// Options for community.general.scaleway_snapshot_info
    hidden options: ScalewaySnapshotInfoOptions?

    /// todo doc
    function configure(): ScalewaySnapshotInfo = this
        .toMap()
        .put(
            "community.general.scaleway_snapshot_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ScalewaySnapshotInfo)

}

/// Scaleway SSH keys management module
class ScalewaySshkeyOptions {
    
    api_url: String?
    
    ssh_pub_key: String
    
    state: ("present"|"absent")?
    
}

/// Task class for scaleway_sshkey
class ScalewaySshkey extends Playbook.Task {

    /// todo doc
    `community.general.scaleway_sshkey`: Dynamic

    /// Options for community.general.scaleway_sshkey
    hidden options: ScalewaySshkeyOptions?

    /// todo doc
    function configure(): ScalewaySshkey = this
        .toMap()
        .put(
            "community.general.scaleway_sshkey",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ScalewaySshkey)

}

/// Scaleway user_data management module
class ScalewayUserDataOptions {
    
    region: ("ams1"|"EMEA-NL-EVS"|"par1"|"EMEA-FR-PAR1"|"par2"|"EMEA-FR-PAR2"|"waw1"|"EMEA-PL-WAW1")
    
    server_id: String
    
    user_data: Any?
    
}

/// Task class for scaleway_user_data
class ScalewayUserData extends Playbook.Task {

    /// todo doc
    `community.general.scaleway_user_data`: Dynamic

    /// Options for community.general.scaleway_user_data
    hidden options: ScalewayUserDataOptions?

    /// todo doc
    function configure(): ScalewayUserData = this
        .toMap()
        .put(
            "community.general.scaleway_user_data",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ScalewayUserData)

}

/// Scaleway volumes management module
class ScalewayVolumeOptions {
    
    name: String
    
    organization: String?
    
    project: String?
    
    region: ("ams1"|"EMEA-NL-EVS"|"par1"|"EMEA-FR-PAR1"|"par2"|"EMEA-FR-PAR2"|"waw1"|"EMEA-PL-WAW1")
    
    size: Int?
    
    state: ("present"|"absent")?
    
    volume_type: String?
    
}

/// Task class for scaleway_volume
class ScalewayVolume extends Playbook.Task {

    /// todo doc
    `community.general.scaleway_volume`: Dynamic

    /// Options for community.general.scaleway_volume
    hidden options: ScalewayVolumeOptions?

    /// todo doc
    function configure(): ScalewayVolume = this
        .toMap()
        .put(
            "community.general.scaleway_volume",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ScalewayVolume)

}

/// Gather information about the Scaleway volumes available
class ScalewayVolumeInfoOptions {
    
    region: ("ams1"|"EMEA-NL-EVS"|"par1"|"EMEA-FR-PAR1"|"par2"|"EMEA-FR-PAR2"|"waw1"|"EMEA-PL-WAW1")
    
}

/// Task class for scaleway_volume_info
class ScalewayVolumeInfo extends Playbook.Task {

    /// todo doc
    `community.general.scaleway_volume_info`: Dynamic

    /// Options for community.general.scaleway_volume_info
    hidden options: ScalewayVolumeInfoOptions?

    /// todo doc
    function configure(): ScalewayVolumeInfo = this
        .toMap()
        .put(
            "community.general.scaleway_volume_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ScalewayVolumeInfo)

}

/// Manages SELinux file context mapping definitions
class SefcontextOptions {
    
    ftype: ("a"|"b"|"c"|"d"|"f"|"l"|"p"|"s")?
    
    ignore_selinux_state: Boolean?
    
    reload: Boolean?
    
    selevel: String?
    
    setype: String?
    
    seuser: String?
    
    state: ("absent"|"present")?
    
    substitute: String?
    
    target: String
    
}

/// Task class for sefcontext
class Sefcontext extends Playbook.Task {

    /// todo doc
    `community.general.sefcontext`: Dynamic

    /// Options for community.general.sefcontext
    hidden options: SefcontextOptions?

    /// todo doc
    function configure(): Sefcontext = this
        .toMap()
        .put(
            "community.general.sefcontext",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Sefcontext)

}

/// Change permissive domain in SELinux policy
class SelinuxPermissiveOptions {
    
    domain: String
    
    no_reload: Boolean?
    
    permissive: Boolean
    
    store: String?
    
}

/// Task class for selinux_permissive
class SelinuxPermissive extends Playbook.Task {

    /// todo doc
    `community.general.selinux_permissive`: Dynamic

    /// Options for community.general.selinux_permissive
    hidden options: SelinuxPermissiveOptions?

    /// todo doc
    function configure(): SelinuxPermissive = this
        .toMap()
        .put(
            "community.general.selinux_permissive",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(SelinuxPermissive)

}

/// Manages linux user to SELinux user mapping
class SeloginOptions {
    
    ignore_selinux_state: Boolean?
    
    login: String
    
    reload: Boolean?
    
    selevel: String?
    
    seuser: String?
    
    state: ("present"|"absent")?
    
}

/// Task class for selogin
class Selogin extends Playbook.Task {

    /// todo doc
    `community.general.selogin`: Dynamic

    /// Options for community.general.selogin
    hidden options: SeloginOptions?

    /// todo doc
    function configure(): Selogin = this
        .toMap()
        .put(
            "community.general.selogin",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Selogin)

}

/// Sends an email with the SendGrid API
class SendgridOptions {
    
    api_key: String?
    
    attachments: Listing<String>?
    
    bcc: Listing<String>?
    
    body: String
    
    cc: Listing<String>?
    
    from_address: String
    
    from_name: String?
    
    headers: Any?
    
    html_body: Boolean?
    
    password: String?
    
    subject: String
    
    to_addresses: Listing<String>
    
    username: String?
    
}

/// Task class for sendgrid
class Sendgrid extends Playbook.Task {

    /// todo doc
    `community.general.sendgrid`: Dynamic

    /// Options for community.general.sendgrid
    hidden options: SendgridOptions?

    /// todo doc
    function configure(): Sendgrid = this
        .toMap()
        .put(
            "community.general.sendgrid",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Sendgrid)

}

/// Manage Sensu checks
class SensuCheckOptions {
    
    aggregate: Boolean?
    
    backup: Boolean?
    
    command: String?
    
    custom: Any?
    
    dependencies: Listing<String>?
    
    handle: Boolean?
    
    handlers: Listing<String>?
    
    high_flap_threshold: Int?
    
    interval: Int?
    
    low_flap_threshold: Int?
    
    metric: Boolean?
    
    name: String
    
    occurrences: Int?
    
    path: String?
    
    publish: Boolean?
    
    refresh: Int?
    
    source: String?
    
    standalone: Boolean?
    
    state: ("present"|"absent")?
    
    subdue_begin: String?
    
    subdue_end: String?
    
    subscribers: Listing<String>?
    
    timeout: Int?
    
    ttl: Int?
    
}

/// Task class for sensu_check
class SensuCheck extends Playbook.Task {

    /// todo doc
    `community.general.sensu_check`: Dynamic

    /// Options for community.general.sensu_check
    hidden options: SensuCheckOptions?

    /// todo doc
    function configure(): SensuCheck = this
        .toMap()
        .put(
            "community.general.sensu_check",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(SensuCheck)

}

/// Manages Sensu client configuration
class SensuClientOptions {
    
    address: String?
    
    chef: Any?
    
    deregister: Boolean?
    
    deregistration: Any?
    
    ec2: Any?
    
    keepalive: Any?
    
    keepalives: Boolean?
    
    name: String?
    
    puppet: Any?
    
    redact: Listing<String>?
    
    registration: Any?
    
    safe_mode: Boolean?
    
    servicenow: Any?
    
    socket: Any?
    
    state: ("present"|"absent")?
    
    subscriptions: Listing<String>?
    
}

/// Task class for sensu_client
class SensuClient extends Playbook.Task {

    /// todo doc
    `community.general.sensu_client`: Dynamic

    /// Options for community.general.sensu_client
    hidden options: SensuClientOptions?

    /// todo doc
    function configure(): SensuClient = this
        .toMap()
        .put(
            "community.general.sensu_client",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(SensuClient)

}

/// Manages Sensu handler configuration
class SensuHandlerOptions {
    
    command: String?
    
    filter: String?
    
    filters: Listing<String>?
    
    handle_flapping: Boolean?
    
    handle_silenced: Boolean?
    
    handlers: Listing<String>?
    
    mutator: String?
    
    name: String
    
    pipe: Any?
    
    severities: Listing<String>?
    
    socket: Any?
    
    state: ("present"|"absent")?
    
    timeout: Int?
    
    type: ("pipe"|"tcp"|"udp"|"transport"|"set")?
    
}

/// Task class for sensu_handler
class SensuHandler extends Playbook.Task {

    /// todo doc
    `community.general.sensu_handler`: Dynamic

    /// Options for community.general.sensu_handler
    hidden options: SensuHandlerOptions?

    /// todo doc
    function configure(): SensuHandler = this
        .toMap()
        .put(
            "community.general.sensu_handler",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(SensuHandler)

}

/// Manage Sensu silence entries
class SensuSilenceOptions {
    
    check: String?
    
    creator: String?
    
    expire: Int?
    
    expire_on_resolve: Boolean?
    
    reason: String?
    
    state: ("present"|"absent")?
    
    subscription: String
    
    url: String?
    
}

/// Task class for sensu_silence
class SensuSilence extends Playbook.Task {

    /// todo doc
    `community.general.sensu_silence`: Dynamic

    /// Options for community.general.sensu_silence
    hidden options: SensuSilenceOptions?

    /// todo doc
    function configure(): SensuSilence = this
        .toMap()
        .put(
            "community.general.sensu_silence",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(SensuSilence)

}

/// Manage Sensu subscriptions
class SensuSubscriptionOptions {
    
    backup: Boolean?
    
    name: String
    
    path: String?
    
    state: ("present"|"absent")?
    
}

/// Task class for sensu_subscription
class SensuSubscription extends Playbook.Task {

    /// todo doc
    `community.general.sensu_subscription`: Dynamic

    /// Options for community.general.sensu_subscription
    hidden options: SensuSubscriptionOptions?

    /// todo doc
    function configure(): SensuSubscription = this
        .toMap()
        .put(
            "community.general.sensu_subscription",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(SensuSubscription)

}

/// Manages SELinux network port type definitions
class SeportOptions {
    
    ignore_selinux_state: Boolean?
    
    `local`: Boolean?
    
    ports: Listing<String>
    
    proto: ("tcp"|"udp")
    
    reload: Boolean?
    
    setype: String
    
    state: ("absent"|"present")?
    
}

/// Task class for seport
class Seport extends Playbook.Task {

    /// todo doc
    `community.general.seport`: Dynamic

    /// Options for community.general.seport
    hidden options: SeportOptions?

    /// todo doc
    function configure(): Seport = this
        .toMap()
        .put(
            "community.general.seport",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Seport)

}

/// Manages a Serverless Framework project
class ServerlessOptions {
    
    deploy: Boolean?
    
    force: Boolean?
    
    region: String?
    
    serverless_bin_path: String?
    
    service_path: String
    
    stage: String?
    
    state: ("absent"|"present")?
    
    verbose: Boolean?
    
}

/// Task class for serverless
class Serverless extends Playbook.Task {

    /// todo doc
    `community.general.serverless`: Dynamic

    /// Options for community.general.serverless
    hidden options: ServerlessOptions?

    /// todo doc
    function configure(): Serverless = this
        .toMap()
        .put(
            "community.general.serverless",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Serverless)

}

/// Shut down a machine
class ShutdownOptions {
    
    delay: Int?
    
    msg: String?
    
    search_paths: Listing<String>?
    
}

/// Task class for shutdown
class Shutdown extends Playbook.Task {

    /// todo doc
    `community.general.shutdown`: Dynamic

    /// Options for community.general.shutdown
    hidden options: ShutdownOptions?

    /// todo doc
    function configure(): Shutdown = this
        .toMap()
        .put(
            "community.general.shutdown",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Shutdown)

}

/// Manage services on Source Mage GNU/Linux
class SimpleinitMsbOptions {
    
    enabled: Boolean?
    
    name: String
    
    state: ("running"|"started"|"stopped"|"restarted"|"reloaded")?
    
}

/// Task class for simpleinit_msb
class SimpleinitMsb extends Playbook.Task {

    /// todo doc
    `community.general.simpleinit_msb`: Dynamic

    /// Options for community.general.simpleinit_msb
    hidden options: SimpleinitMsbOptions?

    /// todo doc
    function configure(): SimpleinitMsb = this
        .toMap()
        .put(
            "community.general.simpleinit_msb",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(SimpleinitMsb)

}

/// Create or cancel a virtual instance in SoftLayer
class SlVmOptions {
    
    cpus: Int?
    
    datacenter: ("ams01"|"ams03"|"che01"|"dal01"|"dal05"|"dal06"|"dal09"|"dal10"|"dal12"|"dal13"|"fra02"|"fra04"|"fra05"|"hkg02"|"hou02"|"lon02"|"lon04"|"lon06"|"mel01"|"mex01"|"mil01"|"mon01"|"osl01"|"par01"|"sao01"|"sea01"|"seo01"|"sjc01"|"sjc03"|"sjc04"|"sng01"|"syd01"|"syd04"|"tok02"|"tor01"|"wdc01"|"wdc04"|"wdc06"|"wdc07")?
    
    dedicated: Boolean?
    
    disks: Listing<Int>?
    
    domain: String?
    
    flavor: String?
    
    hostname: String?
    
    hourly: Boolean?
    
    image_id: String?
    
    instance_id: String?
    
    local_disk: Boolean?
    
    memory: Int?
    
    nic_speed: Int?
    
    os_code: String?
    
    post_uri: String?
    
    private: Boolean?
    
    private_vlan: String?
    
    public_vlan: String?
    
    ssh_keys: Listing<String>?
    
    state: ("absent"|"present")?
    
    tags: String?
    
    wait: Boolean?
    
    wait_time: Int?
    
}

/// Task class for sl_vm
class SlVm extends Playbook.Task {

    /// todo doc
    `community.general.sl_vm`: Dynamic

    /// Options for community.general.sl_vm
    hidden options: SlVmOptions?

    /// todo doc
    function configure(): SlVm = this
        .toMap()
        .put(
            "community.general.sl_vm",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(SlVm)

}

/// Send Slack notifications
class SlackOptions {
    
    attachments: Listing<Any>?
    
    blocks: Listing<Any>?
    
    channel: String?
    
    color: String?
    
    domain: String?
    
    icon_emoji: String?
    
    icon_url: String?
    
    link_names: Int?
    
    message_id: String?
    
    msg: String?
    
    parse: ("full"|"none")?
    
    prepend_hash: ("always"|"never"|"auto")?
    
    thread_id: String?
    
    token: String
    
    username: String?
    
    validate_certs: Boolean?
    
}

/// Task class for slack
class Slack extends Playbook.Task {

    /// todo doc
    `community.general.slack`: Dynamic

    /// Options for community.general.slack
    hidden options: SlackOptions?

    /// todo doc
    function configure(): Slack = this
        .toMap()
        .put(
            "community.general.slack",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Slack)

}

/// Package manager for Slackware >= 12.2
class SlackpkgOptions {
    
    name: Listing<String>
    
    state: ("present"|"absent"|"latest"|"installed"|"removed")?
    
    update_cache: Boolean?
    
}

/// Task class for slackpkg
class Slackpkg extends Playbook.Task {

    /// todo doc
    `community.general.slackpkg`: Dynamic

    /// Options for community.general.slackpkg
    hidden options: SlackpkgOptions?

    /// todo doc
    function configure(): Slackpkg = this
        .toMap()
        .put(
            "community.general.slackpkg",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Slackpkg)

}

/// Get SmartOS image details
class SmartosImageInfoOptions {
    
    filters: String?
    
}

/// Task class for smartos_image_info
class SmartosImageInfo extends Playbook.Task {

    /// todo doc
    `community.general.smartos_image_info`: Dynamic

    /// Options for community.general.smartos_image_info
    hidden options: SmartosImageInfoOptions?

    /// todo doc
    function configure(): SmartosImageInfo = this
        .toMap()
        .put(
            "community.general.smartos_image_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(SmartosImageInfo)

}

/// Manages snaps
class SnapOptions {
    
    channel: String?
    
    classic: Boolean?
    
    dangerous: Boolean?
    
    name: Listing<String>
    
    options: Listing<String>?
    
    state: ("absent"|"present"|"enabled"|"disabled")?
    
}

/// Task class for snap
class Snap extends Playbook.Task {

    /// todo doc
    `community.general.snap`: Dynamic

    /// Options for community.general.snap
    hidden options: SnapOptions?

    /// todo doc
    function configure(): Snap = this
        .toMap()
        .put(
            "community.general.snap",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Snap)

}

/// Manages snap aliases
class SnapAliasOptions {
    
    alias: Listing<String>?
    
    name: String?
    
    state: ("absent"|"present")?
    
}

/// Task class for snap_alias
class SnapAlias extends Playbook.Task {

    /// todo doc
    `community.general.snap_alias`: Dynamic

    /// Options for community.general.snap_alias
    hidden options: SnapAliasOptions?

    /// todo doc
    function configure(): SnapAlias = this
        .toMap()
        .put(
            "community.general.snap_alias",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(SnapAlias)

}

/// Retrieve facts for a device using SNMP
class SnmpFactsOptions {
    
    authkey: String?
    
    community: String?
    
    host: String
    
    integrity: ("md5"|"sha")?
    
    level: ("authNoPriv"|"authPriv")?
    
    privacy: ("aes"|"des")?
    
    privkey: String?
    
    retries: Int?
    
    timeout: Int?
    
    username: String?
    
    version: ("v2"|"v2c"|"v3")
    
}

/// Task class for snmp_facts
class SnmpFacts extends Playbook.Task {

    /// todo doc
    `community.general.snmp_facts`: Dynamic

    /// Options for community.general.snmp_facts
    hidden options: SnmpFactsOptions?

    /// todo doc
    function configure(): SnmpFacts = this
        .toMap()
        .put(
            "community.general.snmp_facts",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(SnmpFacts)

}

/// Manage Solaris zones
class SolarisZoneOptions {
    
    attach_options: String?
    
    config: String?
    
    create_options: String?
    
    install_options: String?
    
    name: String
    
    path: String?
    
    root_password: String?
    
    sparse: Boolean?
    
    state: ("absent"|"attached"|"configured"|"detached"|"installed"|"present"|"running"|"started"|"stopped")?
    
    timeout: Int?
    
}

/// Task class for solaris_zone
class SolarisZone extends Playbook.Task {

    /// todo doc
    `community.general.solaris_zone`: Dynamic

    /// Options for community.general.solaris_zone
    hidden options: SolarisZoneOptions?

    /// todo doc
    function configure(): SolarisZone = this
        .toMap()
        .put(
            "community.general.solaris_zone",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(SolarisZone)

}

/// Package manager for Source Mage GNU/Linux
class SorceryOptions {
    
    cache_valid_time: Int?
    
    depends: String?
    
    name: Listing<String>?
    
    repository: String?
    
    state: ("present"|"latest"|"absent"|"cast"|"dispelled"|"rebuild")?
    
    update: Boolean?
    
    update_cache: Boolean?
    
}

/// Task class for sorcery
class Sorcery extends Playbook.Task {

    /// todo doc
    `community.general.sorcery`: Dynamic

    /// Options for community.general.sorcery
    hidden options: SorceryOptions?

    /// todo doc
    function configure(): Sorcery = this
        .toMap()
        .put(
            "community.general.sorcery",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Sorcery)

}

/// Creates/deletes devices in CA Spectrum
class SpectrumDeviceOptions {
    
    agentport: Int?
    
    community: String
    
    device: String
    
    landscape: String
    
    state: ("present"|"absent")?
    
    url: String
    
    url_password: String
    
    url_username: String
    
    use_proxy: Boolean?
    
    validate_certs: Boolean?
    
}

/// Task class for spectrum_device
class SpectrumDevice extends Playbook.Task {

    /// todo doc
    `community.general.spectrum_device`: Dynamic

    /// Options for community.general.spectrum_device
    hidden options: SpectrumDeviceOptions?

    /// todo doc
    function configure(): SpectrumDevice = this
        .toMap()
        .put(
            "community.general.spectrum_device",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(SpectrumDevice)

}

/// Enforce a model's attributes in CA Spectrum
class SpectrumModelAttrsOptions {
    
    attributes: Listing<Any>
    
    name: String
    
    type: String
    
    url: String
    
    url_password: String
    
    url_username: String
    
    use_proxy: Boolean?
    
    validate_certs: Boolean?
    
}

/// Task class for spectrum_model_attrs
class SpectrumModelAttrs extends Playbook.Task {

    /// todo doc
    `community.general.spectrum_model_attrs`: Dynamic

    /// Options for community.general.spectrum_model_attrs
    hidden options: SpectrumModelAttrsOptions?

    /// todo doc
    function configure(): SpectrumModelAttrs = this
        .toMap()
        .put(
            "community.general.spectrum_model_attrs",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(SpectrumModelAttrs)

}

/// Create, update or delete Spotinst AWS Elastigroups
class SpotinstAwsElastigroupOptions {
    
    account_id: String?
    
    availability_vs_cost: String
    
    availability_zones: Listing<Any>
    
    block_device_mappings: Listing<Any>?
    
    chef: Any?
    
    credentials_path: String?
    
    do_not_update: Listing<String>?
    
    down_scaling_policies: Listing<Any>?
    
    draining_timeout: Int?
    
    ebs_optimized: Boolean?
    
    ebs_volume_pool: Listing<Any>?
    
    ecs: Any?
    
    elastic_beanstalk: Any?
    
    elastic_ips: Listing<String>?
    
    fallback_to_od: Boolean?
    
    health_check_grace_period: Int?
    
    health_check_type: String?
    
    health_check_unhealthy_duration_before_replacement: Int?
    
    iam_role_arn: String?
    
    iam_role_name: String?
    
    id: String?
    
    image_id: String
    
    key_pair: String?
    
    kubernetes: Any?
    
    lifetime_period: Int?
    
    load_balancers: Listing<String>?
    
    max_size: Int
    
    mesosphere: Any?
    
    min_size: Int
    
    monitoring: String?
    
    multai_load_balancers: Listing<Any>?
    
    multai_token: String?
    
    name: String
    
    network_interfaces: Listing<Any>?
    
    on_demand_count: Int?
    
    on_demand_instance_type: String?
    
    opsworks: Any?
    
    persistence: Any?
    
    product: String
    
    rancher: Any?
    
    right_scale: Any?
    
    risk: Int?
    
    roll_config: Any?
    
    scheduled_tasks: Listing<Any>?
    
    security_group_ids: Listing<String>
    
    shutdown_script: String?
    
    signals: Listing<Any>?
    
    spin_up_time: Int?
    
    spot_instance_types: Listing<String>
    
    state: ("present"|"absent")?
    
    tags: Listing<Any>?
    
    target: Int
    
    target_group_arns: Listing<String>?
    
    target_tracking_policies: Listing<Any>?
    
    tenancy: String?
    
    terminate_at_end_of_billing_hour: Boolean?
    
    token: String?
    
    uniqueness_by: ("id"|"name")?
    
    unit: String?
    
    up_scaling_policies: Listing<Any>?
    
    user_data: String?
    
    utilize_reserved_instances: Boolean?
    
    wait_for_instances: Boolean?
    
    wait_timeout: Int?
    
}

/// Task class for spotinst_aws_elastigroup
class SpotinstAwsElastigroup extends Playbook.Task {

    /// todo doc
    `community.general.spotinst_aws_elastigroup`: Dynamic

    /// Options for community.general.spotinst_aws_elastigroup
    hidden options: SpotinstAwsElastigroupOptions?

    /// todo doc
    function configure(): SpotinstAwsElastigroup = this
        .toMap()
        .put(
            "community.general.spotinst_aws_elastigroup",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(SpotinstAwsElastigroup)

}

/// Manage HPE StoreServ 3PAR CPG
class Ss3ParCpgOptions {
    
    cpg_name: String
    
    disk_type: ("FC"|"NL"|"SSD")?
    
    domain: String?
    
    growth_increment: String?
    
    growth_limit: String?
    
    growth_warning: String?
    
    high_availability: ("PORT"|"CAGE"|"MAG")?
    
    raid_type: ("R0"|"R1"|"R5"|"R6")?
    
    secure: Boolean?
    
    set_size: Int?
    
    state: ("present"|"absent")
    
}

/// Task class for ss_3par_cpg
class Ss3ParCpg extends Playbook.Task {

    /// todo doc
    `community.general.ss_3par_cpg`: Dynamic

    /// Options for community.general.ss_3par_cpg
    hidden options: Ss3ParCpgOptions?

    /// todo doc
    function configure(): Ss3ParCpg = this
        .toMap()
        .put(
            "community.general.ss_3par_cpg",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Ss3ParCpg)

}

/// Manage SSH config for user
class SshConfigOptions {
    
    add_keys_to_agent: Boolean?
    
    controlmaster: ("yes"|"no"|"ask"|"auto"|"autoask")?
    
    controlpath: String?
    
    controlpersist: String?
    
    forward_agent: Boolean?
    
    group: String?
    
    host: String
    
    host_key_algorithms: String?
    
    hostname: String?
    
    identities_only: Boolean?
    
    identity_file: String?
    
    port: String?
    
    proxycommand: String?
    
    proxyjump: String?
    
    remote_user: String?
    
    ssh_config_file: String?
    
    state: ("present"|"absent")?
    
    strict_host_key_checking: ("yes"|"no"|"ask")?
    
    user: String?
    
    user_known_hosts_file: String?
    
}

/// Task class for ssh_config
class SshConfig extends Playbook.Task {

    /// todo doc
    `community.general.ssh_config`: Dynamic

    /// Options for community.general.ssh_config
    hidden options: SshConfigOptions?

    /// todo doc
    function configure(): SshConfig = this
        .toMap()
        .put(
            "community.general.ssh_config",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(SshConfig)

}

/// Send code deploy and annotation events to stackdriver
class StackdriverOptions {
    
    annotated_by: String?
    
    deployed_by: String?
    
    deployed_to: String?
    
    event: ("annotation"|"deploy")
    
    event_epoch: String?
    
    instance_id: String?
    
    key: String
    
    level: ("INFO"|"WARN"|"ERROR")?
    
    msg: String?
    
    repository: String?
    
    revision_id: String?
    
}

/// Task class for stackdriver
class Stackdriver extends Playbook.Task {

    /// todo doc
    `community.general.stackdriver`: Dynamic

    /// Options for community.general.stackdriver
    hidden options: StackdriverOptions?

    /// todo doc
    function configure(): Stackdriver = this
        .toMap()
        .put(
            "community.general.stackdriver",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Stackdriver)

}

/// Add or remove host to stacki front-end
class StackiHostOptions {
    
    appliance: String?
    
    force_install: Boolean?
    
    name: String
    
    network: String?
    
    prim_intf: String?
    
    prim_intf_ip: String?
    
    prim_intf_mac: String?
    
    rack: Int?
    
    rank: Int?
    
    stacki_endpoint: String
    
    stacki_password: String
    
    stacki_user: String
    
    state: ("absent"|"present")?
    
}

/// Task class for stacki_host
class StackiHost extends Playbook.Task {

    /// todo doc
    `community.general.stacki_host`: Dynamic

    /// Options for community.general.stacki_host
    hidden options: StackiHostOptions?

    /// todo doc
    function configure(): StackiHost = this
        .toMap()
        .put(
            "community.general.stacki_host",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(StackiHost)

}

/// Send metrics to StatsD
class StatsdOptions {
    
    delta: Boolean?
    
    host: String?
    
    metric: String
    
    metric_prefix: String?
    
    metric_type: ("counter"|"gauge")
    
    port: Int?
    
    protocol: ("udp"|"tcp")?
    
    state: ("present")?
    
    timeout: Any?
    
    value: Int
    
}

/// Task class for statsd
class Statsd extends Playbook.Task {

    /// todo doc
    `community.general.statsd`: Dynamic

    /// Options for community.general.statsd
    hidden options: StatsdOptions?

    /// todo doc
    function configure(): Statsd = this
        .toMap()
        .put(
            "community.general.statsd",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Statsd)

}

/// Create maintenance windows for your status.io dashboard
class StatusioMaintenanceOptions {
    
    all_infrastructure_affected: Boolean?
    
    api_id: String
    
    api_key: String
    
    automation: Boolean?
    
    components: Listing<String>?
    
    containers: Listing<String>?
    
    desc: String?
    
    maintenance_id: String?
    
    maintenance_notify_1_hr: Boolean?
    
    maintenance_notify_24_hr: Boolean?
    
    maintenance_notify_72_hr: Boolean?
    
    maintenance_notify_now: Boolean?
    
    minutes: Int?
    
    start_date: String?
    
    start_time: String?
    
    state: ("present"|"absent")?
    
    statuspage: String
    
    title: String?
    
    url: String?
    
}

/// Task class for statusio_maintenance
class StatusioMaintenance extends Playbook.Task {

    /// todo doc
    `community.general.statusio_maintenance`: Dynamic

    /// Options for community.general.statusio_maintenance
    hidden options: StatusioMaintenanceOptions?

    /// todo doc
    function configure(): StatusioMaintenance = this
        .toMap()
        .put(
            "community.general.statusio_maintenance",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(StatusioMaintenance)

}

/// Manage sudoers files
class SudoersOptions {
    
    commands: Listing<String>?
    
    group: String?
    
    host: String?
    
    name: String
    
    noexec: Boolean?
    
    nopassword: Boolean?
    
    runas: String?
    
    setenv: Boolean?
    
    state: ("present"|"absent")?
    
    sudoers_path: String?
    
    user: String?
    
    validation: ("absent"|"detect"|"required")?
    
}

/// Task class for sudoers
class Sudoers extends Playbook.Task {

    /// todo doc
    `community.general.sudoers`: Dynamic

    /// Options for community.general.sudoers
    hidden options: SudoersOptions?

    /// todo doc
    function configure(): Sudoers = this
        .toMap()
        .put(
            "community.general.sudoers",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Sudoers)

}

/// Manage the state of a program or group of programs running via supervisord
class SupervisorctlOptions {
    
    config: String?
    
    name: String
    
    password: String?
    
    server_url: String?
    
    signal: String?
    
    state: ("present"|"started"|"stopped"|"restarted"|"absent"|"signalled")
    
    stop_before_removing: Boolean?
    
    supervisorctl_path: String?
    
    username: String?
    
}

/// Task class for supervisorctl
class Supervisorctl extends Playbook.Task {

    /// todo doc
    `community.general.supervisorctl`: Dynamic

    /// Options for community.general.supervisorctl
    hidden options: SupervisorctlOptions?

    /// todo doc
    function configure(): Supervisorctl = this
        .toMap()
        .put(
            "community.general.supervisorctl",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Supervisorctl)

}

/// Manage daemontools services
class SvcOptions {
    
    downed: Boolean?
    
    enabled: Boolean?
    
    name: String
    
    service_dir: String?
    
    service_src: String?
    
    state: ("killed"|"once"|"reloaded"|"restarted"|"started"|"stopped")?
    
}

/// Task class for svc
class Svc extends Playbook.Task {

    /// todo doc
    `community.general.svc`: Dynamic

    /// Options for community.general.svc
    hidden options: SvcOptions?

    /// todo doc
    function configure(): Svc = this
        .toMap()
        .put(
            "community.general.svc",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Svc)

}

/// Manage Solaris SVR4 packages
class Svr4PkgOptions {
    
    category: Boolean?
    
    name: String
    
    proxy: String?
    
    response_file: String?
    
    src: String?
    
    state: ("present"|"absent")
    
    zone: ("current"|"all")?
    
}

/// Task class for svr4pkg
class Svr4Pkg extends Playbook.Task {

    /// todo doc
    `community.general.svr4pkg`: Dynamic

    /// Options for community.general.svr4pkg
    hidden options: Svr4PkgOptions?

    /// todo doc
    function configure(): Svr4Pkg = this
        .toMap()
        .put(
            "community.general.svr4pkg",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Svr4Pkg)

}

/// Manage packages with swdepot package manager (HP-UX)
class SwdepotOptions {
    
    depot: String?
    
    name: String
    
    state: ("present"|"latest"|"absent")
    
}

/// Task class for swdepot
class Swdepot extends Playbook.Task {

    /// todo doc
    `community.general.swdepot`: Dynamic

    /// Options for community.general.swdepot
    hidden options: SwdepotOptions?

    /// todo doc
    function configure(): Swdepot = this
        .toMap()
        .put(
            "community.general.swdepot",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Swdepot)

}

/// Manages updates and bundles in ClearLinux systems
class SwupdOptions {
    
    contenturl: String?
    
    format: String?
    
    manifest: Int?
    
    name: String?
    
    state: ("present"|"absent")?
    
    update: Boolean?
    
    url: String?
    
    verify: Boolean?
    
    versionurl: String?
    
}

/// Task class for swupd
class Swupd extends Playbook.Task {

    /// todo doc
    `community.general.swupd`: Dynamic

    /// Options for community.general.swupd
    hidden options: SwupdOptions?

    /// todo doc
    function configure(): Swupd = this
        .toMap()
        .put(
            "community.general.swupd",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Swupd)

}

/// Log messages in the syslog
class SysloggerOptions {
    
    facility: ("kern"|"user"|"mail"|"daemon"|"auth"|"lpr"|"news"|"uucp"|"cron"|"syslog"|"local0"|"local1"|"local2"|"local3"|"local4"|"local5"|"local6"|"local7")?
    
    ident: String?
    
    log_pid: Boolean?
    
    msg: String
    
    priority: ("emerg"|"alert"|"crit"|"err"|"warning"|"notice"|"info"|"debug")?
    
}

/// Task class for syslogger
class Syslogger extends Playbook.Task {

    /// todo doc
    `community.general.syslogger`: Dynamic

    /// Options for community.general.syslogger
    hidden options: SysloggerOptions?

    /// todo doc
    function configure(): Syslogger = this
        .toMap()
        .put(
            "community.general.syslogger",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Syslogger)

}

/// Manage OpenBSD system patches
class SyspatchOptions {
    
    revert: ("all"|"one")?
    
}

/// Task class for syspatch
class Syspatch extends Playbook.Task {

    /// todo doc
    `community.general.syspatch`: Dynamic

    /// Options for community.general.syspatch
    hidden options: SyspatchOptions?

    /// todo doc
    function configure(): Syspatch = this
        .toMap()
        .put(
            "community.general.syspatch",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Syspatch)

}

/// Manage FreeBSD using sysrc
class SysrcOptions {
    
    delim: String?
    
    jail: String?
    
    name: String
    
    path: String?
    
    state: ("absent"|"present"|"value_present"|"value_absent")?
    
    value: String?
    
}

/// Task class for sysrc
class Sysrc extends Playbook.Task {

    /// todo doc
    `community.general.sysrc`: Dynamic

    /// Options for community.general.sysrc
    hidden options: SysrcOptions?

    /// todo doc
    function configure(): Sysrc = this
        .toMap()
        .put(
            "community.general.sysrc",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Sysrc)

}

/// Manage OpenBSD system upgrades
class SysupgradeOptions {
    
    fetch_only: Boolean?
    
    force: Boolean?
    
    installurl: String?
    
    keep_files: Boolean?
    
    snapshot: Boolean?
    
}

/// Task class for sysupgrade
class Sysupgrade extends Playbook.Task {

    /// todo doc
    `community.general.sysupgrade`: Dynamic

    /// Options for community.general.sysupgrade
    hidden options: SysupgradeOptions?

    /// todo doc
    function configure(): Sysupgrade = this
        .toMap()
        .put(
            "community.general.sysupgrade",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Sysupgrade)

}

/// Creates/deletes an issue in a Taiga Project Management Platform
class TaigaIssueOptions {
    
    attachment: String?
    
    attachment_description: String?
    
    description: String?
    
    issue_type: String
    
    priority: String?
    
    project: String
    
    severity: String?
    
    state: ("present"|"absent")?
    
    status: String?
    
    subject: String
    
    tags: Listing<String>?
    
    taiga_host: String?
    
}

/// Task class for taiga_issue
class TaigaIssue extends Playbook.Task {

    /// todo doc
    `community.general.taiga_issue`: Dynamic

    /// Options for community.general.taiga_issue
    hidden options: TaigaIssueOptions?

    /// todo doc
    function configure(): TaigaIssue = this
        .toMap()
        .put(
            "community.general.taiga_issue",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(TaigaIssue)

}

/// Send notifications via telegram
class TelegramOptions {
    
    api_args: Any?
    
    api_method: String?
    
    token: String
    
}

/// Task class for telegram
class Telegram extends Playbook.Task {

    /// todo doc
    `community.general.telegram`: Dynamic

    /// Options for community.general.telegram
    hidden options: TelegramOptions?

    /// todo doc
    function configure(): Telegram = this
        .toMap()
        .put(
            "community.general.telegram",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Telegram)

}

/// Manages a Terraform deployment (and plans)
class TerraformOptions {
    
    backend_config: Any?
    
    backend_config_files: Listing<String>?
    
    binary_path: String?
    
    check_destroy: Boolean?
    
    complex_vars: Boolean?
    
    force_init: Boolean?
    
    init_reconfigure: Boolean?
    
    lock: Boolean?
    
    lock_timeout: Int?
    
    overwrite_init: Boolean?
    
    parallelism: Int?
    
    plan_file: String?
    
    plugin_paths: Listing<String>?
    
    project_path: String
    
    provider_upgrade: Boolean?
    
    purge_workspace: Boolean?
    
    state: ("planned"|"present"|"absent")?
    
    state_file: String?
    
    targets: Listing<String>?
    
    variables: Any?
    
    variables_files: Listing<String>?
    
    workspace: String?
    
}

/// Task class for terraform
class Terraform extends Playbook.Task {

    /// todo doc
    `community.general.terraform`: Dynamic

    /// Options for community.general.terraform
    hidden options: TerraformOptions?

    /// todo doc
    function configure(): Terraform = this
        .toMap()
        .put(
            "community.general.terraform",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Terraform)

}

/// Configure timezone setting
class TimezoneOptions {
    
    hwclock: ("local"|"UTC")?
    
    name: String?
    
}

/// Task class for timezone
class Timezone extends Playbook.Task {

    /// todo doc
    `community.general.timezone`: Dynamic

    /// Options for community.general.timezone
    hidden options: TimezoneOptions?

    /// todo doc
    function configure(): Timezone = this
        .toMap()
        .put(
            "community.general.timezone",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Timezone)

}

/// Sends a text message to a mobile phone through Twilio
class TwilioOptions {
    
    account_sid: String
    
    auth_token: String
    
    from_number: String
    
    media_url: String?
    
    msg: String
    
    to_numbers: Listing<String>
    
}

/// Task class for twilio
class Twilio extends Playbook.Task {

    /// todo doc
    `community.general.twilio`: Dynamic

    /// Options for community.general.twilio
    hidden options: TwilioOptions?

    /// todo doc
    function configure(): Twilio = this
        .toMap()
        .put(
            "community.general.twilio",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Twilio)

}

/// Send a message to typetalk
class TypetalkOptions {
    
    client_id: String
    
    client_secret: String
    
    msg: String
    
    topic: Int
    
}

/// Task class for typetalk
class Typetalk extends Playbook.Task {

    /// todo doc
    `community.general.typetalk`: Dynamic

    /// Options for community.general.typetalk
    hidden options: TypetalkOptions?

    /// todo doc
    function configure(): Typetalk = this
        .toMap()
        .put(
            "community.general.typetalk",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Typetalk)

}

/// Manage dns entries on a univention corporate server
class UdmDnsRecordOptions {
    
    data: Any?
    
    name: String
    
    state: ("present"|"absent")?
    
    type: String
    
    zone: String
    
}

/// Task class for udm_dns_record
class UdmDnsRecord extends Playbook.Task {

    /// todo doc
    `community.general.udm_dns_record`: Dynamic

    /// Options for community.general.udm_dns_record
    hidden options: UdmDnsRecordOptions?

    /// todo doc
    function configure(): UdmDnsRecord = this
        .toMap()
        .put(
            "community.general.udm_dns_record",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(UdmDnsRecord)

}

/// Manage dns zones on a univention corporate server
class UdmDnsZoneOptions {
    
    contact: String?
    
    expire: Int?
    
    interfaces: Listing<String>?
    
    mx: Listing<String>?
    
    nameserver: Listing<String>?
    
    refresh: Int?
    
    retry: Int?
    
    state: ("present"|"absent")?
    
    ttl: Int?
    
    type: String
    
    zone: String
    
}

/// Task class for udm_dns_zone
class UdmDnsZone extends Playbook.Task {

    /// todo doc
    `community.general.udm_dns_zone`: Dynamic

    /// Options for community.general.udm_dns_zone
    hidden options: UdmDnsZoneOptions?

    /// todo doc
    function configure(): UdmDnsZone = this
        .toMap()
        .put(
            "community.general.udm_dns_zone",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(UdmDnsZone)

}

/// Manage of the posix group
class UdmGroupOptions {
    
    description: String?
    
    name: String
    
    ou: String?
    
    position: String?
    
    state: ("present"|"absent")?
    
    subpath: String?
    
}

/// Task class for udm_group
class UdmGroup extends Playbook.Task {

    /// todo doc
    `community.general.udm_group`: Dynamic

    /// Options for community.general.udm_group
    hidden options: UdmGroupOptions?

    /// todo doc
    function configure(): UdmGroup = this
        .toMap()
        .put(
            "community.general.udm_group",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(UdmGroup)

}

/// Manage samba shares on a univention corporate server
class UdmShareOptions {
    
    directorymode: String?
    
    group: String?
    
    host: String?
    
    name: String
    
    nfsCustomSettings: Listing<String>?
    
    nfs_hosts: Listing<String>?
    
    ou: String
    
    owner: String?
    
    path: String?
    
    root_squash: Boolean?
    
    sambaBlockSize: String?
    
    sambaBlockingLocks: Boolean?
    
    sambaBrowseable: Boolean?
    
    sambaCreateMode: String?
    
    sambaCscPolicy: String?
    
    sambaCustomSettings: Listing<Any>?
    
    sambaDirectoryMode: String?
    
    sambaDirectorySecurityMode: String?
    
    sambaDosFilemode: Boolean?
    
    sambaFakeOplocks: Boolean?
    
    sambaForceCreateMode: Boolean?
    
    sambaForceDirectoryMode: Boolean?
    
    sambaForceDirectorySecurityMode: Boolean?
    
    sambaForceGroup: String?
    
    sambaForceSecurityMode: Boolean?
    
    sambaForceUser: String?
    
    sambaHideFiles: String?
    
    sambaHideUnreadable: Boolean?
    
    sambaHostsAllow: Listing<String>?
    
    sambaHostsDeny: Listing<String>?
    
    sambaInheritAcls: Boolean?
    
    sambaInheritOwner: Boolean?
    
    sambaInheritPermissions: Boolean?
    
    sambaInvalidUsers: String?
    
    sambaLevel2Oplocks: Boolean?
    
    sambaLocking: Boolean?
    
    sambaMSDFSRoot: Boolean?
    
    sambaName: String?
    
    sambaNtAclSupport: Boolean?
    
    sambaOplocks: Boolean?
    
    sambaPostexec: String?
    
    sambaPreexec: String?
    
    sambaPublic: Boolean?
    
    sambaSecurityMode: String?
    
    sambaStrictLocking: String?
    
    sambaVFSObjects: String?
    
    sambaValidUsers: String?
    
    sambaWriteList: String?
    
    sambaWriteable: Boolean?
    
    state: ("present"|"absent")?
    
    subtree_checking: Boolean?
    
    sync: String?
    
    writeable: Boolean?
    
}

/// Task class for udm_share
class UdmShare extends Playbook.Task {

    /// todo doc
    `community.general.udm_share`: Dynamic

    /// Options for community.general.udm_share
    hidden options: UdmShareOptions?

    /// todo doc
    function configure(): UdmShare = this
        .toMap()
        .put(
            "community.general.udm_share",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(UdmShare)

}

/// Manage posix users on a univention corporate server
class UdmUserOptions {
    
    birthday: String?
    
    city: String?
    
    country: String?
    
    department_number: String?
    
    description: String?
    
    display_name: String?
    
    email: Listing<String>?
    
    employee_number: String?
    
    employee_type: String?
    
    firstname: String?
    
    gecos: String?
    
    groups: Listing<String>?
    
    home_share: String?
    
    home_share_path: String?
    
    home_telephone_number: Listing<String>?
    
    homedrive: String?
    
    lastname: String?
    
    mail_alternative_address: Listing<String>?
    
    mail_home_server: String?
    
    mail_primary_address: String?
    
    mobile_telephone_number: Listing<String>?
    
    organisation: String?
    
    ou: String?
    
    overridePWHistory: Boolean?
    
    overridePWLength: Boolean?
    
    pager_telephonenumber: Listing<String>?
    
    password: String?
    
    phone: Listing<String>?
    
    position: String?
    
    postcode: String?
    
    primary_group: String?
    
    profilepath: String?
    
    pwd_change_next_login: ("0"|"1")?
    
    room_number: String?
    
    samba_privileges: Listing<String>?
    
    samba_user_workstations: Listing<String>?
    
    sambahome: String?
    
    scriptpath: String?
    
    secretary: Listing<String>?
    
    serviceprovider: Listing<String>?
    
    shell: String?
    
    state: ("present"|"absent")?
    
    street: String?
    
    subpath: String?
    
    title: String?
    
    unixhome: String?
    
    update_password: ("always"|"on_create")?
    
    userexpiry: String?
    
    username: String
    
}

/// Task class for udm_user
class UdmUser extends Playbook.Task {

    /// todo doc
    `community.general.udm_user`: Dynamic

    /// Options for community.general.udm_user
    hidden options: UdmUserOptions?

    /// todo doc
    function configure(): UdmUser = this
        .toMap()
        .put(
            "community.general.udm_user",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(UdmUser)

}

/// Manage firewall with UFW
class UfwOptions {
    
    comment: String?
    
    default: ("allow"|"deny"|"reject")?
    
    `delete`: Boolean?
    
    direction: ("in"|"incoming"|"out"|"outgoing"|"routed")?
    
    from_ip: String?
    
    from_port: String?
    
    insert: Int?
    
    insert_relative_to: ("first-ipv4"|"first-ipv6"|"last-ipv4"|"last-ipv6"|"zero")?
    
    interface: String?
    
    interface_in: String?
    
    interface_out: String?
    
    log: Boolean?
    
    logging: ("on"|"off"|"low"|"medium"|"high"|"full")?
    
    name: String?
    
    proto: ("any"|"tcp"|"udp"|"ipv6"|"esp"|"ah"|"gre"|"igmp")?
    
    route: Boolean?
    
    rule: ("allow"|"deny"|"limit"|"reject")?
    
    state: ("disabled"|"enabled"|"reloaded"|"reset")?
    
    to_ip: String?
    
    to_port: String?
    
}

/// Task class for ufw
class Ufw extends Playbook.Task {

    /// todo doc
    `community.general.ufw`: Dynamic

    /// Options for community.general.ufw
    hidden options: UfwOptions?

    /// todo doc
    function configure(): Ufw = this
        .toMap()
        .put(
            "community.general.ufw",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Ufw)

}

/// Pause and start Uptime Robot monitoring
class UptimerobotOptions {
    
    apikey: String
    
    monitorid: String
    
    state: ("started"|"paused")
    
}

/// Task class for uptimerobot
class Uptimerobot extends Playbook.Task {

    /// todo doc
    `community.general.uptimerobot`: Dynamic

    /// Options for community.general.uptimerobot
    hidden options: UptimerobotOptions?

    /// todo doc
    function configure(): Uptimerobot = this
        .toMap()
        .put(
            "community.general.uptimerobot",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Uptimerobot)

}

/// Urpmi manager
class UrpmiOptions {
    
    force: Boolean?
    
    name: Listing<String>
    
    no_recommends: Boolean?
    
    root: String?
    
    state: ("absent"|"present"|"installed"|"removed")?
    
    update_cache: Boolean?
    
}

/// Task class for urpmi
class Urpmi extends Playbook.Task {

    /// todo doc
    `community.general.urpmi`: Dynamic

    /// Options for community.general.urpmi
    hidden options: UrpmiOptions?

    /// todo doc
    function configure(): Urpmi = this
        .toMap()
        .put(
            "community.general.urpmi",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Urpmi)

}

/// Create, update or destroy an aaa group object in Sophos UTM
class UtmAaaGroupOptions {
    
    adirectory_groups: Listing<String>?
    
    adirectory_groups_sids: Any?
    
    backend_match: ("none"|"adirectory"|"edirectory"|"radius"|"tacacs"|"ldap")?
    
    comment: String?
    
    dynamic: ("none"|"ipsec_dn"|"directory_groups")?
    
    edirectory_groups: Listing<String>?
    
    ipsec_dn: String?
    
    ldap_attribute: String?
    
    ldap_attribute_value: String?
    
    members: Listing<String>?
    
    name: String
    
    network: String?
    
    radius_groups: Listing<String>?
    
    tacacs_groups: Listing<String>?
    
}

/// Task class for utm_aaa_group
class UtmAaaGroup extends Playbook.Task {

    /// todo doc
    `community.general.utm_aaa_group`: Dynamic

    /// Options for community.general.utm_aaa_group
    hidden options: UtmAaaGroupOptions?

    /// todo doc
    function configure(): UtmAaaGroup = this
        .toMap()
        .put(
            "community.general.utm_aaa_group",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(UtmAaaGroup)

}

/// Get info for reverse_proxy frontend entry in Sophos UTM
class UtmAaaGroupInfoOptions {
    
    name: String
    
}

/// Task class for utm_aaa_group_info
class UtmAaaGroupInfo extends Playbook.Task {

    /// todo doc
    `community.general.utm_aaa_group_info`: Dynamic

    /// Options for community.general.utm_aaa_group_info
    hidden options: UtmAaaGroupInfoOptions?

    /// todo doc
    function configure(): UtmAaaGroupInfo = this
        .toMap()
        .put(
            "community.general.utm_aaa_group_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(UtmAaaGroupInfo)

}

/// Create, update or destroy ca host_key_cert entry in Sophos UTM
class UtmCaHostKeyCertOptions {
    
    ca: String
    
    certificate: String
    
    comment: String?
    
    encrypted: Boolean?
    
    key: String?
    
    meta: String
    
    name: String
    
}

/// Task class for utm_ca_host_key_cert
class UtmCaHostKeyCert extends Playbook.Task {

    /// todo doc
    `community.general.utm_ca_host_key_cert`: Dynamic

    /// Options for community.general.utm_ca_host_key_cert
    hidden options: UtmCaHostKeyCertOptions?

    /// todo doc
    function configure(): UtmCaHostKeyCert = this
        .toMap()
        .put(
            "community.general.utm_ca_host_key_cert",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(UtmCaHostKeyCert)

}

/// Get info for a ca host_key_cert entry in Sophos UTM
class UtmCaHostKeyCertInfoOptions {
    
    name: String
    
}

/// Task class for utm_ca_host_key_cert_info
class UtmCaHostKeyCertInfo extends Playbook.Task {

    /// todo doc
    `community.general.utm_ca_host_key_cert_info`: Dynamic

    /// Options for community.general.utm_ca_host_key_cert_info
    hidden options: UtmCaHostKeyCertInfoOptions?

    /// todo doc
    function configure(): UtmCaHostKeyCertInfo = this
        .toMap()
        .put(
            "community.general.utm_ca_host_key_cert_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(UtmCaHostKeyCertInfo)

}

/// Create, update or destroy dns entry in Sophos UTM
class UtmDnsHostOptions {
    
    address: String?
    
    address6: String?
    
    comment: String?
    
    hostname: String?
    
    interface: String?
    
    name: String
    
    resolved: Boolean?
    
    resolved6: Boolean?
    
    timeout: Int?
    
}

/// Task class for utm_dns_host
class UtmDnsHost extends Playbook.Task {

    /// todo doc
    `community.general.utm_dns_host`: Dynamic

    /// Options for community.general.utm_dns_host
    hidden options: UtmDnsHostOptions?

    /// todo doc
    function configure(): UtmDnsHost = this
        .toMap()
        .put(
            "community.general.utm_dns_host",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(UtmDnsHost)

}

/// Create, update or destroy network/interface_address object
class UtmNetworkInterfaceAddressOptions {
    
    address: String
    
    address6: String?
    
    comment: String?
    
    name: String
    
    resolved: Boolean?
    
    resolved6: Boolean?
    
}

/// Task class for utm_network_interface_address
class UtmNetworkInterfaceAddress extends Playbook.Task {

    /// todo doc
    `community.general.utm_network_interface_address`: Dynamic

    /// Options for community.general.utm_network_interface_address
    hidden options: UtmNetworkInterfaceAddressOptions?

    /// todo doc
    function configure(): UtmNetworkInterfaceAddress = this
        .toMap()
        .put(
            "community.general.utm_network_interface_address",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(UtmNetworkInterfaceAddress)

}

/// Get info for a network/interface_address object
class UtmNetworkInterfaceAddressInfoOptions {
    
    name: String
    
}

/// Task class for utm_network_interface_address_info
class UtmNetworkInterfaceAddressInfo extends Playbook.Task {

    /// todo doc
    `community.general.utm_network_interface_address_info`: Dynamic

    /// Options for community.general.utm_network_interface_address_info
    hidden options: UtmNetworkInterfaceAddressInfoOptions?

    /// todo doc
    function configure(): UtmNetworkInterfaceAddressInfo = this
        .toMap()
        .put(
            "community.general.utm_network_interface_address_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(UtmNetworkInterfaceAddressInfo)

}

/// Create, update or destroy reverse_proxy auth_profile entry in Sophos UTM
class UtmProxyAuthProfileOptions {
    
    aaa: Listing<String>
    
    backend_mode: ("Basic"|"None")?
    
    backend_strip_basic_auth: Boolean?
    
    backend_user_prefix: String?
    
    backend_user_suffix: String?
    
    basic_prompt: String
    
    comment: String?
    
    frontend_cookie: String?
    
    frontend_cookie_secret: String?
    
    frontend_form: String?
    
    frontend_form_template: String?
    
    frontend_login: String?
    
    frontend_logout: String?
    
    frontend_mode: ("Basic"|"Form")?
    
    frontend_realm: String?
    
    frontend_session_allow_persistency: Boolean?
    
    frontend_session_lifetime: Int
    
    frontend_session_lifetime_limited: Boolean?
    
    frontend_session_lifetime_scope: ("days"|"hours"|"minutes")?
    
    frontend_session_timeout: Int
    
    frontend_session_timeout_enabled: Boolean?
    
    frontend_session_timeout_scope: ("days"|"hours"|"minutes")?
    
    logout_delegation_urls: Listing<String>?
    
    logout_mode: ("None"|"Delegation")?
    
    name: String
    
    redirect_to_requested_url: Boolean?
    
}

/// Task class for utm_proxy_auth_profile
class UtmProxyAuthProfile extends Playbook.Task {

    /// todo doc
    `community.general.utm_proxy_auth_profile`: Dynamic

    /// Options for community.general.utm_proxy_auth_profile
    hidden options: UtmProxyAuthProfileOptions?

    /// todo doc
    function configure(): UtmProxyAuthProfile = this
        .toMap()
        .put(
            "community.general.utm_proxy_auth_profile",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(UtmProxyAuthProfile)

}

/// Create, update or destroy reverse_proxy exception entry in Sophos UTM
class UtmProxyExceptionOptions {
    
    name: String
    
    op: ("AND"|"OR")?
    
    path: Listing<String>?
    
    skip_custom_threats_filters: Listing<String>?
    
    skip_threats_filter_categories: Listing<String>?
    
    skipav: Boolean?
    
    skipbadclients: Boolean?
    
    skipcookie: Boolean?
    
    skipform: Boolean?
    
    skipform_missingtoken: Boolean?
    
    skiphtmlrewrite: Boolean?
    
    skiptft: Boolean?
    
    skipurl: Boolean?
    
    source: Listing<String>?
    
    status: Boolean?
    
}

/// Task class for utm_proxy_exception
class UtmProxyException extends Playbook.Task {

    /// todo doc
    `community.general.utm_proxy_exception`: Dynamic

    /// Options for community.general.utm_proxy_exception
    hidden options: UtmProxyExceptionOptions?

    /// todo doc
    function configure(): UtmProxyException = this
        .toMap()
        .put(
            "community.general.utm_proxy_exception",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(UtmProxyException)

}

/// Create, update or destroy reverse_proxy frontend entry in Sophos UTM
class UtmProxyFrontendOptions {
    
    add_content_type_header: Boolean?
    
    address: String?
    
    allowed_networks: Listing<String>?
    
    certificate: String?
    
    comment: String?
    
    disable_compression: Boolean?
    
    domain: Listing<String>?
    
    exceptions: Listing<String>?
    
    htmlrewrite: Boolean?
    
    htmlrewrite_cookies: Boolean?
    
    implicitredirect: Boolean?
    
    lbmethod: (""|"bybusyness"|"bytraffic"|"byrequests")?
    
    locations: Listing<String>?
    
    name: String
    
    port: Int?
    
    preservehost: Boolean?
    
    profile: String?
    
    status: Boolean?
    
    type: ("http"|"https")?
    
    xheaders: Boolean?
    
}

/// Task class for utm_proxy_frontend
class UtmProxyFrontend extends Playbook.Task {

    /// todo doc
    `community.general.utm_proxy_frontend`: Dynamic

    /// Options for community.general.utm_proxy_frontend
    hidden options: UtmProxyFrontendOptions?

    /// todo doc
    function configure(): UtmProxyFrontend = this
        .toMap()
        .put(
            "community.general.utm_proxy_frontend",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(UtmProxyFrontend)

}

/// Create, update or destroy reverse_proxy frontend entry in Sophos UTM
class UtmProxyFrontendInfoOptions {
    
    name: String
    
}

/// Task class for utm_proxy_frontend_info
class UtmProxyFrontendInfo extends Playbook.Task {

    /// todo doc
    `community.general.utm_proxy_frontend_info`: Dynamic

    /// Options for community.general.utm_proxy_frontend_info
    hidden options: UtmProxyFrontendInfoOptions?

    /// todo doc
    function configure(): UtmProxyFrontendInfo = this
        .toMap()
        .put(
            "community.general.utm_proxy_frontend_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(UtmProxyFrontendInfo)

}

/// Create, update or destroy reverse_proxy location entry in Sophos UTM
class UtmProxyLocationOptions {
    
    access_control: ("0"|"1")?
    
    allowed_networks: Listing<String>?
    
    auth_profile: String?
    
    backend: Listing<String>?
    
    be_path: String?
    
    comment: String?
    
    denied_networks: Listing<String>?
    
    hot_standby: Boolean?
    
    name: String
    
    path: String?
    
    status: Boolean?
    
    stickysession_id: String?
    
    stickysession_status: Boolean?
    
    websocket_passthrough: Boolean?
    
}

/// Task class for utm_proxy_location
class UtmProxyLocation extends Playbook.Task {

    /// todo doc
    `community.general.utm_proxy_location`: Dynamic

    /// Options for community.general.utm_proxy_location
    hidden options: UtmProxyLocationOptions?

    /// todo doc
    function configure(): UtmProxyLocation = this
        .toMap()
        .put(
            "community.general.utm_proxy_location",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(UtmProxyLocation)

}

/// Create, update or destroy reverse_proxy location entry in Sophos UTM
class UtmProxyLocationInfoOptions {
    
    name: String
    
}

/// Task class for utm_proxy_location_info
class UtmProxyLocationInfo extends Playbook.Task {

    /// todo doc
    `community.general.utm_proxy_location_info`: Dynamic

    /// Options for community.general.utm_proxy_location_info
    hidden options: UtmProxyLocationInfoOptions?

    /// todo doc
    function configure(): UtmProxyLocationInfo = this
        .toMap()
        .put(
            "community.general.utm_proxy_location_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(UtmProxyLocationInfo)

}

/// Module to control VDO
class VdoOptions {
    
    ackthreads: String?
    
    activated: Boolean?
    
    biothreads: String?
    
    blockmapcachesize: String?
    
    compression: ("disabled"|"enabled")?
    
    cputhreads: String?
    
    deduplication: ("disabled"|"enabled")?
    
    device: String?
    
    emulate512: Boolean?
    
    force: Boolean?
    
    growphysical: Boolean?
    
    indexmem: String?
    
    indexmode: ("dense"|"sparse")?
    
    logicalsize: String?
    
    logicalthreads: String?
    
    name: String
    
    physicalthreads: String?
    
    readcache: ("disabled"|"enabled")?
    
    readcachesize: String?
    
    running: Boolean?
    
    slabsize: String?
    
    state: ("absent"|"present")?
    
    writepolicy: ("async"|"auto"|"sync")?
    
}

/// Task class for vdo
class Vdo extends Playbook.Task {

    /// todo doc
    `community.general.vdo`: Dynamic

    /// Options for community.general.vdo
    hidden options: VdoOptions?

    /// todo doc
    function configure(): Vdo = this
        .toMap()
        .put(
            "community.general.vdo",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Vdo)

}

/// Updates Vertica configuration parameters
class VerticaConfigurationOptions {
    
    cluster: String?
    
    db: String?
    
    login_password: String?
    
    login_user: String?
    
    parameter: String
    
    port: String?
    
    value: String?
    
}

/// Task class for vertica_configuration
class VerticaConfiguration extends Playbook.Task {

    /// todo doc
    `community.general.vertica_configuration`: Dynamic

    /// Options for community.general.vertica_configuration
    hidden options: VerticaConfigurationOptions?

    /// todo doc
    function configure(): VerticaConfiguration = this
        .toMap()
        .put(
            "community.general.vertica_configuration",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(VerticaConfiguration)

}

/// Gathers Vertica database facts
class VerticaInfoOptions {
    
    cluster: String?
    
    db: String?
    
    login_password: String?
    
    login_user: String?
    
    port: String?
    
}

/// Task class for vertica_info
class VerticaInfo extends Playbook.Task {

    /// todo doc
    `community.general.vertica_info`: Dynamic

    /// Options for community.general.vertica_info
    hidden options: VerticaInfoOptions?

    /// todo doc
    function configure(): VerticaInfo = this
        .toMap()
        .put(
            "community.general.vertica_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(VerticaInfo)

}

/// Adds or removes Vertica database roles and assigns roles to them
class VerticaRoleOptions {
    
    assigned_roles: String?
    
    cluster: String?
    
    db: String?
    
    login_password: String?
    
    login_user: String?
    
    port: String?
    
    role: String
    
    state: ("present"|"absent")?
    
}

/// Task class for vertica_role
class VerticaRole extends Playbook.Task {

    /// todo doc
    `community.general.vertica_role`: Dynamic

    /// Options for community.general.vertica_role
    hidden options: VerticaRoleOptions?

    /// todo doc
    function configure(): VerticaRole = this
        .toMap()
        .put(
            "community.general.vertica_role",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(VerticaRole)

}

/// Adds or removes Vertica database schema and roles
class VerticaSchemaOptions {
    
    cluster: String?
    
    create_roles: String?
    
    db: String?
    
    login_password: String?
    
    login_user: String?
    
    owner: String?
    
    port: String?
    
    schema: String
    
    state: ("present"|"absent")?
    
    usage_roles: String?
    
}

/// Task class for vertica_schema
class VerticaSchema extends Playbook.Task {

    /// todo doc
    `community.general.vertica_schema`: Dynamic

    /// Options for community.general.vertica_schema
    hidden options: VerticaSchemaOptions?

    /// todo doc
    function configure(): VerticaSchema = this
        .toMap()
        .put(
            "community.general.vertica_schema",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(VerticaSchema)

}

/// Adds or removes Vertica database users and assigns roles
class VerticaUserOptions {
    
    cluster: String?
    
    db: String?
    
    expired: Boolean?
    
    ldap: Boolean?
    
    login_password: String?
    
    login_user: String?
    
    password: String?
    
    port: String?
    
    profile: String?
    
    resource_pool: String?
    
    roles: String?
    
    state: ("present"|"absent"|"locked")?
    
    user: String
    
}

/// Task class for vertica_user
class VerticaUser extends Playbook.Task {

    /// todo doc
    `community.general.vertica_user`: Dynamic

    /// Options for community.general.vertica_user
    hidden options: VerticaUserOptions?

    /// todo doc
    function configure(): VerticaUser = this
        .toMap()
        .put(
            "community.general.vertica_user",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(VerticaUser)

}

/// Manage export groups on Vexata VX100 storage arrays
class VexataEgOptions {
    
    ig: String?
    
    name: String
    
    pg: String?
    
    state: ("present"|"absent")?
    
    vg: String?
    
}

/// Task class for vexata_eg
class VexataEg extends Playbook.Task {

    /// todo doc
    `community.general.vexata_eg`: Dynamic

    /// Options for community.general.vexata_eg
    hidden options: VexataEgOptions?

    /// todo doc
    function configure(): VexataEg = this
        .toMap()
        .put(
            "community.general.vexata_eg",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(VexataEg)

}

/// Manage volumes on Vexata VX100 storage arrays
class VexataVolumeOptions {
    
    name: String
    
    size: String?
    
    state: ("present"|"absent")?
    
}

/// Task class for vexata_volume
class VexataVolume extends Playbook.Task {

    /// todo doc
    `community.general.vexata_volume`: Dynamic

    /// Options for community.general.vexata_volume
    hidden options: VexataVolumeOptions?

    /// todo doc
    function configure(): VexataVolume = this
        .toMap()
        .put(
            "community.general.vexata_volume",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(VexataVolume)

}

/// Manage SmartOS virtual machines and zones
class VmadmOptions {
    
    archive_on_delete: Boolean?
    
    autoboot: Boolean?
    
    boot: String?
    
    brand: ("joyent"|"joyent-minimal"|"lx"|"kvm"|"bhyve")?
    
    cpu_cap: Int?
    
    cpu_shares: Int?
    
    cpu_type: ("qemu64"|"host")?
    
    customer_metadata: Any?
    
    delegate_dataset: Boolean?
    
    disk_driver: String?
    
    disks: Listing<Any>?
    
    dns_domain: String?
    
    docker: Boolean?
    
    filesystems: Listing<Any>?
    
    firewall_enabled: Boolean?
    
    force: Boolean?
    
    fs_allowed: String?
    
    hostname: String?
    
    image_uuid: String?
    
    indestructible_delegated: Boolean?
    
    indestructible_zoneroot: Boolean?
    
    internal_metadata: Any?
    
    internal_metadata_namespace: String?
    
    kernel_version: String?
    
    limit_priv: String?
    
    maintain_resolvers: Boolean?
    
    max_locked_memory: Int?
    
    max_lwps: Int?
    
    max_physical_memory: Int?
    
    max_swap: Int?
    
    mdata_exec_timeout: Int?
    
    name: String?
    
    nic_driver: String?
    
    nics: Listing<Any>?
    
    nowait: Boolean?
    
    qemu_extra_opts: String?
    
    qemu_opts: String?
    
    quota: Int?
    
    ram: Int?
    
    resolvers: Listing<String>?
    
    routes: Any?
    
    spice_opts: String?
    
    spice_password: String?
    
    state: ("present"|"running"|"absent"|"deleted"|"stopped"|"created"|"restarted"|"rebooted")?
    
    tmpfs: Int?
    
    uuid: String?
    
    vcpus: Int?
    
    vga: String?
    
    virtio_txburst: Int?
    
    virtio_txtimer: Int?
    
    vnc_password: String?
    
    vnc_port: Int?
    
    zfs_data_compression: String?
    
    zfs_data_recsize: Int?
    
    zfs_filesystem_limit: Int?
    
    zfs_io_priority: Int?
    
    zfs_root_compression: String?
    
    zfs_root_recsize: Int?
    
    zfs_snapshot_limit: Int?
    
    zpool: String?
    
}

/// Task class for vmadm
class Vmadm extends Playbook.Task {

    /// todo doc
    `community.general.vmadm`: Dynamic

    /// Options for community.general.vmadm
    hidden options: VmadmOptions?

    /// todo doc
    function configure(): Vmadm = this
        .toMap()
        .put(
            "community.general.vmadm",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Vmadm)

}

/// Send a magic Wake-on-LAN (WoL) broadcast packet
class WakeonlanOptions {
    
    broadcast: String?
    
    mac: String
    
    port: Int?
    
}

/// Task class for wakeonlan
class Wakeonlan extends Playbook.Task {

    /// todo doc
    `community.general.wakeonlan`: Dynamic

    /// Options for community.general.wakeonlan
    hidden options: WakeonlanOptions?

    /// todo doc
    function configure(): Wakeonlan = this
        .toMap()
        .put(
            "community.general.wakeonlan",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Wakeonlan)

}

/// Manages WDC UltraStar Data102 Out-Of-Band controllers using Redfish APIs
class WdcRedfishCommandOptions {
    
    auth_token: String?
    
    baseuri: String?
    
    category: String
    
    command: Listing<String>
    
    ioms: Listing<String>?
    
    password: String?
    
    resource_id: String?
    
    timeout: Int?
    
    update_creds: Any?
    
    update_image_uri: String?
    
    username: String?
    
}

/// Task class for wdc_redfish_command
class WdcRedfishCommand extends Playbook.Task {

    /// todo doc
    `community.general.wdc_redfish_command`: Dynamic

    /// Options for community.general.wdc_redfish_command
    hidden options: WdcRedfishCommandOptions?

    /// todo doc
    function configure(): WdcRedfishCommand = this
        .toMap()
        .put(
            "community.general.wdc_redfish_command",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(WdcRedfishCommand)

}

/// Manages WDC UltraStar Data102 Out-Of-Band controllers using Redfish APIs
class WdcRedfishInfoOptions {
    
    auth_token: String?
    
    baseuri: String?
    
    category: String
    
    command: Listing<String>
    
    ioms: Listing<String>?
    
    password: String?
    
    timeout: Int?
    
    username: String?
    
}

/// Task class for wdc_redfish_info
class WdcRedfishInfo extends Playbook.Task {

    /// todo doc
    `community.general.wdc_redfish_info`: Dynamic

    /// Options for community.general.wdc_redfish_info
    hidden options: WdcRedfishInfoOptions?

    /// todo doc
    function configure(): WdcRedfishInfo = this
        .toMap()
        .put(
            "community.general.wdc_redfish_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(WdcRedfishInfo)

}

/// Add or remove applications on a Webfaction host
class WebfactionAppOptions {
    
    autostart: Boolean?
    
    extra_info: String?
    
    login_name: String
    
    login_password: String
    
    machine: String?
    
    name: String
    
    port_open: Boolean?
    
    state: ("present"|"absent")?
    
    type: String
    
}

/// Task class for webfaction_app
class WebfactionApp extends Playbook.Task {

    /// todo doc
    `community.general.webfaction_app`: Dynamic

    /// Options for community.general.webfaction_app
    hidden options: WebfactionAppOptions?

    /// todo doc
    function configure(): WebfactionApp = this
        .toMap()
        .put(
            "community.general.webfaction_app",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(WebfactionApp)

}

/// Add or remove a database on Webfaction
class WebfactionDbOptions {
    
    login_name: String
    
    login_password: String
    
    machine: String?
    
    name: String
    
    password: String?
    
    state: ("present"|"absent")?
    
    type: ("mysql"|"postgresql")
    
}

/// Task class for webfaction_db
class WebfactionDb extends Playbook.Task {

    /// todo doc
    `community.general.webfaction_db`: Dynamic

    /// Options for community.general.webfaction_db
    hidden options: WebfactionDbOptions?

    /// todo doc
    function configure(): WebfactionDb = this
        .toMap()
        .put(
            "community.general.webfaction_db",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(WebfactionDb)

}

/// Add or remove domains and subdomains on Webfaction
class WebfactionDomainOptions {
    
    login_name: String
    
    login_password: String
    
    name: String
    
    state: ("present"|"absent")?
    
    subdomains: Listing<String>?
    
}

/// Task class for webfaction_domain
class WebfactionDomain extends Playbook.Task {

    /// todo doc
    `community.general.webfaction_domain`: Dynamic

    /// Options for community.general.webfaction_domain
    hidden options: WebfactionDomainOptions?

    /// todo doc
    function configure(): WebfactionDomain = this
        .toMap()
        .put(
            "community.general.webfaction_domain",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(WebfactionDomain)

}

/// Add or remove mailboxes on Webfaction
class WebfactionMailboxOptions {
    
    login_name: String
    
    login_password: String
    
    mailbox_name: String
    
    mailbox_password: String
    
    state: ("present"|"absent")?
    
}

/// Task class for webfaction_mailbox
class WebfactionMailbox extends Playbook.Task {

    /// todo doc
    `community.general.webfaction_mailbox`: Dynamic

    /// Options for community.general.webfaction_mailbox
    hidden options: WebfactionMailboxOptions?

    /// todo doc
    function configure(): WebfactionMailbox = this
        .toMap()
        .put(
            "community.general.webfaction_mailbox",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(WebfactionMailbox)

}

/// Manage user defined extended attributes
class XattrOptions {
    
    follow: Boolean?
    
    key: String?
    
    namespace: String?
    
    path: String
    
    state: ("absent"|"all"|"keys"|"present"|"read")?
    
    value: String?
    
}

/// Task class for xattr
class Xattr extends Playbook.Task {

    /// todo doc
    `community.general.xattr`: Dynamic

    /// Options for community.general.xattr
    hidden options: XattrOptions?

    /// todo doc
    function configure(): Xattr = this
        .toMap()
        .put(
            "community.general.xattr",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Xattr)

}

/// Manage packages with XBPS
class XbpsOptions {
    
    name: Listing<String>?
    
    recurse: Boolean?
    
    state: ("present"|"absent"|"latest"|"installed"|"removed")?
    
    update_cache: Boolean?
    
    upgrade: Boolean?
    
    upgrade_xbps: Boolean?
    
}

/// Task class for xbps
class Xbps extends Playbook.Task {

    /// todo doc
    `community.general.xbps`: Dynamic

    /// Options for community.general.xbps
    hidden options: XbpsOptions?

    /// todo doc
    function configure(): Xbps = this
        .toMap()
        .put(
            "community.general.xbps",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Xbps)

}

/// Manages Lenovo Out-Of-Band controllers using Redfish APIs
class XccRedfishCommandOptions {
    
    auth_token: String?
    
    baseuri: String
    
    category: String
    
    command: Listing<String>
    
    password: String?
    
    request_body: Any?
    
    resource_id: String?
    
    resource_uri: String?
    
    timeout: Int?
    
    username: String?
    
    virtual_media: Any?
    
}

/// Task class for xcc_redfish_command
class XccRedfishCommand extends Playbook.Task {

    /// todo doc
    `community.general.xcc_redfish_command`: Dynamic

    /// Options for community.general.xcc_redfish_command
    hidden options: XccRedfishCommandOptions?

    /// todo doc
    function configure(): XccRedfishCommand = this
        .toMap()
        .put(
            "community.general.xcc_redfish_command",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(XccRedfishCommand)

}

/// Get facts reported on xenserver
class XenserverFactsOptions {
    
}

/// Task class for xenserver_facts
class XenserverFacts extends Playbook.Task {

    /// todo doc
    `community.general.xenserver_facts`: Dynamic

    /// Options for community.general.xenserver_facts
    hidden options: XenserverFactsOptions?

    /// todo doc
    function configure(): XenserverFacts = this
        .toMap()
        .put(
            "community.general.xenserver_facts",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(XenserverFacts)

}

/// Manages virtual machines running on Citrix Hypervisor/XenServer host or pool
class XenserverGuestOptions {
    
    cdrom: Any?
    
    custom_params: Listing<Any>?
    
    disks: Listing<Any>?
    
    folder: String?
    
    force: Boolean?
    
    hardware: Any?
    
    home_server: String?
    
    is_template: Boolean?
    
    linked_clone: Boolean?
    
    name: String?
    
    name_desc: String?
    
    networks: Listing<Any>?
    
    state: ("present"|"absent"|"poweredon")?
    
    state_change_timeout: Int?
    
    template: String?
    
    template_uuid: String?
    
    uuid: String?
    
    wait_for_ip_address: Boolean?
    
}

/// Task class for xenserver_guest
class XenserverGuest extends Playbook.Task {

    /// todo doc
    `community.general.xenserver_guest`: Dynamic

    /// Options for community.general.xenserver_guest
    hidden options: XenserverGuestOptions?

    /// todo doc
    function configure(): XenserverGuest = this
        .toMap()
        .put(
            "community.general.xenserver_guest",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(XenserverGuest)

}

/// Gathers information for virtual machines running on Citrix Hypervisor/XenServer host or pool
class XenserverGuestInfoOptions {
    
    name: String?
    
    uuid: String?
    
}

/// Task class for xenserver_guest_info
class XenserverGuestInfo extends Playbook.Task {

    /// todo doc
    `community.general.xenserver_guest_info`: Dynamic

    /// Options for community.general.xenserver_guest_info
    hidden options: XenserverGuestInfoOptions?

    /// todo doc
    function configure(): XenserverGuestInfo = this
        .toMap()
        .put(
            "community.general.xenserver_guest_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(XenserverGuestInfo)

}

/// Manages power states of virtual machines running on Citrix Hypervisor/XenServer host or pool
class XenserverGuestPowerstateOptions {
    
    name: String?
    
    state: ("powered-on"|"powered-off"|"restarted"|"shutdown-guest"|"reboot-guest"|"suspended"|"present")?
    
    state_change_timeout: Int?
    
    uuid: String?
    
    wait_for_ip_address: Boolean?
    
}

/// Task class for xenserver_guest_powerstate
class XenserverGuestPowerstate extends Playbook.Task {

    /// todo doc
    `community.general.xenserver_guest_powerstate`: Dynamic

    /// Options for community.general.xenserver_guest_powerstate
    hidden options: XenserverGuestPowerstateOptions?

    /// todo doc
    function configure(): XenserverGuestPowerstate = this
        .toMap()
        .put(
            "community.general.xenserver_guest_powerstate",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(XenserverGuestPowerstate)

}

/// Edit XFCE4 Configurations
class XfconfOptions {
    
    channel: String
    
    force_array: Boolean?
    
    property: String
    
    state: ("present"|"absent")?
    
    value: Listing<String>?
    
    value_type: Listing<("string"|"int"|"double"|"bool"|"uint"|"uchar"|"char"|"uint64"|"int64"|"float")>?
    
}

/// Task class for xfconf
class Xfconf extends Playbook.Task {

    /// todo doc
    `community.general.xfconf`: Dynamic

    /// Options for community.general.xfconf
    hidden options: XfconfOptions?

    /// todo doc
    function configure(): Xfconf = this
        .toMap()
        .put(
            "community.general.xfconf",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Xfconf)

}

/// Retrieve XFCE4 configurations
class XfconfInfoOptions {
    
    channel: String?
    
    property: String?
    
}

/// Task class for xfconf_info
class XfconfInfo extends Playbook.Task {

    /// todo doc
    `community.general.xfconf_info`: Dynamic

    /// Options for community.general.xfconf_info
    hidden options: XfconfInfoOptions?

    /// todo doc
    function configure(): XfconfInfo = this
        .toMap()
        .put(
            "community.general.xfconf_info",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(XfconfInfo)

}

/// Manage quotas on XFS filesystems
class XfsQuotaOptions {
    
    bhard: String?
    
    bsoft: String?
    
    ihard: Int?
    
    isoft: Int?
    
    mountpoint: String
    
    name: String?
    
    rtbhard: String?
    
    rtbsoft: String?
    
    state: ("present"|"absent")?
    
    type: ("user"|"group"|"project")
    
}

/// Task class for xfs_quota
class XfsQuota extends Playbook.Task {

    /// todo doc
    `community.general.xfs_quota`: Dynamic

    /// Options for community.general.xfs_quota
    hidden options: XfsQuotaOptions?

    /// todo doc
    function configure(): XfsQuota = this
        .toMap()
        .put(
            "community.general.xfs_quota",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(XfsQuota)

}

/// Manage bits and pieces of XML files or strings
class XmlOptions {
    
    add_children: Listing<String>?
    
    attribute: String?
    
    backup: Boolean?
    
    content: ("attribute"|"text")?
    
    count: Boolean?
    
    input_type: ("xml"|"yaml")?
    
    insertafter: Boolean?
    
    insertbefore: Boolean?
    
    namespaces: Any?
    
    path: String?
    
    pretty_print: Boolean?
    
    print_match: Boolean?
    
    set_children: Listing<String>?
    
    state: ("absent"|"present")?
    
    strip_cdata_tags: Boolean?
    
    value: String?
    
    xmlstring: String?
    
    xpath: String?
    
}

/// Task class for xml
class Xml extends Playbook.Task {

    /// todo doc
    `community.general.xml`: Dynamic

    /// Options for community.general.xml
    hidden options: XmlOptions?

    /// todo doc
    function configure(): Xml = this
        .toMap()
        .put(
            "community.general.xml",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Xml)

}

/// Manage node.js packages with Yarn
class YarnOptions {
    
    executable: String?
    
    global: Boolean?
    
    ignore_scripts: Boolean?
    
    name: String?
    
    path: String?
    
    production: Boolean?
    
    registry: String?
    
    state: ("present"|"absent"|"latest")?
    
    version: String?
    
}

/// Task class for yarn
class Yarn extends Playbook.Task {

    /// todo doc
    `community.general.yarn`: Dynamic

    /// Options for community.general.yarn
    hidden options: YarnOptions?

    /// todo doc
    function configure(): Yarn = this
        .toMap()
        .put(
            "community.general.yarn",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Yarn)

}

/// Locks / unlocks a installed package(s) from being updated by yum package manager
class YumVersionlockOptions {
    
    name: Listing<String>
    
    state: ("absent"|"present")?
    
}

/// Task class for yum_versionlock
class YumVersionlock extends Playbook.Task {

    /// todo doc
    `community.general.yum_versionlock`: Dynamic

    /// Options for community.general.yum_versionlock
    hidden options: YumVersionlockOptions?

    /// todo doc
    function configure(): YumVersionlock = this
        .toMap()
        .put(
            "community.general.yum_versionlock",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(YumVersionlock)

}

/// Manage zfs
class ZfsOptions {
    
    extra_zfs_properties: Any?
    
    name: String
    
    origin: String?
    
    state: ("absent"|"present")
    
}

/// Task class for zfs
class Zfs extends Playbook.Task {

    /// todo doc
    `community.general.zfs`: Dynamic

    /// Options for community.general.zfs
    hidden options: ZfsOptions?

    /// todo doc
    function configure(): Zfs = this
        .toMap()
        .put(
            "community.general.zfs",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Zfs)

}

/// Manage ZFS delegated administration (user admin privileges)
class ZfsDelegateAdminOptions {
    
    descendents: Boolean?
    
    everyone: Boolean?
    
    groups: Listing<String>?
    
    `local`: Boolean?
    
    name: String
    
    permissions: Listing<String>?
    
    recursive: Boolean?
    
    state: ("absent"|"present")?
    
    users: Listing<String>?
    
}

/// Task class for zfs_delegate_admin
class ZfsDelegateAdmin extends Playbook.Task {

    /// todo doc
    `community.general.zfs_delegate_admin`: Dynamic

    /// Options for community.general.zfs_delegate_admin
    hidden options: ZfsDelegateAdminOptions?

    /// todo doc
    function configure(): ZfsDelegateAdmin = this
        .toMap()
        .put(
            "community.general.zfs_delegate_admin",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ZfsDelegateAdmin)

}

/// Gather facts about ZFS datasets
class ZfsFactsOptions {
    
    depth: Int?
    
    name: String
    
    parsable: Boolean?
    
    properties: String?
    
    recurse: Boolean?
    
    type: ("all"|"filesystem"|"volume"|"snapshot"|"bookmark")?
    
}

/// Task class for zfs_facts
class ZfsFacts extends Playbook.Task {

    /// todo doc
    `community.general.zfs_facts`: Dynamic

    /// Options for community.general.zfs_facts
    hidden options: ZfsFactsOptions?

    /// todo doc
    function configure(): ZfsFacts = this
        .toMap()
        .put(
            "community.general.zfs_facts",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ZfsFacts)

}

/// Create, delete, retrieve, and update znodes using ZooKeeper
class ZnodeOptions {
    
    auth_credential: String?
    
    auth_scheme: ("digest"|"sasl")?
    
    hosts: String
    
    name: String
    
    op: ("get"|"wait"|"list")?
    
    recursive: Boolean?
    
    state: ("present"|"absent")?
    
    timeout: Int?
    
    use_tls: Boolean?
    
    value: String?
    
}

/// Task class for znode
class Znode extends Playbook.Task {

    /// todo doc
    `community.general.znode`: Dynamic

    /// Options for community.general.znode
    hidden options: ZnodeOptions?

    /// todo doc
    function configure(): Znode = this
        .toMap()
        .put(
            "community.general.znode",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Znode)

}

/// Gather facts about ZFS pools
class ZpoolFactsOptions {
    
    name: String?
    
    parsable: Boolean?
    
    properties: String?
    
}

/// Task class for zpool_facts
class ZpoolFacts extends Playbook.Task {

    /// todo doc
    `community.general.zpool_facts`: Dynamic

    /// Options for community.general.zpool_facts
    hidden options: ZpoolFactsOptions?

    /// todo doc
    function configure(): ZpoolFacts = this
        .toMap()
        .put(
            "community.general.zpool_facts",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ZpoolFacts)

}

/// Manage packages on SUSE and openSUSE
class ZypperOptions {
    
    allow_vendor_change: Boolean?
    
    clean_deps: Boolean?
    
    disable_gpg_check: Boolean?
    
    disable_recommends: Boolean?
    
    extra_args: String?
    
    extra_args_precommand: String?
    
    force: Boolean?
    
    force_resolution: Boolean?
    
    name: Listing<String>
    
    oldpackage: Boolean?
    
    replacefiles: Boolean?
    
    state: ("present"|"latest"|"absent"|"dist-upgrade"|"installed"|"removed")?
    
    type: ("package"|"patch"|"pattern"|"product"|"srcpackage"|"application")?
    
    update_cache: Boolean?
    
}

/// Task class for zypper
class Zypper extends Playbook.Task {

    /// todo doc
    `community.general.zypper`: Dynamic

    /// Options for community.general.zypper
    hidden options: ZypperOptions?

    /// todo doc
    function configure(): Zypper = this
        .toMap()
        .put(
            "community.general.zypper",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Zypper)

}

/// Add and remove Zypper repositories
class ZypperRepositoryOptions {
    
    auto_import_keys: Boolean?
    
    autorefresh: Boolean?
    
    description: String?
    
    disable_gpg_check: Boolean?
    
    enabled: Boolean?
    
    name: String?
    
    overwrite_multiple: Boolean?
    
    priority: Int?
    
    repo: String?
    
    runrefresh: Boolean?
    
    state: ("absent"|"present")?
    
}

/// Task class for zypper_repository
class ZypperRepository extends Playbook.Task {

    /// todo doc
    `community.general.zypper_repository`: Dynamic

    /// Options for community.general.zypper_repository
    hidden options: ZypperRepositoryOptions?

    /// todo doc
    function configure(): ZypperRepository = this
        .toMap()
        .put(
            "community.general.zypper_repository",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ZypperRepository)

}

