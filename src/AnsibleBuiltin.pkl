module AnsibleBuiltin

import "./Playbook.pkl"

/// Add a host (and alternatively a group) to the ansible-playbook in-memory inventory
class AddHostOptions {
    
    groups: Listing<String>?
    
    name: String
    
}

/// Task class for add_host
class AddHost extends Playbook.Task {

    /// todo doc
    `ansible.builtin.add_host`: Dynamic

    /// Options for ansible.builtin.add_host
    hidden options: AddHostOptions?

    /// todo doc
    function configure(): AddHost = this
        .toMap()
        .put(
            "ansible.builtin.add_host",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(AddHost)

}

/// Manages apt-packages
class AptOptions {
    
    allow_change_held_packages: Boolean?
    
    allow_downgrade: Boolean?
    
    allow_unauthenticated: Boolean?
    
    autoclean: Boolean?
    
    autoremove: Boolean?
    
    cache_valid_time: Int?
    
    clean: Boolean?
    
    deb: String?
    
    default_release: String?
    
    dpkg_options: String?
    
    fail_on_autoremove: Boolean?
    
    force: Boolean?
    
    force_apt_get: Boolean?
    
    install_recommends: Boolean?
    
    lock_timeout: Int?
    
    name: Listing<String>?
    
    only_upgrade: Boolean?
    
    policy_rc_d: Int?
    
    purge: Boolean?
    
    state: ("absent"|"build-dep"|"latest"|"present"|"fixed")?
    
    update_cache: Boolean?
    
    update_cache_retries: Int?
    
    update_cache_retry_max_delay: Int?
    
    upgrade: ("dist"|"full"|"no"|"safe"|"yes")?
    
}

/// Task class for apt
class Apt extends Playbook.Task {

    /// todo doc
    `ansible.builtin.apt`: Dynamic

    /// Options for ansible.builtin.apt
    hidden options: AptOptions?

    /// todo doc
    function configure(): Apt = this
        .toMap()
        .put(
            "ansible.builtin.apt",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Apt)

}

/// Add or remove an apt key
class AptKeyOptions {
    
    data: String?
    
    file: String?
    
    id: String?
    
    keyring: String?
    
    keyserver: String?
    
    state: ("absent"|"present")?
    
    url: String?
    
    validate_certs: Boolean?
    
}

/// Task class for apt_key
class AptKey extends Playbook.Task {

    /// todo doc
    `ansible.builtin.apt_key`: Dynamic

    /// Options for ansible.builtin.apt_key
    hidden options: AptKeyOptions?

    /// todo doc
    function configure(): AptKey = this
        .toMap()
        .put(
            "ansible.builtin.apt_key",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(AptKey)

}

/// Add and remove APT repositories
class AptRepositoryOptions {
    
    codename: String?
    
    filename: String?
    
    install_python_apt: Boolean?
    
    mode: String?
    
    repo: String
    
    state: ("absent"|"present")?
    
    update_cache: Boolean?
    
    update_cache_retries: Int?
    
    update_cache_retry_max_delay: Int?
    
    validate_certs: Boolean?
    
}

/// Task class for apt_repository
class AptRepository extends Playbook.Task {

    /// todo doc
    `ansible.builtin.apt_repository`: Dynamic

    /// Options for ansible.builtin.apt_repository
    hidden options: AptRepositoryOptions?

    /// todo doc
    function configure(): AptRepository = this
        .toMap()
        .put(
            "ansible.builtin.apt_repository",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(AptRepository)

}

/// Assemble configuration files from fragments
class AssembleOptions {
    
    backup: Boolean?
    
    delimiter: String?
    
    dest: String
    
    ignore_hidden: Boolean?
    
    regexp: String?
    
    remote_src: Boolean?
    
    src: String
    
    validate: String?
    
}

/// Task class for assemble
class Assemble extends Playbook.Task {

    /// todo doc
    `ansible.builtin.assemble`: Dynamic

    /// Options for ansible.builtin.assemble
    hidden options: AssembleOptions?

    /// todo doc
    function configure(): Assemble = this
        .toMap()
        .put(
            "ansible.builtin.assemble",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Assemble)

}

/// Asserts given expressions are true
class AssertOptions {
    
    fail_msg: String?
    
    quiet: Boolean?
    
    success_msg: String?
    
    that: Listing<String>
    
}

/// Task class for assert
class Assert extends Playbook.Task {

    /// todo doc
    `ansible.builtin.assert`: Dynamic

    /// Options for ansible.builtin.assert
    hidden options: AssertOptions?

    /// todo doc
    function configure(): Assert = this
        .toMap()
        .put(
            "ansible.builtin.assert",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Assert)

}

/// Obtain status of asynchronous task
class AsyncStatusOptions {
    
    jid: String
    
    mode: ("cleanup"|"status")?
    
}

/// Task class for async_status
class AsyncStatus extends Playbook.Task {

    /// todo doc
    `ansible.builtin.async_status`: Dynamic

    /// Options for ansible.builtin.async_status
    hidden options: AsyncStatusOptions?

    /// todo doc
    function configure(): AsyncStatus = this
        .toMap()
        .put(
            "ansible.builtin.async_status",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(AsyncStatus)

}

/// Insert/update/remove a text block surrounded by marker lines
class BlockinfileOptions {
    
    append_newline: Boolean?
    
    backup: Boolean?
    
    block: String?
    
    create: Boolean?
    
    insertafter: ("EOF"|"*regex*")?
    
    insertbefore: ("BOF"|"*regex*")?
    
    marker: String?
    
    marker_begin: String?
    
    marker_end: String?
    
    path: String
    
    prepend_newline: Boolean?
    
    state: ("absent"|"present")?
    
}

/// Task class for blockinfile
class Blockinfile extends Playbook.Task {

    /// todo doc
    `ansible.builtin.blockinfile`: Dynamic

    /// Options for ansible.builtin.blockinfile
    hidden options: BlockinfileOptions?

    /// todo doc
    function configure(): Blockinfile = this
        .toMap()
        .put(
            "ansible.builtin.blockinfile",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Blockinfile)

}

/// Execute commands on targets
class CommandOptions {
    
    argv: Listing<String>?
    
    chdir: String?
    
    cmd: String?
    
    creates: String?
    
    expand_argument_vars: Boolean?
    
    free_form: Any?
    
    removes: String?
    
    stdin: String?
    
    stdin_add_newline: Boolean?
    
    strip_empty_ends: Boolean?
    
}

/// Task class for command
class Command extends Playbook.Task {

    /// todo doc
    `ansible.builtin.command`: Dynamic

    /// Options for ansible.builtin.command
    hidden options: CommandOptions?

    /// todo doc
    function configure(): Command = this
        .toMap()
        .put(
            "ansible.builtin.command",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Command)

}

/// Copy files to remote locations
class CopyOptions {
    
    backup: Boolean?
    
    checksum: String?
    
    content: String?
    
    dest: String
    
    directory_mode: String?
    
    follow: Boolean?
    
    force: Boolean?
    
    local_follow: Boolean?
    
    mode: Any?
    
    remote_src: Boolean?
    
    src: String?
    
}

/// Task class for copy
class Copy extends Playbook.Task {

    /// todo doc
    `ansible.builtin.copy`: Dynamic

    /// Options for ansible.builtin.copy
    hidden options: CopyOptions?

    /// todo doc
    function configure(): Copy = this
        .toMap()
        .put(
            "ansible.builtin.copy",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Copy)

}

/// Manage cron.d and crontab entries
class CronOptions {
    
    backup: Boolean?
    
    cron_file: String?
    
    day: String?
    
    disabled: Boolean?
    
    env: Boolean?
    
    hour: String?
    
    insertafter: String?
    
    insertbefore: String?
    
    job: String?
    
    minute: String?
    
    month: String?
    
    name: String
    
    special_time: ("annually"|"daily"|"hourly"|"monthly"|"reboot"|"weekly"|"yearly")?
    
    state: ("absent"|"present")?
    
    user: String?
    
    weekday: String?
    
}

/// Task class for cron
class Cron extends Playbook.Task {

    /// todo doc
    `ansible.builtin.cron`: Dynamic

    /// Options for ansible.builtin.cron
    hidden options: CronOptions?

    /// todo doc
    function configure(): Cron = this
        .toMap()
        .put(
            "ansible.builtin.cron",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Cron)

}

/// Add and remove deb822 formatted repositories
class Deb822RepositoryOptions {
    
    allow_downgrade_to_insecure: Boolean?
    
    allow_insecure: Boolean?
    
    allow_weak: Boolean?
    
    architectures: Listing<String>?
    
    by_hash: Boolean?
    
    check_date: Boolean?
    
    check_valid_until: Boolean?
    
    components: Listing<String>?
    
    date_max_future: Int?
    
    enabled: Boolean?
    
    inrelease_path: String?
    
    languages: Listing<String>?
    
    mode: String?
    
    name: String
    
    pdiffs: Boolean?
    
    signed_by: String?
    
    state: ("absent"|"present")?
    
    suites: Listing<String>?
    
    targets: Listing<String>?
    
    trusted: Boolean?
    
    types: Listing<("deb"|"deb-src")>?
    
    uris: Listing<String>?
    
}

/// Task class for deb822_repository
class Deb822Repository extends Playbook.Task {

    /// todo doc
    `ansible.builtin.deb822_repository`: Dynamic

    /// Options for ansible.builtin.deb822_repository
    hidden options: Deb822RepositoryOptions?

    /// todo doc
    function configure(): Deb822Repository = this
        .toMap()
        .put(
            "ansible.builtin.deb822_repository",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Deb822Repository)

}

/// Configure a .deb package
class DebconfOptions {
    
    name: String
    
    question: String?
    
    unseen: Boolean?
    
    value: String?
    
    vtype: ("boolean"|"error"|"multiselect"|"note"|"password"|"seen"|"select"|"string"|"text"|"title")?
    
}

/// Task class for debconf
class Debconf extends Playbook.Task {

    /// todo doc
    `ansible.builtin.debconf`: Dynamic

    /// Options for ansible.builtin.debconf
    hidden options: DebconfOptions?

    /// todo doc
    function configure(): Debconf = this
        .toMap()
        .put(
            "ansible.builtin.debconf",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Debconf)

}

/// Print statements during execution
class DebugOptions {
    
    msg: String?
    
    var: String?
    
    verbosity: Int?
    
}

/// Task class for debug
class Debug extends Playbook.Task {

    /// todo doc
    `ansible.builtin.debug`: Dynamic

    /// Options for ansible.builtin.debug
    hidden options: DebugOptions?

    /// todo doc
    function configure(): Debug = this
        .toMap()
        .put(
            "ansible.builtin.debug",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Debug)

}

/// Manages packages with the I(dnf) package manager
class DnfOptions {
    
    allow_downgrade: Boolean?
    
    allowerasing: Boolean?
    
    autoremove: Boolean?
    
    bugfix: Boolean?
    
    cacheonly: Boolean?
    
    conf_file: String?
    
    disable_excludes: String?
    
    disable_gpg_check: Boolean?
    
    disable_plugin: Listing<String>?
    
    disablerepo: Listing<String>?
    
    download_dir: String?
    
    download_only: Boolean?
    
    enable_plugin: Listing<String>?
    
    enablerepo: Listing<String>?
    
    exclude: Listing<String>?
    
    install_repoquery: Boolean?
    
    install_weak_deps: Boolean?
    
    installroot: String?
    
    list: String?
    
    lock_timeout: Int?
    
    name: Listing<String>?
    
    nobest: Boolean?
    
    releasever: String?
    
    security: Boolean?
    
    skip_broken: Boolean?
    
    sslverify: Boolean?
    
    state: ("absent"|"present"|"installed"|"removed"|"latest")?
    
    update_cache: Boolean?
    
    update_only: Boolean?
    
    use_backend: ("auto"|"dnf4"|"dnf5")?
    
    validate_certs: Boolean?
    
}

/// Task class for dnf
class Dnf extends Playbook.Task {

    /// todo doc
    `ansible.builtin.dnf`: Dynamic

    /// Options for ansible.builtin.dnf
    hidden options: DnfOptions?

    /// todo doc
    function configure(): Dnf = this
        .toMap()
        .put(
            "ansible.builtin.dnf",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Dnf)

}

/// Manages packages with the I(dnf5) package manager
class Dnf5Options {
    
    allow_downgrade: Boolean?
    
    allowerasing: Boolean?
    
    autoremove: Boolean?
    
    bugfix: Boolean?
    
    cacheonly: Boolean?
    
    conf_file: String?
    
    disable_excludes: String?
    
    disable_gpg_check: Boolean?
    
    disable_plugin: Listing<String>?
    
    disablerepo: Listing<String>?
    
    download_dir: String?
    
    download_only: Boolean?
    
    enable_plugin: Listing<String>?
    
    enablerepo: Listing<String>?
    
    exclude: Listing<String>?
    
    install_repoquery: Boolean?
    
    install_weak_deps: Boolean?
    
    installroot: String?
    
    list: String?
    
    lock_timeout: Int?
    
    name: Listing<String>?
    
    nobest: Boolean?
    
    releasever: String?
    
    security: Boolean?
    
    skip_broken: Boolean?
    
    sslverify: Boolean?
    
    state: ("absent"|"present"|"installed"|"removed"|"latest")?
    
    update_cache: Boolean?
    
    update_only: Boolean?
    
    validate_certs: Boolean?
    
}

/// Task class for dnf5
class Dnf5 extends Playbook.Task {

    /// todo doc
    `ansible.builtin.dnf5`: Dynamic

    /// Options for ansible.builtin.dnf5
    hidden options: Dnf5Options?

    /// todo doc
    function configure(): Dnf5 = this
        .toMap()
        .put(
            "ansible.builtin.dnf5",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Dnf5)

}

/// Dpkg package selection selections
class DpkgSelectionsOptions {
    
    name: String
    
    selection: ("install"|"hold"|"deinstall"|"purge")
    
}

/// Task class for dpkg_selections
class DpkgSelections extends Playbook.Task {

    /// todo doc
    `ansible.builtin.dpkg_selections`: Dynamic

    /// Options for ansible.builtin.dpkg_selections
    hidden options: DpkgSelectionsOptions?

    /// todo doc
    function configure(): DpkgSelections = this
        .toMap()
        .put(
            "ansible.builtin.dpkg_selections",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(DpkgSelections)

}

/// Executes a command and responds to prompts
class ExpectOptions {
    
    chdir: String?
    
    command: String
    
    creates: String?
    
    echo: Boolean?
    
    removes: String?
    
    responses: Any
    
    timeout: String?
    
}

/// Task class for expect
class Expect extends Playbook.Task {

    /// todo doc
    `ansible.builtin.expect`: Dynamic

    /// Options for ansible.builtin.expect
    hidden options: ExpectOptions?

    /// todo doc
    function configure(): Expect = this
        .toMap()
        .put(
            "ansible.builtin.expect",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Expect)

}

/// Fail with custom message
class FailOptions {
    
    msg: String?
    
}

/// Task class for fail
class Fail extends Playbook.Task {

    /// todo doc
    `ansible.builtin.fail`: Dynamic

    /// Options for ansible.builtin.fail
    hidden options: FailOptions?

    /// todo doc
    function configure(): Fail = this
        .toMap()
        .put(
            "ansible.builtin.fail",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Fail)

}

/// Fetch files from remote nodes
class FetchOptions {
    
    dest: Any
    
    fail_on_missing: Boolean?
    
    flat: Boolean?
    
    src: Any
    
    validate_checksum: Boolean?
    
}

/// Task class for fetch
class Fetch extends Playbook.Task {

    /// todo doc
    `ansible.builtin.fetch`: Dynamic

    /// Options for ansible.builtin.fetch
    hidden options: FetchOptions?

    /// todo doc
    function configure(): Fetch = this
        .toMap()
        .put(
            "ansible.builtin.fetch",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Fetch)

}

/// Manage files and file properties
class FileOptions {
    
    access_time: String?
    
    access_time_format: String?
    
    follow: Boolean?
    
    force: Boolean?
    
    modification_time: String?
    
    modification_time_format: String?
    
    path: String
    
    recurse: Boolean?
    
    src: String?
    
    state: ("absent"|"directory"|"file"|"hard"|"link"|"touch")?
    
}

/// Task class for file
class File extends Playbook.Task {

    /// todo doc
    `ansible.builtin.file`: Dynamic

    /// Options for ansible.builtin.file
    hidden options: FileOptions?

    /// todo doc
    function configure(): File = this
        .toMap()
        .put(
            "ansible.builtin.file",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(File)

}

/// Return a list of files based on specific criteria
class FindOptions {
    
    age: String?
    
    age_stamp: ("atime"|"ctime"|"mtime")?
    
    contains: String?
    
    depth: Int?
    
    exact_mode: Boolean?
    
    excludes: Listing<String>?
    
    file_type: ("any"|"directory"|"file"|"link")?
    
    follow: Boolean?
    
    get_checksum: Boolean?
    
    `hidden`: Boolean?
    
    mode: String?
    
    paths: Listing<String>
    
    patterns: Listing<String>?
    
    read_whole_file: Boolean?
    
    recurse: Boolean?
    
    size: String?
    
    use_regex: Boolean?
    
}

/// Task class for find
class Find extends Playbook.Task {

    /// todo doc
    `ansible.builtin.find`: Dynamic

    /// Options for ansible.builtin.find
    hidden options: FindOptions?

    /// todo doc
    function configure(): Find = this
        .toMap()
        .put(
            "ansible.builtin.find",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Find)

}

/// Gathers facts about remote hosts
class GatherFactsOptions {
    
    parallel: Boolean?
    
}

/// Task class for gather_facts
class GatherFacts extends Playbook.Task {

    /// todo doc
    `ansible.builtin.gather_facts`: Dynamic

    /// Options for ansible.builtin.gather_facts
    hidden options: GatherFactsOptions?

    /// todo doc
    function configure(): GatherFacts = this
        .toMap()
        .put(
            "ansible.builtin.gather_facts",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GatherFacts)

}

/// Downloads files from HTTP, HTTPS, or FTP to node
class GetUrlOptions {
    
    backup: Boolean?
    
    checksum: String?
    
    ciphers: Listing<String>?
    
    client_cert: String?
    
    client_key: String?
    
    decompress: Boolean?
    
    dest: String
    
    force: Boolean?
    
    force_basic_auth: Boolean?
    
    headers: Any?
    
    http_agent: String?
    
    timeout: Int?
    
    tmp_dest: String?
    
    unredirected_headers: Listing<String>?
    
    url: String
    
    url_password: String?
    
    url_username: String?
    
    use_gssapi: Boolean?
    
    use_netrc: Boolean?
    
    use_proxy: Boolean?
    
    validate_certs: Boolean?
    
}

/// Task class for get_url
class GetUrl extends Playbook.Task {

    /// todo doc
    `ansible.builtin.get_url`: Dynamic

    /// Options for ansible.builtin.get_url
    hidden options: GetUrlOptions?

    /// todo doc
    function configure(): GetUrl = this
        .toMap()
        .put(
            "ansible.builtin.get_url",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GetUrl)

}

/// A wrapper to the unix getent utility
class GetentOptions {
    
    database: String
    
    fail_key: Boolean?
    
    key: String?
    
    service: String?
    
    split: String?
    
}

/// Task class for getent
class Getent extends Playbook.Task {

    /// todo doc
    `ansible.builtin.getent`: Dynamic

    /// Options for ansible.builtin.getent
    hidden options: GetentOptions?

    /// todo doc
    function configure(): Getent = this
        .toMap()
        .put(
            "ansible.builtin.getent",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Getent)

}

/// Deploy software (or files) from git checkouts
class GitOptions {
    
    accept_hostkey: Boolean?
    
    accept_newhostkey: Boolean?
    
    archive: String?
    
    archive_prefix: String?
    
    bare: Boolean?
    
    clone: Boolean?
    
    depth: Int?
    
    dest: String
    
    executable: String?
    
    force: Boolean?
    
    gpg_whitelist: Listing<String>?
    
    key_file: String?
    
    recursive: Boolean?
    
    reference: String?
    
    refspec: String?
    
    remote: String?
    
    repo: String
    
    separate_git_dir: String?
    
    single_branch: Boolean?
    
    ssh_opts: String?
    
    track_submodules: Boolean?
    
    umask: String?
    
    update: Boolean?
    
    verify_commit: Boolean?
    
    version: String?
    
}

/// Task class for git
class Git extends Playbook.Task {

    /// todo doc
    `ansible.builtin.git`: Dynamic

    /// Options for ansible.builtin.git
    hidden options: GitOptions?

    /// todo doc
    function configure(): Git = this
        .toMap()
        .put(
            "ansible.builtin.git",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Git)

}

/// Add or remove groups
class GroupOptions {
    
    force: Boolean?
    
    gid: Int?
    
    `local`: Boolean?
    
    name: String
    
    non_unique: Boolean?
    
    state: ("absent"|"present")?
    
    system: Boolean?
    
}

/// Task class for group
class Group extends Playbook.Task {

    /// todo doc
    `ansible.builtin.group`: Dynamic

    /// Options for ansible.builtin.group
    hidden options: GroupOptions?

    /// todo doc
    function configure(): Group = this
        .toMap()
        .put(
            "ansible.builtin.group",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Group)

}

/// Create Ansible groups based on facts
class GroupByOptions {
    
    key: String
    
    parents: Listing<String>?
    
}

/// Task class for group_by
class GroupBy extends Playbook.Task {

    /// todo doc
    `ansible.builtin.group_by`: Dynamic

    /// Options for ansible.builtin.group_by
    hidden options: GroupByOptions?

    /// todo doc
    function configure(): GroupBy = this
        .toMap()
        .put(
            "ansible.builtin.group_by",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(GroupBy)

}

/// Manage hostname
class HostnameOptions {
    
    name: String
    
    use: ("alpine"|"debian"|"freebsd"|"generic"|"macos"|"macosx"|"darwin"|"openbsd"|"openrc"|"redhat"|"sles"|"solaris"|"systemd")?
    
}

/// Task class for hostname
class Hostname extends Playbook.Task {

    /// todo doc
    `ansible.builtin.hostname`: Dynamic

    /// Options for ansible.builtin.hostname
    hidden options: HostnameOptions?

    /// todo doc
    function configure(): Hostname = this
        .toMap()
        .put(
            "ansible.builtin.hostname",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Hostname)

}

/// Import a playbook
class ImportPlaybookOptions {
    
    // free-form: Any?
    
    
}

/// Task class for import_playbook
class ImportPlaybook extends Playbook.Task {

    /// todo doc
    `ansible.builtin.import_playbook`: Dynamic

    /// Options for ansible.builtin.import_playbook
    hidden options: ImportPlaybookOptions?

    /// todo doc
    function configure(): ImportPlaybook = this
        .toMap()
        .put(
            "ansible.builtin.import_playbook",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ImportPlaybook)

}

/// Import a role into a play
class ImportRoleOptions {
    
    allow_duplicates: Boolean?
    
    defaults_from: String?
    
    handlers_from: String?
    
    name: String
    
    rolespec_validate: Boolean?
    
    tasks_from: String?
    
    vars_from: String?
    
}

/// Task class for import_role
class ImportRole extends Playbook.Task {

    /// todo doc
    `ansible.builtin.import_role`: Dynamic

    /// Options for ansible.builtin.import_role
    hidden options: ImportRoleOptions?

    /// todo doc
    function configure(): ImportRole = this
        .toMap()
        .put(
            "ansible.builtin.import_role",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ImportRole)

}

/// Import a task list
class ImportTasksOptions {
    
    file: String?
    
    // free-form: Any?
    
    
}

/// Task class for import_tasks
class ImportTasks extends Playbook.Task {

    /// todo doc
    `ansible.builtin.import_tasks`: Dynamic

    /// Options for ansible.builtin.import_tasks
    hidden options: ImportTasksOptions?

    /// todo doc
    function configure(): ImportTasks = this
        .toMap()
        .put(
            "ansible.builtin.import_tasks",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ImportTasks)

}

/// Load and execute a role
class IncludeRoleOptions {
    
    allow_duplicates: Boolean?
    
    apply: Any?
    
    defaults_from: String?
    
    handlers_from: String?
    
    name: String
    
    public: Boolean?
    
    rolespec_validate: Boolean?
    
    tasks_from: String?
    
    vars_from: String?
    
}

/// Task class for include_role
class IncludeRole extends Playbook.Task {

    /// todo doc
    `ansible.builtin.include_role`: Dynamic

    /// Options for ansible.builtin.include_role
    hidden options: IncludeRoleOptions?

    /// todo doc
    function configure(): IncludeRole = this
        .toMap()
        .put(
            "ansible.builtin.include_role",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IncludeRole)

}

/// Dynamically include a task list
class IncludeTasksOptions {
    
    apply: String?
    
    file: String?
    
    // free-form: Any?
    
    
}

/// Task class for include_tasks
class IncludeTasks extends Playbook.Task {

    /// todo doc
    `ansible.builtin.include_tasks`: Dynamic

    /// Options for ansible.builtin.include_tasks
    hidden options: IncludeTasksOptions?

    /// todo doc
    function configure(): IncludeTasks = this
        .toMap()
        .put(
            "ansible.builtin.include_tasks",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IncludeTasks)

}

/// Load variables from files, dynamically within a task
class IncludeVarsOptions {
    
    depth: Int?
    
    dir: String?
    
    extensions: Listing<String>?
    
    file: String?
    
    files_matching: String?
    
    // free-form: Any?
    
    
    hash_behaviour: ("replace"|"merge")?
    
    ignore_files: Listing<String>?
    
    ignore_unknown_extensions: Boolean?
    
    name: String?
    
}

/// Task class for include_vars
class IncludeVars extends Playbook.Task {

    /// todo doc
    `ansible.builtin.include_vars`: Dynamic

    /// Options for ansible.builtin.include_vars
    hidden options: IncludeVarsOptions?

    /// todo doc
    function configure(): IncludeVars = this
        .toMap()
        .put(
            "ansible.builtin.include_vars",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(IncludeVars)

}

/// Modify iptables rules
class IptablesOptions {
    
    action: ("append"|"insert")?
    
    chain: String?
    
    chain_management: Boolean?
    
    comment: String?
    
    ctstate: Listing<String>?
    
    destination: String?
    
    destination_port: String?
    
    destination_ports: Listing<String>?
    
    dst_range: String?
    
    flush: Boolean?
    
    fragment: String?
    
    gateway: String?
    
    gid_owner: String?
    
    goto: String?
    
    icmp_type: String?
    
    in_interface: String?
    
    ip_version: ("ipv4"|"ipv6")?
    
    jump: String?
    
    limit: String?
    
    limit_burst: String?
    
    log_level: ("0"|"1"|"2"|"3"|"4"|"5"|"6"|"7"|"emerg"|"alert"|"crit"|"error"|"warning"|"notice"|"info"|"debug")?
    
    log_prefix: String?
    
    match: Listing<String>?
    
    match_set: String?
    
    match_set_flags: ("src"|"dst"|"src,dst"|"dst,src")?
    
    numeric: Boolean?
    
    out_interface: String?
    
    policy: ("ACCEPT"|"DROP"|"QUEUE"|"RETURN")?
    
    protocol: String?
    
    reject_with: String?
    
    rule_num: String?
    
    set_counters: String?
    
    set_dscp_mark: String?
    
    set_dscp_mark_class: String?
    
    source: String?
    
    source_port: String?
    
    src_range: String?
    
    state: ("absent"|"present")?
    
    syn: ("ignore"|"match"|"negate")?
    
    table: ("filter"|"nat"|"mangle"|"raw"|"security")?
    
    tcp_flags: Any?
    
    to_destination: String?
    
    to_ports: String?
    
    to_source: String?
    
    uid_owner: String?
    
    wait: String?
    
}

/// Task class for iptables
class Iptables extends Playbook.Task {

    /// todo doc
    `ansible.builtin.iptables`: Dynamic

    /// Options for ansible.builtin.iptables
    hidden options: IptablesOptions?

    /// todo doc
    function configure(): Iptables = this
        .toMap()
        .put(
            "ansible.builtin.iptables",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Iptables)

}

/// Add or remove a host from the C(known_hosts) file
class KnownHostsOptions {
    
    hash_host: Boolean?
    
    key: String?
    
    name: String
    
    path: String?
    
    state: ("absent"|"present")?
    
}

/// Task class for known_hosts
class KnownHosts extends Playbook.Task {

    /// todo doc
    `ansible.builtin.known_hosts`: Dynamic

    /// Options for ansible.builtin.known_hosts
    hidden options: KnownHostsOptions?

    /// todo doc
    function configure(): KnownHosts = this
        .toMap()
        .put(
            "ansible.builtin.known_hosts",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(KnownHosts)

}

/// Manage lines in text files
class LineinfileOptions {
    
    backrefs: Boolean?
    
    backup: Boolean?
    
    create: Boolean?
    
    firstmatch: Boolean?
    
    insertafter: ("EOF"|"*regex*")?
    
    insertbefore: ("BOF"|"*regex*")?
    
    line: String?
    
    others: String?
    
    path: String
    
    regexp: String?
    
    search_string: String?
    
    state: ("absent"|"present")?
    
}

/// Task class for lineinfile
class Lineinfile extends Playbook.Task {

    /// todo doc
    `ansible.builtin.lineinfile`: Dynamic

    /// Options for ansible.builtin.lineinfile
    hidden options: LineinfileOptions?

    /// todo doc
    function configure(): Lineinfile = this
        .toMap()
        .put(
            "ansible.builtin.lineinfile",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Lineinfile)

}

/// Execute Ansible 'actions'
class MetaOptions {
    
    free_form: Any
    
}

/// Task class for meta
class Meta extends Playbook.Task {

    /// todo doc
    `ansible.builtin.meta`: Dynamic

    /// Options for ansible.builtin.meta
    hidden options: MetaOptions?

    /// todo doc
    function configure(): Meta = this
        .toMap()
        .put(
            "ansible.builtin.meta",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Meta)

}

/// Generic OS package manager
class PackageOptions {
    
    name: Any
    
    state: Any
    
    use: Any?
    
}

/// Task class for package
class Package extends Playbook.Task {

    /// todo doc
    `ansible.builtin.package`: Dynamic

    /// Options for ansible.builtin.package
    hidden options: PackageOptions?

    /// todo doc
    function configure(): Package = this
        .toMap()
        .put(
            "ansible.builtin.package",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Package)

}

/// Package information as facts
class PackageFactsOptions {
    
    manager: Listing<("auto"|"rpm"|"apt"|"portage"|"pkg"|"pacman"|"apk"|"pkg_info")>?
    
    strategy: ("first"|"all")?
    
}

/// Task class for package_facts
class PackageFacts extends Playbook.Task {

    /// todo doc
    `ansible.builtin.package_facts`: Dynamic

    /// Options for ansible.builtin.package_facts
    hidden options: PackageFactsOptions?

    /// todo doc
    function configure(): PackageFacts = this
        .toMap()
        .put(
            "ansible.builtin.package_facts",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(PackageFacts)

}

/// Pause playbook execution
class PauseOptions {
    
    echo: Boolean?
    
    minutes: Any?
    
    prompt: Any?
    
    seconds: Any?
    
}

/// Task class for pause
class Pause extends Playbook.Task {

    /// todo doc
    `ansible.builtin.pause`: Dynamic

    /// Options for ansible.builtin.pause
    hidden options: PauseOptions?

    /// todo doc
    function configure(): Pause = this
        .toMap()
        .put(
            "ansible.builtin.pause",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Pause)

}

/// Try to connect to host, verify a usable python and return V(pong) on success
class PingOptions {
    
    data: String?
    
}

/// Task class for ping
class Ping extends Playbook.Task {

    /// todo doc
    `ansible.builtin.ping`: Dynamic

    /// Options for ansible.builtin.ping
    hidden options: PingOptions?

    /// todo doc
    function configure(): Ping = this
        .toMap()
        .put(
            "ansible.builtin.ping",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Ping)

}

/// Manages Python library dependencies
class PipOptions {
    
    chdir: String?
    
    editable: Boolean?
    
    executable: String?
    
    extra_args: String?
    
    name: Listing<String>?
    
    requirements: String?
    
    state: ("absent"|"forcereinstall"|"latest"|"present")?
    
    umask: String?
    
    version: String?
    
    virtualenv: String?
    
    virtualenv_command: String?
    
    virtualenv_python: String?
    
    virtualenv_site_packages: Boolean?
    
}

/// Task class for pip
class Pip extends Playbook.Task {

    /// todo doc
    `ansible.builtin.pip`: Dynamic

    /// Options for ansible.builtin.pip
    hidden options: PipOptions?

    /// todo doc
    function configure(): Pip = this
        .toMap()
        .put(
            "ansible.builtin.pip",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Pip)

}

/// Executes a low-down and dirty command
class RawOptions {
    
    executable: Any?
    
    free_form: Any
    
}

/// Task class for raw
class Raw extends Playbook.Task {

    /// todo doc
    `ansible.builtin.raw`: Dynamic

    /// Options for ansible.builtin.raw
    hidden options: RawOptions?

    /// todo doc
    function configure(): Raw = this
        .toMap()
        .put(
            "ansible.builtin.raw",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Raw)

}

/// Reboot a machine
class RebootOptions {
    
    boot_time_command: String?
    
    connect_timeout: Int?
    
    msg: String?
    
    post_reboot_delay: Int?
    
    pre_reboot_delay: Int?
    
    reboot_command: String?
    
    reboot_timeout: Int?
    
    search_paths: Listing<String>?
    
    test_command: String?
    
}

/// Task class for reboot
class Reboot extends Playbook.Task {

    /// todo doc
    `ansible.builtin.reboot`: Dynamic

    /// Options for ansible.builtin.reboot
    hidden options: RebootOptions?

    /// todo doc
    function configure(): Reboot = this
        .toMap()
        .put(
            "ansible.builtin.reboot",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Reboot)

}

/// Replace all instances of a particular string in a file using a back-referenced regular expression
class ReplaceOptions {
    
    after: String?
    
    backup: Boolean?
    
    before: String?
    
    encoding: String?
    
    others: String?
    
    path: String
    
    regexp: String
    
    replace: String?
    
}

/// Task class for replace
class Replace extends Playbook.Task {

    /// todo doc
    `ansible.builtin.replace`: Dynamic

    /// Options for ansible.builtin.replace
    hidden options: ReplaceOptions?

    /// todo doc
    function configure(): Replace = this
        .toMap()
        .put(
            "ansible.builtin.replace",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Replace)

}

/// Adds or removes a gpg key from the rpm db
class RpmKeyOptions {
    
    fingerprint: String?
    
    key: String
    
    state: ("absent"|"present")?
    
    validate_certs: Boolean?
    
}

/// Task class for rpm_key
class RpmKey extends Playbook.Task {

    /// todo doc
    `ansible.builtin.rpm_key`: Dynamic

    /// Options for ansible.builtin.rpm_key
    hidden options: RpmKeyOptions?

    /// todo doc
    function configure(): RpmKey = this
        .toMap()
        .put(
            "ansible.builtin.rpm_key",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(RpmKey)

}

/// Runs a local script on a remote node after transferring it
class ScriptOptions {
    
    chdir: String?
    
    cmd: String?
    
    creates: String?
    
    executable: String?
    
    free_form: String?
    
    removes: String?
    
}

/// Task class for script
class Script extends Playbook.Task {

    /// todo doc
    `ansible.builtin.script`: Dynamic

    /// Options for ansible.builtin.script
    hidden options: ScriptOptions?

    /// todo doc
    function configure(): Script = this
        .toMap()
        .put(
            "ansible.builtin.script",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Script)

}

/// Manage services
class ServiceOptions {
    
    arguments: String?
    
    enabled: Boolean?
    
    name: String
    
    pattern: String?
    
    runlevel: String?
    
    sleep: Int?
    
    state: ("reloaded"|"restarted"|"started"|"stopped")?
    
    use: String?
    
}

/// Task class for service
class Service extends Playbook.Task {

    /// todo doc
    `ansible.builtin.service`: Dynamic

    /// Options for ansible.builtin.service
    hidden options: ServiceOptions?

    /// todo doc
    function configure(): Service = this
        .toMap()
        .put(
            "ansible.builtin.service",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Service)

}

/// Return service state information as fact data
class ServiceFactsOptions {
    
}

/// Task class for service_facts
class ServiceFacts extends Playbook.Task {

    /// todo doc
    `ansible.builtin.service_facts`: Dynamic

    /// Options for ansible.builtin.service_facts
    hidden options: ServiceFactsOptions?

    /// todo doc
    function configure(): ServiceFacts = this
        .toMap()
        .put(
            "ansible.builtin.service_facts",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ServiceFacts)

}

/// Set host variable(s) and fact(s).
class SetFactOptions {
    
    cacheable: Boolean?
    
    key_value: Any
    
}

/// Task class for set_fact
class SetFact extends Playbook.Task {

    /// todo doc
    `ansible.builtin.set_fact`: Dynamic

    /// Options for ansible.builtin.set_fact
    hidden options: SetFactOptions?

    /// todo doc
    function configure(): SetFact = this
        .toMap()
        .put(
            "ansible.builtin.set_fact",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(SetFact)

}

/// Define and display stats for the current ansible run
class SetStatsOptions {
    
    aggregate: Boolean?
    
    data: Any
    
    per_host: Boolean?
    
}

/// Task class for set_stats
class SetStats extends Playbook.Task {

    /// todo doc
    `ansible.builtin.set_stats`: Dynamic

    /// Options for ansible.builtin.set_stats
    hidden options: SetStatsOptions?

    /// todo doc
    function configure(): SetStats = this
        .toMap()
        .put(
            "ansible.builtin.set_stats",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(SetStats)

}

/// Gathers facts about remote hosts
class SetupOptions {
    
    fact_path: String?
    
    filter: Listing<String>?
    
    gather_subset: Listing<String>?
    
    gather_timeout: Int?
    
}

/// Task class for setup
class Setup extends Playbook.Task {

    /// todo doc
    `ansible.builtin.setup`: Dynamic

    /// Options for ansible.builtin.setup
    hidden options: SetupOptions?

    /// todo doc
    function configure(): Setup = this
        .toMap()
        .put(
            "ansible.builtin.setup",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Setup)

}

/// Execute shell commands on targets
class ShellOptions {
    
    chdir: String?
    
    cmd: String?
    
    creates: String?
    
    executable: String?
    
    free_form: String?
    
    removes: String?
    
    stdin: String?
    
    stdin_add_newline: Boolean?
    
}

/// Task class for shell
class Shell extends Playbook.Task {

    /// todo doc
    `ansible.builtin.shell`: Dynamic

    /// Options for ansible.builtin.shell
    hidden options: ShellOptions?

    /// todo doc
    function configure(): Shell = this
        .toMap()
        .put(
            "ansible.builtin.shell",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Shell)

}

/// Slurps a file from remote nodes
class SlurpOptions {
    
    src: String
    
}

/// Task class for slurp
class Slurp extends Playbook.Task {

    /// todo doc
    `ansible.builtin.slurp`: Dynamic

    /// Options for ansible.builtin.slurp
    hidden options: SlurpOptions?

    /// todo doc
    function configure(): Slurp = this
        .toMap()
        .put(
            "ansible.builtin.slurp",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Slurp)

}

/// Retrieve file or file system status
class StatOptions {
    
    checksum_algorithm: ("md5"|"sha1"|"sha224"|"sha256"|"sha384"|"sha512")?
    
    follow: Boolean?
    
    get_attributes: Boolean?
    
    get_checksum: Boolean?
    
    get_mime: Boolean?
    
    path: String
    
}

/// Task class for stat
class Stat extends Playbook.Task {

    /// todo doc
    `ansible.builtin.stat`: Dynamic

    /// Options for ansible.builtin.stat
    hidden options: StatOptions?

    /// todo doc
    function configure(): Stat = this
        .toMap()
        .put(
            "ansible.builtin.stat",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Stat)

}

/// Deploys a subversion repository
class SubversionOptions {
    
    checkout: Boolean?
    
    dest: String?
    
    executable: String?
    
    export: Boolean?
    
    force: Boolean?
    
    in_place: Boolean?
    
    password: String?
    
    repo: String
    
    revision: String?
    
    `switch`: Boolean?
    
    update: Boolean?
    
    username: String?
    
    validate_certs: Boolean?
    
}

/// Task class for subversion
class Subversion extends Playbook.Task {

    /// todo doc
    `ansible.builtin.subversion`: Dynamic

    /// Options for ansible.builtin.subversion
    hidden options: SubversionOptions?

    /// todo doc
    function configure(): Subversion = this
        .toMap()
        .put(
            "ansible.builtin.subversion",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Subversion)

}

/// Manage systemd units
class SystemdServiceOptions {
    
    daemon_reexec: Boolean?
    
    daemon_reload: Boolean?
    
    enabled: Boolean?
    
    force: Boolean?
    
    masked: Boolean?
    
    name: String?
    
    no_block: Boolean?
    
    scope: ("system"|"user"|"global")?
    
    state: ("reloaded"|"restarted"|"started"|"stopped")?
    
}

/// Task class for systemd_service
class SystemdService extends Playbook.Task {

    /// todo doc
    `ansible.builtin.systemd_service`: Dynamic

    /// Options for ansible.builtin.systemd_service
    hidden options: SystemdServiceOptions?

    /// todo doc
    function configure(): SystemdService = this
        .toMap()
        .put(
            "ansible.builtin.systemd_service",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(SystemdService)

}

/// Manage SysV services.
class SysvinitOptions {
    
    arguments: String?
    
    daemonize: Boolean?
    
    enabled: Boolean?
    
    name: String
    
    pattern: String?
    
    runlevels: Listing<String>?
    
    sleep: Int?
    
    state: ("started"|"stopped"|"restarted"|"reloaded")?
    
}

/// Task class for sysvinit
class Sysvinit extends Playbook.Task {

    /// todo doc
    `ansible.builtin.sysvinit`: Dynamic

    /// Options for ansible.builtin.sysvinit
    hidden options: SysvinitOptions?

    /// todo doc
    function configure(): Sysvinit = this
        .toMap()
        .put(
            "ansible.builtin.sysvinit",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Sysvinit)

}

/// Creates temporary files and directories
class TempfileOptions {
    
    path: String?
    
    prefix: String?
    
    state: ("directory"|"file")?
    
    suffix: String?
    
}

/// Task class for tempfile
class Tempfile extends Playbook.Task {

    /// todo doc
    `ansible.builtin.tempfile`: Dynamic

    /// Options for ansible.builtin.tempfile
    hidden options: TempfileOptions?

    /// todo doc
    function configure(): Tempfile = this
        .toMap()
        .put(
            "ansible.builtin.tempfile",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Tempfile)

}

/// Template a file out to a target host
class TemplateOptions {
    
    follow: Boolean?
    
}

/// Task class for template
class Template extends Playbook.Task {

    /// todo doc
    `ansible.builtin.template`: Dynamic

    /// Options for ansible.builtin.template
    hidden options: TemplateOptions?

    /// todo doc
    function configure(): Template = this
        .toMap()
        .put(
            "ansible.builtin.template",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Template)

}

/// Unpacks an archive after (optionally) copying it from the local machine
class UnarchiveOptions {
    
    copy: Boolean?
    
    creates: String?
    
    dest: String
    
    exclude: Listing<String>?
    
    extra_opts: Listing<String>?
    
    include: Listing<String>?
    
    io_buffer_size: Int?
    
    keep_newer: Boolean?
    
    list_files: Boolean?
    
    remote_src: Boolean?
    
    src: String
    
    validate_certs: Boolean?
    
}

/// Task class for unarchive
class Unarchive extends Playbook.Task {

    /// todo doc
    `ansible.builtin.unarchive`: Dynamic

    /// Options for ansible.builtin.unarchive
    hidden options: UnarchiveOptions?

    /// todo doc
    function configure(): Unarchive = this
        .toMap()
        .put(
            "ansible.builtin.unarchive",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Unarchive)

}

/// Interacts with webservices
class UriOptions {
    
    body: String?
    
    body_format: ("form-urlencoded"|"json"|"raw"|"form-multipart")?
    
    ca_path: String?
    
    ciphers: Listing<String>?
    
    client_cert: String?
    
    client_key: String?
    
    creates: String?
    
    decompress: Boolean?
    
    dest: String?
    
    follow_redirects: ("all"|"no"|"none"|"safe"|"urllib2"|"yes")?
    
    force: Boolean?
    
    force_basic_auth: Boolean?
    
    headers: Any?
    
    http_agent: String?
    
    method: String?
    
    remote_src: Boolean?
    
    removes: String?
    
    return_content: Boolean?
    
    src: String?
    
    status_code: Listing<Int>?
    
    timeout: Int?
    
    unix_socket: String?
    
    unredirected_headers: Listing<String>?
    
    url: String
    
    url_password: String?
    
    url_username: String?
    
    use_gssapi: Boolean?
    
    use_netrc: Boolean?
    
    use_proxy: Boolean?
    
    validate_certs: Boolean?
    
}

/// Task class for uri
class Uri extends Playbook.Task {

    /// todo doc
    `ansible.builtin.uri`: Dynamic

    /// Options for ansible.builtin.uri
    hidden options: UriOptions?

    /// todo doc
    function configure(): Uri = this
        .toMap()
        .put(
            "ansible.builtin.uri",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Uri)

}

/// Manage user accounts
class UserOptions {
    
    append: Boolean?
    
    authorization: String?
    
    comment: String?
    
    create_home: Boolean?
    
    expires: Any?
    
    force: Boolean?
    
    generate_ssh_key: Boolean?
    
    group: String?
    
    groups: Listing<String>?
    
    `hidden`: Boolean?
    
    home: String?
    
    `local`: Boolean?
    
    login_class: String?
    
    move_home: Boolean?
    
    name: String
    
    non_unique: Boolean?
    
    password: String?
    
    password_expire_max: Int?
    
    password_expire_min: Int?
    
    password_expire_warn: Int?
    
    password_lock: Boolean?
    
    profile: String?
    
    remove: Boolean?
    
    role: String?
    
    seuser: String?
    
    shell: String?
    
    skeleton: String?
    
    ssh_key_bits: Int?
    
    ssh_key_comment: String?
    
    ssh_key_file: String?
    
    ssh_key_passphrase: String?
    
    ssh_key_type: String?
    
    state: ("absent"|"present")?
    
    system: Boolean?
    
    uid: Int?
    
    umask: String?
    
    update_password: ("always"|"on_create")?
    
}

/// Task class for user
class User extends Playbook.Task {

    /// todo doc
    `ansible.builtin.user`: Dynamic

    /// Options for ansible.builtin.user
    hidden options: UserOptions?

    /// todo doc
    function configure(): User = this
        .toMap()
        .put(
            "ansible.builtin.user",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(User)

}

/// Validate role argument specs.
class ValidateArgumentSpecOptions {
    
    argument_spec: Any
    
    provided_arguments: Any?
    
}

/// Task class for validate_argument_spec
class ValidateArgumentSpec extends Playbook.Task {

    /// todo doc
    `ansible.builtin.validate_argument_spec`: Dynamic

    /// Options for ansible.builtin.validate_argument_spec
    hidden options: ValidateArgumentSpecOptions?

    /// todo doc
    function configure(): ValidateArgumentSpec = this
        .toMap()
        .put(
            "ansible.builtin.validate_argument_spec",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(ValidateArgumentSpec)

}

/// Waits for a condition before continuing
class WaitForOptions {
    
    active_connection_states: Listing<String>?
    
    connect_timeout: Int?
    
    delay: Int?
    
    exclude_hosts: Listing<String>?
    
    host: String?
    
    msg: String?
    
    path: String?
    
    port: Int?
    
    search_regex: String?
    
    sleep: Int?
    
    state: ("absent"|"drained"|"present"|"started"|"stopped")?
    
    timeout: Int?
    
}

/// Task class for wait_for
class WaitFor extends Playbook.Task {

    /// todo doc
    `ansible.builtin.wait_for`: Dynamic

    /// Options for ansible.builtin.wait_for
    hidden options: WaitForOptions?

    /// todo doc
    function configure(): WaitFor = this
        .toMap()
        .put(
            "ansible.builtin.wait_for",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(WaitFor)

}

/// Waits until remote system is reachable/usable
class WaitForConnectionOptions {
    
    connect_timeout: Int?
    
    delay: Int?
    
    sleep: Int?
    
    timeout: Int?
    
}

/// Task class for wait_for_connection
class WaitForConnection extends Playbook.Task {

    /// todo doc
    `ansible.builtin.wait_for_connection`: Dynamic

    /// Options for ansible.builtin.wait_for_connection
    hidden options: WaitForConnectionOptions?

    /// todo doc
    function configure(): WaitForConnection = this
        .toMap()
        .put(
            "ansible.builtin.wait_for_connection",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(WaitForConnection)

}

/// Manages packages with the I(yum) package manager
class YumOptions {
    
    allow_downgrade: Boolean?
    
    autoremove: Boolean?
    
    bugfix: Boolean?
    
    cacheonly: Boolean?
    
    conf_file: String?
    
    disable_excludes: String?
    
    disable_gpg_check: Boolean?
    
    disable_plugin: Listing<String>?
    
    disablerepo: Listing<String>?
    
    download_dir: String?
    
    download_only: Boolean?
    
    enable_plugin: Listing<String>?
    
    enablerepo: Listing<String>?
    
    exclude: Listing<String>?
    
    install_repoquery: Boolean?
    
    install_weak_deps: Boolean?
    
    installroot: String?
    
    list: String?
    
    lock_timeout: Int?
    
    name: Listing<String>?
    
    releasever: String?
    
    security: Boolean?
    
    skip_broken: Boolean?
    
    sslverify: Boolean?
    
    state: ("absent"|"installed"|"latest"|"present"|"removed")?
    
    update_cache: Boolean?
    
    update_only: Boolean?
    
    use_backend: ("auto"|"yum"|"yum4"|"dnf"|"dnf4"|"dnf5")?
    
    validate_certs: Boolean?
    
}

/// Task class for yum
class Yum extends Playbook.Task {

    /// todo doc
    `ansible.builtin.yum`: Dynamic

    /// Options for ansible.builtin.yum
    hidden options: YumOptions?

    /// todo doc
    function configure(): Yum = this
        .toMap()
        .put(
            "ansible.builtin.yum",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(Yum)

}

/// Add or remove YUM repositories
class YumRepositoryOptions {
    
    async: Boolean?
    
    bandwidth: String?
    
    baseurl: Listing<String>?
    
    cost: String?
    
    deltarpm_metadata_percentage: String?
    
    deltarpm_percentage: String?
    
    description: String?
    
    enabled: Boolean?
    
    enablegroups: Boolean?
    
    exclude: Listing<String>?
    
    failovermethod: ("roundrobin"|"priority")?
    
    file: String?
    
    gpgcakey: String?
    
    gpgcheck: Boolean?
    
    gpgkey: Listing<String>?
    
    http_caching: ("all"|"packages"|"none")?
    
    include: String?
    
    includepkgs: Listing<String>?
    
    ip_resolve: ("4"|"6"|"IPv4"|"IPv6"|"whatever")?
    
    keepalive: Boolean?
    
    keepcache: ("0"|"1")?
    
    metadata_expire: String?
    
    metadata_expire_filter: ("never"|"read-only:past"|"read-only:present"|"read-only:future")?
    
    metalink: String?
    
    mirrorlist: String?
    
    mirrorlist_expire: String?
    
    module_hotfixes: Boolean?
    
    name: String
    
    password: String?
    
    priority: String?
    
    protect: Boolean?
    
    proxy: String?
    
    proxy_password: String?
    
    proxy_username: String?
    
    repo_gpgcheck: Boolean?
    
    reposdir: String?
    
    retries: String?
    
    s3_enabled: Boolean?
    
    skip_if_unavailable: Boolean?
    
    ssl_check_cert_permissions: Boolean?
    
    sslcacert: String?
    
    sslclientcert: String?
    
    sslclientkey: String?
    
    sslverify: Boolean?
    
    state: ("absent"|"present")?
    
    throttle: String?
    
    timeout: String?
    
    ui_repoid_vars: String?
    
    username: String?
    
}

/// Task class for yum_repository
class YumRepository extends Playbook.Task {

    /// todo doc
    `ansible.builtin.yum_repository`: Dynamic

    /// Options for ansible.builtin.yum_repository
    hidden options: YumRepositoryOptions?

    /// todo doc
    function configure(): YumRepository = this
        .toMap()
        .put(
            "ansible.builtin.yum_repository",
            (this.options.ifNonNull((it) -> it.toDynamic()) ?? new Dynamic{})
                |> (this.options_mixin ?? new Mixin<Dynamic>{})
        )
        .toTyped(YumRepository)

}

