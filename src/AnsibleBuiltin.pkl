module AnsibleBuiltin

import "./Playbook.pkl"

// Add a host (and alternatively a group) to the ansible-playbook in-memory inventory
class AddHostOptions {
    
    groups: Listing<String>?
    
    name: String
    
}

// Task class for add_host
class AddHost extends Playbook.Task {

    hidden options: AddHostOptions

    `ansible.builtin.add_host`: AddHostOptions?

    function into(): AddHost = this
        .toMap()
        .put("ansible.builtin.add_host", this.options)
        .toTyped(AddHost)

}

// Manages apt-packages
class AptOptions {
    
    allow_change_held_packages: Boolean?
    
    allow_downgrade: Boolean?
    
    allow_unauthenticated: Boolean?
    
    autoclean: Boolean?
    
    autoremove: Boolean?
    
    cache_valid_time: Int?
    
    clean: Boolean?
    
    deb: String?
    
    default_release: String?
    
    dpkg_options: String?
    
    fail_on_autoremove: Boolean?
    
    force: Boolean?
    
    force_apt_get: Boolean?
    
    install_recommends: Boolean?
    
    lock_timeout: Int?
    
    name: Listing<String>?
    
    only_upgrade: Boolean?
    
    policy_rc_d: Int?
    
    purge: Boolean?
    
    state: ("absent"|"build-dep"|"latest"|"present"|"fixed")?
    
    update_cache: Boolean?
    
    update_cache_retries: Int?
    
    update_cache_retry_max_delay: Int?
    
    upgrade: ("dist"|"full"|"no"|"safe"|"yes")?
    
}

// Task class for apt
class Apt extends Playbook.Task {

    hidden options: AptOptions

    `ansible.builtin.apt`: AptOptions?

    function into(): Apt = this
        .toMap()
        .put("ansible.builtin.apt", this.options)
        .toTyped(Apt)

}

// Add or remove an apt key
class AptKeyOptions {
    
    data: String?
    
    file: String?
    
    id: String?
    
    keyring: String?
    
    keyserver: String?
    
    state: ("absent"|"present")?
    
    url: String?
    
    validate_certs: Boolean?
    
}

// Task class for apt_key
class AptKey extends Playbook.Task {

    hidden options: AptKeyOptions

    `ansible.builtin.apt_key`: AptKeyOptions?

    function into(): AptKey = this
        .toMap()
        .put("ansible.builtin.apt_key", this.options)
        .toTyped(AptKey)

}

// Add and remove APT repositories
class AptRepositoryOptions {
    
    codename: String?
    
    filename: String?
    
    install_python_apt: Boolean?
    
    mode: String?
    
    repo: String
    
    state: ("absent"|"present")?
    
    update_cache: Boolean?
    
    update_cache_retries: Int?
    
    update_cache_retry_max_delay: Int?
    
    validate_certs: Boolean?
    
}

// Task class for apt_repository
class AptRepository extends Playbook.Task {

    hidden options: AptRepositoryOptions

    `ansible.builtin.apt_repository`: AptRepositoryOptions?

    function into(): AptRepository = this
        .toMap()
        .put("ansible.builtin.apt_repository", this.options)
        .toTyped(AptRepository)

}

// Assemble configuration files from fragments
class AssembleOptions {
    
    backup: Boolean?
    
    delimiter: String?
    
    dest: String
    
    ignore_hidden: Boolean?
    
    regexp: String?
    
    remote_src: Boolean?
    
    src: String
    
    validate: String?
    
}

// Task class for assemble
class Assemble extends Playbook.Task {

    hidden options: AssembleOptions

    `ansible.builtin.assemble`: AssembleOptions?

    function into(): Assemble = this
        .toMap()
        .put("ansible.builtin.assemble", this.options)
        .toTyped(Assemble)

}

// Asserts given expressions are true
class AssertOptions {
    
    fail_msg: String?
    
    quiet: Boolean?
    
    success_msg: String?
    
    that: Listing<String>
    
}

// Task class for assert
class Assert extends Playbook.Task {

    hidden options: AssertOptions

    `ansible.builtin.assert`: AssertOptions?

    function into(): Assert = this
        .toMap()
        .put("ansible.builtin.assert", this.options)
        .toTyped(Assert)

}

// Obtain status of asynchronous task
class AsyncStatusOptions {
    
    jid: String
    
    mode: ("cleanup"|"status")?
    
}

// Task class for async_status
class AsyncStatus extends Playbook.Task {

    hidden options: AsyncStatusOptions

    `ansible.builtin.async_status`: AsyncStatusOptions?

    function into(): AsyncStatus = this
        .toMap()
        .put("ansible.builtin.async_status", this.options)
        .toTyped(AsyncStatus)

}

// Insert/update/remove a text block surrounded by marker lines
class BlockinfileOptions {
    
    append_newline: Boolean?
    
    backup: Boolean?
    
    block: String?
    
    create: Boolean?
    
    insertafter: ("EOF"|"*regex*")?
    
    insertbefore: ("BOF"|"*regex*")?
    
    marker: String?
    
    marker_begin: String?
    
    marker_end: String?
    
    path: String
    
    prepend_newline: Boolean?
    
    state: ("absent"|"present")?
    
}

// Task class for blockinfile
class Blockinfile extends Playbook.Task {

    hidden options: BlockinfileOptions

    `ansible.builtin.blockinfile`: BlockinfileOptions?

    function into(): Blockinfile = this
        .toMap()
        .put("ansible.builtin.blockinfile", this.options)
        .toTyped(Blockinfile)

}

// Execute commands on targets
class CommandOptions {
    
    argv: Listing<String>?
    
    chdir: String?
    
    cmd: String?
    
    creates: String?
    
    expand_argument_vars: Boolean?
    
    free_form: String?
    
    removes: String?
    
    stdin: String?
    
    stdin_add_newline: Boolean?
    
    strip_empty_ends: Boolean?
    
}

// Task class for command
class Command extends Playbook.Task {

    hidden options: CommandOptions

    `ansible.builtin.command`: CommandOptions?

    function into(): Command = this
        .toMap()
        .put("ansible.builtin.command", this.options)
        .toTyped(Command)

}

// Copy files to remote locations
class CopyOptions {
    
    backup: Boolean?
    
    checksum: String?
    
    content: String?
    
    dest: String
    
    directory_mode: String?
    
    follow: Boolean?
    
    force: Boolean?
    
    local_follow: Boolean?
    
    mode: String?
    
    remote_src: Boolean?
    
    src: String?
    
}

// Task class for copy
class Copy extends Playbook.Task {

    hidden options: CopyOptions

    `ansible.builtin.copy`: CopyOptions?

    function into(): Copy = this
        .toMap()
        .put("ansible.builtin.copy", this.options)
        .toTyped(Copy)

}

// Manage cron.d and crontab entries
class CronOptions {
    
    backup: Boolean?
    
    cron_file: String?
    
    day: String?
    
    disabled: Boolean?
    
    env: Boolean?
    
    hour: String?
    
    insertafter: String?
    
    insertbefore: String?
    
    job: String?
    
    minute: String?
    
    month: String?
    
    name: String
    
    special_time: ("annually"|"daily"|"hourly"|"monthly"|"reboot"|"weekly"|"yearly")?
    
    state: ("absent"|"present")?
    
    user: String?
    
    weekday: String?
    
}

// Task class for cron
class Cron extends Playbook.Task {

    hidden options: CronOptions

    `ansible.builtin.cron`: CronOptions?

    function into(): Cron = this
        .toMap()
        .put("ansible.builtin.cron", this.options)
        .toTyped(Cron)

}

// Add and remove deb822 formatted repositories
class Deb822RepositoryOptions {
    
    allow_downgrade_to_insecure: Boolean?
    
    allow_insecure: Boolean?
    
    allow_weak: Boolean?
    
    architectures: Listing<String>?
    
    by_hash: Boolean?
    
    check_date: Boolean?
    
    check_valid_until: Boolean?
    
    components: Listing<String>?
    
    date_max_future: Int?
    
    enabled: Boolean?
    
    inrelease_path: String?
    
    languages: Listing<String>?
    
    mode: String?
    
    name: String
    
    pdiffs: Boolean?
    
    signed_by: String?
    
    state: ("absent"|"present")?
    
    suites: Listing<String>?
    
    targets: Listing<String>?
    
    trusted: Boolean?
    
    types: Listing<("deb"|"deb-src")>?
    
    uris: Listing<String>?
    
}

// Task class for deb822_repository
class Deb822Repository extends Playbook.Task {

    hidden options: Deb822RepositoryOptions

    `ansible.builtin.deb822_repository`: Deb822RepositoryOptions?

    function into(): Deb822Repository = this
        .toMap()
        .put("ansible.builtin.deb822_repository", this.options)
        .toTyped(Deb822Repository)

}

// Configure a .deb package
class DebconfOptions {
    
    name: String
    
    question: String?
    
    unseen: Boolean?
    
    value: String?
    
    vtype: ("boolean"|"error"|"multiselect"|"note"|"password"|"seen"|"select"|"string"|"text"|"title")?
    
}

// Task class for debconf
class Debconf extends Playbook.Task {

    hidden options: DebconfOptions

    `ansible.builtin.debconf`: DebconfOptions?

    function into(): Debconf = this
        .toMap()
        .put("ansible.builtin.debconf", this.options)
        .toTyped(Debconf)

}

// Print statements during execution
class DebugOptions {
    
    msg: String?
    
    var: String?
    
    verbosity: Int?
    
}

// Task class for debug
class Debug extends Playbook.Task {

    hidden options: DebugOptions

    `ansible.builtin.debug`: DebugOptions?

    function into(): Debug = this
        .toMap()
        .put("ansible.builtin.debug", this.options)
        .toTyped(Debug)

}

// Manages packages with the I(dnf) package manager
class DnfOptions {
    
    allow_downgrade: Boolean?
    
    allowerasing: Boolean?
    
    autoremove: Boolean?
    
    bugfix: Boolean?
    
    cacheonly: Boolean?
    
    conf_file: String?
    
    disable_excludes: String?
    
    disable_gpg_check: Boolean?
    
    disable_plugin: Listing<String>?
    
    disablerepo: Listing<String>?
    
    download_dir: String?
    
    download_only: Boolean?
    
    enable_plugin: Listing<String>?
    
    enablerepo: Listing<String>?
    
    exclude: Listing<String>?
    
    install_repoquery: Boolean?
    
    install_weak_deps: Boolean?
    
    installroot: String?
    
    list: String?
    
    lock_timeout: Int?
    
    name: Listing<String>?
    
    nobest: Boolean?
    
    releasever: String?
    
    security: Boolean?
    
    skip_broken: Boolean?
    
    sslverify: Boolean?
    
    state: ("absent"|"present"|"installed"|"removed"|"latest")?
    
    update_cache: Boolean?
    
    update_only: Boolean?
    
    use_backend: ("auto"|"dnf4"|"dnf5")?
    
    validate_certs: Boolean?
    
}

// Task class for dnf
class Dnf extends Playbook.Task {

    hidden options: DnfOptions

    `ansible.builtin.dnf`: DnfOptions?

    function into(): Dnf = this
        .toMap()
        .put("ansible.builtin.dnf", this.options)
        .toTyped(Dnf)

}

// Manages packages with the I(dnf5) package manager
class Dnf5Options {
    
    allow_downgrade: Boolean?
    
    allowerasing: Boolean?
    
    autoremove: Boolean?
    
    bugfix: Boolean?
    
    cacheonly: Boolean?
    
    conf_file: String?
    
    disable_excludes: String?
    
    disable_gpg_check: Boolean?
    
    disable_plugin: Listing<String>?
    
    disablerepo: Listing<String>?
    
    download_dir: String?
    
    download_only: Boolean?
    
    enable_plugin: Listing<String>?
    
    enablerepo: Listing<String>?
    
    exclude: Listing<String>?
    
    install_repoquery: Boolean?
    
    install_weak_deps: Boolean?
    
    installroot: String?
    
    list: String?
    
    lock_timeout: Int?
    
    name: Listing<String>?
    
    nobest: Boolean?
    
    releasever: String?
    
    security: Boolean?
    
    skip_broken: Boolean?
    
    sslverify: Boolean?
    
    state: ("absent"|"present"|"installed"|"removed"|"latest")?
    
    update_cache: Boolean?
    
    update_only: Boolean?
    
    validate_certs: Boolean?
    
}

// Task class for dnf5
class Dnf5 extends Playbook.Task {

    hidden options: Dnf5Options

    `ansible.builtin.dnf5`: Dnf5Options?

    function into(): Dnf5 = this
        .toMap()
        .put("ansible.builtin.dnf5", this.options)
        .toTyped(Dnf5)

}

// Dpkg package selection selections
class DpkgSelectionsOptions {
    
    name: String
    
    selection: ("install"|"hold"|"deinstall"|"purge")
    
}

// Task class for dpkg_selections
class DpkgSelections extends Playbook.Task {

    hidden options: DpkgSelectionsOptions

    `ansible.builtin.dpkg_selections`: DpkgSelectionsOptions?

    function into(): DpkgSelections = this
        .toMap()
        .put("ansible.builtin.dpkg_selections", this.options)
        .toTyped(DpkgSelections)

}

// Executes a command and responds to prompts
class ExpectOptions {
    
    chdir: String?
    
    command: String
    
    creates: String?
    
    echo: Boolean?
    
    removes: String?
    
    responses: String
    
    timeout: String?
    
}

// Task class for expect
class Expect extends Playbook.Task {

    hidden options: ExpectOptions

    `ansible.builtin.expect`: ExpectOptions?

    function into(): Expect = this
        .toMap()
        .put("ansible.builtin.expect", this.options)
        .toTyped(Expect)

}

// Fail with custom message
class FailOptions {
    
    msg: String?
    
}

// Task class for fail
class Fail extends Playbook.Task {

    hidden options: FailOptions

    `ansible.builtin.fail`: FailOptions?

    function into(): Fail = this
        .toMap()
        .put("ansible.builtin.fail", this.options)
        .toTyped(Fail)

}

// Fetch files from remote nodes
class FetchOptions {
    
    dest: String
    
    fail_on_missing: Boolean?
    
    flat: Boolean?
    
    src: String
    
    validate_checksum: Boolean?
    
}

// Task class for fetch
class Fetch extends Playbook.Task {

    hidden options: FetchOptions

    `ansible.builtin.fetch`: FetchOptions?

    function into(): Fetch = this
        .toMap()
        .put("ansible.builtin.fetch", this.options)
        .toTyped(Fetch)

}

// Manage files and file properties
class FileOptions {
    
    access_time: String?
    
    access_time_format: String?
    
    follow: Boolean?
    
    force: Boolean?
    
    modification_time: String?
    
    modification_time_format: String?
    
    path: String
    
    recurse: Boolean?
    
    src: String?
    
    state: ("absent"|"directory"|"file"|"hard"|"link"|"touch")?
    
}

// Task class for file
class File extends Playbook.Task {

    hidden options: FileOptions

    `ansible.builtin.file`: FileOptions?

    function into(): File = this
        .toMap()
        .put("ansible.builtin.file", this.options)
        .toTyped(File)

}

// Return a list of files based on specific criteria
class FindOptions {
    
    age: String?
    
    age_stamp: ("atime"|"ctime"|"mtime")?
    
    contains: String?
    
    depth: Int?
    
    exact_mode: Boolean?
    
    excludes: Listing<String>?
    
    file_type: ("any"|"directory"|"file"|"link")?
    
    follow: Boolean?
    
    get_checksum: Boolean?
    
    `hidden`: Boolean?
    
    mode: String?
    
    paths: Listing<String>
    
    patterns: Listing<String>?
    
    read_whole_file: Boolean?
    
    recurse: Boolean?
    
    size: String?
    
    use_regex: Boolean?
    
}

// Task class for find
class Find extends Playbook.Task {

    hidden options: FindOptions

    `ansible.builtin.find`: FindOptions?

    function into(): Find = this
        .toMap()
        .put("ansible.builtin.find", this.options)
        .toTyped(Find)

}

// Gathers facts about remote hosts
class GatherFactsOptions {
    
    parallel: Boolean?
    
}

// Task class for gather_facts
class GatherFacts extends Playbook.Task {

    hidden options: GatherFactsOptions

    `ansible.builtin.gather_facts`: GatherFactsOptions?

    function into(): GatherFacts = this
        .toMap()
        .put("ansible.builtin.gather_facts", this.options)
        .toTyped(GatherFacts)

}

// Downloads files from HTTP, HTTPS, or FTP to node
class GetUrlOptions {
    
    backup: Boolean?
    
    checksum: String?
    
    ciphers: Listing<String>?
    
    client_cert: String?
    
    client_key: String?
    
    decompress: Boolean?
    
    dest: String
    
    force: Boolean?
    
    force_basic_auth: Boolean?
    
    headers: String?
    
    http_agent: String?
    
    timeout: Int?
    
    tmp_dest: String?
    
    unredirected_headers: Listing<String>?
    
    url: String
    
    url_password: String?
    
    url_username: String?
    
    use_gssapi: Boolean?
    
    use_netrc: Boolean?
    
    use_proxy: Boolean?
    
    validate_certs: Boolean?
    
}

// Task class for get_url
class GetUrl extends Playbook.Task {

    hidden options: GetUrlOptions

    `ansible.builtin.get_url`: GetUrlOptions?

    function into(): GetUrl = this
        .toMap()
        .put("ansible.builtin.get_url", this.options)
        .toTyped(GetUrl)

}

// A wrapper to the unix getent utility
class GetentOptions {
    
    database: String
    
    fail_key: Boolean?
    
    key: String?
    
    service: String?
    
    split: String?
    
}

// Task class for getent
class Getent extends Playbook.Task {

    hidden options: GetentOptions

    `ansible.builtin.getent`: GetentOptions?

    function into(): Getent = this
        .toMap()
        .put("ansible.builtin.getent", this.options)
        .toTyped(Getent)

}

// Deploy software (or files) from git checkouts
class GitOptions {
    
    accept_hostkey: Boolean?
    
    accept_newhostkey: Boolean?
    
    archive: String?
    
    archive_prefix: String?
    
    bare: Boolean?
    
    clone: Boolean?
    
    depth: Int?
    
    dest: String
    
    executable: String?
    
    force: Boolean?
    
    gpg_whitelist: Listing<String>?
    
    key_file: String?
    
    recursive: Boolean?
    
    reference: String?
    
    refspec: String?
    
    remote: String?
    
    repo: String
    
    separate_git_dir: String?
    
    single_branch: Boolean?
    
    ssh_opts: String?
    
    track_submodules: Boolean?
    
    umask: String?
    
    update: Boolean?
    
    verify_commit: Boolean?
    
    version: String?
    
}

// Task class for git
class Git extends Playbook.Task {

    hidden options: GitOptions

    `ansible.builtin.git`: GitOptions?

    function into(): Git = this
        .toMap()
        .put("ansible.builtin.git", this.options)
        .toTyped(Git)

}

// Add or remove groups
class GroupOptions {
    
    force: Boolean?
    
    gid: Int?
    
    `local`: Boolean?
    
    name: String
    
    non_unique: Boolean?
    
    state: ("absent"|"present")?
    
    system: Boolean?
    
}

// Task class for group
class Group extends Playbook.Task {

    hidden options: GroupOptions

    `ansible.builtin.group`: GroupOptions?

    function into(): Group = this
        .toMap()
        .put("ansible.builtin.group", this.options)
        .toTyped(Group)

}

// Create Ansible groups based on facts
class GroupByOptions {
    
    key: String
    
    parents: Listing<String>?
    
}

// Task class for group_by
class GroupBy extends Playbook.Task {

    hidden options: GroupByOptions

    `ansible.builtin.group_by`: GroupByOptions?

    function into(): GroupBy = this
        .toMap()
        .put("ansible.builtin.group_by", this.options)
        .toTyped(GroupBy)

}

// Manage hostname
class HostnameOptions {
    
    name: String
    
    use: ("alpine"|"debian"|"freebsd"|"generic"|"macos"|"macosx"|"darwin"|"openbsd"|"openrc"|"redhat"|"sles"|"solaris"|"systemd")?
    
}

// Task class for hostname
class Hostname extends Playbook.Task {

    hidden options: HostnameOptions

    `ansible.builtin.hostname`: HostnameOptions?

    function into(): Hostname = this
        .toMap()
        .put("ansible.builtin.hostname", this.options)
        .toTyped(Hostname)

}

// Import a playbook
class ImportPlaybookOptions {
    
    // free-form: String?
    
    
}

// Task class for import_playbook
class ImportPlaybook extends Playbook.Task {

    hidden options: ImportPlaybookOptions

    `ansible.builtin.import_playbook`: ImportPlaybookOptions?

    function into(): ImportPlaybook = this
        .toMap()
        .put("ansible.builtin.import_playbook", this.options)
        .toTyped(ImportPlaybook)

}

// Import a role into a play
class ImportRoleOptions {
    
    allow_duplicates: Boolean?
    
    defaults_from: String?
    
    handlers_from: String?
    
    name: String
    
    rolespec_validate: Boolean?
    
    tasks_from: String?
    
    vars_from: String?
    
}

// Task class for import_role
class ImportRole extends Playbook.Task {

    hidden options: ImportRoleOptions

    `ansible.builtin.import_role`: ImportRoleOptions?

    function into(): ImportRole = this
        .toMap()
        .put("ansible.builtin.import_role", this.options)
        .toTyped(ImportRole)

}

// Import a task list
class ImportTasksOptions {
    
    file: String?
    
    // free-form: String?
    
    
}

// Task class for import_tasks
class ImportTasks extends Playbook.Task {

    hidden options: ImportTasksOptions

    `ansible.builtin.import_tasks`: ImportTasksOptions?

    function into(): ImportTasks = this
        .toMap()
        .put("ansible.builtin.import_tasks", this.options)
        .toTyped(ImportTasks)

}

// Load and execute a role
class IncludeRoleOptions {
    
    allow_duplicates: Boolean?
    
    apply: String?
    
    defaults_from: String?
    
    handlers_from: String?
    
    name: String
    
    public: Boolean?
    
    rolespec_validate: Boolean?
    
    tasks_from: String?
    
    vars_from: String?
    
}

// Task class for include_role
class IncludeRole extends Playbook.Task {

    hidden options: IncludeRoleOptions

    `ansible.builtin.include_role`: IncludeRoleOptions?

    function into(): IncludeRole = this
        .toMap()
        .put("ansible.builtin.include_role", this.options)
        .toTyped(IncludeRole)

}

// Dynamically include a task list
class IncludeTasksOptions {
    
    apply: String?
    
    file: String?
    
    // free-form: String?
    
    
}

// Task class for include_tasks
class IncludeTasks extends Playbook.Task {

    hidden options: IncludeTasksOptions

    `ansible.builtin.include_tasks`: IncludeTasksOptions?

    function into(): IncludeTasks = this
        .toMap()
        .put("ansible.builtin.include_tasks", this.options)
        .toTyped(IncludeTasks)

}

// Load variables from files, dynamically within a task
class IncludeVarsOptions {
    
    depth: Int?
    
    dir: String?
    
    extensions: Listing<String>?
    
    file: String?
    
    files_matching: String?
    
    // free-form: String?
    
    
    hash_behaviour: ("replace"|"merge")?
    
    ignore_files: Listing<String>?
    
    ignore_unknown_extensions: Boolean?
    
    name: String?
    
}

// Task class for include_vars
class IncludeVars extends Playbook.Task {

    hidden options: IncludeVarsOptions

    `ansible.builtin.include_vars`: IncludeVarsOptions?

    function into(): IncludeVars = this
        .toMap()
        .put("ansible.builtin.include_vars", this.options)
        .toTyped(IncludeVars)

}

// Modify iptables rules
class IptablesOptions {
    
    action: ("append"|"insert")?
    
    chain: String?
    
    chain_management: Boolean?
    
    comment: String?
    
    ctstate: Listing<String>?
    
    destination: String?
    
    destination_port: String?
    
    destination_ports: Listing<String>?
    
    dst_range: String?
    
    flush: Boolean?
    
    fragment: String?
    
    gateway: String?
    
    gid_owner: String?
    
    goto: String?
    
    icmp_type: String?
    
    in_interface: String?
    
    ip_version: ("ipv4"|"ipv6")?
    
    jump: String?
    
    limit: String?
    
    limit_burst: String?
    
    log_level: ("0"|"1"|"2"|"3"|"4"|"5"|"6"|"7"|"emerg"|"alert"|"crit"|"error"|"warning"|"notice"|"info"|"debug")?
    
    log_prefix: String?
    
    match: Listing<String>?
    
    match_set: String?
    
    match_set_flags: ("src"|"dst"|"src,dst"|"dst,src")?
    
    numeric: Boolean?
    
    out_interface: String?
    
    policy: ("ACCEPT"|"DROP"|"QUEUE"|"RETURN")?
    
    protocol: String?
    
    reject_with: String?
    
    rule_num: String?
    
    set_counters: String?
    
    set_dscp_mark: String?
    
    set_dscp_mark_class: String?
    
    source: String?
    
    source_port: String?
    
    src_range: String?
    
    state: ("absent"|"present")?
    
    syn: ("ignore"|"match"|"negate")?
    
    table: ("filter"|"nat"|"mangle"|"raw"|"security")?
    
    tcp_flags: String?
    
    to_destination: String?
    
    to_ports: String?
    
    to_source: String?
    
    uid_owner: String?
    
    wait: String?
    
}

// Task class for iptables
class Iptables extends Playbook.Task {

    hidden options: IptablesOptions

    `ansible.builtin.iptables`: IptablesOptions?

    function into(): Iptables = this
        .toMap()
        .put("ansible.builtin.iptables", this.options)
        .toTyped(Iptables)

}

// Add or remove a host from the C(known_hosts) file
class KnownHostsOptions {
    
    hash_host: Boolean?
    
    key: String?
    
    name: String
    
    path: String?
    
    state: ("absent"|"present")?
    
}

// Task class for known_hosts
class KnownHosts extends Playbook.Task {

    hidden options: KnownHostsOptions

    `ansible.builtin.known_hosts`: KnownHostsOptions?

    function into(): KnownHosts = this
        .toMap()
        .put("ansible.builtin.known_hosts", this.options)
        .toTyped(KnownHosts)

}

// Manage lines in text files
class LineinfileOptions {
    
    backrefs: Boolean?
    
    backup: Boolean?
    
    create: Boolean?
    
    firstmatch: Boolean?
    
    insertafter: ("EOF"|"*regex*")?
    
    insertbefore: ("BOF"|"*regex*")?
    
    line: String?
    
    others: String?
    
    path: String
    
    regexp: String?
    
    search_string: String?
    
    state: ("absent"|"present")?
    
}

// Task class for lineinfile
class Lineinfile extends Playbook.Task {

    hidden options: LineinfileOptions

    `ansible.builtin.lineinfile`: LineinfileOptions?

    function into(): Lineinfile = this
        .toMap()
        .put("ansible.builtin.lineinfile", this.options)
        .toTyped(Lineinfile)

}

// Execute Ansible 'actions'
class MetaOptions {
    
    free_form: String
    
}

// Task class for meta
class Meta extends Playbook.Task {

    hidden options: MetaOptions

    `ansible.builtin.meta`: MetaOptions?

    function into(): Meta = this
        .toMap()
        .put("ansible.builtin.meta", this.options)
        .toTyped(Meta)

}

// Generic OS package manager
class PackageOptions {
    
    name: String
    
    state: String
    
    use: String?
    
}

// Task class for package
class Package extends Playbook.Task {

    hidden options: PackageOptions

    `ansible.builtin.package`: PackageOptions?

    function into(): Package = this
        .toMap()
        .put("ansible.builtin.package", this.options)
        .toTyped(Package)

}

// Package information as facts
class PackageFactsOptions {
    
    manager: Listing<("auto"|"rpm"|"apt"|"portage"|"pkg"|"pacman"|"apk"|"pkg_info")>?
    
    strategy: ("first"|"all")?
    
}

// Task class for package_facts
class PackageFacts extends Playbook.Task {

    hidden options: PackageFactsOptions

    `ansible.builtin.package_facts`: PackageFactsOptions?

    function into(): PackageFacts = this
        .toMap()
        .put("ansible.builtin.package_facts", this.options)
        .toTyped(PackageFacts)

}

// Pause playbook execution
class PauseOptions {
    
    echo: Boolean?
    
    minutes: String?
    
    prompt: String?
    
    seconds: String?
    
}

// Task class for pause
class Pause extends Playbook.Task {

    hidden options: PauseOptions

    `ansible.builtin.pause`: PauseOptions?

    function into(): Pause = this
        .toMap()
        .put("ansible.builtin.pause", this.options)
        .toTyped(Pause)

}

// Try to connect to host, verify a usable python and return V(pong) on success
class PingOptions {
    
    data: String?
    
}

// Task class for ping
class Ping extends Playbook.Task {

    hidden options: PingOptions

    `ansible.builtin.ping`: PingOptions?

    function into(): Ping = this
        .toMap()
        .put("ansible.builtin.ping", this.options)
        .toTyped(Ping)

}

// Manages Python library dependencies
class PipOptions {
    
    chdir: String?
    
    editable: Boolean?
    
    executable: String?
    
    extra_args: String?
    
    name: Listing<String>?
    
    requirements: String?
    
    state: ("absent"|"forcereinstall"|"latest"|"present")?
    
    umask: String?
    
    version: String?
    
    virtualenv: String?
    
    virtualenv_command: String?
    
    virtualenv_python: String?
    
    virtualenv_site_packages: Boolean?
    
}

// Task class for pip
class Pip extends Playbook.Task {

    hidden options: PipOptions

    `ansible.builtin.pip`: PipOptions?

    function into(): Pip = this
        .toMap()
        .put("ansible.builtin.pip", this.options)
        .toTyped(Pip)

}

// Executes a low-down and dirty command
class RawOptions {
    
    executable: String?
    
    free_form: String
    
}

// Task class for raw
class Raw extends Playbook.Task {

    hidden options: RawOptions

    `ansible.builtin.raw`: RawOptions?

    function into(): Raw = this
        .toMap()
        .put("ansible.builtin.raw", this.options)
        .toTyped(Raw)

}

// Reboot a machine
class RebootOptions {
    
    boot_time_command: String?
    
    connect_timeout: Int?
    
    msg: String?
    
    post_reboot_delay: Int?
    
    pre_reboot_delay: Int?
    
    reboot_command: String?
    
    reboot_timeout: Int?
    
    search_paths: Listing<String>?
    
    test_command: String?
    
}

// Task class for reboot
class Reboot extends Playbook.Task {

    hidden options: RebootOptions

    `ansible.builtin.reboot`: RebootOptions?

    function into(): Reboot = this
        .toMap()
        .put("ansible.builtin.reboot", this.options)
        .toTyped(Reboot)

}

// Replace all instances of a particular string in a file using a back-referenced regular expression
class ReplaceOptions {
    
    after: String?
    
    backup: Boolean?
    
    before: String?
    
    encoding: String?
    
    others: String?
    
    path: String
    
    regexp: String
    
    replace: String?
    
}

// Task class for replace
class Replace extends Playbook.Task {

    hidden options: ReplaceOptions

    `ansible.builtin.replace`: ReplaceOptions?

    function into(): Replace = this
        .toMap()
        .put("ansible.builtin.replace", this.options)
        .toTyped(Replace)

}

// Adds or removes a gpg key from the rpm db
class RpmKeyOptions {
    
    fingerprint: String?
    
    key: String
    
    state: ("absent"|"present")?
    
    validate_certs: Boolean?
    
}

// Task class for rpm_key
class RpmKey extends Playbook.Task {

    hidden options: RpmKeyOptions

    `ansible.builtin.rpm_key`: RpmKeyOptions?

    function into(): RpmKey = this
        .toMap()
        .put("ansible.builtin.rpm_key", this.options)
        .toTyped(RpmKey)

}

// Runs a local script on a remote node after transferring it
class ScriptOptions {
    
    chdir: String?
    
    cmd: String?
    
    creates: String?
    
    executable: String?
    
    free_form: String?
    
    removes: String?
    
}

// Task class for script
class Script extends Playbook.Task {

    hidden options: ScriptOptions

    `ansible.builtin.script`: ScriptOptions?

    function into(): Script = this
        .toMap()
        .put("ansible.builtin.script", this.options)
        .toTyped(Script)

}

// Manage services
class ServiceOptions {
    
    arguments: String?
    
    enabled: Boolean?
    
    name: String
    
    pattern: String?
    
    runlevel: String?
    
    sleep: Int?
    
    state: ("reloaded"|"restarted"|"started"|"stopped")?
    
    use: String?
    
}

// Task class for service
class Service extends Playbook.Task {

    hidden options: ServiceOptions

    `ansible.builtin.service`: ServiceOptions?

    function into(): Service = this
        .toMap()
        .put("ansible.builtin.service", this.options)
        .toTyped(Service)

}

// Return service state information as fact data
class ServiceFactsOptions {
    
}

// Task class for service_facts
class ServiceFacts extends Playbook.Task {

    hidden options: ServiceFactsOptions

    `ansible.builtin.service_facts`: ServiceFactsOptions?

    function into(): ServiceFacts = this
        .toMap()
        .put("ansible.builtin.service_facts", this.options)
        .toTyped(ServiceFacts)

}

// Set host variable(s) and fact(s).
class SetFactOptions {
    
    cacheable: Boolean?
    
    key_value: String
    
}

// Task class for set_fact
class SetFact extends Playbook.Task {

    hidden options: SetFactOptions

    `ansible.builtin.set_fact`: SetFactOptions?

    function into(): SetFact = this
        .toMap()
        .put("ansible.builtin.set_fact", this.options)
        .toTyped(SetFact)

}

// Define and display stats for the current ansible run
class SetStatsOptions {
    
    aggregate: Boolean?
    
    data: String
    
    per_host: Boolean?
    
}

// Task class for set_stats
class SetStats extends Playbook.Task {

    hidden options: SetStatsOptions

    `ansible.builtin.set_stats`: SetStatsOptions?

    function into(): SetStats = this
        .toMap()
        .put("ansible.builtin.set_stats", this.options)
        .toTyped(SetStats)

}

// Gathers facts about remote hosts
class SetupOptions {
    
    fact_path: String?
    
    filter: Listing<String>?
    
    gather_subset: Listing<String>?
    
    gather_timeout: Int?
    
}

// Task class for setup
class Setup extends Playbook.Task {

    hidden options: SetupOptions

    `ansible.builtin.setup`: SetupOptions?

    function into(): Setup = this
        .toMap()
        .put("ansible.builtin.setup", this.options)
        .toTyped(Setup)

}

// Execute shell commands on targets
class ShellOptions {
    
    chdir: String?
    
    cmd: String?
    
    creates: String?
    
    executable: String?
    
    free_form: String?
    
    removes: String?
    
    stdin: String?
    
    stdin_add_newline: Boolean?
    
}

// Task class for shell
class Shell extends Playbook.Task {

    hidden options: ShellOptions

    `ansible.builtin.shell`: ShellOptions?

    function into(): Shell = this
        .toMap()
        .put("ansible.builtin.shell", this.options)
        .toTyped(Shell)

}

// Slurps a file from remote nodes
class SlurpOptions {
    
    src: String
    
}

// Task class for slurp
class Slurp extends Playbook.Task {

    hidden options: SlurpOptions

    `ansible.builtin.slurp`: SlurpOptions?

    function into(): Slurp = this
        .toMap()
        .put("ansible.builtin.slurp", this.options)
        .toTyped(Slurp)

}

// Retrieve file or file system status
class StatOptions {
    
    checksum_algorithm: ("md5"|"sha1"|"sha224"|"sha256"|"sha384"|"sha512")?
    
    follow: Boolean?
    
    get_attributes: Boolean?
    
    get_checksum: Boolean?
    
    get_mime: Boolean?
    
    path: String
    
}

// Task class for stat
class Stat extends Playbook.Task {

    hidden options: StatOptions

    `ansible.builtin.stat`: StatOptions?

    function into(): Stat = this
        .toMap()
        .put("ansible.builtin.stat", this.options)
        .toTyped(Stat)

}

// Deploys a subversion repository
class SubversionOptions {
    
    checkout: Boolean?
    
    dest: String?
    
    executable: String?
    
    export: Boolean?
    
    force: Boolean?
    
    in_place: Boolean?
    
    password: String?
    
    repo: String
    
    revision: String?
    
    `switch`: Boolean?
    
    update: Boolean?
    
    username: String?
    
    validate_certs: Boolean?
    
}

// Task class for subversion
class Subversion extends Playbook.Task {

    hidden options: SubversionOptions

    `ansible.builtin.subversion`: SubversionOptions?

    function into(): Subversion = this
        .toMap()
        .put("ansible.builtin.subversion", this.options)
        .toTyped(Subversion)

}

// Manage systemd units
class SystemdServiceOptions {
    
    daemon_reexec: Boolean?
    
    daemon_reload: Boolean?
    
    enabled: Boolean?
    
    force: Boolean?
    
    masked: Boolean?
    
    name: String?
    
    no_block: Boolean?
    
    scope: ("system"|"user"|"global")?
    
    state: ("reloaded"|"restarted"|"started"|"stopped")?
    
}

// Task class for systemd_service
class SystemdService extends Playbook.Task {

    hidden options: SystemdServiceOptions

    `ansible.builtin.systemd_service`: SystemdServiceOptions?

    function into(): SystemdService = this
        .toMap()
        .put("ansible.builtin.systemd_service", this.options)
        .toTyped(SystemdService)

}

// Manage SysV services.
class SysvinitOptions {
    
    arguments: String?
    
    daemonize: Boolean?
    
    enabled: Boolean?
    
    name: String
    
    pattern: String?
    
    runlevels: Listing<String>?
    
    sleep: Int?
    
    state: ("started"|"stopped"|"restarted"|"reloaded")?
    
}

// Task class for sysvinit
class Sysvinit extends Playbook.Task {

    hidden options: SysvinitOptions

    `ansible.builtin.sysvinit`: SysvinitOptions?

    function into(): Sysvinit = this
        .toMap()
        .put("ansible.builtin.sysvinit", this.options)
        .toTyped(Sysvinit)

}

// Creates temporary files and directories
class TempfileOptions {
    
    path: String?
    
    prefix: String?
    
    state: ("directory"|"file")?
    
    suffix: String?
    
}

// Task class for tempfile
class Tempfile extends Playbook.Task {

    hidden options: TempfileOptions

    `ansible.builtin.tempfile`: TempfileOptions?

    function into(): Tempfile = this
        .toMap()
        .put("ansible.builtin.tempfile", this.options)
        .toTyped(Tempfile)

}

// Template a file out to a target host
class TemplateOptions {
    
    follow: Boolean?
    
}

// Task class for template
class Template extends Playbook.Task {

    hidden options: TemplateOptions

    `ansible.builtin.template`: TemplateOptions?

    function into(): Template = this
        .toMap()
        .put("ansible.builtin.template", this.options)
        .toTyped(Template)

}

// Unpacks an archive after (optionally) copying it from the local machine
class UnarchiveOptions {
    
    copy: Boolean?
    
    creates: String?
    
    dest: String
    
    exclude: Listing<String>?
    
    extra_opts: Listing<String>?
    
    include: Listing<String>?
    
    io_buffer_size: Int?
    
    keep_newer: Boolean?
    
    list_files: Boolean?
    
    remote_src: Boolean?
    
    src: String
    
    validate_certs: Boolean?
    
}

// Task class for unarchive
class Unarchive extends Playbook.Task {

    hidden options: UnarchiveOptions

    `ansible.builtin.unarchive`: UnarchiveOptions?

    function into(): Unarchive = this
        .toMap()
        .put("ansible.builtin.unarchive", this.options)
        .toTyped(Unarchive)

}

// Interacts with webservices
class UriOptions {
    
    body: String?
    
    body_format: ("form-urlencoded"|"json"|"raw"|"form-multipart")?
    
    ca_path: String?
    
    ciphers: Listing<String>?
    
    client_cert: String?
    
    client_key: String?
    
    creates: String?
    
    decompress: Boolean?
    
    dest: String?
    
    follow_redirects: ("all"|"no"|"none"|"safe"|"urllib2"|"yes")?
    
    force: Boolean?
    
    force_basic_auth: Boolean?
    
    headers: String?
    
    http_agent: String?
    
    method: String?
    
    remote_src: Boolean?
    
    removes: String?
    
    return_content: Boolean?
    
    src: String?
    
    status_code: Listing<Int>?
    
    timeout: Int?
    
    unix_socket: String?
    
    unredirected_headers: Listing<String>?
    
    url: String
    
    url_password: String?
    
    url_username: String?
    
    use_gssapi: Boolean?
    
    use_netrc: Boolean?
    
    use_proxy: Boolean?
    
    validate_certs: Boolean?
    
}

// Task class for uri
class Uri extends Playbook.Task {

    hidden options: UriOptions

    `ansible.builtin.uri`: UriOptions?

    function into(): Uri = this
        .toMap()
        .put("ansible.builtin.uri", this.options)
        .toTyped(Uri)

}

// Manage user accounts
class UserOptions {
    
    append: Boolean?
    
    authorization: String?
    
    comment: String?
    
    create_home: Boolean?
    
    expires: String?
    
    force: Boolean?
    
    generate_ssh_key: Boolean?
    
    group: String?
    
    groups: Listing<String>?
    
    `hidden`: Boolean?
    
    home: String?
    
    `local`: Boolean?
    
    login_class: String?
    
    move_home: Boolean?
    
    name: String
    
    non_unique: Boolean?
    
    password: String?
    
    password_expire_max: Int?
    
    password_expire_min: Int?
    
    password_expire_warn: Int?
    
    password_lock: Boolean?
    
    profile: String?
    
    remove: Boolean?
    
    role: String?
    
    seuser: String?
    
    shell: String?
    
    skeleton: String?
    
    ssh_key_bits: Int?
    
    ssh_key_comment: String?
    
    ssh_key_file: String?
    
    ssh_key_passphrase: String?
    
    ssh_key_type: String?
    
    state: ("absent"|"present")?
    
    system: Boolean?
    
    uid: Int?
    
    umask: String?
    
    update_password: ("always"|"on_create")?
    
}

// Task class for user
class User extends Playbook.Task {

    hidden options: UserOptions

    `ansible.builtin.user`: UserOptions?

    function into(): User = this
        .toMap()
        .put("ansible.builtin.user", this.options)
        .toTyped(User)

}

// Validate role argument specs.
class ValidateArgumentSpecOptions {
    
    argument_spec: String
    
    provided_arguments: String?
    
}

// Task class for validate_argument_spec
class ValidateArgumentSpec extends Playbook.Task {

    hidden options: ValidateArgumentSpecOptions

    `ansible.builtin.validate_argument_spec`: ValidateArgumentSpecOptions?

    function into(): ValidateArgumentSpec = this
        .toMap()
        .put("ansible.builtin.validate_argument_spec", this.options)
        .toTyped(ValidateArgumentSpec)

}

// Waits for a condition before continuing
class WaitForOptions {
    
    active_connection_states: Listing<String>?
    
    connect_timeout: Int?
    
    delay: Int?
    
    exclude_hosts: Listing<String>?
    
    host: String?
    
    msg: String?
    
    path: String?
    
    port: Int?
    
    search_regex: String?
    
    sleep: Int?
    
    state: ("absent"|"drained"|"present"|"started"|"stopped")?
    
    timeout: Int?
    
}

// Task class for wait_for
class WaitFor extends Playbook.Task {

    hidden options: WaitForOptions

    `ansible.builtin.wait_for`: WaitForOptions?

    function into(): WaitFor = this
        .toMap()
        .put("ansible.builtin.wait_for", this.options)
        .toTyped(WaitFor)

}

// Waits until remote system is reachable/usable
class WaitForConnectionOptions {
    
    connect_timeout: Int?
    
    delay: Int?
    
    sleep: Int?
    
    timeout: Int?
    
}

// Task class for wait_for_connection
class WaitForConnection extends Playbook.Task {

    hidden options: WaitForConnectionOptions

    `ansible.builtin.wait_for_connection`: WaitForConnectionOptions?

    function into(): WaitForConnection = this
        .toMap()
        .put("ansible.builtin.wait_for_connection", this.options)
        .toTyped(WaitForConnection)

}

// Manages packages with the I(yum) package manager
class YumOptions {
    
    allow_downgrade: Boolean?
    
    autoremove: Boolean?
    
    bugfix: Boolean?
    
    cacheonly: Boolean?
    
    conf_file: String?
    
    disable_excludes: String?
    
    disable_gpg_check: Boolean?
    
    disable_plugin: Listing<String>?
    
    disablerepo: Listing<String>?
    
    download_dir: String?
    
    download_only: Boolean?
    
    enable_plugin: Listing<String>?
    
    enablerepo: Listing<String>?
    
    exclude: Listing<String>?
    
    install_repoquery: Boolean?
    
    install_weak_deps: Boolean?
    
    installroot: String?
    
    list: String?
    
    lock_timeout: Int?
    
    name: Listing<String>?
    
    releasever: String?
    
    security: Boolean?
    
    skip_broken: Boolean?
    
    sslverify: Boolean?
    
    state: ("absent"|"installed"|"latest"|"present"|"removed")?
    
    update_cache: Boolean?
    
    update_only: Boolean?
    
    use_backend: ("auto"|"yum"|"yum4"|"dnf"|"dnf4"|"dnf5")?
    
    validate_certs: Boolean?
    
}

// Task class for yum
class Yum extends Playbook.Task {

    hidden options: YumOptions

    `ansible.builtin.yum`: YumOptions?

    function into(): Yum = this
        .toMap()
        .put("ansible.builtin.yum", this.options)
        .toTyped(Yum)

}

// Add or remove YUM repositories
class YumRepositoryOptions {
    
    async: Boolean?
    
    bandwidth: String?
    
    baseurl: Listing<String>?
    
    cost: String?
    
    deltarpm_metadata_percentage: String?
    
    deltarpm_percentage: String?
    
    description: String?
    
    enabled: Boolean?
    
    enablegroups: Boolean?
    
    exclude: Listing<String>?
    
    failovermethod: ("roundrobin"|"priority")?
    
    file: String?
    
    gpgcakey: String?
    
    gpgcheck: Boolean?
    
    gpgkey: Listing<String>?
    
    http_caching: ("all"|"packages"|"none")?
    
    include: String?
    
    includepkgs: Listing<String>?
    
    ip_resolve: ("4"|"6"|"IPv4"|"IPv6"|"whatever")?
    
    keepalive: Boolean?
    
    keepcache: ("0"|"1")?
    
    metadata_expire: String?
    
    metadata_expire_filter: ("never"|"read-only:past"|"read-only:present"|"read-only:future")?
    
    metalink: String?
    
    mirrorlist: String?
    
    mirrorlist_expire: String?
    
    module_hotfixes: Boolean?
    
    name: String
    
    password: String?
    
    priority: String?
    
    protect: Boolean?
    
    proxy: String?
    
    proxy_password: String?
    
    proxy_username: String?
    
    repo_gpgcheck: Boolean?
    
    reposdir: String?
    
    retries: String?
    
    s3_enabled: Boolean?
    
    skip_if_unavailable: Boolean?
    
    ssl_check_cert_permissions: Boolean?
    
    sslcacert: String?
    
    sslclientcert: String?
    
    sslclientkey: String?
    
    sslverify: Boolean?
    
    state: ("absent"|"present")?
    
    throttle: String?
    
    timeout: String?
    
    ui_repoid_vars: String?
    
    username: String?
    
}

// Task class for yum_repository
class YumRepository extends Playbook.Task {

    hidden options: YumRepositoryOptions

    `ansible.builtin.yum_repository`: YumRepositoryOptions?

    function into(): YumRepository = this
        .toMap()
        .put("ansible.builtin.yum_repository", this.options)
        .toTyped(YumRepository)

}

